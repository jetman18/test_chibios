
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

00200000 <__vectors_base__>:
  200000:	20000400 	.word	0x20000400
  200004:	0020031d 	.word	0x0020031d
  200008:	0020031f 	.word	0x0020031f
  20000c:	0020031f 	.word	0x0020031f
  200010:	0020031f 	.word	0x0020031f
  200014:	0020031f 	.word	0x0020031f
  200018:	0020031f 	.word	0x0020031f
  20001c:	0020031f 	.word	0x0020031f
  200020:	0020031f 	.word	0x0020031f
  200024:	0020031f 	.word	0x0020031f
  200028:	0020031f 	.word	0x0020031f
  20002c:	00207071 	.word	0x00207071
  200030:	0020031f 	.word	0x0020031f
  200034:	0020031f 	.word	0x0020031f
  200038:	0020031f 	.word	0x0020031f
  20003c:	0020031f 	.word	0x0020031f
  200040:	0020031f 	.word	0x0020031f
  200044:	0020031f 	.word	0x0020031f
  200048:	0020031f 	.word	0x0020031f
  20004c:	0020031f 	.word	0x0020031f
  200050:	0020031f 	.word	0x0020031f
  200054:	0020031f 	.word	0x0020031f
  200058:	0020031f 	.word	0x0020031f
  20005c:	0020031f 	.word	0x0020031f
  200060:	0020031f 	.word	0x0020031f
  200064:	0020031f 	.word	0x0020031f
  200068:	0020031f 	.word	0x0020031f
  20006c:	0020031f 	.word	0x0020031f
  200070:	0020031f 	.word	0x0020031f
  200074:	0020031f 	.word	0x0020031f
  200078:	0020031f 	.word	0x0020031f
  20007c:	0020031f 	.word	0x0020031f
  200080:	0020031f 	.word	0x0020031f
  200084:	0020031f 	.word	0x0020031f
  200088:	0020031f 	.word	0x0020031f
  20008c:	0020031f 	.word	0x0020031f
  200090:	0020031f 	.word	0x0020031f
  200094:	0020031f 	.word	0x0020031f
  200098:	0020031f 	.word	0x0020031f
  20009c:	0020031f 	.word	0x0020031f
  2000a0:	0020031f 	.word	0x0020031f
  2000a4:	0020031f 	.word	0x0020031f
  2000a8:	0020031f 	.word	0x0020031f
  2000ac:	0020031f 	.word	0x0020031f
  2000b0:	00201441 	.word	0x00201441
  2000b4:	0020031f 	.word	0x0020031f
  2000b8:	0020031f 	.word	0x0020031f
  2000bc:	0020031f 	.word	0x0020031f
  2000c0:	0020031f 	.word	0x0020031f
  2000c4:	0020031f 	.word	0x0020031f
  2000c8:	0020031f 	.word	0x0020031f
  2000cc:	0020031f 	.word	0x0020031f
  2000d0:	0020031f 	.word	0x0020031f
  2000d4:	0020031f 	.word	0x0020031f
  2000d8:	0020031f 	.word	0x0020031f
  2000dc:	002013b1 	.word	0x002013b1
  2000e0:	0020031f 	.word	0x0020031f
  2000e4:	0020031f 	.word	0x0020031f
  2000e8:	0020031f 	.word	0x0020031f
  2000ec:	0020031f 	.word	0x0020031f
  2000f0:	0020031f 	.word	0x0020031f
  2000f4:	0020031f 	.word	0x0020031f
  2000f8:	0020031f 	.word	0x0020031f
  2000fc:	0020031f 	.word	0x0020031f
  200100:	0020031f 	.word	0x0020031f
  200104:	0020031f 	.word	0x0020031f
  200108:	0020031f 	.word	0x0020031f
  20010c:	0020031f 	.word	0x0020031f
  200110:	0020031f 	.word	0x0020031f
  200114:	0020031f 	.word	0x0020031f
  200118:	0020031f 	.word	0x0020031f
  20011c:	0020031f 	.word	0x0020031f
  200120:	0020031f 	.word	0x0020031f
  200124:	0020031f 	.word	0x0020031f
  200128:	0020031f 	.word	0x0020031f
  20012c:	0020031f 	.word	0x0020031f
  200130:	0020031f 	.word	0x0020031f
  200134:	0020031f 	.word	0x0020031f
  200138:	0020031f 	.word	0x0020031f
  20013c:	0020031f 	.word	0x0020031f
  200140:	0020031f 	.word	0x0020031f
  200144:	0020031f 	.word	0x0020031f
  200148:	0020031f 	.word	0x0020031f
  20014c:	0020031f 	.word	0x0020031f
  200150:	0020031f 	.word	0x0020031f
  200154:	0020031f 	.word	0x0020031f
  200158:	0020031f 	.word	0x0020031f
  20015c:	0020031f 	.word	0x0020031f
  200160:	0020031f 	.word	0x0020031f
  200164:	0020031f 	.word	0x0020031f
  200168:	0020031f 	.word	0x0020031f
  20016c:	0020031f 	.word	0x0020031f
  200170:	0020031f 	.word	0x0020031f
  200174:	0020031f 	.word	0x0020031f
  200178:	0020031f 	.word	0x0020031f
  20017c:	0020031f 	.word	0x0020031f
  200180:	0020031f 	.word	0x0020031f
  200184:	0020031f 	.word	0x0020031f
  200188:	0020031f 	.word	0x0020031f
  20018c:	0020031f 	.word	0x0020031f
  200190:	0020031f 	.word	0x0020031f
  200194:	0020031f 	.word	0x0020031f
  200198:	0020031f 	.word	0x0020031f
  20019c:	0020031f 	.word	0x0020031f
  2001a0:	0020031f 	.word	0x0020031f
  2001a4:	0020031f 	.word	0x0020031f
  2001a8:	0020031f 	.word	0x0020031f
  2001ac:	0020031f 	.word	0x0020031f
  2001b0:	0020031f 	.word	0x0020031f
  2001b4:	0020031f 	.word	0x0020031f
  2001b8:	0020031f 	.word	0x0020031f
  2001bc:	0020031f 	.word	0x0020031f
  2001c0:	0020031f 	.word	0x0020031f
  2001c4:	0020031f 	.word	0x0020031f
  2001c8:	0020031f 	.word	0x0020031f
  2001cc:	0020031f 	.word	0x0020031f
  2001d0:	0020031f 	.word	0x0020031f
  2001d4:	0020031f 	.word	0x0020031f
  2001d8:	0020031f 	.word	0x0020031f
  2001dc:	0020031f 	.word	0x0020031f
  2001e0:	0020031f 	.word	0x0020031f
  2001e4:	0020031f 	.word	0x0020031f
  2001e8:	0020031f 	.word	0x0020031f
  2001ec:	0020031f 	.word	0x0020031f
  2001f0:	0020031f 	.word	0x0020031f
  2001f4:	0020031f 	.word	0x0020031f
  2001f8:	0020031f 	.word	0x0020031f
  2001fc:	0020031f 	.word	0x0020031f

Disassembly of section .text:

00200200 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
  200200:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
  200202:	4837      	ldr	r0, [pc, #220]	@ (2002e0 <_crt0_entry+0xe0>)
                msr     MSP, r0
  200204:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
  200208:	4836      	ldr	r0, [pc, #216]	@ (2002e4 <_crt0_entry+0xe4>)
                msr     PSP, r0
  20020a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
  20020e:	4836      	ldr	r0, [pc, #216]	@ (2002e8 <_crt0_entry+0xe8>)
                ldr     r1, =SCB_VTOR
  200210:	4936      	ldr	r1, [pc, #216]	@ (2002ec <_crt0_entry+0xec>)
                str     r0, [r1]
  200212:	6008      	str	r0, [r1, #0]
#endif

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
  200214:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
  200218:	f2cc 0000 	movt	r0, #49152	@ 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
  20021c:	f64e 7134 	movw	r1, #61236	@ 0xef34
                movt    r1, #SCB_FPCCR >> 16
  200220:	f2ce 0100 	movt	r1, #57344	@ 0xe000
                str     r0, [r1]
  200224:	6008      	str	r0, [r1, #0]
                dsb
  200226:	f3bf 8f4f 	dsb	sy
                isb
  20022a:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
  20022e:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
  200232:	f2c0 00f0 	movt	r0, #240	@ 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
  200236:	f64e 5188 	movw	r1, #60808	@ 0xed88
                movt    r1, #SCB_CPACR >> 16
  20023a:	f2ce 0100 	movt	r1, #57344	@ 0xe000
                str     r0, [r1]
  20023e:	6008      	str	r0, [r1, #0]
                dsb
  200240:	f3bf 8f4f 	dsb	sy
                isb
  200244:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
  200248:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
  20024c:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
  200250:	f64e 713c 	movw	r1, #61244	@ 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
  200254:	f2ce 0100 	movt	r1, #57344	@ 0xe000
                str     r0, [r1]
  200258:	6008      	str	r0, [r1, #0]
#endif

                /* CONTROL register initialization as configured.*/
                movs    r0, #CRT0_CONTROL_INIT
  20025a:	2002      	movs	r0, #2
                msr     CONTROL, r0
  20025c:	f380 8814 	msr	CONTROL, r0
                isb
  200260:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
  200264:	f000 fa8c 	bl	200780 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
  200268:	f001 fdd2 	bl	201e10 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
  20026c:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
  200270:	491f      	ldr	r1, [pc, #124]	@ (2002f0 <_crt0_entry+0xf0>)
                ldr     r2, =__main_stack_end__
  200272:	4a1b      	ldr	r2, [pc, #108]	@ (2002e0 <_crt0_entry+0xe0>)
.Lmsloop:
                cmp     r1, r2
  200274:	4291      	cmp	r1, r2
                itt     lo
  200276:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  200278:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lmsloop
  20027c:	e7fa      	bcc.n	200274 <_crt0_entry+0x74>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
  20027e:	491d      	ldr	r1, [pc, #116]	@ (2002f4 <_crt0_entry+0xf4>)
                ldr     r2, =__process_stack_end__
  200280:	4a18      	ldr	r2, [pc, #96]	@ (2002e4 <_crt0_entry+0xe4>)
.Lpsloop:
                cmp     r1, r2
  200282:	4291      	cmp	r1, r2
                itt     lo
  200284:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  200286:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lpsloop
  20028a:	e7fa      	bcc.n	200282 <_crt0_entry+0x82>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
  20028c:	491a      	ldr	r1, [pc, #104]	@ (2002f8 <_crt0_entry+0xf8>)
                ldr     r2, =__data_base__
  20028e:	4a1b      	ldr	r2, [pc, #108]	@ (2002fc <_crt0_entry+0xfc>)
                ldr     r3, =__data_end__
  200290:	4b1b      	ldr	r3, [pc, #108]	@ (200300 <_crt0_entry+0x100>)
.Ldloop:
                cmp     r2, r3
  200292:	429a      	cmp	r2, r3
                ittt    lo
  200294:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
  200296:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
  20029a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     .Ldloop
  20029e:	e7f8      	bcc.n	200292 <_crt0_entry+0x92>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
  2002a0:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
  2002a2:	4918      	ldr	r1, [pc, #96]	@ (200304 <_crt0_entry+0x104>)
                ldr     r2, =__bss_end__
  2002a4:	4a18      	ldr	r2, [pc, #96]	@ (200308 <_crt0_entry+0x108>)
.Lbloop:
                cmp     r1, r2
  2002a6:	4291      	cmp	r1, r2
                itt     lo
  2002a8:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  2002aa:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lbloop
  2002ae:	e7fa      	bcc.n	2002a6 <_crt0_entry+0xa6>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
  2002b0:	f000 fa7e 	bl	2007b0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
  2002b4:	f000 fa6c 	bl	200790 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
  2002b8:	4c14      	ldr	r4, [pc, #80]	@ (20030c <_crt0_entry+0x10c>)
                ldr     r5, =__init_array_end__
  2002ba:	4d15      	ldr	r5, [pc, #84]	@ (200310 <_crt0_entry+0x110>)
.Linitloop:
                cmp     r4, r5
  2002bc:	42ac      	cmp	r4, r5
                bge     .Lendinitloop
  2002be:	da03      	bge.n	2002c8 <_crt0_entry+0xc8>
                ldr     r1, [r4], #4
  2002c0:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
  2002c4:	4788      	blx	r1
                b       .Linitloop
  2002c6:	e7f9      	b.n	2002bc <_crt0_entry+0xbc>
.Lendinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
  2002c8:	f00f fe2a 	bl	20ff20 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
  2002cc:	4c11      	ldr	r4, [pc, #68]	@ (200314 <_crt0_entry+0x114>)
                ldr     r5, =__fini_array_end__
  2002ce:	4d12      	ldr	r5, [pc, #72]	@ (200318 <_crt0_entry+0x118>)
.Lfiniloop:
                cmp     r4, r5
  2002d0:	42ac      	cmp	r4, r5
                bge     .Lendfiniloop
  2002d2:	da03      	bge.n	2002dc <_crt0_entry+0xdc>
                ldr     r1, [r4], #4
  2002d4:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
  2002d8:	4788      	blx	r1
                b       .Lfiniloop
  2002da:	e7f9      	b.n	2002d0 <_crt0_entry+0xd0>
.Lendfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
  2002dc:	f000 ba60 	b.w	2007a0 <__default_exit>
                ldr     r0, =__main_stack_end__
  2002e0:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
  2002e4:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
  2002e8:	00200000 	.word	0x00200000
                ldr     r1, =SCB_VTOR
  2002ec:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
  2002f0:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
  2002f4:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
  2002f8:	08012900 	.word	0x08012900
                ldr     r2, =__data_base__
  2002fc:	20020000 	.word	0x20020000
                ldr     r3, =__data_end__
  200300:	200200dc 	.word	0x200200dc
                ldr     r1, =__bss_base__
  200304:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
  200308:	20002a20 	.word	0x20002a20
                ldr     r4, =__init_array_base__
  20030c:	00200200 	.word	0x00200200
                ldr     r5, =__init_array_end__
  200310:	00200200 	.word	0x00200200
                ldr     r4, =__fini_array_base__
  200314:	00200200 	.word	0x00200200
                ldr     r5, =__fini_array_end__
  200318:	00200200 	.word	0x00200200

0020031c <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
  20031c:	e770      	b.n	200200 <_crt0_entry>

0020031e <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
  20031e:	f000 f800 	bl	200322 <_unhandled_exception>

00200322 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
  200322:	e7fe      	b.n	200322 <_unhandled_exception>

00200324 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
  200324:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                /* Saving FPU context.*/
                vpush   {s16-s31}
  200328:	ed2d 8a10 	vpush	{s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
  20032c:	f8c1 d00c 	str.w	sp, [r1, #12]
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
                mov     sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
  200330:	f8d0 d00c 	ldr.w	sp, [r0, #12]
#endif

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
  200334:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
  200338:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0020033c <__port_thread_start>:
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
  20033c:	2300      	movs	r3, #0
                msr     BASEPRI, r3
  20033e:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
  200342:	4628      	mov	r0, r5
                blx     r4
  200344:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
  200346:	2000      	movs	r0, #0
                bl      chThdExit
  200348:	f003 f8a2 	bl	203490 <chThdExit>
1:              b       1b
  20034c:	e7fe      	b.n	20034c <__port_thread_start+0x10>

0020034e <__port_switch_from_isr>:
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
#endif
                bl      chSchDoPreemption
  20034e:	f002 fccf 	bl	202cf0 <chSchDoPreemption>

00200352 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
  200352:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
1:              b       1b
  200354:	e7fe      	b.n	200354 <__port_exit_from_isr+0x2>
	...

00200358 <memset>:
  200358:	0783      	lsls	r3, r0, #30
  20035a:	b530      	push	{r4, r5, lr}
  20035c:	d047      	beq.n	2003ee <memset+0x96>
  20035e:	1e54      	subs	r4, r2, #1
  200360:	2a00      	cmp	r2, #0
  200362:	d03e      	beq.n	2003e2 <memset+0x8a>
  200364:	b2ca      	uxtb	r2, r1
  200366:	4603      	mov	r3, r0
  200368:	e001      	b.n	20036e <memset+0x16>
  20036a:	3c01      	subs	r4, #1
  20036c:	d339      	bcc.n	2003e2 <memset+0x8a>
  20036e:	f803 2b01 	strb.w	r2, [r3], #1
  200372:	079d      	lsls	r5, r3, #30
  200374:	d1f9      	bne.n	20036a <memset+0x12>
  200376:	2c03      	cmp	r4, #3
  200378:	d92c      	bls.n	2003d4 <memset+0x7c>
  20037a:	b2cd      	uxtb	r5, r1
  20037c:	eb05 2505 	add.w	r5, r5, r5, lsl #8
  200380:	2c0f      	cmp	r4, #15
  200382:	eb05 4505 	add.w	r5, r5, r5, lsl #16
  200386:	d935      	bls.n	2003f4 <memset+0x9c>
  200388:	f1a4 0210 	sub.w	r2, r4, #16
  20038c:	f022 0c0f 	bic.w	ip, r2, #15
  200390:	f103 0e10 	add.w	lr, r3, #16
  200394:	44e6      	add	lr, ip
  200396:	ea4f 1c12 	mov.w	ip, r2, lsr #4
  20039a:	461a      	mov	r2, r3
  20039c:	e9c2 5500 	strd	r5, r5, [r2]
  2003a0:	e9c2 5502 	strd	r5, r5, [r2, #8]
  2003a4:	3210      	adds	r2, #16
  2003a6:	4572      	cmp	r2, lr
  2003a8:	d1f8      	bne.n	20039c <memset+0x44>
  2003aa:	f10c 0201 	add.w	r2, ip, #1
  2003ae:	f014 0f0c 	tst.w	r4, #12
  2003b2:	eb03 1202 	add.w	r2, r3, r2, lsl #4
  2003b6:	f004 0c0f 	and.w	ip, r4, #15
  2003ba:	d013      	beq.n	2003e4 <memset+0x8c>
  2003bc:	f1ac 0304 	sub.w	r3, ip, #4
  2003c0:	f023 0303 	bic.w	r3, r3, #3
  2003c4:	3304      	adds	r3, #4
  2003c6:	4413      	add	r3, r2
  2003c8:	f842 5b04 	str.w	r5, [r2], #4
  2003cc:	4293      	cmp	r3, r2
  2003ce:	d1fb      	bne.n	2003c8 <memset+0x70>
  2003d0:	f00c 0403 	and.w	r4, ip, #3
  2003d4:	b12c      	cbz	r4, 2003e2 <memset+0x8a>
  2003d6:	b2c9      	uxtb	r1, r1
  2003d8:	441c      	add	r4, r3
  2003da:	f803 1b01 	strb.w	r1, [r3], #1
  2003de:	42a3      	cmp	r3, r4
  2003e0:	d1fb      	bne.n	2003da <memset+0x82>
  2003e2:	bd30      	pop	{r4, r5, pc}
  2003e4:	4664      	mov	r4, ip
  2003e6:	4613      	mov	r3, r2
  2003e8:	2c00      	cmp	r4, #0
  2003ea:	d1f4      	bne.n	2003d6 <memset+0x7e>
  2003ec:	e7f9      	b.n	2003e2 <memset+0x8a>
  2003ee:	4603      	mov	r3, r0
  2003f0:	4614      	mov	r4, r2
  2003f2:	e7c0      	b.n	200376 <memset+0x1e>
  2003f4:	461a      	mov	r2, r3
  2003f6:	46a4      	mov	ip, r4
  2003f8:	e7e0      	b.n	2003bc <memset+0x64>
  2003fa:	bf00      	nop

002003fc <strncmp>:
  2003fc:	2a00      	cmp	r2, #0
  2003fe:	d03e      	beq.n	20047e <strncmp+0x82>
  200400:	b530      	push	{r4, r5, lr}
  200402:	4684      	mov	ip, r0
  200404:	4604      	mov	r4, r0
  200406:	4308      	orrs	r0, r1
  200408:	0780      	lsls	r0, r0, #30
  20040a:	460b      	mov	r3, r1
  20040c:	d12e      	bne.n	20046c <strncmp+0x70>
  20040e:	2a03      	cmp	r2, #3
  200410:	d807      	bhi.n	200422 <strncmp+0x26>
  200412:	e02b      	b.n	20046c <strncmp+0x70>
  200414:	3a04      	subs	r2, #4
  200416:	d025      	beq.n	200464 <strncmp+0x68>
  200418:	f01e 3f80 	tst.w	lr, #2155905152	@ 0x80808080
  20041c:	d122      	bne.n	200464 <strncmp+0x68>
  20041e:	2a03      	cmp	r2, #3
  200420:	d922      	bls.n	200468 <strncmp+0x6c>
  200422:	6820      	ldr	r0, [r4, #0]
  200424:	4619      	mov	r1, r3
  200426:	f853 5b04 	ldr.w	r5, [r3], #4
  20042a:	f1a0 3e01 	sub.w	lr, r0, #16843009	@ 0x1010101
  20042e:	42a8      	cmp	r0, r5
  200430:	46a4      	mov	ip, r4
  200432:	ea2e 0e00 	bic.w	lr, lr, r0
  200436:	f104 0404 	add.w	r4, r4, #4
  20043a:	d0eb      	beq.n	200414 <strncmp+0x18>
  20043c:	f89c 0000 	ldrb.w	r0, [ip]
  200440:	780c      	ldrb	r4, [r1, #0]
  200442:	4284      	cmp	r4, r0
  200444:	d11d      	bne.n	200482 <strncmp+0x86>
  200446:	46e6      	mov	lr, ip
  200448:	b168      	cbz	r0, 200466 <strncmp+0x6a>
  20044a:	f81e 0f01 	ldrb.w	r0, [lr, #1]!
  20044e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  200452:	eba2 030e 	sub.w	r3, r2, lr
  200456:	42a0      	cmp	r0, r4
  200458:	f103 33ff 	add.w	r3, r3, #4294967295	@ 0xffffffff
  20045c:	d111      	bne.n	200482 <strncmp+0x86>
  20045e:	eb1c 0303 	adds.w	r3, ip, r3
  200462:	d1f1      	bne.n	200448 <strncmp+0x4c>
  200464:	2000      	movs	r0, #0
  200466:	bd30      	pop	{r4, r5, pc}
  200468:	46a4      	mov	ip, r4
  20046a:	4619      	mov	r1, r3
  20046c:	f89c 0000 	ldrb.w	r0, [ip]
  200470:	780c      	ldrb	r4, [r1, #0]
  200472:	42a0      	cmp	r0, r4
  200474:	d105      	bne.n	200482 <strncmp+0x86>
  200476:	2a01      	cmp	r2, #1
  200478:	d0f4      	beq.n	200464 <strncmp+0x68>
  20047a:	46e6      	mov	lr, ip
  20047c:	e7e4      	b.n	200448 <strncmp+0x4c>
  20047e:	4610      	mov	r0, r2
  200480:	4770      	bx	lr
  200482:	1b00      	subs	r0, r0, r4
  200484:	bd30      	pop	{r4, r5, pc}
  200486:	bf00      	nop

00200488 <memcmp>:
  200488:	2a03      	cmp	r2, #3
  20048a:	b430      	push	{r4, r5}
  20048c:	d915      	bls.n	2004ba <memcmp+0x32>
  20048e:	ea41 0400 	orr.w	r4, r1, r0
  200492:	07a4      	lsls	r4, r4, #30
  200494:	4684      	mov	ip, r0
  200496:	460b      	mov	r3, r1
  200498:	d004      	beq.n	2004a4 <memcmp+0x1c>
  20049a:	1e54      	subs	r4, r2, #1
  20049c:	e00f      	b.n	2004be <memcmp+0x36>
  20049e:	3a04      	subs	r2, #4
  2004a0:	2a03      	cmp	r2, #3
  2004a2:	d908      	bls.n	2004b6 <memcmp+0x2e>
  2004a4:	4619      	mov	r1, r3
  2004a6:	4660      	mov	r0, ip
  2004a8:	f853 4b04 	ldr.w	r4, [r3], #4
  2004ac:	f85c 5b04 	ldr.w	r5, [ip], #4
  2004b0:	42a5      	cmp	r5, r4
  2004b2:	d0f4      	beq.n	20049e <memcmp+0x16>
  2004b4:	e7f1      	b.n	20049a <memcmp+0x12>
  2004b6:	4660      	mov	r0, ip
  2004b8:	4619      	mov	r1, r3
  2004ba:	1e54      	subs	r4, r2, #1
  2004bc:	b17a      	cbz	r2, 2004de <memcmp+0x56>
  2004be:	1e43      	subs	r3, r0, #1
  2004c0:	3901      	subs	r1, #1
  2004c2:	1902      	adds	r2, r0, r4
  2004c4:	e001      	b.n	2004ca <memcmp+0x42>
  2004c6:	429a      	cmp	r2, r3
  2004c8:	d009      	beq.n	2004de <memcmp+0x56>
  2004ca:	f813 0f01 	ldrb.w	r0, [r3, #1]!
  2004ce:	f811 cf01 	ldrb.w	ip, [r1, #1]!
  2004d2:	4560      	cmp	r0, ip
  2004d4:	d0f7      	beq.n	2004c6 <memcmp+0x3e>
  2004d6:	eba0 000c 	sub.w	r0, r0, ip
  2004da:	bc30      	pop	{r4, r5}
  2004dc:	4770      	bx	lr
  2004de:	2000      	movs	r0, #0
  2004e0:	bc30      	pop	{r4, r5}
  2004e2:	4770      	bx	lr

002004e4 <memcpy>:
  2004e4:	4684      	mov	ip, r0
  2004e6:	ea41 0300 	orr.w	r3, r1, r0
  2004ea:	f013 0303 	ands.w	r3, r3, #3
  2004ee:	d16d      	bne.n	2005cc <memcpy+0xe8>
  2004f0:	3a40      	subs	r2, #64	@ 0x40
  2004f2:	d341      	bcc.n	200578 <memcpy+0x94>
  2004f4:	f851 3b04 	ldr.w	r3, [r1], #4
  2004f8:	f840 3b04 	str.w	r3, [r0], #4
  2004fc:	f851 3b04 	ldr.w	r3, [r1], #4
  200500:	f840 3b04 	str.w	r3, [r0], #4
  200504:	f851 3b04 	ldr.w	r3, [r1], #4
  200508:	f840 3b04 	str.w	r3, [r0], #4
  20050c:	f851 3b04 	ldr.w	r3, [r1], #4
  200510:	f840 3b04 	str.w	r3, [r0], #4
  200514:	f851 3b04 	ldr.w	r3, [r1], #4
  200518:	f840 3b04 	str.w	r3, [r0], #4
  20051c:	f851 3b04 	ldr.w	r3, [r1], #4
  200520:	f840 3b04 	str.w	r3, [r0], #4
  200524:	f851 3b04 	ldr.w	r3, [r1], #4
  200528:	f840 3b04 	str.w	r3, [r0], #4
  20052c:	f851 3b04 	ldr.w	r3, [r1], #4
  200530:	f840 3b04 	str.w	r3, [r0], #4
  200534:	f851 3b04 	ldr.w	r3, [r1], #4
  200538:	f840 3b04 	str.w	r3, [r0], #4
  20053c:	f851 3b04 	ldr.w	r3, [r1], #4
  200540:	f840 3b04 	str.w	r3, [r0], #4
  200544:	f851 3b04 	ldr.w	r3, [r1], #4
  200548:	f840 3b04 	str.w	r3, [r0], #4
  20054c:	f851 3b04 	ldr.w	r3, [r1], #4
  200550:	f840 3b04 	str.w	r3, [r0], #4
  200554:	f851 3b04 	ldr.w	r3, [r1], #4
  200558:	f840 3b04 	str.w	r3, [r0], #4
  20055c:	f851 3b04 	ldr.w	r3, [r1], #4
  200560:	f840 3b04 	str.w	r3, [r0], #4
  200564:	f851 3b04 	ldr.w	r3, [r1], #4
  200568:	f840 3b04 	str.w	r3, [r0], #4
  20056c:	f851 3b04 	ldr.w	r3, [r1], #4
  200570:	f840 3b04 	str.w	r3, [r0], #4
  200574:	3a40      	subs	r2, #64	@ 0x40
  200576:	d2bd      	bcs.n	2004f4 <memcpy+0x10>
  200578:	3230      	adds	r2, #48	@ 0x30
  20057a:	d311      	bcc.n	2005a0 <memcpy+0xbc>
  20057c:	f851 3b04 	ldr.w	r3, [r1], #4
  200580:	f840 3b04 	str.w	r3, [r0], #4
  200584:	f851 3b04 	ldr.w	r3, [r1], #4
  200588:	f840 3b04 	str.w	r3, [r0], #4
  20058c:	f851 3b04 	ldr.w	r3, [r1], #4
  200590:	f840 3b04 	str.w	r3, [r0], #4
  200594:	f851 3b04 	ldr.w	r3, [r1], #4
  200598:	f840 3b04 	str.w	r3, [r0], #4
  20059c:	3a10      	subs	r2, #16
  20059e:	d2ed      	bcs.n	20057c <memcpy+0x98>
  2005a0:	320c      	adds	r2, #12
  2005a2:	d305      	bcc.n	2005b0 <memcpy+0xcc>
  2005a4:	f851 3b04 	ldr.w	r3, [r1], #4
  2005a8:	f840 3b04 	str.w	r3, [r0], #4
  2005ac:	3a04      	subs	r2, #4
  2005ae:	d2f9      	bcs.n	2005a4 <memcpy+0xc0>
  2005b0:	3204      	adds	r2, #4
  2005b2:	d008      	beq.n	2005c6 <memcpy+0xe2>
  2005b4:	07d2      	lsls	r2, r2, #31
  2005b6:	bf1c      	itt	ne
  2005b8:	f811 3b01 	ldrbne.w	r3, [r1], #1
  2005bc:	f800 3b01 	strbne.w	r3, [r0], #1
  2005c0:	d301      	bcc.n	2005c6 <memcpy+0xe2>
  2005c2:	880b      	ldrh	r3, [r1, #0]
  2005c4:	8003      	strh	r3, [r0, #0]
  2005c6:	4660      	mov	r0, ip
  2005c8:	4770      	bx	lr
  2005ca:	bf00      	nop
  2005cc:	2a08      	cmp	r2, #8
  2005ce:	d313      	bcc.n	2005f8 <memcpy+0x114>
  2005d0:	078b      	lsls	r3, r1, #30
  2005d2:	d08d      	beq.n	2004f0 <memcpy+0xc>
  2005d4:	f010 0303 	ands.w	r3, r0, #3
  2005d8:	d08a      	beq.n	2004f0 <memcpy+0xc>
  2005da:	f1c3 0304 	rsb	r3, r3, #4
  2005de:	1ad2      	subs	r2, r2, r3
  2005e0:	07db      	lsls	r3, r3, #31
  2005e2:	bf1c      	itt	ne
  2005e4:	f811 3b01 	ldrbne.w	r3, [r1], #1
  2005e8:	f800 3b01 	strbne.w	r3, [r0], #1
  2005ec:	d380      	bcc.n	2004f0 <memcpy+0xc>
  2005ee:	f831 3b02 	ldrh.w	r3, [r1], #2
  2005f2:	f820 3b02 	strh.w	r3, [r0], #2
  2005f6:	e77b      	b.n	2004f0 <memcpy+0xc>
  2005f8:	3a04      	subs	r2, #4
  2005fa:	d3d9      	bcc.n	2005b0 <memcpy+0xcc>
  2005fc:	3a01      	subs	r2, #1
  2005fe:	f811 3b01 	ldrb.w	r3, [r1], #1
  200602:	f800 3b01 	strb.w	r3, [r0], #1
  200606:	d2f9      	bcs.n	2005fc <memcpy+0x118>
  200608:	780b      	ldrb	r3, [r1, #0]
  20060a:	7003      	strb	r3, [r0, #0]
  20060c:	784b      	ldrb	r3, [r1, #1]
  20060e:	7043      	strb	r3, [r0, #1]
  200610:	788b      	ldrb	r3, [r1, #2]
  200612:	7083      	strb	r3, [r0, #2]
  200614:	4660      	mov	r0, ip
  200616:	4770      	bx	lr
	...

00200620 <SCB_EnableICache>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
  200620:	f3bf 8f4f 	dsb	sy
}
  200624:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
  200626:	f3bf 8f6f 	isb	sy
}
  20062a:	bf00      	nop
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  20062c:	4b0b      	ldr	r3, [pc, #44]	@ (20065c <SCB_EnableICache+0x3c>)
  20062e:	2200      	movs	r2, #0
  200630:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
  200634:	f3bf 8f4f 	dsb	sy
}
  200638:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
  20063a:	f3bf 8f6f 	isb	sy
}
  20063e:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  200640:	4b06      	ldr	r3, [pc, #24]	@ (20065c <SCB_EnableICache+0x3c>)
  200642:	695b      	ldr	r3, [r3, #20]
  200644:	4a05      	ldr	r2, [pc, #20]	@ (20065c <SCB_EnableICache+0x3c>)
  200646:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  20064a:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  20064c:	f3bf 8f4f 	dsb	sy
}
  200650:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
  200652:	f3bf 8f6f 	isb	sy
}
  200656:	bf00      	nop
    __DSB();
    __ISB();
  #endif
}
  200658:	bf00      	nop
  20065a:	4770      	bx	lr
  20065c:	e000ed00 	.word	0xe000ed00

00200660 <SCB_InvalidateICache>:
  __ASM volatile ("dsb 0xF":::"memory");
  200660:	f3bf 8f4f 	dsb	sy
}
  200664:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
  200666:	f3bf 8f6f 	isb	sy
}
  20066a:	bf00      	nop
__STATIC_INLINE void SCB_InvalidateICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;
  20066c:	4b05      	ldr	r3, [pc, #20]	@ (200684 <SCB_InvalidateICache+0x24>)
  20066e:	2200      	movs	r2, #0
  200670:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
  200674:	f3bf 8f4f 	dsb	sy
}
  200678:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
  20067a:	f3bf 8f6f 	isb	sy
}
  20067e:	bf00      	nop
    __DSB();
    __ISB();
  #endif
}
  200680:	bf00      	nop
  200682:	4770      	bx	lr
  200684:	e000ed00 	.word	0xe000ed00
	...

00200690 <SCB_EnableDCache>:
/**
  \brief   Enable D-Cache
  \details Turns on D-Cache
  */
__STATIC_INLINE void SCB_EnableDCache (void)
{
  200690:	b084      	sub	sp, #16
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
  200692:	4b1e      	ldr	r3, [pc, #120]	@ (20070c <SCB_EnableDCache+0x7c>)
  200694:	2200      	movs	r2, #0
  200696:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  20069a:	f3bf 8f4f 	dsb	sy
}
  20069e:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
  2006a0:	4b1a      	ldr	r3, [pc, #104]	@ (20070c <SCB_EnableDCache+0x7c>)
  2006a2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
  2006a6:	9301      	str	r3, [sp, #4]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  2006a8:	9b01      	ldr	r3, [sp, #4]
  2006aa:	0b5b      	lsrs	r3, r3, #13
  2006ac:	f3c3 030e 	ubfx	r3, r3, #0, #15
  2006b0:	9303      	str	r3, [sp, #12]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  2006b2:	9b01      	ldr	r3, [sp, #4]
  2006b4:	08db      	lsrs	r3, r3, #3
  2006b6:	f3c3 0309 	ubfx	r3, r3, #0, #10
  2006ba:	9302      	str	r3, [sp, #8]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  2006bc:	9b03      	ldr	r3, [sp, #12]
  2006be:	015a      	lsls	r2, r3, #5
  2006c0:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
  2006c4:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
  2006c6:	9a02      	ldr	r2, [sp, #8]
  2006c8:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  2006ca:	4910      	ldr	r1, [pc, #64]	@ (20070c <SCB_EnableDCache+0x7c>)
  2006cc:	4313      	orrs	r3, r2
  2006ce:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
  2006d2:	9b02      	ldr	r3, [sp, #8]
  2006d4:	1e5a      	subs	r2, r3, #1
  2006d6:	9202      	str	r2, [sp, #8]
  2006d8:	2b00      	cmp	r3, #0
  2006da:	d1ef      	bne.n	2006bc <SCB_EnableDCache+0x2c>
    } while(sets-- != 0U);
  2006dc:	9b03      	ldr	r3, [sp, #12]
  2006de:	1e5a      	subs	r2, r3, #1
  2006e0:	9203      	str	r2, [sp, #12]
  2006e2:	2b00      	cmp	r3, #0
  2006e4:	d1e5      	bne.n	2006b2 <SCB_EnableDCache+0x22>
  __ASM volatile ("dsb 0xF":::"memory");
  2006e6:	f3bf 8f4f 	dsb	sy
}
  2006ea:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
  2006ec:	4b07      	ldr	r3, [pc, #28]	@ (20070c <SCB_EnableDCache+0x7c>)
  2006ee:	695b      	ldr	r3, [r3, #20]
  2006f0:	4a06      	ldr	r2, [pc, #24]	@ (20070c <SCB_EnableDCache+0x7c>)
  2006f2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
  2006f6:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  2006f8:	f3bf 8f4f 	dsb	sy
}
  2006fc:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
  2006fe:	f3bf 8f6f 	isb	sy
}
  200702:	bf00      	nop

    __DSB();
    __ISB();
  #endif
}
  200704:	bf00      	nop
  200706:	b004      	add	sp, #16
  200708:	4770      	bx	lr
  20070a:	bf00      	nop
  20070c:	e000ed00 	.word	0xe000ed00

00200710 <SCB_CleanDCache>:
/**
  \brief   Clean D-Cache
  \details Cleans D-Cache
  */
__STATIC_INLINE void SCB_CleanDCache (void)
{
  200710:	b084      	sub	sp, #16
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

     SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
  200712:	4b19      	ldr	r3, [pc, #100]	@ (200778 <SCB_CleanDCache+0x68>)
  200714:	2200      	movs	r2, #0
  200716:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  20071a:	f3bf 8f4f 	dsb	sy
}
  20071e:	bf00      	nop
   __DSB();

    ccsidr = SCB->CCSIDR;
  200720:	4b15      	ldr	r3, [pc, #84]	@ (200778 <SCB_CleanDCache+0x68>)
  200722:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
  200726:	9301      	str	r3, [sp, #4]

                                            /* clean D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  200728:	9b01      	ldr	r3, [sp, #4]
  20072a:	0b5b      	lsrs	r3, r3, #13
  20072c:	f3c3 030e 	ubfx	r3, r3, #0, #15
  200730:	9303      	str	r3, [sp, #12]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  200732:	9b01      	ldr	r3, [sp, #4]
  200734:	08db      	lsrs	r3, r3, #3
  200736:	f3c3 0309 	ubfx	r3, r3, #0, #10
  20073a:	9302      	str	r3, [sp, #8]
      do {
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
  20073c:	9b03      	ldr	r3, [sp, #12]
  20073e:	015a      	lsls	r2, r3, #5
  200740:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
  200744:	4013      	ands	r3, r2
                      ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );
  200746:	9a02      	ldr	r2, [sp, #8]
  200748:	0792      	lsls	r2, r2, #30
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
  20074a:	490b      	ldr	r1, [pc, #44]	@ (200778 <SCB_CleanDCache+0x68>)
  20074c:	4313      	orrs	r3, r2
  20074e:	f8c1 326c 	str.w	r3, [r1, #620]	@ 0x26c
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
  200752:	9b02      	ldr	r3, [sp, #8]
  200754:	1e5a      	subs	r2, r3, #1
  200756:	9202      	str	r2, [sp, #8]
  200758:	2b00      	cmp	r3, #0
  20075a:	d1ef      	bne.n	20073c <SCB_CleanDCache+0x2c>
    } while(sets-- != 0U);
  20075c:	9b03      	ldr	r3, [sp, #12]
  20075e:	1e5a      	subs	r2, r3, #1
  200760:	9203      	str	r2, [sp, #12]
  200762:	2b00      	cmp	r3, #0
  200764:	d1e5      	bne.n	200732 <SCB_CleanDCache+0x22>
  __ASM volatile ("dsb 0xF":::"memory");
  200766:	f3bf 8f4f 	dsb	sy
}
  20076a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
  20076c:	f3bf 8f6f 	isb	sy
}
  200770:	bf00      	nop

    __DSB();
    __ISB();
  #endif
}
  200772:	bf00      	nop
  200774:	b004      	add	sp, #16
  200776:	4770      	bx	lr
  200778:	e000ed00 	.word	0xe000ed00
  20077c:	00000000 	.word	0x00000000

00200780 <__cpu_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __cpu_init(void) {
  200780:	b508      	push	{r3, lr}

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  200782:	f7ff ff4d 	bl	200620 <SCB_EnableICache>
  SCB_EnableDCache();
  200786:	f7ff ff83 	bl	200690 <SCB_EnableDCache>
#endif
}
  20078a:	bf00      	nop
  20078c:	bd08      	pop	{r3, pc}
  20078e:	bf00      	nop

00200790 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
  200790:	bf00      	nop
  200792:	4770      	bx	lr
	...

002007a0 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  2007a0:	bf00      	nop
  2007a2:	e7fd      	b.n	2007a0 <__default_exit>
	...

002007b0 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
  2007b0:	b500      	push	{lr}
  2007b2:	b085      	sub	sp, #20
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
  2007b4:	4b19      	ldr	r3, [pc, #100]	@ (20081c <__init_ram_areas+0x6c>)
  2007b6:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
  2007b8:	9b03      	ldr	r3, [sp, #12]
  2007ba:	681b      	ldr	r3, [r3, #0]
  2007bc:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
  2007be:	9b03      	ldr	r3, [sp, #12]
  2007c0:	685b      	ldr	r3, [r3, #4]
  2007c2:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
  2007c4:	e009      	b.n	2007da <__init_ram_areas+0x2a>
      *p = *tp;
  2007c6:	9b02      	ldr	r3, [sp, #8]
  2007c8:	681a      	ldr	r2, [r3, #0]
  2007ca:	9b01      	ldr	r3, [sp, #4]
  2007cc:	601a      	str	r2, [r3, #0]
      p++;
  2007ce:	9b01      	ldr	r3, [sp, #4]
  2007d0:	3304      	adds	r3, #4
  2007d2:	9301      	str	r3, [sp, #4]
      tp++;
  2007d4:	9b02      	ldr	r3, [sp, #8]
  2007d6:	3304      	adds	r3, #4
  2007d8:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
  2007da:	9b03      	ldr	r3, [sp, #12]
  2007dc:	689b      	ldr	r3, [r3, #8]
  2007de:	9a01      	ldr	r2, [sp, #4]
  2007e0:	429a      	cmp	r2, r3
  2007e2:	d3f0      	bcc.n	2007c6 <__init_ram_areas+0x16>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
  2007e4:	e005      	b.n	2007f2 <__init_ram_areas+0x42>
      *p = 0;
  2007e6:	9b01      	ldr	r3, [sp, #4]
  2007e8:	2200      	movs	r2, #0
  2007ea:	601a      	str	r2, [r3, #0]
      p++;
  2007ec:	9b01      	ldr	r3, [sp, #4]
  2007ee:	3304      	adds	r3, #4
  2007f0:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
  2007f2:	9b03      	ldr	r3, [sp, #12]
  2007f4:	68db      	ldr	r3, [r3, #12]
  2007f6:	9a01      	ldr	r2, [sp, #4]
  2007f8:	429a      	cmp	r2, r3
  2007fa:	d3f4      	bcc.n	2007e6 <__init_ram_areas+0x36>
    }
    rap++;
  2007fc:	9b03      	ldr	r3, [sp, #12]
  2007fe:	3310      	adds	r3, #16
  200800:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
  200802:	9b03      	ldr	r3, [sp, #12]
  200804:	4a06      	ldr	r2, [pc, #24]	@ (200820 <__init_ram_areas+0x70>)
  200806:	4293      	cmp	r3, r2
  200808:	d3d6      	bcc.n	2007b8 <__init_ram_areas+0x8>
#if CORTEX_MODEL == 7
  /* PM0253 - 4.8.7 Cache maintenance design hints and tips - required
     for self-modifying code.*/
  SCB_CleanDCache();
  20080a:	f7ff ff81 	bl	200710 <SCB_CleanDCache>
  SCB_InvalidateICache();
  20080e:	f7ff ff27 	bl	200660 <SCB_InvalidateICache>
#endif
#endif
}
  200812:	bf00      	nop
  200814:	b005      	add	sp, #20
  200816:	f85d fb04 	ldr.w	pc, [sp], #4
  20081a:	bf00      	nop
  20081c:	0800ffa0 	.word	0x0800ffa0
  200820:	08010020 	.word	0x08010020
	...

00200830 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
  200830:	bf00      	nop
  200832:	4770      	bx	lr
	...

00200840 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
  200840:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
  200842:	f7ff fff5 	bl	200830 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
  200846:	f000 feab 	bl	2015a0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
  20084a:	f000 ffa1 	bl	201790 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
  20084e:	f000 fc87 	bl	201160 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
  200852:	f001 fae5 	bl	201e20 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
  200856:	f000 f83b 	bl	2008d0 <stInit>
#endif
}
  20085a:	bf00      	nop
  20085c:	bd08      	pop	{r3, pc}
  20085e:	bf00      	nop

00200860 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
  200860:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  200864:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
}
  200866:	4618      	mov	r0, r3
  200868:	4770      	bx	lr
  20086a:	bf00      	nop
  20086c:	0000      	movs	r0, r0
	...

00200870 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
  200870:	b082      	sub	sp, #8
  200872:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
  200874:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
  200878:	9b01      	ldr	r3, [sp, #4]
  20087a:	6353      	str	r3, [r2, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
  20087c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  200880:	2200      	movs	r2, #0
  200882:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
  200884:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  200888:	2202      	movs	r2, #2
  20088a:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
  20088c:	bf00      	nop
  20088e:	b002      	add	sp, #8
  200890:	4770      	bx	lr
  200892:	bf00      	nop
	...

002008a0 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
  2008a0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  2008a4:	2200      	movs	r2, #0
  2008a6:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
  2008a8:	bf00      	nop
  2008aa:	4770      	bx	lr
  2008ac:	0000      	movs	r0, r0
	...

002008b0 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
  2008b0:	b082      	sub	sp, #8
  2008b2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
  2008b4:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
  2008b8:	9b01      	ldr	r3, [sp, #4]
  2008ba:	6353      	str	r3, [r2, #52]	@ 0x34
}
  2008bc:	bf00      	nop
  2008be:	b002      	add	sp, #8
  2008c0:	4770      	bx	lr
  2008c2:	bf00      	nop
	...

002008d0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
  2008d0:	b508      	push	{r3, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
  2008d2:	f000 ff9d 	bl	201810 <st_lld_init>
}
  2008d6:	bf00      	nop
  2008d8:	bd08      	pop	{r3, pc}
  2008da:	bf00      	nop
  2008dc:	0000      	movs	r0, r0
	...

002008e0 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
  2008e0:	b508      	push	{r3, lr}

  return st_lld_get_counter();
  2008e2:	f7ff ffbd 	bl	200860 <st_lld_get_counter>
  2008e6:	4603      	mov	r3, r0
}
  2008e8:	4618      	mov	r0, r3
  2008ea:	bd08      	pop	{r3, pc}
  2008ec:	0000      	movs	r0, r0
	...

002008f0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
  2008f0:	b500      	push	{lr}
  2008f2:	b083      	sub	sp, #12
  2008f4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
  2008f6:	9801      	ldr	r0, [sp, #4]
  2008f8:	f7ff ffba 	bl	200870 <st_lld_start_alarm>
}
  2008fc:	bf00      	nop
  2008fe:	b003      	add	sp, #12
  200900:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00200910 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
  200910:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
  200912:	f7ff ffc5 	bl	2008a0 <st_lld_stop_alarm>
}
  200916:	bf00      	nop
  200918:	bd08      	pop	{r3, pc}
  20091a:	bf00      	nop
  20091c:	0000      	movs	r0, r0
	...

00200920 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
  200920:	b500      	push	{lr}
  200922:	b083      	sub	sp, #12
  200924:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
  200926:	9801      	ldr	r0, [sp, #4]
  200928:	f7ff ffc2 	bl	2008b0 <st_lld_set_alarm>
}
  20092c:	bf00      	nop
  20092e:	b003      	add	sp, #12
  200930:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00200940 <chSysLock.lto_priv.1>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
  200940:	b082      	sub	sp, #8
  200942:	2330      	movs	r3, #48	@ 0x30
  200944:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  200946:	9b01      	ldr	r3, [sp, #4]
  200948:	f383 8811 	msr	BASEPRI, r3
}
  20094c:	bf00      	nop
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
  20094e:	bf00      	nop

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
}
  200950:	bf00      	nop
  200952:	b002      	add	sp, #8
  200954:	4770      	bx	lr
  200956:	bf00      	nop
	...

00200960 <chSysUnlock.lto_priv.1>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  200960:	b082      	sub	sp, #8
  200962:	2300      	movs	r3, #0
  200964:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  200966:	9b01      	ldr	r3, [sp, #4]
  200968:	f383 8811 	msr	BASEPRI, r3
}
  20096c:	bf00      	nop
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
  20096e:	bf00      	nop
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
  200970:	bf00      	nop
  200972:	b002      	add	sp, #8
  200974:	4770      	bx	lr
  200976:	bf00      	nop
	...

00200980 <osalSysLock.lto_priv.1>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
  200980:	b508      	push	{r3, lr}

  chSysLock();
  200982:	f7ff ffdd 	bl	200940 <chSysLock.lto_priv.1>
}
  200986:	bf00      	nop
  200988:	bd08      	pop	{r3, pc}
  20098a:	bf00      	nop
  20098c:	0000      	movs	r0, r0
	...

00200990 <osalSysUnlock.lto_priv.1>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
  200990:	b508      	push	{r3, lr}

  chSysUnlock();
  200992:	f7ff ffe5 	bl	200960 <chSysUnlock.lto_priv.1>
}
  200996:	bf00      	nop
  200998:	bd08      	pop	{r3, pc}
  20099a:	bf00      	nop
  20099c:	0000      	movs	r0, r0
	...

002009a0 <osalThreadQueueObjectInit.lto_priv.1>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
  2009a0:	b500      	push	{lr}
  2009a2:	b083      	sub	sp, #12
  2009a4:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
  2009a6:	9801      	ldr	r0, [sp, #4]
  2009a8:	f002 feca 	bl	203740 <chThdQueueObjectInit>
}
  2009ac:	bf00      	nop
  2009ae:	b003      	add	sp, #12
  2009b0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002009c0 <osalThreadEnqueueTimeoutS.lto_priv.1>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {
  2009c0:	b500      	push	{lr}
  2009c2:	b083      	sub	sp, #12
  2009c4:	9001      	str	r0, [sp, #4]
  2009c6:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, timeout);
  2009c8:	9900      	ldr	r1, [sp, #0]
  2009ca:	9801      	ldr	r0, [sp, #4]
  2009cc:	f002 fec8 	bl	203760 <chThdEnqueueTimeoutS>
  2009d0:	4603      	mov	r3, r0
}
  2009d2:	4618      	mov	r0, r3
  2009d4:	b003      	add	sp, #12
  2009d6:	f85d fb04 	ldr.w	pc, [sp], #4
  2009da:	bf00      	nop
  2009dc:	0000      	movs	r0, r0
	...

002009e0 <osalThreadDequeueNextI.lto_priv.1>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  2009e0:	b500      	push	{lr}
  2009e2:	b083      	sub	sp, #12
  2009e4:	9001      	str	r0, [sp, #4]
  2009e6:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
  2009e8:	9900      	ldr	r1, [sp, #0]
  2009ea:	9801      	ldr	r0, [sp, #4]
  2009ec:	f002 fed8 	bl	2037a0 <chThdDequeueNextI>
}
  2009f0:	bf00      	nop
  2009f2:	b003      	add	sp, #12
  2009f4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00200a00 <iq_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
  200a00:	b500      	push	{lr}
  200a02:	b087      	sub	sp, #28
  200a04:	9003      	str	r0, [sp, #12]
  200a06:	9102      	str	r1, [sp, #8]
  200a08:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
  200a0a:	9b03      	ldr	r3, [sp, #12]
  200a0c:	689b      	ldr	r3, [r3, #8]
  200a0e:	9a01      	ldr	r2, [sp, #4]
  200a10:	429a      	cmp	r2, r3
  200a12:	d902      	bls.n	200a1a <iq_read+0x1a>
    n = iqGetFullI(iqp);
  200a14:	9b03      	ldr	r3, [sp, #12]
  200a16:	689b      	ldr	r3, [r3, #8]
  200a18:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
  200a1a:	9b03      	ldr	r3, [sp, #12]
  200a1c:	691a      	ldr	r2, [r3, #16]
  200a1e:	9b03      	ldr	r3, [sp, #12]
  200a20:	699b      	ldr	r3, [r3, #24]
  200a22:	1ad3      	subs	r3, r2, r3
  200a24:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
  200a26:	9a01      	ldr	r2, [sp, #4]
  200a28:	9b05      	ldr	r3, [sp, #20]
  200a2a:	429a      	cmp	r2, r3
  200a2c:	d20d      	bcs.n	200a4a <iq_read+0x4a>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
  200a2e:	9b03      	ldr	r3, [sp, #12]
  200a30:	699b      	ldr	r3, [r3, #24]
  200a32:	9a01      	ldr	r2, [sp, #4]
  200a34:	4619      	mov	r1, r3
  200a36:	9802      	ldr	r0, [sp, #8]
  200a38:	f7ff fd54 	bl	2004e4 <memcpy>
    iqp->q_rdptr += n;
  200a3c:	9b03      	ldr	r3, [sp, #12]
  200a3e:	699a      	ldr	r2, [r3, #24]
  200a40:	9b01      	ldr	r3, [sp, #4]
  200a42:	441a      	add	r2, r3
  200a44:	9b03      	ldr	r3, [sp, #12]
  200a46:	619a      	str	r2, [r3, #24]
  200a48:	e02b      	b.n	200aa2 <iq_read+0xa2>
  }
  else if (n > s1) {
  200a4a:	9a01      	ldr	r2, [sp, #4]
  200a4c:	9b05      	ldr	r3, [sp, #20]
  200a4e:	429a      	cmp	r2, r3
  200a50:	d91c      	bls.n	200a8c <iq_read+0x8c>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
  200a52:	9b03      	ldr	r3, [sp, #12]
  200a54:	699b      	ldr	r3, [r3, #24]
  200a56:	9a05      	ldr	r2, [sp, #20]
  200a58:	4619      	mov	r1, r3
  200a5a:	9802      	ldr	r0, [sp, #8]
  200a5c:	f7ff fd42 	bl	2004e4 <memcpy>
    bp += s1;
  200a60:	9a02      	ldr	r2, [sp, #8]
  200a62:	9b05      	ldr	r3, [sp, #20]
  200a64:	4413      	add	r3, r2
  200a66:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
  200a68:	9a01      	ldr	r2, [sp, #4]
  200a6a:	9b05      	ldr	r3, [sp, #20]
  200a6c:	1ad3      	subs	r3, r2, r3
  200a6e:	9304      	str	r3, [sp, #16]
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
  200a70:	9b03      	ldr	r3, [sp, #12]
  200a72:	68db      	ldr	r3, [r3, #12]
  200a74:	9a04      	ldr	r2, [sp, #16]
  200a76:	4619      	mov	r1, r3
  200a78:	9802      	ldr	r0, [sp, #8]
  200a7a:	f7ff fd33 	bl	2004e4 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
  200a7e:	9b03      	ldr	r3, [sp, #12]
  200a80:	68da      	ldr	r2, [r3, #12]
  200a82:	9b04      	ldr	r3, [sp, #16]
  200a84:	441a      	add	r2, r3
  200a86:	9b03      	ldr	r3, [sp, #12]
  200a88:	619a      	str	r2, [r3, #24]
  200a8a:	e00a      	b.n	200aa2 <iq_read+0xa2>
  }
  else {
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
  200a8c:	9b03      	ldr	r3, [sp, #12]
  200a8e:	699b      	ldr	r3, [r3, #24]
  200a90:	9a01      	ldr	r2, [sp, #4]
  200a92:	4619      	mov	r1, r3
  200a94:	9802      	ldr	r0, [sp, #8]
  200a96:	f7ff fd25 	bl	2004e4 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
  200a9a:	9b03      	ldr	r3, [sp, #12]
  200a9c:	68da      	ldr	r2, [r3, #12]
  200a9e:	9b03      	ldr	r3, [sp, #12]
  200aa0:	619a      	str	r2, [r3, #24]
  }

  iqp->q_counter -= n;
  200aa2:	9b03      	ldr	r3, [sp, #12]
  200aa4:	689a      	ldr	r2, [r3, #8]
  200aa6:	9b01      	ldr	r3, [sp, #4]
  200aa8:	1ad2      	subs	r2, r2, r3
  200aaa:	9b03      	ldr	r3, [sp, #12]
  200aac:	609a      	str	r2, [r3, #8]
  return n;
  200aae:	9b01      	ldr	r3, [sp, #4]
}
  200ab0:	4618      	mov	r0, r3
  200ab2:	b007      	add	sp, #28
  200ab4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00200ac0 <oq_write>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
  200ac0:	b500      	push	{lr}
  200ac2:	b087      	sub	sp, #28
  200ac4:	9003      	str	r0, [sp, #12]
  200ac6:	9102      	str	r1, [sp, #8]
  200ac8:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
  200aca:	9b03      	ldr	r3, [sp, #12]
  200acc:	689b      	ldr	r3, [r3, #8]
  200ace:	9a01      	ldr	r2, [sp, #4]
  200ad0:	429a      	cmp	r2, r3
  200ad2:	d902      	bls.n	200ada <oq_write+0x1a>
    n = oqGetEmptyI(oqp);
  200ad4:	9b03      	ldr	r3, [sp, #12]
  200ad6:	689b      	ldr	r3, [r3, #8]
  200ad8:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
  200ada:	9b03      	ldr	r3, [sp, #12]
  200adc:	691a      	ldr	r2, [r3, #16]
  200ade:	9b03      	ldr	r3, [sp, #12]
  200ae0:	695b      	ldr	r3, [r3, #20]
  200ae2:	1ad3      	subs	r3, r2, r3
  200ae4:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
  200ae6:	9a01      	ldr	r2, [sp, #4]
  200ae8:	9b05      	ldr	r3, [sp, #20]
  200aea:	429a      	cmp	r2, r3
  200aec:	d20d      	bcs.n	200b0a <oq_write+0x4a>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
  200aee:	9b03      	ldr	r3, [sp, #12]
  200af0:	695b      	ldr	r3, [r3, #20]
  200af2:	9a01      	ldr	r2, [sp, #4]
  200af4:	9902      	ldr	r1, [sp, #8]
  200af6:	4618      	mov	r0, r3
  200af8:	f7ff fcf4 	bl	2004e4 <memcpy>
    oqp->q_wrptr += n;
  200afc:	9b03      	ldr	r3, [sp, #12]
  200afe:	695a      	ldr	r2, [r3, #20]
  200b00:	9b01      	ldr	r3, [sp, #4]
  200b02:	441a      	add	r2, r3
  200b04:	9b03      	ldr	r3, [sp, #12]
  200b06:	615a      	str	r2, [r3, #20]
  200b08:	e02b      	b.n	200b62 <oq_write+0xa2>
  }
  else if (n > s1) {
  200b0a:	9a01      	ldr	r2, [sp, #4]
  200b0c:	9b05      	ldr	r3, [sp, #20]
  200b0e:	429a      	cmp	r2, r3
  200b10:	d91c      	bls.n	200b4c <oq_write+0x8c>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
  200b12:	9b03      	ldr	r3, [sp, #12]
  200b14:	695b      	ldr	r3, [r3, #20]
  200b16:	9a05      	ldr	r2, [sp, #20]
  200b18:	9902      	ldr	r1, [sp, #8]
  200b1a:	4618      	mov	r0, r3
  200b1c:	f7ff fce2 	bl	2004e4 <memcpy>
    bp += s1;
  200b20:	9a02      	ldr	r2, [sp, #8]
  200b22:	9b05      	ldr	r3, [sp, #20]
  200b24:	4413      	add	r3, r2
  200b26:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
  200b28:	9a01      	ldr	r2, [sp, #4]
  200b2a:	9b05      	ldr	r3, [sp, #20]
  200b2c:	1ad3      	subs	r3, r2, r3
  200b2e:	9304      	str	r3, [sp, #16]
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
  200b30:	9b03      	ldr	r3, [sp, #12]
  200b32:	68db      	ldr	r3, [r3, #12]
  200b34:	9a04      	ldr	r2, [sp, #16]
  200b36:	9902      	ldr	r1, [sp, #8]
  200b38:	4618      	mov	r0, r3
  200b3a:	f7ff fcd3 	bl	2004e4 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
  200b3e:	9b03      	ldr	r3, [sp, #12]
  200b40:	68da      	ldr	r2, [r3, #12]
  200b42:	9b04      	ldr	r3, [sp, #16]
  200b44:	441a      	add	r2, r3
  200b46:	9b03      	ldr	r3, [sp, #12]
  200b48:	615a      	str	r2, [r3, #20]
  200b4a:	e00a      	b.n	200b62 <oq_write+0xa2>
  }
  else {
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
  200b4c:	9b03      	ldr	r3, [sp, #12]
  200b4e:	695b      	ldr	r3, [r3, #20]
  200b50:	9a01      	ldr	r2, [sp, #4]
  200b52:	9902      	ldr	r1, [sp, #8]
  200b54:	4618      	mov	r0, r3
  200b56:	f7ff fcc5 	bl	2004e4 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
  200b5a:	9b03      	ldr	r3, [sp, #12]
  200b5c:	68da      	ldr	r2, [r3, #12]
  200b5e:	9b03      	ldr	r3, [sp, #12]
  200b60:	615a      	str	r2, [r3, #20]
  }

  oqp->q_counter -= n;
  200b62:	9b03      	ldr	r3, [sp, #12]
  200b64:	689a      	ldr	r2, [r3, #8]
  200b66:	9b01      	ldr	r3, [sp, #4]
  200b68:	1ad2      	subs	r2, r2, r3
  200b6a:	9b03      	ldr	r3, [sp, #12]
  200b6c:	609a      	str	r2, [r3, #8]
  return n;
  200b6e:	9b01      	ldr	r3, [sp, #4]
}
  200b70:	4618      	mov	r0, r3
  200b72:	b007      	add	sp, #28
  200b74:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00200b80 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
  200b80:	b500      	push	{lr}
  200b82:	b085      	sub	sp, #20
  200b84:	9003      	str	r0, [sp, #12]
  200b86:	9102      	str	r1, [sp, #8]
  200b88:	9201      	str	r2, [sp, #4]
  200b8a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
  200b8c:	9b03      	ldr	r3, [sp, #12]
  200b8e:	4618      	mov	r0, r3
  200b90:	f7ff ff06 	bl	2009a0 <osalThreadQueueObjectInit.lto_priv.1>
  iqp->q_counter = 0;
  200b94:	9b03      	ldr	r3, [sp, #12]
  200b96:	2200      	movs	r2, #0
  200b98:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
  200b9a:	9b03      	ldr	r3, [sp, #12]
  200b9c:	9a02      	ldr	r2, [sp, #8]
  200b9e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
  200ba0:	9b03      	ldr	r3, [sp, #12]
  200ba2:	9a02      	ldr	r2, [sp, #8]
  200ba4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
  200ba6:	9b03      	ldr	r3, [sp, #12]
  200ba8:	9a02      	ldr	r2, [sp, #8]
  200baa:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
  200bac:	9a02      	ldr	r2, [sp, #8]
  200bae:	9b01      	ldr	r3, [sp, #4]
  200bb0:	441a      	add	r2, r3
  200bb2:	9b03      	ldr	r3, [sp, #12]
  200bb4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
  200bb6:	9b03      	ldr	r3, [sp, #12]
  200bb8:	9a00      	ldr	r2, [sp, #0]
  200bba:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
  200bbc:	9b03      	ldr	r3, [sp, #12]
  200bbe:	9a06      	ldr	r2, [sp, #24]
  200bc0:	621a      	str	r2, [r3, #32]
}
  200bc2:	bf00      	nop
  200bc4:	b005      	add	sp, #20
  200bc6:	f85d fb04 	ldr.w	pc, [sp], #4
  200bca:	bf00      	nop
  200bcc:	0000      	movs	r0, r0
	...

00200bd0 <iqPutI>:
 * @retval MSG_OK       if the operation has been completed with success.
 * @retval MSG_TIMEOUT  if the queue is full.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
  200bd0:	b500      	push	{lr}
  200bd2:	b083      	sub	sp, #12
  200bd4:	9001      	str	r0, [sp, #4]
  200bd6:	460b      	mov	r3, r1
  200bd8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
  200bdc:	9b01      	ldr	r3, [sp, #4]
  200bde:	695a      	ldr	r2, [r3, #20]
  200be0:	9b01      	ldr	r3, [sp, #4]
  200be2:	699b      	ldr	r3, [r3, #24]
  200be4:	429a      	cmp	r2, r3
  200be6:	d105      	bne.n	200bf4 <iqPutI+0x24>
  200be8:	9b01      	ldr	r3, [sp, #4]
  200bea:	689b      	ldr	r3, [r3, #8]
  200bec:	2b00      	cmp	r3, #0
  200bee:	d001      	beq.n	200bf4 <iqPutI+0x24>
  200bf0:	2301      	movs	r3, #1
  200bf2:	e000      	b.n	200bf6 <iqPutI+0x26>
  200bf4:	2300      	movs	r3, #0
  200bf6:	f003 0301 	and.w	r3, r3, #1
  200bfa:	b2db      	uxtb	r3, r3
  200bfc:	f083 0301 	eor.w	r3, r3, #1
  200c00:	b2db      	uxtb	r3, r3
  200c02:	2b00      	cmp	r3, #0
  200c04:	d01d      	beq.n	200c42 <iqPutI+0x72>
    iqp->q_counter++;
  200c06:	9b01      	ldr	r3, [sp, #4]
  200c08:	689b      	ldr	r3, [r3, #8]
  200c0a:	1c5a      	adds	r2, r3, #1
  200c0c:	9b01      	ldr	r3, [sp, #4]
  200c0e:	609a      	str	r2, [r3, #8]
    *iqp->q_wrptr++ = b;
  200c10:	9b01      	ldr	r3, [sp, #4]
  200c12:	695b      	ldr	r3, [r3, #20]
  200c14:	1c59      	adds	r1, r3, #1
  200c16:	9a01      	ldr	r2, [sp, #4]
  200c18:	6151      	str	r1, [r2, #20]
  200c1a:	f89d 2003 	ldrb.w	r2, [sp, #3]
  200c1e:	701a      	strb	r2, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
  200c20:	9b01      	ldr	r3, [sp, #4]
  200c22:	695a      	ldr	r2, [r3, #20]
  200c24:	9b01      	ldr	r3, [sp, #4]
  200c26:	691b      	ldr	r3, [r3, #16]
  200c28:	429a      	cmp	r2, r3
  200c2a:	d303      	bcc.n	200c34 <iqPutI+0x64>
      iqp->q_wrptr = iqp->q_buffer;
  200c2c:	9b01      	ldr	r3, [sp, #4]
  200c2e:	68da      	ldr	r2, [r3, #12]
  200c30:	9b01      	ldr	r3, [sp, #4]
  200c32:	615a      	str	r2, [r3, #20]
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
  200c34:	9b01      	ldr	r3, [sp, #4]
  200c36:	2100      	movs	r1, #0
  200c38:	4618      	mov	r0, r3
  200c3a:	f7ff fed1 	bl	2009e0 <osalThreadDequeueNextI.lto_priv.1>

    return MSG_OK;
  200c3e:	2300      	movs	r3, #0
  200c40:	e001      	b.n	200c46 <iqPutI+0x76>
  }

  return MSG_TIMEOUT;
  200c42:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
  200c46:	4618      	mov	r0, r3
  200c48:	b003      	add	sp, #12
  200c4a:	f85d fb04 	ldr.w	pc, [sp], #4
  200c4e:	bf00      	nop

00200c50 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
  200c50:	b500      	push	{lr}
  200c52:	b085      	sub	sp, #20
  200c54:	9001      	str	r0, [sp, #4]
  200c56:	9100      	str	r1, [sp, #0]
  uint8_t b;

  osalSysLock();
  200c58:	f7ff fe92 	bl	200980 <osalSysLock.lto_priv.1>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
  200c5c:	e00c      	b.n	200c78 <iqGetTimeout+0x28>
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
  200c5e:	9b01      	ldr	r3, [sp, #4]
  200c60:	9900      	ldr	r1, [sp, #0]
  200c62:	4618      	mov	r0, r3
  200c64:	f7ff feac 	bl	2009c0 <osalThreadEnqueueTimeoutS.lto_priv.1>
  200c68:	9002      	str	r0, [sp, #8]
    if (msg < MSG_OK) {
  200c6a:	9b02      	ldr	r3, [sp, #8]
  200c6c:	2b00      	cmp	r3, #0
  200c6e:	da03      	bge.n	200c78 <iqGetTimeout+0x28>
      osalSysUnlock();
  200c70:	f7ff fe8e 	bl	200990 <osalSysUnlock.lto_priv.1>
      return msg;
  200c74:	9b02      	ldr	r3, [sp, #8]
  200c76:	e026      	b.n	200cc6 <iqGetTimeout+0x76>
  while (iqIsEmptyI(iqp)) {
  200c78:	9b01      	ldr	r3, [sp, #4]
  200c7a:	689b      	ldr	r3, [r3, #8]
  200c7c:	2b00      	cmp	r3, #0
  200c7e:	d0ee      	beq.n	200c5e <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  200c80:	9b01      	ldr	r3, [sp, #4]
  200c82:	689b      	ldr	r3, [r3, #8]
  200c84:	1e5a      	subs	r2, r3, #1
  200c86:	9b01      	ldr	r3, [sp, #4]
  200c88:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
  200c8a:	9b01      	ldr	r3, [sp, #4]
  200c8c:	699b      	ldr	r3, [r3, #24]
  200c8e:	1c59      	adds	r1, r3, #1
  200c90:	9a01      	ldr	r2, [sp, #4]
  200c92:	6191      	str	r1, [r2, #24]
  200c94:	781b      	ldrb	r3, [r3, #0]
  200c96:	f88d 300f 	strb.w	r3, [sp, #15]
  if (iqp->q_rdptr >= iqp->q_top) {
  200c9a:	9b01      	ldr	r3, [sp, #4]
  200c9c:	699a      	ldr	r2, [r3, #24]
  200c9e:	9b01      	ldr	r3, [sp, #4]
  200ca0:	691b      	ldr	r3, [r3, #16]
  200ca2:	429a      	cmp	r2, r3
  200ca4:	d303      	bcc.n	200cae <iqGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
  200ca6:	9b01      	ldr	r3, [sp, #4]
  200ca8:	68da      	ldr	r2, [r3, #12]
  200caa:	9b01      	ldr	r3, [sp, #4]
  200cac:	619a      	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
  200cae:	9b01      	ldr	r3, [sp, #4]
  200cb0:	69db      	ldr	r3, [r3, #28]
  200cb2:	2b00      	cmp	r3, #0
  200cb4:	d003      	beq.n	200cbe <iqGetTimeout+0x6e>
    iqp->q_notify(iqp);
  200cb6:	9b01      	ldr	r3, [sp, #4]
  200cb8:	69db      	ldr	r3, [r3, #28]
  200cba:	9801      	ldr	r0, [sp, #4]
  200cbc:	4798      	blx	r3
  }

  osalSysUnlock();
  200cbe:	f7ff fe67 	bl	200990 <osalSysUnlock.lto_priv.1>

  return (msg_t)b;
  200cc2:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
  200cc6:	4618      	mov	r0, r3
  200cc8:	b005      	add	sp, #20
  200cca:	f85d fb04 	ldr.w	pc, [sp], #4
  200cce:	bf00      	nop

00200cd0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
  200cd0:	b500      	push	{lr}
  200cd2:	b089      	sub	sp, #36	@ 0x24
  200cd4:	9003      	str	r0, [sp, #12]
  200cd6:	9102      	str	r1, [sp, #8]
  200cd8:	9201      	str	r2, [sp, #4]
  200cda:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
  200cdc:	9b03      	ldr	r3, [sp, #12]
  200cde:	69db      	ldr	r3, [r3, #28]
  200ce0:	9307      	str	r3, [sp, #28]
  size_t max = n;
  200ce2:	9b01      	ldr	r3, [sp, #4]
  200ce4:	9306      	str	r3, [sp, #24]

  osalDbgCheck(n > 0U);

  osalSysLock();
  200ce6:	f7ff fe4b 	bl	200980 <osalSysLock.lto_priv.1>

  while (n > 0U) {
  200cea:	e024      	b.n	200d36 <iqReadTimeout+0x66>
    size_t done;

    done = iq_read(iqp, bp, n);
  200cec:	9a01      	ldr	r2, [sp, #4]
  200cee:	9902      	ldr	r1, [sp, #8]
  200cf0:	9803      	ldr	r0, [sp, #12]
  200cf2:	f7ff fe85 	bl	200a00 <iq_read>
  200cf6:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
  200cf8:	9b05      	ldr	r3, [sp, #20]
  200cfa:	2b00      	cmp	r3, #0
  200cfc:	d109      	bne.n	200d12 <iqReadTimeout+0x42>
      msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
  200cfe:	9b03      	ldr	r3, [sp, #12]
  200d00:	9900      	ldr	r1, [sp, #0]
  200d02:	4618      	mov	r0, r3
  200d04:	f7ff fe5c 	bl	2009c0 <osalThreadEnqueueTimeoutS.lto_priv.1>
  200d08:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
  200d0a:	9b04      	ldr	r3, [sp, #16]
  200d0c:	2b00      	cmp	r3, #0
  200d0e:	d012      	beq.n	200d36 <iqReadTimeout+0x66>
        break;
  200d10:	e014      	b.n	200d3c <iqReadTimeout+0x6c>
      }
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
  200d12:	9b07      	ldr	r3, [sp, #28]
  200d14:	2b00      	cmp	r3, #0
  200d16:	d002      	beq.n	200d1e <iqReadTimeout+0x4e>
        nfy(iqp);
  200d18:	9b07      	ldr	r3, [sp, #28]
  200d1a:	9803      	ldr	r0, [sp, #12]
  200d1c:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
  200d1e:	f7ff fe37 	bl	200990 <osalSysUnlock.lto_priv.1>

      n  -= done;
  200d22:	9a01      	ldr	r2, [sp, #4]
  200d24:	9b05      	ldr	r3, [sp, #20]
  200d26:	1ad3      	subs	r3, r2, r3
  200d28:	9301      	str	r3, [sp, #4]
      bp += done;
  200d2a:	9a02      	ldr	r2, [sp, #8]
  200d2c:	9b05      	ldr	r3, [sp, #20]
  200d2e:	4413      	add	r3, r2
  200d30:	9302      	str	r3, [sp, #8]

      osalSysLock();
  200d32:	f7ff fe25 	bl	200980 <osalSysLock.lto_priv.1>
  while (n > 0U) {
  200d36:	9b01      	ldr	r3, [sp, #4]
  200d38:	2b00      	cmp	r3, #0
  200d3a:	d1d7      	bne.n	200cec <iqReadTimeout+0x1c>
    }
  }

  osalSysUnlock();
  200d3c:	f7ff fe28 	bl	200990 <osalSysUnlock.lto_priv.1>
  return max - n;
  200d40:	9a06      	ldr	r2, [sp, #24]
  200d42:	9b01      	ldr	r3, [sp, #4]
  200d44:	1ad3      	subs	r3, r2, r3
}
  200d46:	4618      	mov	r0, r3
  200d48:	b009      	add	sp, #36	@ 0x24
  200d4a:	f85d fb04 	ldr.w	pc, [sp], #4
  200d4e:	bf00      	nop

00200d50 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
  200d50:	b500      	push	{lr}
  200d52:	b085      	sub	sp, #20
  200d54:	9003      	str	r0, [sp, #12]
  200d56:	9102      	str	r1, [sp, #8]
  200d58:	9201      	str	r2, [sp, #4]
  200d5a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
  200d5c:	9b03      	ldr	r3, [sp, #12]
  200d5e:	4618      	mov	r0, r3
  200d60:	f7ff fe1e 	bl	2009a0 <osalThreadQueueObjectInit.lto_priv.1>
  oqp->q_counter = size;
  200d64:	9b03      	ldr	r3, [sp, #12]
  200d66:	9a01      	ldr	r2, [sp, #4]
  200d68:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
  200d6a:	9b03      	ldr	r3, [sp, #12]
  200d6c:	9a02      	ldr	r2, [sp, #8]
  200d6e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
  200d70:	9b03      	ldr	r3, [sp, #12]
  200d72:	9a02      	ldr	r2, [sp, #8]
  200d74:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
  200d76:	9b03      	ldr	r3, [sp, #12]
  200d78:	9a02      	ldr	r2, [sp, #8]
  200d7a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
  200d7c:	9a02      	ldr	r2, [sp, #8]
  200d7e:	9b01      	ldr	r3, [sp, #4]
  200d80:	441a      	add	r2, r3
  200d82:	9b03      	ldr	r3, [sp, #12]
  200d84:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
  200d86:	9b03      	ldr	r3, [sp, #12]
  200d88:	9a00      	ldr	r2, [sp, #0]
  200d8a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
  200d8c:	9b03      	ldr	r3, [sp, #12]
  200d8e:	9a06      	ldr	r2, [sp, #24]
  200d90:	621a      	str	r2, [r3, #32]
}
  200d92:	bf00      	nop
  200d94:	b005      	add	sp, #20
  200d96:	f85d fb04 	ldr.w	pc, [sp], #4
  200d9a:	bf00      	nop
  200d9c:	0000      	movs	r0, r0
	...

00200da0 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
  200da0:	b500      	push	{lr}
  200da2:	b087      	sub	sp, #28
  200da4:	9003      	str	r0, [sp, #12]
  200da6:	460b      	mov	r3, r1
  200da8:	9201      	str	r2, [sp, #4]
  200daa:	f88d 300b 	strb.w	r3, [sp, #11]

  osalSysLock();
  200dae:	f7ff fde7 	bl	200980 <osalSysLock.lto_priv.1>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
  200db2:	e00c      	b.n	200dce <oqPutTimeout+0x2e>
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
  200db4:	9b03      	ldr	r3, [sp, #12]
  200db6:	9901      	ldr	r1, [sp, #4]
  200db8:	4618      	mov	r0, r3
  200dba:	f7ff fe01 	bl	2009c0 <osalThreadEnqueueTimeoutS.lto_priv.1>
  200dbe:	9005      	str	r0, [sp, #20]
    if (msg < MSG_OK) {
  200dc0:	9b05      	ldr	r3, [sp, #20]
  200dc2:	2b00      	cmp	r3, #0
  200dc4:	da03      	bge.n	200dce <oqPutTimeout+0x2e>
      osalSysUnlock();
  200dc6:	f7ff fde3 	bl	200990 <osalSysUnlock.lto_priv.1>
      return msg;
  200dca:	9b05      	ldr	r3, [sp, #20]
  200dcc:	e025      	b.n	200e1a <oqPutTimeout+0x7a>
  while (oqIsFullI(oqp)) {
  200dce:	9b03      	ldr	r3, [sp, #12]
  200dd0:	689b      	ldr	r3, [r3, #8]
  200dd2:	2b00      	cmp	r3, #0
  200dd4:	d0ee      	beq.n	200db4 <oqPutTimeout+0x14>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  200dd6:	9b03      	ldr	r3, [sp, #12]
  200dd8:	689b      	ldr	r3, [r3, #8]
  200dda:	1e5a      	subs	r2, r3, #1
  200ddc:	9b03      	ldr	r3, [sp, #12]
  200dde:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
  200de0:	9b03      	ldr	r3, [sp, #12]
  200de2:	695b      	ldr	r3, [r3, #20]
  200de4:	1c59      	adds	r1, r3, #1
  200de6:	9a03      	ldr	r2, [sp, #12]
  200de8:	6151      	str	r1, [r2, #20]
  200dea:	f89d 200b 	ldrb.w	r2, [sp, #11]
  200dee:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
  200df0:	9b03      	ldr	r3, [sp, #12]
  200df2:	695a      	ldr	r2, [r3, #20]
  200df4:	9b03      	ldr	r3, [sp, #12]
  200df6:	691b      	ldr	r3, [r3, #16]
  200df8:	429a      	cmp	r2, r3
  200dfa:	d303      	bcc.n	200e04 <oqPutTimeout+0x64>
    oqp->q_wrptr = oqp->q_buffer;
  200dfc:	9b03      	ldr	r3, [sp, #12]
  200dfe:	68da      	ldr	r2, [r3, #12]
  200e00:	9b03      	ldr	r3, [sp, #12]
  200e02:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
  200e04:	9b03      	ldr	r3, [sp, #12]
  200e06:	69db      	ldr	r3, [r3, #28]
  200e08:	2b00      	cmp	r3, #0
  200e0a:	d003      	beq.n	200e14 <oqPutTimeout+0x74>
    oqp->q_notify(oqp);
  200e0c:	9b03      	ldr	r3, [sp, #12]
  200e0e:	69db      	ldr	r3, [r3, #28]
  200e10:	9803      	ldr	r0, [sp, #12]
  200e12:	4798      	blx	r3
  }

  osalSysUnlock();
  200e14:	f7ff fdbc 	bl	200990 <osalSysUnlock.lto_priv.1>

  return MSG_OK;
  200e18:	2300      	movs	r3, #0
}
  200e1a:	4618      	mov	r0, r3
  200e1c:	b007      	add	sp, #28
  200e1e:	f85d fb04 	ldr.w	pc, [sp], #4
  200e22:	bf00      	nop
	...

00200e30 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
  200e30:	b500      	push	{lr}
  200e32:	b085      	sub	sp, #20
  200e34:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
  200e36:	9b01      	ldr	r3, [sp, #4]
  200e38:	695a      	ldr	r2, [r3, #20]
  200e3a:	9b01      	ldr	r3, [sp, #4]
  200e3c:	699b      	ldr	r3, [r3, #24]
  200e3e:	429a      	cmp	r2, r3
  200e40:	d105      	bne.n	200e4e <oqGetI+0x1e>
  200e42:	9b01      	ldr	r3, [sp, #4]
  200e44:	689b      	ldr	r3, [r3, #8]
  200e46:	2b00      	cmp	r3, #0
  200e48:	d001      	beq.n	200e4e <oqGetI+0x1e>
  200e4a:	2301      	movs	r3, #1
  200e4c:	e000      	b.n	200e50 <oqGetI+0x20>
  200e4e:	2300      	movs	r3, #0
  200e50:	f003 0301 	and.w	r3, r3, #1
  200e54:	b2db      	uxtb	r3, r3
  200e56:	f083 0301 	eor.w	r3, r3, #1
  200e5a:	b2db      	uxtb	r3, r3
  200e5c:	2b00      	cmp	r3, #0
  200e5e:	d01e      	beq.n	200e9e <oqGetI+0x6e>
    uint8_t b;

    oqp->q_counter++;
  200e60:	9b01      	ldr	r3, [sp, #4]
  200e62:	689b      	ldr	r3, [r3, #8]
  200e64:	1c5a      	adds	r2, r3, #1
  200e66:	9b01      	ldr	r3, [sp, #4]
  200e68:	609a      	str	r2, [r3, #8]
    b = *oqp->q_rdptr++;
  200e6a:	9b01      	ldr	r3, [sp, #4]
  200e6c:	699b      	ldr	r3, [r3, #24]
  200e6e:	1c59      	adds	r1, r3, #1
  200e70:	9a01      	ldr	r2, [sp, #4]
  200e72:	6191      	str	r1, [r2, #24]
  200e74:	781b      	ldrb	r3, [r3, #0]
  200e76:	f88d 300f 	strb.w	r3, [sp, #15]
    if (oqp->q_rdptr >= oqp->q_top) {
  200e7a:	9b01      	ldr	r3, [sp, #4]
  200e7c:	699a      	ldr	r2, [r3, #24]
  200e7e:	9b01      	ldr	r3, [sp, #4]
  200e80:	691b      	ldr	r3, [r3, #16]
  200e82:	429a      	cmp	r2, r3
  200e84:	d303      	bcc.n	200e8e <oqGetI+0x5e>
      oqp->q_rdptr = oqp->q_buffer;
  200e86:	9b01      	ldr	r3, [sp, #4]
  200e88:	68da      	ldr	r2, [r3, #12]
  200e8a:	9b01      	ldr	r3, [sp, #4]
  200e8c:	619a      	str	r2, [r3, #24]
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
  200e8e:	9b01      	ldr	r3, [sp, #4]
  200e90:	2100      	movs	r1, #0
  200e92:	4618      	mov	r0, r3
  200e94:	f7ff fda4 	bl	2009e0 <osalThreadDequeueNextI.lto_priv.1>

    return (msg_t)b;
  200e98:	f89d 300f 	ldrb.w	r3, [sp, #15]
  200e9c:	e001      	b.n	200ea2 <oqGetI+0x72>
  }

  return MSG_TIMEOUT;
  200e9e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
  200ea2:	4618      	mov	r0, r3
  200ea4:	b005      	add	sp, #20
  200ea6:	f85d fb04 	ldr.w	pc, [sp], #4
  200eaa:	bf00      	nop
  200eac:	0000      	movs	r0, r0
	...

00200eb0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
  200eb0:	b500      	push	{lr}
  200eb2:	b089      	sub	sp, #36	@ 0x24
  200eb4:	9003      	str	r0, [sp, #12]
  200eb6:	9102      	str	r1, [sp, #8]
  200eb8:	9201      	str	r2, [sp, #4]
  200eba:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
  200ebc:	9b03      	ldr	r3, [sp, #12]
  200ebe:	69db      	ldr	r3, [r3, #28]
  200ec0:	9307      	str	r3, [sp, #28]
  size_t max = n;
  200ec2:	9b01      	ldr	r3, [sp, #4]
  200ec4:	9306      	str	r3, [sp, #24]

  osalDbgCheck(n > 0U);

  osalSysLock();
  200ec6:	f7ff fd5b 	bl	200980 <osalSysLock.lto_priv.1>

  while (n > 0U) {
  200eca:	e024      	b.n	200f16 <oqWriteTimeout+0x66>
    size_t done;

    done = oq_write(oqp, bp, n);
  200ecc:	9a01      	ldr	r2, [sp, #4]
  200ece:	9902      	ldr	r1, [sp, #8]
  200ed0:	9803      	ldr	r0, [sp, #12]
  200ed2:	f7ff fdf5 	bl	200ac0 <oq_write>
  200ed6:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
  200ed8:	9b05      	ldr	r3, [sp, #20]
  200eda:	2b00      	cmp	r3, #0
  200edc:	d109      	bne.n	200ef2 <oqWriteTimeout+0x42>
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
  200ede:	9b03      	ldr	r3, [sp, #12]
  200ee0:	9900      	ldr	r1, [sp, #0]
  200ee2:	4618      	mov	r0, r3
  200ee4:	f7ff fd6c 	bl	2009c0 <osalThreadEnqueueTimeoutS.lto_priv.1>
  200ee8:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
  200eea:	9b04      	ldr	r3, [sp, #16]
  200eec:	2b00      	cmp	r3, #0
  200eee:	d012      	beq.n	200f16 <oqWriteTimeout+0x66>
        break;
  200ef0:	e014      	b.n	200f1c <oqWriteTimeout+0x6c>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
  200ef2:	9b07      	ldr	r3, [sp, #28]
  200ef4:	2b00      	cmp	r3, #0
  200ef6:	d002      	beq.n	200efe <oqWriteTimeout+0x4e>
        nfy(oqp);
  200ef8:	9b07      	ldr	r3, [sp, #28]
  200efa:	9803      	ldr	r0, [sp, #12]
  200efc:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
  200efe:	f7ff fd47 	bl	200990 <osalSysUnlock.lto_priv.1>

      n  -= done;
  200f02:	9a01      	ldr	r2, [sp, #4]
  200f04:	9b05      	ldr	r3, [sp, #20]
  200f06:	1ad3      	subs	r3, r2, r3
  200f08:	9301      	str	r3, [sp, #4]
      bp += done;
  200f0a:	9a02      	ldr	r2, [sp, #8]
  200f0c:	9b05      	ldr	r3, [sp, #20]
  200f0e:	4413      	add	r3, r2
  200f10:	9302      	str	r3, [sp, #8]

      osalSysLock();
  200f12:	f7ff fd35 	bl	200980 <osalSysLock.lto_priv.1>
  while (n > 0U) {
  200f16:	9b01      	ldr	r3, [sp, #4]
  200f18:	2b00      	cmp	r3, #0
  200f1a:	d1d7      	bne.n	200ecc <oqWriteTimeout+0x1c>
    }
  }

  osalSysUnlock();
  200f1c:	f7ff fd38 	bl	200990 <osalSysUnlock.lto_priv.1>
  return max - n;
  200f20:	9a06      	ldr	r2, [sp, #24]
  200f22:	9b01      	ldr	r3, [sp, #4]
  200f24:	1ad3      	subs	r3, r2, r3
}
  200f26:	4618      	mov	r0, r3
  200f28:	b009      	add	sp, #36	@ 0x24
  200f2a:	f85d fb04 	ldr.w	pc, [sp], #4
  200f2e:	bf00      	nop

00200f30 <chSysLock.lto_priv.2>:
static inline void chSysLock(void) {
  200f30:	b082      	sub	sp, #8
  200f32:	2330      	movs	r3, #48	@ 0x30
  200f34:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  200f36:	9b01      	ldr	r3, [sp, #4]
  200f38:	f383 8811 	msr	BASEPRI, r3
}
  200f3c:	bf00      	nop
}
  200f3e:	bf00      	nop
}
  200f40:	bf00      	nop
  200f42:	b002      	add	sp, #8
  200f44:	4770      	bx	lr
  200f46:	bf00      	nop
	...

00200f50 <chSysUnlock.lto_priv.2>:
static inline void chSysUnlock(void) {
  200f50:	b082      	sub	sp, #8
  200f52:	2300      	movs	r3, #0
  200f54:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  200f56:	9b01      	ldr	r3, [sp, #4]
  200f58:	f383 8811 	msr	BASEPRI, r3
}
  200f5c:	bf00      	nop
}
  200f5e:	bf00      	nop
}
  200f60:	bf00      	nop
  200f62:	b002      	add	sp, #8
  200f64:	4770      	bx	lr
  200f66:	bf00      	nop
	...

00200f70 <osalSysLock.lto_priv.2>:
static inline void osalSysLock(void) {
  200f70:	b508      	push	{r3, lr}
  chSysLock();
  200f72:	f7ff ffdd 	bl	200f30 <chSysLock.lto_priv.2>
}
  200f76:	bf00      	nop
  200f78:	bd08      	pop	{r3, pc}
  200f7a:	bf00      	nop
  200f7c:	0000      	movs	r0, r0
	...

00200f80 <osalSysUnlock.lto_priv.2>:
static inline void osalSysUnlock(void) {
  200f80:	b508      	push	{r3, lr}
  chSysUnlock();
  200f82:	f7ff ffe5 	bl	200f50 <chSysUnlock.lto_priv.2>
}
  200f86:	bf00      	nop
  200f88:	bd08      	pop	{r3, pc}
  200f8a:	bf00      	nop
  200f8c:	0000      	movs	r0, r0
	...

00200f90 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event source object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
  200f90:	b500      	push	{lr}
  200f92:	b083      	sub	sp, #12
  200f94:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
  200f96:	9801      	ldr	r0, [sp, #4]
  200f98:	f003 fada 	bl	204550 <chEvtObjectInit>
}
  200f9c:	bf00      	nop
  200f9e:	b003      	add	sp, #12
  200fa0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00200fb0 <osalEventBroadcastFlagsI.lto_priv.1>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
  200fb0:	b500      	push	{lr}
  200fb2:	b083      	sub	sp, #12
  200fb4:	9001      	str	r0, [sp, #4]
  200fb6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
  200fb8:	9900      	ldr	r1, [sp, #0]
  200fba:	9801      	ldr	r0, [sp, #4]
  200fbc:	f003 fbb0 	bl	204720 <chEvtBroadcastFlagsI>
}
  200fc0:	bf00      	nop
  200fc2:	b003      	add	sp, #12
  200fc4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00200fd0 <_write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
  200fd0:	b500      	push	{lr}
  200fd2:	b085      	sub	sp, #20
  200fd4:	9003      	str	r0, [sp, #12]
  200fd6:	9102      	str	r1, [sp, #8]
  200fd8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
  200fda:	9b03      	ldr	r3, [sp, #12]
  200fdc:	f103 0030 	add.w	r0, r3, #48	@ 0x30
  200fe0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  200fe4:	9a01      	ldr	r2, [sp, #4]
  200fe6:	9902      	ldr	r1, [sp, #8]
  200fe8:	f7ff ff62 	bl	200eb0 <oqWriteTimeout>
  200fec:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
  200fee:	4618      	mov	r0, r3
  200ff0:	b005      	add	sp, #20
  200ff2:	f85d fb04 	ldr.w	pc, [sp], #4
  200ff6:	bf00      	nop
	...

00201000 <_read>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
  201000:	b500      	push	{lr}
  201002:	b085      	sub	sp, #20
  201004:	9003      	str	r0, [sp, #12]
  201006:	9102      	str	r1, [sp, #8]
  201008:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
  20100a:	9b03      	ldr	r3, [sp, #12]
  20100c:	f103 000c 	add.w	r0, r3, #12
  201010:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  201014:	9a01      	ldr	r2, [sp, #4]
  201016:	9902      	ldr	r1, [sp, #8]
  201018:	f7ff fe5a 	bl	200cd0 <iqReadTimeout>
  20101c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
  20101e:	4618      	mov	r0, r3
  201020:	b005      	add	sp, #20
  201022:	f85d fb04 	ldr.w	pc, [sp], #4
  201026:	bf00      	nop
	...

00201030 <_put>:

static msg_t _put(void *ip, uint8_t b) {
  201030:	b500      	push	{lr}
  201032:	b083      	sub	sp, #12
  201034:	9001      	str	r0, [sp, #4]
  201036:	460b      	mov	r3, r1
  201038:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
  20103c:	9b01      	ldr	r3, [sp, #4]
  20103e:	3330      	adds	r3, #48	@ 0x30
  201040:	f89d 1003 	ldrb.w	r1, [sp, #3]
  201044:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  201048:	4618      	mov	r0, r3
  20104a:	f7ff fea9 	bl	200da0 <oqPutTimeout>
  20104e:	4603      	mov	r3, r0
}
  201050:	4618      	mov	r0, r3
  201052:	b003      	add	sp, #12
  201054:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00201060 <_get>:

static msg_t _get(void *ip) {
  201060:	b500      	push	{lr}
  201062:	b083      	sub	sp, #12
  201064:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
  201066:	9b01      	ldr	r3, [sp, #4]
  201068:	330c      	adds	r3, #12
  20106a:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
  20106e:	4618      	mov	r0, r3
  201070:	f7ff fdee 	bl	200c50 <iqGetTimeout>
  201074:	4603      	mov	r3, r0
}
  201076:	4618      	mov	r0, r3
  201078:	b003      	add	sp, #12
  20107a:	f85d fb04 	ldr.w	pc, [sp], #4
  20107e:	bf00      	nop

00201080 <_putt>:

static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
  201080:	b500      	push	{lr}
  201082:	b085      	sub	sp, #20
  201084:	9003      	str	r0, [sp, #12]
  201086:	460b      	mov	r3, r1
  201088:	9201      	str	r2, [sp, #4]
  20108a:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
  20108e:	9b03      	ldr	r3, [sp, #12]
  201090:	3330      	adds	r3, #48	@ 0x30
  201092:	f89d 100b 	ldrb.w	r1, [sp, #11]
  201096:	9a01      	ldr	r2, [sp, #4]
  201098:	4618      	mov	r0, r3
  20109a:	f7ff fe81 	bl	200da0 <oqPutTimeout>
  20109e:	4603      	mov	r3, r0
}
  2010a0:	4618      	mov	r0, r3
  2010a2:	b005      	add	sp, #20
  2010a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002010b0 <_gett>:

static msg_t _gett(void *ip, sysinterval_t timeout) {
  2010b0:	b500      	push	{lr}
  2010b2:	b083      	sub	sp, #12
  2010b4:	9001      	str	r0, [sp, #4]
  2010b6:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
  2010b8:	9b01      	ldr	r3, [sp, #4]
  2010ba:	330c      	adds	r3, #12
  2010bc:	9900      	ldr	r1, [sp, #0]
  2010be:	4618      	mov	r0, r3
  2010c0:	f7ff fdc6 	bl	200c50 <iqGetTimeout>
  2010c4:	4603      	mov	r3, r0
}
  2010c6:	4618      	mov	r0, r3
  2010c8:	b003      	add	sp, #12
  2010ca:	f85d fb04 	ldr.w	pc, [sp], #4
  2010ce:	bf00      	nop

002010d0 <_writet>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n,
                      sysinterval_t timeout) {
  2010d0:	b500      	push	{lr}
  2010d2:	b085      	sub	sp, #20
  2010d4:	9003      	str	r0, [sp, #12]
  2010d6:	9102      	str	r1, [sp, #8]
  2010d8:	9201      	str	r2, [sp, #4]
  2010da:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
  2010dc:	9b03      	ldr	r3, [sp, #12]
  2010de:	f103 0030 	add.w	r0, r3, #48	@ 0x30
  2010e2:	9b00      	ldr	r3, [sp, #0]
  2010e4:	9a01      	ldr	r2, [sp, #4]
  2010e6:	9902      	ldr	r1, [sp, #8]
  2010e8:	f7ff fee2 	bl	200eb0 <oqWriteTimeout>
  2010ec:	4603      	mov	r3, r0
}
  2010ee:	4618      	mov	r0, r3
  2010f0:	b005      	add	sp, #20
  2010f2:	f85d fb04 	ldr.w	pc, [sp], #4
  2010f6:	bf00      	nop
	...

00201100 <_readt>:

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {
  201100:	b500      	push	{lr}
  201102:	b085      	sub	sp, #20
  201104:	9003      	str	r0, [sp, #12]
  201106:	9102      	str	r1, [sp, #8]
  201108:	9201      	str	r2, [sp, #4]
  20110a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
  20110c:	9b03      	ldr	r3, [sp, #12]
  20110e:	f103 000c 	add.w	r0, r3, #12
  201112:	9b00      	ldr	r3, [sp, #0]
  201114:	9a01      	ldr	r2, [sp, #4]
  201116:	9902      	ldr	r1, [sp, #8]
  201118:	f7ff fdda 	bl	200cd0 <iqReadTimeout>
  20111c:	4603      	mov	r3, r0
}
  20111e:	4618      	mov	r0, r3
  201120:	b005      	add	sp, #20
  201122:	f85d fb04 	ldr.w	pc, [sp], #4
  201126:	bf00      	nop
	...

00201130 <_ctl>:

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
  201130:	b086      	sub	sp, #24
  201132:	9003      	str	r0, [sp, #12]
  201134:	9102      	str	r1, [sp, #8]
  201136:	9201      	str	r2, [sp, #4]
  SerialDriver *sdp = (SerialDriver *)ip;
  201138:	9b03      	ldr	r3, [sp, #12]
  20113a:	9305      	str	r3, [sp, #20]

  osalDbgCheck(sdp != NULL);

  switch (operation) {
  20113c:	9b02      	ldr	r3, [sp, #8]
  20113e:	2b00      	cmp	r3, #0
  201140:	d003      	beq.n	20114a <_ctl+0x1a>
  201142:	9b02      	ldr	r3, [sp, #8]
  201144:	2b01      	cmp	r3, #1
  201146:	d103      	bne.n	201150 <_ctl+0x20>
  case CHN_CTL_NOP:
    osalDbgCheck(arg == NULL);
    break;
  201148:	e005      	b.n	201156 <_ctl+0x26>
  case CHN_CTL_INVALID:
    return HAL_RET_UNKNOWN_CTL;
  20114a:	f06f 0313 	mvn.w	r3, #19
  20114e:	e003      	b.n	201158 <_ctl+0x28>
  default:
#if defined(SD_LLD_IMPLEMENTS_CTL)
    /* Delegating to the LLD if supported.*/
    return sd_lld_control(sdp, operation, arg);
#else
    return HAL_RET_UNKNOWN_CTL;
  201150:	f06f 0313 	mvn.w	r3, #19
  201154:	e000      	b.n	201158 <_ctl+0x28>
#endif
  }
  return HAL_RET_SUCCESS;
  201156:	2300      	movs	r3, #0
}
  201158:	4618      	mov	r0, r3
  20115a:	b006      	add	sp, #24
  20115c:	4770      	bx	lr
  20115e:	bf00      	nop

00201160 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
  201160:	b508      	push	{r3, lr}

  sd_lld_init();
  201162:	f000 fcad 	bl	201ac0 <sd_lld_init>
}
  201166:	bf00      	nop
  201168:	bd08      	pop	{r3, pc}
  20116a:	bf00      	nop
  20116c:	0000      	movs	r0, r0
	...

00201170 <sdObjectInit>:
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {
  201170:	b500      	push	{lr}
  201172:	b083      	sub	sp, #12
  201174:	9001      	str	r0, [sp, #4]

  sdp->vmt = &vmt;
  201176:	9b01      	ldr	r3, [sp, #4]
  201178:	4a06      	ldr	r2, [pc, #24]	@ (201194 <sdObjectInit+0x24>)
  20117a:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
  20117c:	9b01      	ldr	r3, [sp, #4]
  20117e:	3304      	adds	r3, #4
  201180:	4618      	mov	r0, r3
  201182:	f7ff ff05 	bl	200f90 <osalEventObjectInit>
  sdp->state = SD_STOP;
  201186:	9b01      	ldr	r3, [sp, #4]
  201188:	2201      	movs	r2, #1
  20118a:	721a      	strb	r2, [r3, #8]
}
  20118c:	bf00      	nop
  20118e:	b003      	add	sp, #12
  201190:	f85d fb04 	ldr.w	pc, [sp], #4
  201194:	08010020 	.word	0x08010020
	...

002011a0 <sdStart>:
 *                      configuration is used.
 * @return              The operation status.
 *
 * @api
 */
msg_t sdStart(SerialDriver *sdp, const SerialConfig *config) {
  2011a0:	b500      	push	{lr}
  2011a2:	b085      	sub	sp, #20
  2011a4:	9001      	str	r0, [sp, #4]
  2011a6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck(sdp != NULL);

  osalSysLock();
  2011a8:	f7ff fee2 	bl	200f70 <osalSysLock.lto_priv.2>
                "invalid state");

#if defined(SD_LLD_ENHANCED_API)
  msg = sd_lld_start(sdp, config);
#else
  sd_lld_start(sdp, config);
  2011ac:	9900      	ldr	r1, [sp, #0]
  2011ae:	9801      	ldr	r0, [sp, #4]
  2011b0:	f000 fcb6 	bl	201b20 <sd_lld_start>
  msg = HAL_RET_SUCCESS;
  2011b4:	2300      	movs	r3, #0
  2011b6:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
  2011b8:	9b03      	ldr	r3, [sp, #12]
  2011ba:	2b00      	cmp	r3, #0
  2011bc:	d103      	bne.n	2011c6 <sdStart+0x26>
    sdp->state = SD_READY;
  2011be:	9b01      	ldr	r3, [sp, #4]
  2011c0:	2202      	movs	r2, #2
  2011c2:	721a      	strb	r2, [r3, #8]
  2011c4:	e002      	b.n	2011cc <sdStart+0x2c>
  }
  else {
    sdp->state = SD_STOP;
  2011c6:	9b01      	ldr	r3, [sp, #4]
  2011c8:	2201      	movs	r2, #1
  2011ca:	721a      	strb	r2, [r3, #8]
  }

  osalSysUnlock();
  2011cc:	f7ff fed8 	bl	200f80 <osalSysUnlock.lto_priv.2>

  return msg;
  2011d0:	9b03      	ldr	r3, [sp, #12]
}
  2011d2:	4618      	mov	r0, r3
  2011d4:	b005      	add	sp, #20
  2011d6:	f85d fb04 	ldr.w	pc, [sp], #4
  2011da:	bf00      	nop
  2011dc:	0000      	movs	r0, r0
	...

002011e0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
  2011e0:	b500      	push	{lr}
  2011e2:	b083      	sub	sp, #12
  2011e4:	9001      	str	r0, [sp, #4]
  2011e6:	460b      	mov	r3, r1
  2011e8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
  2011ec:	9b01      	ldr	r3, [sp, #4]
  2011ee:	695b      	ldr	r3, [r3, #20]
  2011f0:	2b00      	cmp	r3, #0
  2011f2:	d105      	bne.n	201200 <sdIncomingDataI+0x20>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  2011f4:	9b01      	ldr	r3, [sp, #4]
  2011f6:	3304      	adds	r3, #4
  2011f8:	2104      	movs	r1, #4
  2011fa:	4618      	mov	r0, r3
  2011fc:	f7ff fed8 	bl	200fb0 <osalEventBroadcastFlagsI.lto_priv.1>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
  201200:	9b01      	ldr	r3, [sp, #4]
  201202:	330c      	adds	r3, #12
  201204:	f89d 2003 	ldrb.w	r2, [sp, #3]
  201208:	4611      	mov	r1, r2
  20120a:	4618      	mov	r0, r3
  20120c:	f7ff fce0 	bl	200bd0 <iqPutI>
  201210:	4603      	mov	r3, r0
  201212:	2b00      	cmp	r3, #0
  201214:	da06      	bge.n	201224 <sdIncomingDataI+0x44>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
  201216:	9b01      	ldr	r3, [sp, #4]
  201218:	3304      	adds	r3, #4
  20121a:	f44f 6100 	mov.w	r1, #2048	@ 0x800
  20121e:	4618      	mov	r0, r3
  201220:	f7ff fec6 	bl	200fb0 <osalEventBroadcastFlagsI.lto_priv.1>
}
  201224:	bf00      	nop
  201226:	b003      	add	sp, #12
  201228:	f85d fb04 	ldr.w	pc, [sp], #4
  20122c:	0000      	movs	r0, r0
	...

00201230 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  201230:	b082      	sub	sp, #8
  201232:	9001      	str	r0, [sp, #4]
  201234:	9100      	str	r1, [sp, #0]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
  201236:	9b00      	ldr	r3, [sp, #0]
  201238:	b2db      	uxtb	r3, r3
  20123a:	4a11      	ldr	r2, [pc, #68]	@ (201280 <nvicEnableVector+0x50>)
  20123c:	011b      	lsls	r3, r3, #4
  20123e:	b2d9      	uxtb	r1, r3
  201240:	9b01      	ldr	r3, [sp, #4]
  201242:	4413      	add	r3, r2
  201244:	f503 7340 	add.w	r3, r3, #768	@ 0x300
  201248:	460a      	mov	r2, r1
  20124a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20124c:	9b01      	ldr	r3, [sp, #4]
  20124e:	f003 021f 	and.w	r2, r3, #31
  201252:	490b      	ldr	r1, [pc, #44]	@ (201280 <nvicEnableVector+0x50>)
  201254:	9b01      	ldr	r3, [sp, #4]
  201256:	095b      	lsrs	r3, r3, #5
  201258:	2001      	movs	r0, #1
  20125a:	fa00 f202 	lsl.w	r2, r0, r2
  20125e:	3360      	adds	r3, #96	@ 0x60
  201260:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
  201264:	9b01      	ldr	r3, [sp, #4]
  201266:	f003 021f 	and.w	r2, r3, #31
  20126a:	4905      	ldr	r1, [pc, #20]	@ (201280 <nvicEnableVector+0x50>)
  20126c:	9b01      	ldr	r3, [sp, #4]
  20126e:	095b      	lsrs	r3, r3, #5
  201270:	2001      	movs	r0, #1
  201272:	fa00 f202 	lsl.w	r2, r0, r2
  201276:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
  20127a:	bf00      	nop
  20127c:	b002      	add	sp, #8
  20127e:	4770      	bx	lr
  201280:	e000e100 	.word	0xe000e100
	...

00201290 <exti0_irq_init>:

static inline void exti0_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_NUMBER, STM32_IRQ_EXTI0_PRIORITY);
#endif
}
  201290:	bf00      	nop
  201292:	4770      	bx	lr
	...

002012a0 <exti1_irq_init>:

static inline void exti1_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI1_NUMBER, STM32_IRQ_EXTI1_PRIORITY);
#endif
}
  2012a0:	bf00      	nop
  2012a2:	4770      	bx	lr
	...

002012b0 <exti2_irq_init>:

static inline void exti2_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_NUMBER, STM32_IRQ_EXTI2_PRIORITY);
#endif
}
  2012b0:	bf00      	nop
  2012b2:	4770      	bx	lr
	...

002012c0 <exti3_irq_init>:

static inline void exti3_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI3_NUMBER, STM32_IRQ_EXTI3_PRIORITY);
#endif
}
  2012c0:	bf00      	nop
  2012c2:	4770      	bx	lr
	...

002012d0 <exti4_irq_init>:

static inline void exti4_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_NUMBER, STM32_IRQ_EXTI4_PRIORITY);
#endif
}
  2012d0:	bf00      	nop
  2012d2:	4770      	bx	lr
	...

002012e0 <exti5_9_irq_init>:

static inline void exti5_9_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI5_9_NUMBER, STM32_IRQ_EXTI5_9_PRIORITY);
#endif
}
  2012e0:	bf00      	nop
  2012e2:	4770      	bx	lr
	...

002012f0 <exti10_15_irq_init>:

static inline void exti10_15_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI10_15_NUMBER, STM32_IRQ_EXTI10_15_PRIORITY);
#endif
}
  2012f0:	bf00      	nop
  2012f2:	4770      	bx	lr
	...

00201300 <exti16_irq_init>:

static inline void exti16_irq_init(void) {
#if defined(STM32_EXTI16_IS_USED)
  nvicEnableVector(STM32_EXTI16_NUMBER, STM32_IRQ_EXTI16_PRIORITY);
#endif
}
  201300:	bf00      	nop
  201302:	4770      	bx	lr
	...

00201310 <exti17_irq_init>:

static inline void exti17_irq_init(void) {
#if defined(STM32_EXTI17_IS_USED)
  nvicEnableVector(STM32_EXTI17_NUMBER, STM32_IRQ_EXTI17_PRIORITY);
#endif
}
  201310:	bf00      	nop
  201312:	4770      	bx	lr
	...

00201320 <exti18_irq_init>:

static inline void exti18_irq_init(void) {
#if defined(STM32_EXTI18_IS_USED)
  nvicEnableVector(STM32_EXTI18_NUMBER, STM32_IRQ_EXTI18_PRIORITY);
#endif
}
  201320:	bf00      	nop
  201322:	4770      	bx	lr
	...

00201330 <exti19_irq_init>:

static inline void exti19_irq_init(void) {
#if defined(STM32_EXTI19_IS_USED)
  nvicEnableVector(STM32_EXTI19_NUMBER, STM32_IRQ_EXTI19_PRIORITY);
#endif
}
  201330:	bf00      	nop
  201332:	4770      	bx	lr
	...

00201340 <exti20_irq_init>:

static inline void exti20_irq_init(void) {
#if defined(STM32_EXTI20_IS_USED)
  nvicEnableVector(STM32_EXTI20_NUMBER, STM32_IRQ_EXTI20_PRIORITY);
#endif
}
  201340:	bf00      	nop
  201342:	4770      	bx	lr
	...

00201350 <exti21_irq_init>:

static inline void exti21_irq_init(void) {
#if defined(STM32_EXTI21_IS_USED)
  nvicEnableVector(STM32_EXTI21_NUMBER, STM32_IRQ_EXTI21_PRIORITY);
#endif
}
  201350:	bf00      	nop
  201352:	4770      	bx	lr
	...

00201360 <exti22_irq_init>:

static inline void exti22_irq_init(void) {
#if defined(STM32_EXTI22_IS_USED)
  nvicEnableVector(STM32_EXTI22_NUMBER, STM32_IRQ_EXTI22_PRIORITY);
#endif
}
  201360:	bf00      	nop
  201362:	4770      	bx	lr
	...

00201370 <exti23_irq_init>:

static inline void exti23_irq_init(void) {
#if defined(STM32_EXTI23_IS_USED)
  nvicEnableVector(STM32_EXTI23_NUMBER, STM32_IRQ_EXTI23_PRIORITY);
#endif
}
  201370:	bf00      	nop
  201372:	4770      	bx	lr
	...

00201380 <usart1_irq_init>:

static inline void usart1_irq_init(void) {
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
#endif
}
  201380:	bf00      	nop
  201382:	4770      	bx	lr
	...

00201390 <usart2_irq_init>:

static inline void usart2_irq_init(void) {
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
#endif
}
  201390:	bf00      	nop
  201392:	4770      	bx	lr
	...

002013a0 <usart3_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void usart3_irq_init(void) {
  2013a0:	b508      	push	{r3, lr}
#if defined(STM32_USART3_IS_USED)
  nvicEnableVector(STM32_USART3_NUMBER, STM32_IRQ_USART3_PRIORITY);
  2013a2:	210c      	movs	r1, #12
  2013a4:	2027      	movs	r0, #39	@ 0x27
  2013a6:	f7ff ff43 	bl	201230 <nvicEnableVector>
#endif
}
  2013aa:	bf00      	nop
  2013ac:	bd08      	pop	{r3, pc}
  2013ae:	bf00      	nop

002013b0 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
  2013b0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

#if HAL_USE_SERIAL
#if STM32_SERIAL_USE_USART3
  sd_lld_serve_interrupt(&SD3);
  2013b2:	4803      	ldr	r0, [pc, #12]	@ (2013c0 <VectorDC+0x10>)
  2013b4:	f000 fbe4 	bl	201b80 <sd_lld_serve_interrupt>
#if STM32_UART_USE_USART3
  uart_lld_serve_interrupt(&UARTD3);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
  2013b8:	f005 fed2 	bl	207160 <__port_irq_epilogue>
}
  2013bc:	bf00      	nop
  2013be:	bd08      	pop	{r3, pc}
  2013c0:	20000800 	.word	0x20000800
	...

002013d0 <uart4_irq_init>:

static inline void uart4_irq_init(void) {
#if defined(STM32_UART4_IS_USED)
  nvicEnableVector(STM32_UART4_NUMBER, STM32_IRQ_UART4_PRIORITY);
#endif
}
  2013d0:	bf00      	nop
  2013d2:	4770      	bx	lr
	...

002013e0 <uart5_irq_init>:

static inline void uart5_irq_init(void) {
#if defined(STM32_UART5_IS_USED)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_IRQ_UART5_PRIORITY);
#endif
}
  2013e0:	bf00      	nop
  2013e2:	4770      	bx	lr
	...

002013f0 <usart6_irq_init>:

static inline void usart6_irq_init(void) {
#if defined(STM32_USART6_IS_USED)
  nvicEnableVector(STM32_USART6_NUMBER, STM32_IRQ_USART6_PRIORITY);
#endif
}
  2013f0:	bf00      	nop
  2013f2:	4770      	bx	lr
	...

00201400 <uart7_irq_init>:

static inline void uart7_irq_init(void) {
#if defined(STM32_UART7_IS_USED)
  nvicEnableVector(STM32_UART7_NUMBER, STM32_IRQ_UART7_PRIORITY);
#endif
}
  201400:	bf00      	nop
  201402:	4770      	bx	lr
	...

00201410 <uart8_irq_init>:

static inline void uart8_irq_init(void) {
#if defined(STM32_UART8_IS_USED)
  nvicEnableVector(STM32_UART8_NUMBER, STM32_IRQ_UART8_PRIORITY);
#endif
}
  201410:	bf00      	nop
  201412:	4770      	bx	lr
	...

00201420 <tim1_tim9_tim10_tim11_irq_init>:
#endif
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_CC_NUMBER,
                   STM32_IRQ_TIM1_CC_PRIORITY);
#endif
}
  201420:	bf00      	nop
  201422:	4770      	bx	lr
	...

00201430 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
  201430:	b508      	push	{r3, lr}
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
  201432:	2107      	movs	r1, #7
  201434:	201c      	movs	r0, #28
  201436:	f7ff fefb 	bl	201230 <nvicEnableVector>
#endif
}
  20143a:	bf00      	nop
  20143c:	bd08      	pop	{r3, pc}
  20143e:	bf00      	nop

00201440 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
  201440:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
  201442:	f000 fa25 	bl	201890 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
  201446:	f005 fe8b 	bl	207160 <__port_irq_epilogue>
}
  20144a:	bf00      	nop
  20144c:	bd08      	pop	{r3, pc}
  20144e:	bf00      	nop

00201450 <tim3_irq_init>:

static inline void tim3_irq_init(void) {
#if defined(STM32_TIM3_IS_USED)
  nvicEnableVector(STM32_TIM3_NUMBER, STM32_IRQ_TIM3_PRIORITY);
#endif
}
  201450:	bf00      	nop
  201452:	4770      	bx	lr
	...

00201460 <tim4_irq_init>:

static inline void tim4_irq_init(void) {
#if defined(STM32_TIM4_IS_USED)
  nvicEnableVector(STM32_TIM4_NUMBER, STM32_IRQ_TIM4_PRIORITY);
#endif
}
  201460:	bf00      	nop
  201462:	4770      	bx	lr
	...

00201470 <tim5_irq_init>:

static inline void tim5_irq_init(void) {
#if defined(STM32_TIM5_IS_USED)
  nvicEnableVector(STM32_TIM5_NUMBER, STM32_IRQ_TIM5_PRIORITY);
#endif
}
  201470:	bf00      	nop
  201472:	4770      	bx	lr
	...

00201480 <tim6_irq_init>:

static inline void tim6_irq_init(void) {
#if defined(STM32_TIM6_IS_USED)
  nvicEnableVector(STM32_TIM6_NUMBER, STM32_IRQ_TIM6_PRIORITY);
#endif
}
  201480:	bf00      	nop
  201482:	4770      	bx	lr
	...

00201490 <tim7_irq_init>:

static inline void tim7_irq_init(void) {
#if defined(STM32_TIM7_IS_USED)
  nvicEnableVector(STM32_TIM7_NUMBER, STM32_IRQ_TIM7_PRIORITY);
#endif
}
  201490:	bf00      	nop
  201492:	4770      	bx	lr
	...

002014a0 <tim8_tim12_tim13_tim14_irq_init>:
#endif
#if defined(STM32_TIM8_IS_USED)
  nvicEnableVector(STM32_TIM8_CC_NUMBER,
                   STM32_IRQ_TIM8_CC_PRIORITY);
#endif
}
  2014a0:	bf00      	nop
  2014a2:	4770      	bx	lr
	...

002014b0 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
  2014b0:	b508      	push	{r3, lr}

  exti0_irq_init();
  2014b2:	f7ff feed 	bl	201290 <exti0_irq_init>
  exti1_irq_init();
  2014b6:	f7ff fef3 	bl	2012a0 <exti1_irq_init>
  exti2_irq_init();
  2014ba:	f7ff fef9 	bl	2012b0 <exti2_irq_init>
  exti3_irq_init();
  2014be:	f7ff feff 	bl	2012c0 <exti3_irq_init>
  exti4_irq_init();
  2014c2:	f7ff ff05 	bl	2012d0 <exti4_irq_init>
  exti5_9_irq_init();
  2014c6:	f7ff ff0b 	bl	2012e0 <exti5_9_irq_init>
  exti10_15_irq_init();
  2014ca:	f7ff ff11 	bl	2012f0 <exti10_15_irq_init>
  exti16_irq_init();
  2014ce:	f7ff ff17 	bl	201300 <exti16_irq_init>
  exti17_irq_init();
  2014d2:	f7ff ff1d 	bl	201310 <exti17_irq_init>
  exti18_irq_init();
  2014d6:	f7ff ff23 	bl	201320 <exti18_irq_init>
  exti19_irq_init();
  2014da:	f7ff ff29 	bl	201330 <exti19_irq_init>
  exti20_irq_init();
  2014de:	f7ff ff2f 	bl	201340 <exti20_irq_init>
  exti21_irq_init();
  2014e2:	f7ff ff35 	bl	201350 <exti21_irq_init>
  exti22_irq_init();
  2014e6:	f7ff ff3b 	bl	201360 <exti22_irq_init>
  exti23_irq_init();
  2014ea:	f7ff ff41 	bl	201370 <exti23_irq_init>

  tim1_tim9_tim10_tim11_irq_init();
  2014ee:	f7ff ff97 	bl	201420 <tim1_tim9_tim10_tim11_irq_init>
  tim2_irq_init();
  2014f2:	f7ff ff9d 	bl	201430 <tim2_irq_init>
  tim3_irq_init();
  2014f6:	f7ff ffab 	bl	201450 <tim3_irq_init>
  tim4_irq_init();
  2014fa:	f7ff ffb1 	bl	201460 <tim4_irq_init>
  tim5_irq_init();
  2014fe:	f7ff ffb7 	bl	201470 <tim5_irq_init>
  tim6_irq_init();
  201502:	f7ff ffbd 	bl	201480 <tim6_irq_init>
  tim7_irq_init();
  201506:	f7ff ffc3 	bl	201490 <tim7_irq_init>
  tim8_tim12_tim13_tim14_irq_init();
  20150a:	f7ff ffc9 	bl	2014a0 <tim8_tim12_tim13_tim14_irq_init>

  usart1_irq_init();
  20150e:	f7ff ff37 	bl	201380 <usart1_irq_init>
  usart2_irq_init();
  201512:	f7ff ff3d 	bl	201390 <usart2_irq_init>
  usart3_irq_init();
  201516:	f7ff ff43 	bl	2013a0 <usart3_irq_init>
  uart4_irq_init();
  20151a:	f7ff ff59 	bl	2013d0 <uart4_irq_init>
  uart5_irq_init();
  20151e:	f7ff ff5f 	bl	2013e0 <uart5_irq_init>
  usart6_irq_init();
  201522:	f7ff ff65 	bl	2013f0 <usart6_irq_init>
  uart7_irq_init();
  201526:	f7ff ff6b 	bl	201400 <uart7_irq_init>
  uart8_irq_init();
  20152a:	f7ff ff71 	bl	201410 <uart8_irq_init>
}
  20152e:	bf00      	nop
  201530:	bd08      	pop	{r3, pc}
  201532:	bf00      	nop
	...

00201540 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR1 |= PWR_CR1_DBP;
  201540:	4b14      	ldr	r3, [pc, #80]	@ (201594 <hal_lld_backup_domain_init+0x54>)
  201542:	681b      	ldr	r3, [r3, #0]
  201544:	4a13      	ldr	r2, [pc, #76]	@ (201594 <hal_lld_backup_domain_init+0x54>)
  201546:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
  20154a:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
  20154c:	4b12      	ldr	r3, [pc, #72]	@ (201598 <hal_lld_backup_domain_init+0x58>)
  20154e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
  201550:	f403 7340 	and.w	r3, r3, #768	@ 0x300
  201554:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
  201558:	d006      	beq.n	201568 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
  20155a:	4b0f      	ldr	r3, [pc, #60]	@ (201598 <hal_lld_backup_domain_init+0x58>)
  20155c:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
  201560:	671a      	str	r2, [r3, #112]	@ 0x70
    RCC->BDCR = 0;
  201562:	4b0d      	ldr	r3, [pc, #52]	@ (201598 <hal_lld_backup_domain_init+0x58>)
  201564:	2200      	movs	r2, #0
  201566:	671a      	str	r2, [r3, #112]	@ 0x70
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  201568:	4b0b      	ldr	r3, [pc, #44]	@ (201598 <hal_lld_backup_domain_init+0x58>)
  20156a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
  20156c:	4a0a      	ldr	r2, [pc, #40]	@ (201598 <hal_lld_backup_domain_init+0x58>)
  20156e:	f043 0319 	orr.w	r3, r3, #25
  201572:	6713      	str	r3, [r2, #112]	@ 0x70
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  201574:	bf00      	nop
  201576:	4b08      	ldr	r3, [pc, #32]	@ (201598 <hal_lld_backup_domain_init+0x58>)
  201578:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
  20157a:	f003 0302 	and.w	r3, r3, #2
  20157e:	2b00      	cmp	r3, #0
  201580:	d0f9      	beq.n	201576 <hal_lld_backup_domain_init+0x36>

  PWR->CSR1 |= PWR_CSR1_BRE;
  while ((PWR->CSR1 & PWR_CSR1_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR1 &= ~PWR_CSR1_BRE;
  201582:	4b04      	ldr	r3, [pc, #16]	@ (201594 <hal_lld_backup_domain_init+0x54>)
  201584:	685b      	ldr	r3, [r3, #4]
  201586:	4a03      	ldr	r2, [pc, #12]	@ (201594 <hal_lld_backup_domain_init+0x54>)
  201588:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
  20158c:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
  20158e:	bf00      	nop
  201590:	4770      	bx	lr
  201592:	bf00      	nop
  201594:	40007000 	.word	0x40007000
  201598:	40023800 	.word	0x40023800
  20159c:	00000000 	.word	0x00000000

002015a0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
  2015a0:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  2015a2:	4b1e      	ldr	r3, [pc, #120]	@ (20161c <hal_lld_init+0x7c>)
  2015a4:	691a      	ldr	r2, [r3, #16]
  2015a6:	491d      	ldr	r1, [pc, #116]	@ (20161c <hal_lld_init+0x7c>)
  2015a8:	4b1d      	ldr	r3, [pc, #116]	@ (201620 <hal_lld_init+0x80>)
  2015aa:	4313      	orrs	r3, r2
  2015ac:	610b      	str	r3, [r1, #16]
  2015ae:	4b1b      	ldr	r3, [pc, #108]	@ (20161c <hal_lld_init+0x7c>)
  2015b0:	691b      	ldr	r3, [r3, #16]
  2015b2:	4a1a      	ldr	r2, [pc, #104]	@ (20161c <hal_lld_init+0x7c>)
  2015b4:	f3c3 030a 	ubfx	r3, r3, #0, #11
  2015b8:	6113      	str	r3, [r2, #16]
  2015ba:	4b18      	ldr	r3, [pc, #96]	@ (20161c <hal_lld_init+0x7c>)
  2015bc:	691b      	ldr	r3, [r3, #16]
  rccResetAHB2(~0);
  2015be:	4b17      	ldr	r3, [pc, #92]	@ (20161c <hal_lld_init+0x7c>)
  2015c0:	695b      	ldr	r3, [r3, #20]
  2015c2:	4b16      	ldr	r3, [pc, #88]	@ (20161c <hal_lld_init+0x7c>)
  2015c4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  2015c8:	615a      	str	r2, [r3, #20]
  2015ca:	4b14      	ldr	r3, [pc, #80]	@ (20161c <hal_lld_init+0x7c>)
  2015cc:	695b      	ldr	r3, [r3, #20]
  2015ce:	4b13      	ldr	r3, [pc, #76]	@ (20161c <hal_lld_init+0x7c>)
  2015d0:	2200      	movs	r2, #0
  2015d2:	615a      	str	r2, [r3, #20]
  2015d4:	4b11      	ldr	r3, [pc, #68]	@ (20161c <hal_lld_init+0x7c>)
  2015d6:	695b      	ldr	r3, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
  2015d8:	4b10      	ldr	r3, [pc, #64]	@ (20161c <hal_lld_init+0x7c>)
  2015da:	6a1b      	ldr	r3, [r3, #32]
  2015dc:	4a0f      	ldr	r2, [pc, #60]	@ (20161c <hal_lld_init+0x7c>)
  2015de:	f063 5380 	orn	r3, r3, #268435456	@ 0x10000000
  2015e2:	6213      	str	r3, [r2, #32]
  2015e4:	4b0d      	ldr	r3, [pc, #52]	@ (20161c <hal_lld_init+0x7c>)
  2015e6:	6a1b      	ldr	r3, [r3, #32]
  2015e8:	4a0c      	ldr	r2, [pc, #48]	@ (20161c <hal_lld_init+0x7c>)
  2015ea:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
  2015ee:	6213      	str	r3, [r2, #32]
  2015f0:	4b0a      	ldr	r3, [pc, #40]	@ (20161c <hal_lld_init+0x7c>)
  2015f2:	6a1b      	ldr	r3, [r3, #32]
  rccResetAPB2(~0);
  2015f4:	4b09      	ldr	r3, [pc, #36]	@ (20161c <hal_lld_init+0x7c>)
  2015f6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  2015f8:	4b08      	ldr	r3, [pc, #32]	@ (20161c <hal_lld_init+0x7c>)
  2015fa:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  2015fe:	625a      	str	r2, [r3, #36]	@ 0x24
  201600:	4b06      	ldr	r3, [pc, #24]	@ (20161c <hal_lld_init+0x7c>)
  201602:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  201604:	4b05      	ldr	r3, [pc, #20]	@ (20161c <hal_lld_init+0x7c>)
  201606:	2200      	movs	r2, #0
  201608:	625a      	str	r2, [r3, #36]	@ 0x24
  20160a:	4b04      	ldr	r3, [pc, #16]	@ (20161c <hal_lld_init+0x7c>)
  20160c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
  20160e:	f7ff ff97 	bl	201540 <hal_lld_backup_domain_init>
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
#endif

  /* IRQ subsystem initialization.*/
  irqInit();
  201612:	f7ff ff4d 	bl	2014b0 <irqInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR1 |= PWR_CR1_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
  201616:	bf00      	nop
  201618:	bd08      	pop	{r3, pc}
  20161a:	bf00      	nop
  20161c:	40023800 	.word	0x40023800
  201620:	fffff800 	.word	0xfffff800
	...

00201630 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
  201630:	b082      	sub	sp, #8

#if !STM32_NO_INIT
  /* PWR clock enabled.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  201632:	4b4f      	ldr	r3, [pc, #316]	@ (201770 <stm32_clock_init+0x140>)
  201634:	4a4f      	ldr	r2, [pc, #316]	@ (201774 <stm32_clock_init+0x144>)
  201636:	641a      	str	r2, [r3, #64]	@ 0x40
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
  PWR->CR1 = STM32_VOS;
  201638:	4b4f      	ldr	r3, [pc, #316]	@ (201778 <stm32_clock_init+0x148>)
  20163a:	f44f 4240 	mov.w	r2, #49152	@ 0xc000
  20163e:	601a      	str	r2, [r3, #0]

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  201640:	4b4b      	ldr	r3, [pc, #300]	@ (201770 <stm32_clock_init+0x140>)
  201642:	681b      	ldr	r3, [r3, #0]
  201644:	4a4a      	ldr	r2, [pc, #296]	@ (201770 <stm32_clock_init+0x140>)
  201646:	f043 0301 	orr.w	r3, r3, #1
  20164a:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
  20164c:	bf00      	nop
  20164e:	4b48      	ldr	r3, [pc, #288]	@ (201770 <stm32_clock_init+0x140>)
  201650:	681b      	ldr	r3, [r3, #0]
  201652:	f003 0302 	and.w	r3, r3, #2
  201656:	2b00      	cmp	r3, #0
  201658:	d0f9      	beq.n	20164e <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
  20165a:	4b45      	ldr	r3, [pc, #276]	@ (201770 <stm32_clock_init+0x140>)
  20165c:	689b      	ldr	r3, [r3, #8]
  20165e:	4a44      	ldr	r2, [pc, #272]	@ (201770 <stm32_clock_init+0x140>)
  201660:	f023 0303 	bic.w	r3, r3, #3
  201664:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  201666:	bf00      	nop
  201668:	4b41      	ldr	r3, [pc, #260]	@ (201770 <stm32_clock_init+0x140>)
  20166a:	689b      	ldr	r3, [r3, #8]
  20166c:	f003 030c 	and.w	r3, r3, #12
  201670:	2b00      	cmp	r3, #0
  201672:	d1f9      	bne.n	201668 <stm32_clock_init+0x38>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  201674:	4b3e      	ldr	r3, [pc, #248]	@ (201770 <stm32_clock_init+0x140>)
  201676:	681b      	ldr	r3, [r3, #0]
  201678:	4a3d      	ldr	r2, [pc, #244]	@ (201770 <stm32_clock_init+0x140>)
  20167a:	f003 03f9 	and.w	r3, r3, #249	@ 0xf9
  20167e:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  201680:	4b3b      	ldr	r3, [pc, #236]	@ (201770 <stm32_clock_init+0x140>)
  201682:	2200      	movs	r2, #0
  201684:	609a      	str	r2, [r3, #8]

#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
  201686:	4b3a      	ldr	r3, [pc, #232]	@ (201770 <stm32_clock_init+0x140>)
  201688:	681b      	ldr	r3, [r3, #0]
  20168a:	4a39      	ldr	r2, [pc, #228]	@ (201770 <stm32_clock_init+0x140>)
  20168c:	f443 23a0 	orr.w	r3, r3, #327680	@ 0x50000
  201690:	6013      	str	r3, [r2, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  201692:	bf00      	nop
  201694:	4b36      	ldr	r3, [pc, #216]	@ (201770 <stm32_clock_init+0x140>)
  201696:	681b      	ldr	r3, [r3, #0]
  201698:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
  20169c:	2b00      	cmp	r3, #0
  20169e:	d0f9      	beq.n	201694 <stm32_clock_init+0x64>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  2016a0:	4b33      	ldr	r3, [pc, #204]	@ (201770 <stm32_clock_init+0x140>)
  2016a2:	4a36      	ldr	r2, [pc, #216]	@ (20177c <stm32_clock_init+0x14c>)
  2016a4:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
  2016a6:	4b32      	ldr	r3, [pc, #200]	@ (201770 <stm32_clock_init+0x140>)
  2016a8:	681b      	ldr	r3, [r3, #0]
  2016aa:	4a31      	ldr	r2, [pc, #196]	@ (201770 <stm32_clock_init+0x140>)
  2016ac:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
  2016b0:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  2016b2:	bf00      	nop
  2016b4:	4b30      	ldr	r3, [pc, #192]	@ (201778 <stm32_clock_init+0x148>)
  2016b6:	685b      	ldr	r3, [r3, #4]
  2016b8:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
  2016bc:	2b00      	cmp	r3, #0
  2016be:	d0f9      	beq.n	2016b4 <stm32_clock_init+0x84>
    ;                           /* Waits until power regulator is stable.   */

#if STM32_OVERDRIVE_REQUIRED
  /* Overdrive activation performed after activating the PLL in order to save
     time as recommended in RM in "Entering Over-drive mode" paragraph.*/
  PWR->CR1 |= PWR_CR1_ODEN;
  2016c0:	4b2d      	ldr	r3, [pc, #180]	@ (201778 <stm32_clock_init+0x148>)
  2016c2:	681b      	ldr	r3, [r3, #0]
  2016c4:	4a2c      	ldr	r2, [pc, #176]	@ (201778 <stm32_clock_init+0x148>)
  2016c6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
  2016ca:	6013      	str	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  2016cc:	bf00      	nop
  2016ce:	4b2a      	ldr	r3, [pc, #168]	@ (201778 <stm32_clock_init+0x148>)
  2016d0:	685b      	ldr	r3, [r3, #4]
  2016d2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
  2016d6:	2b00      	cmp	r3, #0
  2016d8:	d0f9      	beq.n	2016ce <stm32_clock_init+0x9e>
      ;
  PWR->CR1 |= PWR_CR1_ODSWEN;
  2016da:	4b27      	ldr	r3, [pc, #156]	@ (201778 <stm32_clock_init+0x148>)
  2016dc:	681b      	ldr	r3, [r3, #0]
  2016de:	4a26      	ldr	r2, [pc, #152]	@ (201778 <stm32_clock_init+0x148>)
  2016e0:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  2016e4:	6013      	str	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  2016e6:	bf00      	nop
  2016e8:	4b23      	ldr	r3, [pc, #140]	@ (201778 <stm32_clock_init+0x148>)
  2016ea:	685b      	ldr	r3, [r3, #4]
  2016ec:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
  2016f0:	2b00      	cmp	r3, #0
  2016f2:	d0f9      	beq.n	2016e8 <stm32_clock_init+0xb8>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
  2016f4:	bf00      	nop
  2016f6:	4b1e      	ldr	r3, [pc, #120]	@ (201770 <stm32_clock_init+0x140>)
  2016f8:	681b      	ldr	r3, [r3, #0]
  2016fa:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
  2016fe:	2b00      	cmp	r3, #0
  201700:	d0f9      	beq.n	2016f6 <stm32_clock_init+0xc6>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  201702:	4b1b      	ldr	r3, [pc, #108]	@ (201770 <stm32_clock_init+0x140>)
  201704:	4a1e      	ldr	r2, [pc, #120]	@ (201780 <stm32_clock_init+0x150>)
  201706:	609a      	str	r2, [r3, #8]
              STM32_HPRE;

  /* DCKCFGR1 register initialization, note, must take care of the _OFF
     pseudo settings.*/
  {
    uint32_t dckcfgr1 = STM32_PLLI2SDIVQ | STM32_PLLSAIDIVQ | STM32_PLLSAIDIVR;
  201708:	f240 1301 	movw	r3, #257	@ 0x101
  20170c:	9301      	str	r3, [sp, #4]
    dckcfgr1 |= STM32_SAI1SEL;
#endif
#if STM32_TIMPRE_ENABLE == TRUE
    dckcfgr1 |= RCC_DCKCFGR1_TIMPRE;
#endif
    RCC->DCKCFGR1 = dckcfgr1;
  20170e:	4a18      	ldr	r2, [pc, #96]	@ (201770 <stm32_clock_init+0x140>)
  201710:	9b01      	ldr	r3, [sp, #4]
  201712:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
  }

  /* Peripheral clock sources.*/
  RCC->DCKCFGR2 = STM32_SDMMC2SEL | STM32_SDMMC1SEL | STM32_CK48MSEL  |
  201716:	4b16      	ldr	r3, [pc, #88]	@ (201770 <stm32_clock_init+0x140>)
  201718:	2200      	movs	r2, #0
  20171a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
                  STM32_UART8SEL  | STM32_UART7SEL  | STM32_USART6SEL |
                  STM32_UART5SEL  | STM32_UART4SEL  | STM32_USART3SEL |
                  STM32_USART2SEL | STM32_USART1SEL;

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  20171e:	4b19      	ldr	r3, [pc, #100]	@ (201784 <stm32_clock_init+0x154>)
  201720:	f240 3207 	movw	r2, #775	@ 0x307
  201724:	601a      	str	r2, [r3, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
  201726:	bf00      	nop
  201728:	4b16      	ldr	r3, [pc, #88]	@ (201784 <stm32_clock_init+0x154>)
  20172a:	681b      	ldr	r3, [r3, #0]
  20172c:	f003 030f 	and.w	r3, r3, #15
  201730:	2b07      	cmp	r3, #7
  201732:	d1f9      	bne.n	201728 <stm32_clock_init+0xf8>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  201734:	4b0e      	ldr	r3, [pc, #56]	@ (201770 <stm32_clock_init+0x140>)
  201736:	689b      	ldr	r3, [r3, #8]
  201738:	4a0d      	ldr	r2, [pc, #52]	@ (201770 <stm32_clock_init+0x140>)
  20173a:	f043 0302 	orr.w	r3, r3, #2
  20173e:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  201740:	bf00      	nop
  201742:	4b0b      	ldr	r3, [pc, #44]	@ (201770 <stm32_clock_init+0x140>)
  201744:	689b      	ldr	r3, [r3, #8]
  201746:	f003 030c 	and.w	r3, r3, #12
  20174a:	2b08      	cmp	r3, #8
  20174c:	d1f9      	bne.n	201742 <stm32_clock_init+0x112>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
  20174e:	4b08      	ldr	r3, [pc, #32]	@ (201770 <stm32_clock_init+0x140>)
  201750:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  201752:	4a07      	ldr	r2, [pc, #28]	@ (201770 <stm32_clock_init+0x140>)
  201754:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
  201758:	6453      	str	r3, [r2, #68]	@ 0x44
  20175a:	4b05      	ldr	r3, [pc, #20]	@ (201770 <stm32_clock_init+0x140>)
  20175c:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
  20175e:	4a04      	ldr	r2, [pc, #16]	@ (201770 <stm32_clock_init+0x140>)
  201760:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
  201764:	6653      	str	r3, [r2, #100]	@ 0x64
  201766:	4b02      	ldr	r3, [pc, #8]	@ (201770 <stm32_clock_init+0x140>)
  201768:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
}
  20176a:	bf00      	nop
  20176c:	b002      	add	sp, #8
  20176e:	4770      	bx	lr
  201770:	40023800 	.word	0x40023800
  201774:	10000400 	.word	0x10000400
  201778:	40007000 	.word	0x40007000
  20177c:	09406c08 	.word	0x09406c08
  201780:	30999400 	.word	0x30999400
  201784:	40023c00 	.word	0x40023c00
	...

00201790 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
  201790:	bf00      	nop
  201792:	4770      	bx	lr
	...

002017a0 <chSysLockFromISR.lto_priv.0>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  2017a0:	b082      	sub	sp, #8
  2017a2:	2330      	movs	r3, #48	@ 0x30
  2017a4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2017a6:	9b01      	ldr	r3, [sp, #4]
  2017a8:	f383 8811 	msr	BASEPRI, r3
}
  2017ac:	bf00      	nop
}
  2017ae:	bf00      	nop
 * @note    Same as @p port_lock() in this port.
 */
__STATIC_FORCEINLINE void port_lock_from_isr(void) {

  port_lock();
}
  2017b0:	bf00      	nop

  port_lock_from_isr();
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
}
  2017b2:	bf00      	nop
  2017b4:	b002      	add	sp, #8
  2017b6:	4770      	bx	lr
	...

002017c0 <chSysUnlockFromISR.lto_priv.0>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  2017c0:	b082      	sub	sp, #8
  2017c2:	2300      	movs	r3, #0
  2017c4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2017c6:	9b01      	ldr	r3, [sp, #4]
  2017c8:	f383 8811 	msr	BASEPRI, r3
}
  2017cc:	bf00      	nop
}
  2017ce:	bf00      	nop
 * @note    Same as @p port_unlock() in this port.
 */
__STATIC_FORCEINLINE void port_unlock_from_isr(void) {

  port_unlock();
}
  2017d0:	bf00      	nop

  __dbg_check_unlock_from_isr();
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
}
  2017d2:	bf00      	nop
  2017d4:	b002      	add	sp, #8
  2017d6:	4770      	bx	lr
	...

002017e0 <osalSysLockFromISR.lto_priv.0>:
static inline void osalSysLockFromISR(void) {
  2017e0:	b508      	push	{r3, lr}
  chSysLockFromISR();
  2017e2:	f7ff ffdd 	bl	2017a0 <chSysLockFromISR.lto_priv.0>
}
  2017e6:	bf00      	nop
  2017e8:	bd08      	pop	{r3, pc}
  2017ea:	bf00      	nop
  2017ec:	0000      	movs	r0, r0
	...

002017f0 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
  2017f0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
  2017f2:	f7ff ffe5 	bl	2017c0 <chSysUnlockFromISR.lto_priv.0>
}
  2017f6:	bf00      	nop
  2017f8:	bd08      	pop	{r3, pc}
  2017fa:	bf00      	nop
  2017fc:	0000      	movs	r0, r0
	...

00201800 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
  201800:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
  201802:	f000 fc45 	bl	202090 <chSysTimerHandlerI>
}
  201806:	bf00      	nop
  201808:	bd08      	pop	{r3, pc}
  20180a:	bf00      	nop
  20180c:	0000      	movs	r0, r0
	...

00201810 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
  201810:	4b1b      	ldr	r3, [pc, #108]	@ (201880 <st_lld_init+0x70>)
  201812:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
  201814:	4a1a      	ldr	r2, [pc, #104]	@ (201880 <st_lld_init+0x70>)
  201816:	f043 0301 	orr.w	r3, r3, #1
  20181a:	6413      	str	r3, [r2, #64]	@ 0x40
  20181c:	4b18      	ldr	r3, [pc, #96]	@ (201880 <st_lld_init+0x70>)
  20181e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
  201820:	4a17      	ldr	r2, [pc, #92]	@ (201880 <st_lld_init+0x70>)
  201822:	f043 0301 	orr.w	r3, r3, #1
  201826:	6613      	str	r3, [r2, #96]	@ 0x60
  201828:	4b15      	ldr	r3, [pc, #84]	@ (201880 <st_lld_init+0x70>)
  20182a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
  20182c:	4b15      	ldr	r3, [pc, #84]	@ (201884 <st_lld_init+0x74>)
  20182e:	689b      	ldr	r3, [r3, #8]
  201830:	4a14      	ldr	r2, [pc, #80]	@ (201884 <st_lld_init+0x74>)
  201832:	f043 0301 	orr.w	r3, r3, #1
  201836:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  201838:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  20183c:	f642 222f 	movw	r2, #10799	@ 0x2a2f
  201840:	629a      	str	r2, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  201842:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  201846:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20184a:	62da      	str	r2, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CCMR1  = 0;
  20184c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  201850:	2200      	movs	r2, #0
  201852:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
  201854:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  201858:	2200      	movs	r2, #0
  20185a:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
  20185c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  201860:	2200      	movs	r2, #0
  201862:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
  201864:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  201868:	2200      	movs	r2, #0
  20186a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  20186c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  201870:	2201      	movs	r2, #1
  201872:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
  201874:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  201878:	2201      	movs	r2, #1
  20187a:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
  20187c:	bf00      	nop
  20187e:	4770      	bx	lr
  201880:	40023800 	.word	0x40023800
  201884:	e0042000 	.word	0xe0042000
	...

00201890 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
  201890:	b500      	push	{lr}
  201892:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
  201894:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  201898:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
  20189a:	9b01      	ldr	r3, [sp, #4]
  20189c:	691b      	ldr	r3, [r3, #16]
  20189e:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
  2018a0:	9b01      	ldr	r3, [sp, #4]
  2018a2:	68db      	ldr	r3, [r3, #12]
  2018a4:	b2db      	uxtb	r3, r3
  2018a6:	9a00      	ldr	r2, [sp, #0]
  2018a8:	4013      	ands	r3, r2
  2018aa:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
  2018ac:	9b00      	ldr	r3, [sp, #0]
  2018ae:	43da      	mvns	r2, r3
  2018b0:	9b01      	ldr	r3, [sp, #4]
  2018b2:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
  2018b4:	9b00      	ldr	r3, [sp, #0]
  2018b6:	f003 0302 	and.w	r3, r3, #2
  2018ba:	2b00      	cmp	r3, #0
  2018bc:	d005      	beq.n	2018ca <st_lld_serve_interrupt+0x3a>
#endif
  {
    osalSysLockFromISR();
  2018be:	f7ff ff8f 	bl	2017e0 <osalSysLockFromISR.lto_priv.0>
    osalOsTimerHandlerI();
  2018c2:	f7ff ff9d 	bl	201800 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
  2018c6:	f7ff ff93 	bl	2017f0 <osalSysUnlockFromISR.lto_priv.0>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
  2018ca:	bf00      	nop
  2018cc:	b003      	add	sp, #12
  2018ce:	f85d fb04 	ldr.w	pc, [sp], #4
  2018d2:	bf00      	nop
	...

002018e0 <chSysLockFromISR.lto_priv.1>:
static inline void chSysLockFromISR(void) {
  2018e0:	b082      	sub	sp, #8
  2018e2:	2330      	movs	r3, #48	@ 0x30
  2018e4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2018e6:	9b01      	ldr	r3, [sp, #4]
  2018e8:	f383 8811 	msr	BASEPRI, r3
}
  2018ec:	bf00      	nop
}
  2018ee:	bf00      	nop
}
  2018f0:	bf00      	nop
}
  2018f2:	bf00      	nop
  2018f4:	b002      	add	sp, #8
  2018f6:	4770      	bx	lr
	...

00201900 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
  201900:	b082      	sub	sp, #8
  201902:	2300      	movs	r3, #0
  201904:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201906:	9b01      	ldr	r3, [sp, #4]
  201908:	f383 8811 	msr	BASEPRI, r3
}
  20190c:	bf00      	nop
}
  20190e:	bf00      	nop
}
  201910:	bf00      	nop
}
  201912:	bf00      	nop
  201914:	b002      	add	sp, #8
  201916:	4770      	bx	lr
	...

00201920 <osalSysLockFromISR.lto_priv.1>:
static inline void osalSysLockFromISR(void) {
  201920:	b508      	push	{r3, lr}
  chSysLockFromISR();
  201922:	f7ff ffdd 	bl	2018e0 <chSysLockFromISR.lto_priv.1>
}
  201926:	bf00      	nop
  201928:	bd08      	pop	{r3, pc}
  20192a:	bf00      	nop
  20192c:	0000      	movs	r0, r0
	...

00201930 <osalSysUnlockFromISR.lto_priv.1>:
static inline void osalSysUnlockFromISR(void) {
  201930:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
  201932:	f7ff ffe5 	bl	201900 <chSysUnlockFromISR.lto_priv.1>
}
  201936:	bf00      	nop
  201938:	bd08      	pop	{r3, pc}
  20193a:	bf00      	nop
  20193c:	0000      	movs	r0, r0
	...

00201940 <osalEventBroadcastFlagsI.lto_priv.2>:
                                            eventflags_t flags) {
  201940:	b500      	push	{lr}
  201942:	b083      	sub	sp, #12
  201944:	9001      	str	r0, [sp, #4]
  201946:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
  201948:	9900      	ldr	r1, [sp, #0]
  20194a:	9801      	ldr	r0, [sp, #4]
  20194c:	f002 fee8 	bl	204720 <chEvtBroadcastFlagsI>
}
  201950:	bf00      	nop
  201952:	b003      	add	sp, #12
  201954:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00201960 <usart_init>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp,
                       const SerialConfig *config) {
  201960:	b086      	sub	sp, #24
  201962:	9001      	str	r0, [sp, #4]
  201964:	9100      	str	r1, [sp, #0]
  uint32_t brr, clock;
  USART_TypeDef *u = sdp->usart;
  201966:	9b01      	ldr	r3, [sp, #4]
  201968:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
  20196a:	9304      	str	r3, [sp, #16]

  /* Baud rate setting.*/
  clock = sdp->clock;
  20196c:	9b01      	ldr	r3, [sp, #4]
  20196e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
  201970:	9303      	str	r3, [sp, #12]
    osalDbgAssert((brr >= 0x300) && (brr < 0x100000), "invalid BRR value");
  }
  else
#endif
  {
    brr = (uint32_t)((clock + config->speed / 2) / config->speed);
  201972:	9b00      	ldr	r3, [sp, #0]
  201974:	681b      	ldr	r3, [r3, #0]
  201976:	085a      	lsrs	r2, r3, #1
  201978:	9b03      	ldr	r3, [sp, #12]
  20197a:	441a      	add	r2, r3
  20197c:	9b00      	ldr	r3, [sp, #0]
  20197e:	681b      	ldr	r3, [r3, #0]
  201980:	fbb2 f3f3 	udiv	r3, r2, r3
  201984:	9305      	str	r3, [sp, #20]

    /* Correcting BRR value when oversampling by 8 instead of 16.
       Fraction is still 4 bits wide, but only lower 3 bits used.
       Mantissa is doubled, but Fraction is left the same.*/
    if (config->cr1 & USART_CR1_OVER8)
  201986:	9b00      	ldr	r3, [sp, #0]
  201988:	685b      	ldr	r3, [r3, #4]
  20198a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
  20198e:	2b00      	cmp	r3, #0
  201990:	d008      	beq.n	2019a4 <usart_init+0x44>
      brr = ((brr & ~7) * 2) | (brr & 7);
  201992:	9b05      	ldr	r3, [sp, #20]
  201994:	f023 0307 	bic.w	r3, r3, #7
  201998:	005a      	lsls	r2, r3, #1
  20199a:	9b05      	ldr	r3, [sp, #20]
  20199c:	f003 0307 	and.w	r3, r3, #7
  2019a0:	4313      	orrs	r3, r2
  2019a2:	9305      	str	r3, [sp, #20]

    osalDbgAssert(brr < 0x10000, "invalid BRR value");
  }
  u->BRR = brr;
  2019a4:	9b04      	ldr	r3, [sp, #16]
  2019a6:	9a05      	ldr	r2, [sp, #20]
  2019a8:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  2019aa:	9b00      	ldr	r3, [sp, #0]
  2019ac:	689b      	ldr	r3, [r3, #8]
  2019ae:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
  2019b2:	9b04      	ldr	r3, [sp, #16]
  2019b4:	605a      	str	r2, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
  2019b6:	9b00      	ldr	r3, [sp, #0]
  2019b8:	68db      	ldr	r3, [r3, #12]
  2019ba:	f043 0201 	orr.w	r2, r3, #1
  2019be:	9b04      	ldr	r3, [sp, #16]
  2019c0:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  2019c2:	9b00      	ldr	r3, [sp, #0]
  2019c4:	685a      	ldr	r2, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
  2019c6:	f240 132d 	movw	r3, #301	@ 0x12d
  2019ca:	4313      	orrs	r3, r2
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  2019cc:	9a04      	ldr	r2, [sp, #16]
  2019ce:	6013      	str	r3, [r2, #0]
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
  2019d0:	9b04      	ldr	r3, [sp, #16]
  2019d2:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  2019d6:	621a      	str	r2, [r3, #32]

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & USART_CR1_PCE) != 0U) {
  2019d8:	9b00      	ldr	r3, [sp, #0]
  2019da:	685b      	ldr	r3, [r3, #4]
  2019dc:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
  2019e0:	2b00      	cmp	r3, #0
  2019e2:	d018      	beq.n	201a16 <usart_init+0xb6>
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
  2019e4:	9b00      	ldr	r3, [sp, #0]
  2019e6:	685b      	ldr	r3, [r3, #4]
  2019e8:	f003 2310 	and.w	r3, r3, #268439552	@ 0x10001000
  2019ec:	2b00      	cmp	r3, #0
  2019ee:	d003      	beq.n	2019f8 <usart_init+0x98>
  2019f0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
  2019f4:	d005      	beq.n	201a02 <usart_init+0xa2>
  2019f6:	e009      	b.n	201a0c <usart_init+0xac>
    case 0:
      sdp->rxmask = 0x7F;
  2019f8:	9b01      	ldr	r3, [sp, #4]
  2019fa:	227f      	movs	r2, #127	@ 0x7f
  2019fc:	f883 205c 	strb.w	r2, [r3, #92]	@ 0x5c
      break;
  201a00:	e00e      	b.n	201a20 <usart_init+0xc0>
    case USART_CR1_M_1:
      sdp->rxmask = 0x3F;
  201a02:	9b01      	ldr	r3, [sp, #4]
  201a04:	223f      	movs	r2, #63	@ 0x3f
  201a06:	f883 205c 	strb.w	r2, [r3, #92]	@ 0x5c
      break;
  201a0a:	e009      	b.n	201a20 <usart_init+0xc0>
    default:
      sdp->rxmask = 0xFF;
  201a0c:	9b01      	ldr	r3, [sp, #4]
  201a0e:	22ff      	movs	r2, #255	@ 0xff
  201a10:	f883 205c 	strb.w	r2, [r3, #92]	@ 0x5c
    }
  }
  else {
    sdp->rxmask = 0xFF;
  }
}
  201a14:	e004      	b.n	201a20 <usart_init+0xc0>
    sdp->rxmask = 0xFF;
  201a16:	9b01      	ldr	r3, [sp, #4]
  201a18:	22ff      	movs	r2, #255	@ 0xff
  201a1a:	f883 205c 	strb.w	r2, [r3, #92]	@ 0x5c
}
  201a1e:	e7ff      	b.n	201a20 <usart_init+0xc0>
  201a20:	bf00      	nop
  201a22:	b006      	add	sp, #24
  201a24:	4770      	bx	lr
  201a26:	bf00      	nop
	...

00201a30 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  201a30:	b500      	push	{lr}
  201a32:	b085      	sub	sp, #20
  201a34:	9001      	str	r0, [sp, #4]
  201a36:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
  201a38:	2300      	movs	r3, #0
  201a3a:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
  201a3c:	9b00      	ldr	r3, [sp, #0]
  201a3e:	f003 0308 	and.w	r3, r3, #8
  201a42:	2b00      	cmp	r3, #0
  201a44:	d003      	beq.n	201a4e <set_error+0x1e>
    sts |= SD_OVERRUN_ERROR;
  201a46:	9b03      	ldr	r3, [sp, #12]
  201a48:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
  201a4c:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
  201a4e:	9b00      	ldr	r3, [sp, #0]
  201a50:	f003 0301 	and.w	r3, r3, #1
  201a54:	2b00      	cmp	r3, #0
  201a56:	d003      	beq.n	201a60 <set_error+0x30>
    sts |= SD_PARITY_ERROR;
  201a58:	9b03      	ldr	r3, [sp, #12]
  201a5a:	f043 0320 	orr.w	r3, r3, #32
  201a5e:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
  201a60:	9b00      	ldr	r3, [sp, #0]
  201a62:	f003 0302 	and.w	r3, r3, #2
  201a66:	2b00      	cmp	r3, #0
  201a68:	d003      	beq.n	201a72 <set_error+0x42>
    sts |= SD_FRAMING_ERROR;
  201a6a:	9b03      	ldr	r3, [sp, #12]
  201a6c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
  201a70:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
  201a72:	9b00      	ldr	r3, [sp, #0]
  201a74:	f003 0304 	and.w	r3, r3, #4
  201a78:	2b00      	cmp	r3, #0
  201a7a:	d003      	beq.n	201a84 <set_error+0x54>
    sts |= SD_NOISE_ERROR;
  201a7c:	9b03      	ldr	r3, [sp, #12]
  201a7e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
  201a82:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
  201a84:	f7ff ff4c 	bl	201920 <osalSysLockFromISR.lto_priv.1>
  chnAddFlagsI(sdp, sts);
  201a88:	9b01      	ldr	r3, [sp, #4]
  201a8a:	3304      	adds	r3, #4
  201a8c:	9903      	ldr	r1, [sp, #12]
  201a8e:	4618      	mov	r0, r3
  201a90:	f7ff ff56 	bl	201940 <osalEventBroadcastFlagsI.lto_priv.2>
  osalSysUnlockFromISR();
  201a94:	f7ff ff4c 	bl	201930 <osalSysUnlockFromISR.lto_priv.1>
}
  201a98:	bf00      	nop
  201a9a:	b005      	add	sp, #20
  201a9c:	f85d fb04 	ldr.w	pc, [sp], #4

00201aa0 <notify3>:
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
}
#endif

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {
  201aa0:	b082      	sub	sp, #8
  201aa2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
  201aa4:	4b04      	ldr	r3, [pc, #16]	@ (201ab8 <notify3+0x18>)
  201aa6:	681b      	ldr	r3, [r3, #0]
  201aa8:	4a03      	ldr	r2, [pc, #12]	@ (201ab8 <notify3+0x18>)
  201aaa:	f043 03c0 	orr.w	r3, r3, #192	@ 0xc0
  201aae:	6013      	str	r3, [r2, #0]
}
  201ab0:	bf00      	nop
  201ab2:	b002      	add	sp, #8
  201ab4:	4770      	bx	lr
  201ab6:	bf00      	nop
  201ab8:	40004800 	.word	0x40004800
  201abc:	00000000 	.word	0x00000000

00201ac0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
  201ac0:	b500      	push	{lr}
  201ac2:	b083      	sub	sp, #12
  nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
#endif
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3);
  201ac4:	480e      	ldr	r0, [pc, #56]	@ (201b00 <sd_lld_init+0x40>)
  201ac6:	f7ff fb53 	bl	201170 <sdObjectInit>
  iqObjectInit(&SD3.iqueue, sd_in_buf3, sizeof sd_in_buf3, NULL, &SD3);
  201aca:	4b0d      	ldr	r3, [pc, #52]	@ (201b00 <sd_lld_init+0x40>)
  201acc:	9300      	str	r3, [sp, #0]
  201ace:	2300      	movs	r3, #0
  201ad0:	2210      	movs	r2, #16
  201ad2:	490c      	ldr	r1, [pc, #48]	@ (201b04 <sd_lld_init+0x44>)
  201ad4:	480c      	ldr	r0, [pc, #48]	@ (201b08 <sd_lld_init+0x48>)
  201ad6:	f7ff f853 	bl	200b80 <iqObjectInit>
  oqObjectInit(&SD3.oqueue, sd_out_buf3, sizeof sd_out_buf3, notify3, &SD3);
  201ada:	4b09      	ldr	r3, [pc, #36]	@ (201b00 <sd_lld_init+0x40>)
  201adc:	9300      	str	r3, [sp, #0]
  201ade:	4b0b      	ldr	r3, [pc, #44]	@ (201b0c <sd_lld_init+0x4c>)
  201ae0:	2210      	movs	r2, #16
  201ae2:	490b      	ldr	r1, [pc, #44]	@ (201b10 <sd_lld_init+0x50>)
  201ae4:	480b      	ldr	r0, [pc, #44]	@ (201b14 <sd_lld_init+0x54>)
  201ae6:	f7ff f933 	bl	200d50 <oqObjectInit>
  SD3.usart = USART3;
  201aea:	4b05      	ldr	r3, [pc, #20]	@ (201b00 <sd_lld_init+0x40>)
  201aec:	4a0a      	ldr	r2, [pc, #40]	@ (201b18 <sd_lld_init+0x58>)
  201aee:	655a      	str	r2, [r3, #84]	@ 0x54
  SD3.clock = STM32_USART3CLK;
  201af0:	4b03      	ldr	r3, [pc, #12]	@ (201b00 <sd_lld_init+0x40>)
  201af2:	4a0a      	ldr	r2, [pc, #40]	@ (201b1c <sd_lld_init+0x5c>)
  201af4:	659a      	str	r2, [r3, #88]	@ 0x58
  LPSD1.clock = STM32_LPUART1CLK;
#if !defined(STM32_LPUART1_SUPPRESS_ISR) && defined(STM32_LPUART1_NUMBER)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_SERIAL_LPUART1_PRIORITY);
#endif
#endif
}
  201af6:	bf00      	nop
  201af8:	b003      	add	sp, #12
  201afa:	f85d fb04 	ldr.w	pc, [sp], #4
  201afe:	bf00      	nop
  201b00:	20000800 	.word	0x20000800
  201b04:	20000860 	.word	0x20000860
  201b08:	2000080c 	.word	0x2000080c
  201b0c:	00201aa1 	.word	0x00201aa1
  201b10:	20000870 	.word	0x20000870
  201b14:	20000830 	.word	0x20000830
  201b18:	40004800 	.word	0x40004800
  201b1c:	0337f980 	.word	0x0337f980

00201b20 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
  201b20:	b500      	push	{lr}
  201b22:	b083      	sub	sp, #12
  201b24:	9001      	str	r0, [sp, #4]
  201b26:	9100      	str	r1, [sp, #0]

  if (config == NULL)
  201b28:	9b00      	ldr	r3, [sp, #0]
  201b2a:	2b00      	cmp	r3, #0
  201b2c:	d101      	bne.n	201b32 <sd_lld_start+0x12>
    config = &default_config;
  201b2e:	4b10      	ldr	r3, [pc, #64]	@ (201b70 <sd_lld_start+0x50>)
  201b30:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
  201b32:	9b01      	ldr	r3, [sp, #4]
  201b34:	7a1b      	ldrb	r3, [r3, #8]
  201b36:	2b01      	cmp	r3, #1
  201b38:	d111      	bne.n	201b5e <sd_lld_start+0x3e>
    if (&SD2 == sdp) {
      rccEnableUSART2(true);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
  201b3a:	9b01      	ldr	r3, [sp, #4]
  201b3c:	4a0d      	ldr	r2, [pc, #52]	@ (201b74 <sd_lld_start+0x54>)
  201b3e:	4293      	cmp	r3, r2
  201b40:	d10d      	bne.n	201b5e <sd_lld_start+0x3e>
      rccEnableUSART3(true);
  201b42:	4b0d      	ldr	r3, [pc, #52]	@ (201b78 <sd_lld_start+0x58>)
  201b44:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
  201b46:	4a0c      	ldr	r2, [pc, #48]	@ (201b78 <sd_lld_start+0x58>)
  201b48:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
  201b4c:	6413      	str	r3, [r2, #64]	@ 0x40
  201b4e:	4b0a      	ldr	r3, [pc, #40]	@ (201b78 <sd_lld_start+0x58>)
  201b50:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
  201b52:	4a09      	ldr	r2, [pc, #36]	@ (201b78 <sd_lld_start+0x58>)
  201b54:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
  201b58:	6613      	str	r3, [r2, #96]	@ 0x60
  201b5a:	4b07      	ldr	r3, [pc, #28]	@ (201b78 <sd_lld_start+0x58>)
  201b5c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
    if (&LPSD1 == sdp) {
      rccEnableLPUART1(true);
    }
#endif
  }
  usart_init(sdp, config);
  201b5e:	9900      	ldr	r1, [sp, #0]
  201b60:	9801      	ldr	r0, [sp, #4]
  201b62:	f7ff fefd 	bl	201960 <usart_init>
}
  201b66:	bf00      	nop
  201b68:	b003      	add	sp, #12
  201b6a:	f85d fb04 	ldr.w	pc, [sp], #4
  201b6e:	bf00      	nop
  201b70:	08010048 	.word	0x08010048
  201b74:	20000800 	.word	0x20000800
  201b78:	40023800 	.word	0x40023800
  201b7c:	00000000 	.word	0x00000000

00201b80 <sd_lld_serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
void sd_lld_serve_interrupt(SerialDriver *sdp) {
  201b80:	b500      	push	{lr}
  201b82:	b087      	sub	sp, #28
  201b84:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
  201b86:	9b01      	ldr	r3, [sp, #4]
  201b88:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
  201b8a:	9303      	str	r3, [sp, #12]
  uint32_t cr1;
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
  201b8c:	9b03      	ldr	r3, [sp, #12]
  201b8e:	69db      	ldr	r3, [r3, #28]
  201b90:	9304      	str	r3, [sp, #16]
  u->ICR = isr;
  201b92:	9b03      	ldr	r3, [sp, #12]
  201b94:	9a04      	ldr	r2, [sp, #16]
  201b96:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
  201b98:	9b04      	ldr	r3, [sp, #16]
  201b9a:	f003 030f 	and.w	r3, r3, #15
  201b9e:	2b00      	cmp	r3, #0
  201ba0:	d003      	beq.n	201baa <sd_lld_serve_interrupt+0x2a>
    set_error(sdp, isr);
  201ba2:	9904      	ldr	r1, [sp, #16]
  201ba4:	9801      	ldr	r0, [sp, #4]
  201ba6:	f7ff ff43 	bl	201a30 <set_error>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
  201baa:	9b04      	ldr	r3, [sp, #16]
  201bac:	f403 7380 	and.w	r3, r3, #256	@ 0x100
  201bb0:	2b00      	cmp	r3, #0
  201bb2:	d01e      	beq.n	201bf2 <sd_lld_serve_interrupt+0x72>
    osalSysLockFromISR();
  201bb4:	f7ff feb4 	bl	201920 <osalSysLockFromISR.lto_priv.1>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
  201bb8:	9b01      	ldr	r3, [sp, #4]
  201bba:	3304      	adds	r3, #4
  201bbc:	f44f 6180 	mov.w	r1, #1024	@ 0x400
  201bc0:	4618      	mov	r0, r3
  201bc2:	f7ff febd 	bl	201940 <osalEventBroadcastFlagsI.lto_priv.2>
    osalSysUnlockFromISR();
  201bc6:	f7ff feb3 	bl	201930 <osalSysUnlockFromISR.lto_priv.1>
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
  201bca:	e012      	b.n	201bf2 <sd_lld_serve_interrupt+0x72>
    osalSysLockFromISR();
  201bcc:	f7ff fea8 	bl	201920 <osalSysLockFromISR.lto_priv.1>
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
  201bd0:	9b03      	ldr	r3, [sp, #12]
  201bd2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  201bd4:	b2da      	uxtb	r2, r3
  201bd6:	9b01      	ldr	r3, [sp, #4]
  201bd8:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
  201bdc:	4013      	ands	r3, r2
  201bde:	b2db      	uxtb	r3, r3
  201be0:	4619      	mov	r1, r3
  201be2:	9801      	ldr	r0, [sp, #4]
  201be4:	f7ff fafc 	bl	2011e0 <sdIncomingDataI>
    osalSysUnlockFromISR();
  201be8:	f7ff fea2 	bl	201930 <osalSysUnlockFromISR.lto_priv.1>

    isr = u->ISR;
  201bec:	9b03      	ldr	r3, [sp, #12]
  201bee:	69db      	ldr	r3, [r3, #28]
  201bf0:	9304      	str	r3, [sp, #16]
  while (isr & USART_ISR_RXNE) {
  201bf2:	9b04      	ldr	r3, [sp, #16]
  201bf4:	f003 0320 	and.w	r3, r3, #32
  201bf8:	2b00      	cmp	r3, #0
  201bfa:	d1e7      	bne.n	201bcc <sd_lld_serve_interrupt+0x4c>
  }

  /* Caching CR1.*/
  cr1 = u->CR1;
  201bfc:	9b03      	ldr	r3, [sp, #12]
  201bfe:	681b      	ldr	r3, [r3, #0]
  201c00:	9305      	str	r3, [sp, #20]
     situations:
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
  201c02:	9b05      	ldr	r3, [sp, #20]
  201c04:	f003 0380 	and.w	r3, r3, #128	@ 0x80
  201c08:	2b00      	cmp	r3, #0
  201c0a:	d025      	beq.n	201c58 <sd_lld_serve_interrupt+0xd8>
    while (isr & USART_ISR_TXE) {
  201c0c:	e01f      	b.n	201c4e <sd_lld_serve_interrupt+0xce>
      msg_t b;

      osalSysLockFromISR();
  201c0e:	f7ff fe87 	bl	201920 <osalSysLockFromISR.lto_priv.1>
      b = oqGetI(&sdp->oqueue);
  201c12:	9b01      	ldr	r3, [sp, #4]
  201c14:	3330      	adds	r3, #48	@ 0x30
  201c16:	4618      	mov	r0, r3
  201c18:	f7ff f90a 	bl	200e30 <oqGetI>
  201c1c:	9002      	str	r0, [sp, #8]
      if (b < MSG_OK) {
  201c1e:	9b02      	ldr	r3, [sp, #8]
  201c20:	2b00      	cmp	r3, #0
  201c22:	da0c      	bge.n	201c3e <sd_lld_serve_interrupt+0xbe>
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  201c24:	9b01      	ldr	r3, [sp, #4]
  201c26:	3304      	adds	r3, #4
  201c28:	2108      	movs	r1, #8
  201c2a:	4618      	mov	r0, r3
  201c2c:	f7ff fe88 	bl	201940 <osalEventBroadcastFlagsI.lto_priv.2>
        cr1 &= ~USART_CR1_TXEIE;
  201c30:	9b05      	ldr	r3, [sp, #20]
  201c32:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
  201c36:	9305      	str	r3, [sp, #20]
        osalSysUnlockFromISR();
  201c38:	f7ff fe7a 	bl	201930 <osalSysUnlockFromISR.lto_priv.1>
        break;
  201c3c:	e00c      	b.n	201c58 <sd_lld_serve_interrupt+0xd8>
      }
      u->TDR = b;
  201c3e:	9a02      	ldr	r2, [sp, #8]
  201c40:	9b03      	ldr	r3, [sp, #12]
  201c42:	629a      	str	r2, [r3, #40]	@ 0x28
      osalSysUnlockFromISR();
  201c44:	f7ff fe74 	bl	201930 <osalSysUnlockFromISR.lto_priv.1>

      isr = u->ISR;
  201c48:	9b03      	ldr	r3, [sp, #12]
  201c4a:	69db      	ldr	r3, [r3, #28]
  201c4c:	9304      	str	r3, [sp, #16]
    while (isr & USART_ISR_TXE) {
  201c4e:	9b04      	ldr	r3, [sp, #16]
  201c50:	f003 0380 	and.w	r3, r3, #128	@ 0x80
  201c54:	2b00      	cmp	r3, #0
  201c56:	d1da      	bne.n	201c0e <sd_lld_serve_interrupt+0x8e>
    }
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
  201c58:	9b05      	ldr	r3, [sp, #20]
  201c5a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
  201c5e:	2b00      	cmp	r3, #0
  201c60:	d024      	beq.n	201cac <sd_lld_serve_interrupt+0x12c>
  201c62:	9b04      	ldr	r3, [sp, #16]
  201c64:	f003 0340 	and.w	r3, r3, #64	@ 0x40
  201c68:	2b00      	cmp	r3, #0
  201c6a:	d01f      	beq.n	201cac <sd_lld_serve_interrupt+0x12c>
    osalSysLockFromISR();
  201c6c:	f7ff fe58 	bl	201920 <osalSysLockFromISR.lto_priv.1>
    if (oqIsEmptyI(&sdp->oqueue)) {
  201c70:	9b01      	ldr	r3, [sp, #4]
  201c72:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  201c74:	9b01      	ldr	r3, [sp, #4]
  201c76:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
  201c78:	429a      	cmp	r2, r3
  201c7a:	d105      	bne.n	201c88 <sd_lld_serve_interrupt+0x108>
  201c7c:	9b01      	ldr	r3, [sp, #4]
  201c7e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
  201c80:	2b00      	cmp	r3, #0
  201c82:	d001      	beq.n	201c88 <sd_lld_serve_interrupt+0x108>
  201c84:	2301      	movs	r3, #1
  201c86:	e000      	b.n	201c8a <sd_lld_serve_interrupt+0x10a>
  201c88:	2300      	movs	r3, #0
  201c8a:	f003 0301 	and.w	r3, r3, #1
  201c8e:	b2db      	uxtb	r3, r3
  201c90:	2b00      	cmp	r3, #0
  201c92:	d009      	beq.n	201ca8 <sd_lld_serve_interrupt+0x128>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
  201c94:	9b01      	ldr	r3, [sp, #4]
  201c96:	3304      	adds	r3, #4
  201c98:	2110      	movs	r1, #16
  201c9a:	4618      	mov	r0, r3
  201c9c:	f7ff fe50 	bl	201940 <osalEventBroadcastFlagsI.lto_priv.2>
      cr1 &= ~USART_CR1_TCIE;
  201ca0:	9b05      	ldr	r3, [sp, #20]
  201ca2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
  201ca6:	9305      	str	r3, [sp, #20]
    }
    osalSysUnlockFromISR();
  201ca8:	f7ff fe42 	bl	201930 <osalSysUnlockFromISR.lto_priv.1>
  }

  /* Writing CR1 once.*/
  u->CR1 = cr1;
  201cac:	9b03      	ldr	r3, [sp, #12]
  201cae:	9a05      	ldr	r2, [sp, #20]
  201cb0:	601a      	str	r2, [r3, #0]
}
  201cb2:	bf00      	nop
  201cb4:	b007      	add	sp, #28
  201cb6:	f85d fb04 	ldr.w	pc, [sp], #4
  201cba:	bf00      	nop
  201cbc:	0000      	movs	r0, r0
	...

00201cc0 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
  201cc0:	b082      	sub	sp, #8
  201cc2:	9001      	str	r0, [sp, #4]
  201cc4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
  201cc6:	9b00      	ldr	r3, [sp, #0]
  201cc8:	685a      	ldr	r2, [r3, #4]
  201cca:	9b01      	ldr	r3, [sp, #4]
  201ccc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
  201cce:	9b00      	ldr	r3, [sp, #0]
  201cd0:	689a      	ldr	r2, [r3, #8]
  201cd2:	9b01      	ldr	r3, [sp, #4]
  201cd4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
  201cd6:	9b00      	ldr	r3, [sp, #0]
  201cd8:	68da      	ldr	r2, [r3, #12]
  201cda:	9b01      	ldr	r3, [sp, #4]
  201cdc:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
  201cde:	9b00      	ldr	r3, [sp, #0]
  201ce0:	691a      	ldr	r2, [r3, #16]
  201ce2:	9b01      	ldr	r3, [sp, #4]
  201ce4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
  201ce6:	9b00      	ldr	r3, [sp, #0]
  201ce8:	695a      	ldr	r2, [r3, #20]
  201cea:	9b01      	ldr	r3, [sp, #4]
  201cec:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
  201cee:	9b00      	ldr	r3, [sp, #0]
  201cf0:	699a      	ldr	r2, [r3, #24]
  201cf2:	9b01      	ldr	r3, [sp, #4]
  201cf4:	625a      	str	r2, [r3, #36]	@ 0x24
  gpiop->MODER   = config->moder;
  201cf6:	9b00      	ldr	r3, [sp, #0]
  201cf8:	681a      	ldr	r2, [r3, #0]
  201cfa:	9b01      	ldr	r3, [sp, #4]
  201cfc:	601a      	str	r2, [r3, #0]
}
  201cfe:	bf00      	nop
  201d00:	b002      	add	sp, #8
  201d02:	4770      	bx	lr
	...

00201d10 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
  201d10:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
  201d12:	4b26      	ldr	r3, [pc, #152]	@ (201dac <stm32_gpio_init+0x9c>)
  201d14:	691a      	ldr	r2, [r3, #16]
  201d16:	4925      	ldr	r1, [pc, #148]	@ (201dac <stm32_gpio_init+0x9c>)
  201d18:	f240 73ff 	movw	r3, #2047	@ 0x7ff
  201d1c:	4313      	orrs	r3, r2
  201d1e:	610b      	str	r3, [r1, #16]
  201d20:	4b22      	ldr	r3, [pc, #136]	@ (201dac <stm32_gpio_init+0x9c>)
  201d22:	691a      	ldr	r2, [r3, #16]
  201d24:	4921      	ldr	r1, [pc, #132]	@ (201dac <stm32_gpio_init+0x9c>)
  201d26:	4b22      	ldr	r3, [pc, #136]	@ (201db0 <stm32_gpio_init+0xa0>)
  201d28:	4013      	ands	r3, r2
  201d2a:	610b      	str	r3, [r1, #16]
  201d2c:	4b1f      	ldr	r3, [pc, #124]	@ (201dac <stm32_gpio_init+0x9c>)
  201d2e:	691b      	ldr	r3, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  201d30:	4b1e      	ldr	r3, [pc, #120]	@ (201dac <stm32_gpio_init+0x9c>)
  201d32:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
  201d34:	491d      	ldr	r1, [pc, #116]	@ (201dac <stm32_gpio_init+0x9c>)
  201d36:	f240 73ff 	movw	r3, #2047	@ 0x7ff
  201d3a:	4313      	orrs	r3, r2
  201d3c:	630b      	str	r3, [r1, #48]	@ 0x30
  201d3e:	4b1b      	ldr	r3, [pc, #108]	@ (201dac <stm32_gpio_init+0x9c>)
  201d40:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
  201d42:	491a      	ldr	r1, [pc, #104]	@ (201dac <stm32_gpio_init+0x9c>)
  201d44:	f240 73ff 	movw	r3, #2047	@ 0x7ff
  201d48:	4313      	orrs	r3, r2
  201d4a:	650b      	str	r3, [r1, #80]	@ 0x50
  201d4c:	4b17      	ldr	r3, [pc, #92]	@ (201dac <stm32_gpio_init+0x9c>)
  201d4e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
  201d50:	4918      	ldr	r1, [pc, #96]	@ (201db4 <stm32_gpio_init+0xa4>)
  201d52:	4819      	ldr	r0, [pc, #100]	@ (201db8 <stm32_gpio_init+0xa8>)
  201d54:	f7ff ffb4 	bl	201cc0 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
  201d58:	4918      	ldr	r1, [pc, #96]	@ (201dbc <stm32_gpio_init+0xac>)
  201d5a:	4819      	ldr	r0, [pc, #100]	@ (201dc0 <stm32_gpio_init+0xb0>)
  201d5c:	f7ff ffb0 	bl	201cc0 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
  201d60:	4918      	ldr	r1, [pc, #96]	@ (201dc4 <stm32_gpio_init+0xb4>)
  201d62:	4819      	ldr	r0, [pc, #100]	@ (201dc8 <stm32_gpio_init+0xb8>)
  201d64:	f7ff ffac 	bl	201cc0 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
  201d68:	4918      	ldr	r1, [pc, #96]	@ (201dcc <stm32_gpio_init+0xbc>)
  201d6a:	4819      	ldr	r0, [pc, #100]	@ (201dd0 <stm32_gpio_init+0xc0>)
  201d6c:	f7ff ffa8 	bl	201cc0 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
  201d70:	4918      	ldr	r1, [pc, #96]	@ (201dd4 <stm32_gpio_init+0xc4>)
  201d72:	4819      	ldr	r0, [pc, #100]	@ (201dd8 <stm32_gpio_init+0xc8>)
  201d74:	f7ff ffa4 	bl	201cc0 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
  201d78:	4918      	ldr	r1, [pc, #96]	@ (201ddc <stm32_gpio_init+0xcc>)
  201d7a:	4819      	ldr	r0, [pc, #100]	@ (201de0 <stm32_gpio_init+0xd0>)
  201d7c:	f7ff ffa0 	bl	201cc0 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
  201d80:	4918      	ldr	r1, [pc, #96]	@ (201de4 <stm32_gpio_init+0xd4>)
  201d82:	4819      	ldr	r0, [pc, #100]	@ (201de8 <stm32_gpio_init+0xd8>)
  201d84:	f7ff ff9c 	bl	201cc0 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
  201d88:	4918      	ldr	r1, [pc, #96]	@ (201dec <stm32_gpio_init+0xdc>)
  201d8a:	4819      	ldr	r0, [pc, #100]	@ (201df0 <stm32_gpio_init+0xe0>)
  201d8c:	f7ff ff98 	bl	201cc0 <gpio_init>
#endif
#if STM32_HAS_GPIOI
  gpio_init(GPIOI, &gpio_default_config.PIData);
  201d90:	4918      	ldr	r1, [pc, #96]	@ (201df4 <stm32_gpio_init+0xe4>)
  201d92:	4819      	ldr	r0, [pc, #100]	@ (201df8 <stm32_gpio_init+0xe8>)
  201d94:	f7ff ff94 	bl	201cc0 <gpio_init>
#endif
#if STM32_HAS_GPIOJ
  gpio_init(GPIOJ, &gpio_default_config.PJData);
  201d98:	4918      	ldr	r1, [pc, #96]	@ (201dfc <stm32_gpio_init+0xec>)
  201d9a:	4819      	ldr	r0, [pc, #100]	@ (201e00 <stm32_gpio_init+0xf0>)
  201d9c:	f7ff ff90 	bl	201cc0 <gpio_init>
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
  201da0:	4918      	ldr	r1, [pc, #96]	@ (201e04 <stm32_gpio_init+0xf4>)
  201da2:	4819      	ldr	r0, [pc, #100]	@ (201e08 <stm32_gpio_init+0xf8>)
  201da4:	f7ff ff8c 	bl	201cc0 <gpio_init>
#endif
}
  201da8:	bf00      	nop
  201daa:	bd08      	pop	{r3, pc}
  201dac:	40023800 	.word	0x40023800
  201db0:	fffff800 	.word	0xfffff800
  201db4:	08010058 	.word	0x08010058
  201db8:	40020000 	.word	0x40020000
  201dbc:	08010074 	.word	0x08010074
  201dc0:	40020400 	.word	0x40020400
  201dc4:	08010090 	.word	0x08010090
  201dc8:	40020800 	.word	0x40020800
  201dcc:	080100ac 	.word	0x080100ac
  201dd0:	40020c00 	.word	0x40020c00
  201dd4:	080100c8 	.word	0x080100c8
  201dd8:	40021000 	.word	0x40021000
  201ddc:	080100e4 	.word	0x080100e4
  201de0:	40021400 	.word	0x40021400
  201de4:	08010100 	.word	0x08010100
  201de8:	40021800 	.word	0x40021800
  201dec:	0801011c 	.word	0x0801011c
  201df0:	40021c00 	.word	0x40021c00
  201df4:	08010138 	.word	0x08010138
  201df8:	40022000 	.word	0x40022000
  201dfc:	08010154 	.word	0x08010154
  201e00:	40022400 	.word	0x40022400
  201e04:	08010170 	.word	0x08010170
  201e08:	40022800 	.word	0x40022800
  201e0c:	00000000 	.word	0x00000000

00201e10 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
  201e10:	b508      	push	{r3, lr}

  stm32_gpio_init();
  201e12:	f7ff ff7d 	bl	201d10 <stm32_gpio_init>
  stm32_clock_init();
  201e16:	f7ff fc0b 	bl	201630 <stm32_clock_init>
}
  201e1a:	bf00      	nop
  201e1c:	bd08      	pop	{r3, pc}
  201e1e:	bf00      	nop

00201e20 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
  201e20:	bf00      	nop
  201e22:	4770      	bx	lr
	...

00201e30 <__tm_calibration_object_init>:
 *
 * @param[out] tcp      pointer to a @p tm_calibration_t object
 *
 * @notapi
 */
static inline void __tm_calibration_object_init(tm_calibration_t *tcp) {
  201e30:	b500      	push	{lr}
  201e32:	b08b      	sub	sp, #44	@ 0x2c
  201e34:	9001      	str	r0, [sp, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
  201e36:	9b01      	ldr	r3, [sp, #4]
  201e38:	2200      	movs	r2, #0
  201e3a:	601a      	str	r2, [r3, #0]
  chTMObjectInit(&tm);
  201e3c:	ab02      	add	r3, sp, #8
  201e3e:	4618      	mov	r0, r3
  201e40:	f001 fd16 	bl	203870 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
  201e44:	2304      	movs	r3, #4
  201e46:	9309      	str	r3, [sp, #36]	@ 0x24
  do {
    chTMStartMeasurementX(&tm);
  201e48:	ab02      	add	r3, sp, #8
  201e4a:	4618      	mov	r0, r3
  201e4c:	f001 fd30 	bl	2038b0 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
  201e50:	ab02      	add	r3, sp, #8
  201e52:	4618      	mov	r0, r3
  201e54:	f001 fd3c 	bl	2038d0 <chTMStopMeasurementX>
    i--;
  201e58:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  201e5a:	3b01      	subs	r3, #1
  201e5c:	9309      	str	r3, [sp, #36]	@ 0x24
  } while (i > 0U);
  201e5e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  201e60:	2b00      	cmp	r3, #0
  201e62:	d1f1      	bne.n	201e48 <__tm_calibration_object_init+0x18>
  tcp->offset = tm.best;
  201e64:	9a02      	ldr	r2, [sp, #8]
  201e66:	9b01      	ldr	r3, [sp, #4]
  201e68:	601a      	str	r2, [r3, #0]
}
  201e6a:	bf00      	nop
  201e6c:	b00b      	add	sp, #44	@ 0x2c
  201e6e:	f85d fb04 	ldr.w	pc, [sp], #4
  201e72:	bf00      	nop
	...

00201e80 <chSysLock.lto_priv.3>:
static inline void chSysLock(void) {
  201e80:	b082      	sub	sp, #8
  201e82:	2330      	movs	r3, #48	@ 0x30
  201e84:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201e86:	9b01      	ldr	r3, [sp, #4]
  201e88:	f383 8811 	msr	BASEPRI, r3
}
  201e8c:	bf00      	nop
}
  201e8e:	bf00      	nop
}
  201e90:	bf00      	nop
  201e92:	b002      	add	sp, #8
  201e94:	4770      	bx	lr
  201e96:	bf00      	nop
	...

00201ea0 <chSysUnlock.lto_priv.3>:
static inline void chSysUnlock(void) {
  201ea0:	b082      	sub	sp, #8
  201ea2:	2300      	movs	r3, #0
  201ea4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201ea6:	9b01      	ldr	r3, [sp, #4]
  201ea8:	f383 8811 	msr	BASEPRI, r3
}
  201eac:	bf00      	nop
}
  201eae:	bf00      	nop
}
  201eb0:	bf00      	nop
  201eb2:	b002      	add	sp, #8
  201eb4:	4770      	bx	lr
  201eb6:	bf00      	nop
	...

00201ec0 <chSysLockFromISR.lto_priv.2>:
static inline void chSysLockFromISR(void) {
  201ec0:	b082      	sub	sp, #8
  201ec2:	2330      	movs	r3, #48	@ 0x30
  201ec4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201ec6:	9b01      	ldr	r3, [sp, #4]
  201ec8:	f383 8811 	msr	BASEPRI, r3
}
  201ecc:	bf00      	nop
}
  201ece:	bf00      	nop
}
  201ed0:	bf00      	nop
}
  201ed2:	bf00      	nop
  201ed4:	b002      	add	sp, #8
  201ed6:	4770      	bx	lr
	...

00201ee0 <chSysUnlockFromISR.lto_priv.2>:
static inline void chSysUnlockFromISR(void) {
  201ee0:	b082      	sub	sp, #8
  201ee2:	2300      	movs	r3, #0
  201ee4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201ee6:	9b01      	ldr	r3, [sp, #4]
  201ee8:	f383 8811 	msr	BASEPRI, r3
}
  201eec:	bf00      	nop
}
  201eee:	bf00      	nop
}
  201ef0:	bf00      	nop
}
  201ef2:	bf00      	nop
  201ef4:	b002      	add	sp, #8
  201ef6:	4770      	bx	lr
	...

00201f00 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
  201f00:	b508      	push	{r3, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
  201f02:	f003 fa55 	bl	2053b0 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
  201f06:	f003 faeb 	bl	2054e0 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
  201f0a:	f004 fde9 	bl	206ae0 <__factory_init>
#endif
}
  201f0e:	bf00      	nop
  201f10:	bd08      	pop	{r3, pc}
  201f12:	bf00      	nop
	...

00201f20 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
  201f20:	b500      	push	{lr}
  201f22:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
  201f24:	4b11      	ldr	r3, [pc, #68]	@ (201f6c <chSysInit+0x4c>)
  201f26:	2201      	movs	r2, #1
  201f28:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
  201f2a:	2300      	movs	r3, #0
  201f2c:	9301      	str	r3, [sp, #4]
  201f2e:	e008      	b.n	201f42 <chSysInit+0x22>
    ch_system.instances[i] = NULL;
  201f30:	4a0e      	ldr	r2, [pc, #56]	@ (201f6c <chSysInit+0x4c>)
  201f32:	9b01      	ldr	r3, [sp, #4]
  201f34:	009b      	lsls	r3, r3, #2
  201f36:	4413      	add	r3, r2
  201f38:	2200      	movs	r2, #0
  201f3a:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
  201f3c:	9b01      	ldr	r3, [sp, #4]
  201f3e:	3301      	adds	r3, #1
  201f40:	9301      	str	r3, [sp, #4]
  201f42:	9b01      	ldr	r3, [sp, #4]
  201f44:	2b00      	cmp	r3, #0
  201f46:	d0f3      	beq.n	201f30 <chSysInit+0x10>
  }

#if CH_CFG_USE_TM == TRUE
  /* Time Measurement calibration.*/
  __tm_calibration_object_init(&ch_system.tmc);
  201f48:	4809      	ldr	r0, [pc, #36]	@ (201f70 <chSysInit+0x50>)
  201f4a:	f7ff ff71 	bl	201e30 <__tm_calibration_object_init>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
  201f4e:	f7ff ffd7 	bl	201f00 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
  201f52:	4908      	ldr	r1, [pc, #32]	@ (201f74 <chSysInit+0x54>)
  201f54:	4808      	ldr	r0, [pc, #32]	@ (201f78 <chSysInit+0x58>)
  201f56:	f000 ffab 	bl	202eb0 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
  201f5a:	4b04      	ldr	r3, [pc, #16]	@ (201f6c <chSysInit+0x4c>)
  201f5c:	2202      	movs	r2, #2
  201f5e:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
  201f60:	f7ff ff9e 	bl	201ea0 <chSysUnlock.lto_priv.3>
}
  201f64:	bf00      	nop
  201f66:	b003      	add	sp, #12
  201f68:	f85d fb04 	ldr.w	pc, [sp], #4
  201f6c:	20000880 	.word	0x20000880
  201f70:	20000888 	.word	0x20000888
  201f74:	080121c0 	.word	0x080121c0
  201f78:	20000890 	.word	0x20000890
  201f7c:	00000000 	.word	0x00000000

00201f80 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
  201f80:	b088      	sub	sp, #32
  201f82:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
  201f84:	4b41      	ldr	r3, [pc, #260]	@ (20208c <chSysIntegrityCheckI+0x10c>)
  201f86:	9303      	str	r3, [sp, #12]
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
  201f88:	9b01      	ldr	r3, [sp, #4]
  201f8a:	f003 0301 	and.w	r3, r3, #1
  201f8e:	2b00      	cmp	r3, #0
  201f90:	d022      	beq.n	201fd8 <chSysIntegrityCheckI+0x58>
    ch_priority_queue_t *pqp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
  201f92:	2300      	movs	r3, #0
  201f94:	9307      	str	r3, [sp, #28]
    pqp = oip->rlist.pqueue.next;
  201f96:	9b03      	ldr	r3, [sp, #12]
  201f98:	681b      	ldr	r3, [r3, #0]
  201f9a:	9306      	str	r3, [sp, #24]
    while (pqp != &oip->rlist.pqueue) {
  201f9c:	e005      	b.n	201faa <chSysIntegrityCheckI+0x2a>
      n++;
  201f9e:	9b07      	ldr	r3, [sp, #28]
  201fa0:	3301      	adds	r3, #1
  201fa2:	9307      	str	r3, [sp, #28]
      pqp = pqp->next;
  201fa4:	9b06      	ldr	r3, [sp, #24]
  201fa6:	681b      	ldr	r3, [r3, #0]
  201fa8:	9306      	str	r3, [sp, #24]
    while (pqp != &oip->rlist.pqueue) {
  201faa:	9b03      	ldr	r3, [sp, #12]
  201fac:	9a06      	ldr	r2, [sp, #24]
  201fae:	429a      	cmp	r2, r3
  201fb0:	d1f5      	bne.n	201f9e <chSysIntegrityCheckI+0x1e>
    }

    /* Scanning the ready list backward.*/
    pqp = oip->rlist.pqueue.prev;
  201fb2:	9b03      	ldr	r3, [sp, #12]
  201fb4:	685b      	ldr	r3, [r3, #4]
  201fb6:	9306      	str	r3, [sp, #24]
    while (pqp != &oip->rlist.pqueue) {
  201fb8:	e005      	b.n	201fc6 <chSysIntegrityCheckI+0x46>
      n--;
  201fba:	9b07      	ldr	r3, [sp, #28]
  201fbc:	3b01      	subs	r3, #1
  201fbe:	9307      	str	r3, [sp, #28]
      pqp = pqp->prev;
  201fc0:	9b06      	ldr	r3, [sp, #24]
  201fc2:	685b      	ldr	r3, [r3, #4]
  201fc4:	9306      	str	r3, [sp, #24]
    while (pqp != &oip->rlist.pqueue) {
  201fc6:	9b03      	ldr	r3, [sp, #12]
  201fc8:	9a06      	ldr	r2, [sp, #24]
  201fca:	429a      	cmp	r2, r3
  201fcc:	d1f5      	bne.n	201fba <chSysIntegrityCheckI+0x3a>
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
  201fce:	9b07      	ldr	r3, [sp, #28]
  201fd0:	2b00      	cmp	r3, #0
  201fd2:	d001      	beq.n	201fd8 <chSysIntegrityCheckI+0x58>
      return true;
  201fd4:	2301      	movs	r3, #1
  201fd6:	e055      	b.n	202084 <chSysIntegrityCheckI+0x104>
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
  201fd8:	9b01      	ldr	r3, [sp, #4]
  201fda:	f003 0302 	and.w	r3, r3, #2
  201fde:	2b00      	cmp	r3, #0
  201fe0:	d024      	beq.n	20202c <chSysIntegrityCheckI+0xac>
    ch_delta_list_t *dlp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
  201fe2:	2300      	movs	r3, #0
  201fe4:	9307      	str	r3, [sp, #28]
    dlp = oip->vtlist.dlist.next;
  201fe6:	9b03      	ldr	r3, [sp, #12]
  201fe8:	691b      	ldr	r3, [r3, #16]
  201fea:	9305      	str	r3, [sp, #20]
    while (dlp != &oip->vtlist.dlist) {
  201fec:	e005      	b.n	201ffa <chSysIntegrityCheckI+0x7a>
      n++;
  201fee:	9b07      	ldr	r3, [sp, #28]
  201ff0:	3301      	adds	r3, #1
  201ff2:	9307      	str	r3, [sp, #28]
      dlp = dlp->next;
  201ff4:	9b05      	ldr	r3, [sp, #20]
  201ff6:	681b      	ldr	r3, [r3, #0]
  201ff8:	9305      	str	r3, [sp, #20]
    while (dlp != &oip->vtlist.dlist) {
  201ffa:	9b03      	ldr	r3, [sp, #12]
  201ffc:	3310      	adds	r3, #16
  201ffe:	9a05      	ldr	r2, [sp, #20]
  202000:	429a      	cmp	r2, r3
  202002:	d1f4      	bne.n	201fee <chSysIntegrityCheckI+0x6e>
    }

    /* Scanning the timers list backward.*/
    dlp = oip->vtlist.dlist.prev;
  202004:	9b03      	ldr	r3, [sp, #12]
  202006:	695b      	ldr	r3, [r3, #20]
  202008:	9305      	str	r3, [sp, #20]
    while (dlp != &oip->vtlist.dlist) {
  20200a:	e005      	b.n	202018 <chSysIntegrityCheckI+0x98>
      n--;
  20200c:	9b07      	ldr	r3, [sp, #28]
  20200e:	3b01      	subs	r3, #1
  202010:	9307      	str	r3, [sp, #28]
      dlp = dlp->prev;
  202012:	9b05      	ldr	r3, [sp, #20]
  202014:	685b      	ldr	r3, [r3, #4]
  202016:	9305      	str	r3, [sp, #20]
    while (dlp != &oip->vtlist.dlist) {
  202018:	9b03      	ldr	r3, [sp, #12]
  20201a:	3310      	adds	r3, #16
  20201c:	9a05      	ldr	r2, [sp, #20]
  20201e:	429a      	cmp	r2, r3
  202020:	d1f4      	bne.n	20200c <chSysIntegrityCheckI+0x8c>
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
  202022:	9b07      	ldr	r3, [sp, #28]
  202024:	2b00      	cmp	r3, #0
  202026:	d001      	beq.n	20202c <chSysIntegrityCheckI+0xac>
      return true;
  202028:	2301      	movs	r3, #1
  20202a:	e02b      	b.n	202084 <chSysIntegrityCheckI+0x104>
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
  20202c:	9b01      	ldr	r3, [sp, #4]
  20202e:	f003 0304 	and.w	r3, r3, #4
  202032:	2b00      	cmp	r3, #0
  202034:	d025      	beq.n	202082 <chSysIntegrityCheckI+0x102>
    ch_queue_t *qp, *rqp;

    /* Registry header, access to this list depends on the current
       kernel configuration.*/
    rqp = REG_HEADER(oip);
  202036:	9b03      	ldr	r3, [sp, #12]
  202038:	3330      	adds	r3, #48	@ 0x30
  20203a:	9302      	str	r3, [sp, #8]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
  20203c:	2300      	movs	r3, #0
  20203e:	9307      	str	r3, [sp, #28]
    qp = rqp->next;
  202040:	9b02      	ldr	r3, [sp, #8]
  202042:	681b      	ldr	r3, [r3, #0]
  202044:	9304      	str	r3, [sp, #16]
    while (qp != rqp) {
  202046:	e005      	b.n	202054 <chSysIntegrityCheckI+0xd4>
      n++;
  202048:	9b07      	ldr	r3, [sp, #28]
  20204a:	3301      	adds	r3, #1
  20204c:	9307      	str	r3, [sp, #28]
      qp = qp->next;
  20204e:	9b04      	ldr	r3, [sp, #16]
  202050:	681b      	ldr	r3, [r3, #0]
  202052:	9304      	str	r3, [sp, #16]
    while (qp != rqp) {
  202054:	9a04      	ldr	r2, [sp, #16]
  202056:	9b02      	ldr	r3, [sp, #8]
  202058:	429a      	cmp	r2, r3
  20205a:	d1f5      	bne.n	202048 <chSysIntegrityCheckI+0xc8>
    }

    /* Scanning the ready list backward.*/
    qp = rqp->prev;
  20205c:	9b02      	ldr	r3, [sp, #8]
  20205e:	685b      	ldr	r3, [r3, #4]
  202060:	9304      	str	r3, [sp, #16]
    while (qp != rqp) {
  202062:	e005      	b.n	202070 <chSysIntegrityCheckI+0xf0>
      n--;
  202064:	9b07      	ldr	r3, [sp, #28]
  202066:	3b01      	subs	r3, #1
  202068:	9307      	str	r3, [sp, #28]
      qp = qp->prev;
  20206a:	9b04      	ldr	r3, [sp, #16]
  20206c:	685b      	ldr	r3, [r3, #4]
  20206e:	9304      	str	r3, [sp, #16]
    while (qp != rqp) {
  202070:	9a04      	ldr	r2, [sp, #16]
  202072:	9b02      	ldr	r3, [sp, #8]
  202074:	429a      	cmp	r2, r3
  202076:	d1f5      	bne.n	202064 <chSysIntegrityCheckI+0xe4>
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
  202078:	9b07      	ldr	r3, [sp, #28]
  20207a:	2b00      	cmp	r3, #0
  20207c:	d001      	beq.n	202082 <chSysIntegrityCheckI+0x102>
      return true;
  20207e:	2301      	movs	r3, #1
  202080:	e000      	b.n	202084 <chSysIntegrityCheckI+0x104>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
  202082:	2300      	movs	r3, #0
}
  202084:	4618      	mov	r0, r3
  202086:	b008      	add	sp, #32
  202088:	4770      	bx	lr
  20208a:	bf00      	nop
  20208c:	20000890 	.word	0x20000890

00202090 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
  202090:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
  202092:	f000 fb05 	bl	2026a0 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
  202096:	bf00      	nop
  202098:	bd08      	pop	{r3, pc}
  20209a:	bf00      	nop
  20209c:	0000      	movs	r0, r0
	...

002020a0 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
  2020a0:	b500      	push	{lr}
  2020a2:	b087      	sub	sp, #28
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
  2020a4:	f3ef 8311 	mrs	r3, BASEPRI
  2020a8:	9303      	str	r3, [sp, #12]
  return(result);
  2020aa:	9b03      	ldr	r3, [sp, #12]
  sts = (syssts_t)__get_BASEPRI();
  2020ac:	9302      	str	r3, [sp, #8]
  return sts;
  2020ae:	9b02      	ldr	r3, [sp, #8]

  syssts_t sts = port_get_lock_status();
  2020b0:	9305      	str	r3, [sp, #20]
  2020b2:	9b05      	ldr	r3, [sp, #20]
  2020b4:	9304      	str	r3, [sp, #16]
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
  2020b6:	9b04      	ldr	r3, [sp, #16]
  2020b8:	2b00      	cmp	r3, #0
  2020ba:	bf0c      	ite	eq
  2020bc:	2301      	moveq	r3, #1
  2020be:	2300      	movne	r3, #0
  2020c0:	b2db      	uxtb	r3, r3
  if (!port_is_locked(sts)) {
  2020c2:	2b00      	cmp	r3, #0
  2020c4:	d011      	beq.n	2020ea <chSysGetStatusAndLockX+0x4a>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
  2020c6:	f3ef 8305 	mrs	r3, IPSR
  2020ca:	9301      	str	r3, [sp, #4]
  return(result);
  2020cc:	9b01      	ldr	r3, [sp, #4]
  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
  2020ce:	f3c3 0308 	ubfx	r3, r3, #0, #9
  2020d2:	2b00      	cmp	r3, #0
  2020d4:	bf14      	ite	ne
  2020d6:	2301      	movne	r3, #1
  2020d8:	2300      	moveq	r3, #0
  2020da:	b2db      	uxtb	r3, r3
    if (port_is_isr_context()) {
  2020dc:	2b00      	cmp	r3, #0
  2020de:	d002      	beq.n	2020e6 <chSysGetStatusAndLockX+0x46>
      chSysLockFromISR();
  2020e0:	f7ff feee 	bl	201ec0 <chSysLockFromISR.lto_priv.2>
  2020e4:	e001      	b.n	2020ea <chSysGetStatusAndLockX+0x4a>
    }
    else {
      chSysLock();
  2020e6:	f7ff fecb 	bl	201e80 <chSysLock.lto_priv.3>
    }
  }
  return sts;
  2020ea:	9b05      	ldr	r3, [sp, #20]
}
  2020ec:	4618      	mov	r0, r3
  2020ee:	b007      	add	sp, #28
  2020f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00202100 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
  202100:	b500      	push	{lr}
  202102:	b085      	sub	sp, #20
  202104:	9001      	str	r0, [sp, #4]
  202106:	9b01      	ldr	r3, [sp, #4]
  202108:	9303      	str	r3, [sp, #12]
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
  20210a:	9b03      	ldr	r3, [sp, #12]
  20210c:	2b00      	cmp	r3, #0
  20210e:	bf0c      	ite	eq
  202110:	2301      	moveq	r3, #1
  202112:	2300      	movne	r3, #0
  202114:	b2db      	uxtb	r3, r3

  if (!port_is_locked(sts)) {
  202116:	2b00      	cmp	r3, #0
  202118:	d013      	beq.n	202142 <chSysRestoreStatusX+0x42>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
  20211a:	f3ef 8305 	mrs	r3, IPSR
  20211e:	9302      	str	r3, [sp, #8]
  return(result);
  202120:	9b02      	ldr	r3, [sp, #8]
  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
  202122:	f3c3 0308 	ubfx	r3, r3, #0, #9
  202126:	2b00      	cmp	r3, #0
  202128:	bf14      	ite	ne
  20212a:	2301      	movne	r3, #1
  20212c:	2300      	moveq	r3, #0
  20212e:	b2db      	uxtb	r3, r3
    if (port_is_isr_context()) {
  202130:	2b00      	cmp	r3, #0
  202132:	d002      	beq.n	20213a <chSysRestoreStatusX+0x3a>
      chSysUnlockFromISR();
  202134:	f7ff fed4 	bl	201ee0 <chSysUnlockFromISR.lto_priv.2>
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
  202138:	e003      	b.n	202142 <chSysRestoreStatusX+0x42>
      chSchRescheduleS();
  20213a:	f000 fd99 	bl	202c70 <chSchRescheduleS>
      chSysUnlock();
  20213e:	f7ff feaf 	bl	201ea0 <chSysUnlock.lto_priv.3>
}
  202142:	bf00      	nop
  202144:	b005      	add	sp, #20
  202146:	f85d fb04 	ldr.w	pc, [sp], #4
  20214a:	bf00      	nop
  20214c:	0000      	movs	r0, r0
	...

00202150 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
  202150:	b082      	sub	sp, #8
  202152:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
  202154:	4b04      	ldr	r3, [pc, #16]	@ (202168 <chRFCUCollectFaultsI+0x18>)
  202156:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
  202158:	9b01      	ldr	r3, [sp, #4]
  20215a:	4313      	orrs	r3, r2
  20215c:	4a02      	ldr	r2, [pc, #8]	@ (202168 <chRFCUCollectFaultsI+0x18>)
  20215e:	63d3      	str	r3, [r2, #60]	@ 0x3c
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
  202160:	bf00      	nop
  202162:	b002      	add	sp, #8
  202164:	4770      	bx	lr
  202166:	bf00      	nop
  202168:	20000890 	.word	0x20000890
  20216c:	00000000 	.word	0x00000000

00202170 <chTimeAddX.lto_priv.0>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
  202170:	b082      	sub	sp, #8
  202172:	9001      	str	r0, [sp, #4]
  202174:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
  202176:	9a01      	ldr	r2, [sp, #4]
  202178:	9b00      	ldr	r3, [sp, #0]
  20217a:	4413      	add	r3, r2
}
  20217c:	4618      	mov	r0, r3
  20217e:	b002      	add	sp, #8
  202180:	4770      	bx	lr
  202182:	bf00      	nop
	...

00202190 <chTimeDiffX.lto_priv.0>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
  202190:	b082      	sub	sp, #8
  202192:	9001      	str	r0, [sp, #4]
  202194:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
  202196:	9a00      	ldr	r2, [sp, #0]
  202198:	9b01      	ldr	r3, [sp, #4]
  20219a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
  20219c:	4618      	mov	r0, r3
  20219e:	b002      	add	sp, #8
  2021a0:	4770      	bx	lr
  2021a2:	bf00      	nop
	...

002021b0 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
  2021b0:	b082      	sub	sp, #8
  2021b2:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
  2021b4:	9b01      	ldr	r3, [sp, #4]
  2021b6:	681b      	ldr	r3, [r3, #0]
  2021b8:	9a01      	ldr	r2, [sp, #4]
  2021ba:	429a      	cmp	r2, r3
  2021bc:	bf0c      	ite	eq
  2021be:	2301      	moveq	r3, #1
  2021c0:	2300      	movne	r3, #0
  2021c2:	b2db      	uxtb	r3, r3
}
  2021c4:	4618      	mov	r0, r3
  2021c6:	b002      	add	sp, #8
  2021c8:	4770      	bx	lr
  2021ca:	bf00      	nop
  2021cc:	0000      	movs	r0, r0
	...

002021d0 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
  2021d0:	b082      	sub	sp, #8
  2021d2:	9001      	str	r0, [sp, #4]
  2021d4:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
  2021d6:	9b01      	ldr	r3, [sp, #4]
  2021d8:	681b      	ldr	r3, [r3, #0]
  2021da:	9a00      	ldr	r2, [sp, #0]
  2021dc:	429a      	cmp	r2, r3
  2021de:	bf0c      	ite	eq
  2021e0:	2301      	moveq	r3, #1
  2021e2:	2300      	movne	r3, #0
  2021e4:	b2db      	uxtb	r3, r3
}
  2021e6:	4618      	mov	r0, r3
  2021e8:	b002      	add	sp, #8
  2021ea:	4770      	bx	lr
  2021ec:	0000      	movs	r0, r0
	...

002021f0 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
  2021f0:	b084      	sub	sp, #16
  2021f2:	9003      	str	r0, [sp, #12]
  2021f4:	9102      	str	r1, [sp, #8]
  2021f6:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
  2021f8:	9b02      	ldr	r3, [sp, #8]
  2021fa:	9a01      	ldr	r2, [sp, #4]
  2021fc:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
  2021fe:	9b02      	ldr	r3, [sp, #8]
  202200:	9a03      	ldr	r2, [sp, #12]
  202202:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
  202204:	9b02      	ldr	r3, [sp, #8]
  202206:	685b      	ldr	r3, [r3, #4]
  202208:	681a      	ldr	r2, [r3, #0]
  20220a:	9b02      	ldr	r3, [sp, #8]
  20220c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
  20220e:	9b02      	ldr	r3, [sp, #8]
  202210:	681b      	ldr	r3, [r3, #0]
  202212:	9a02      	ldr	r2, [sp, #8]
  202214:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
  202216:	9b03      	ldr	r3, [sp, #12]
  202218:	9a02      	ldr	r2, [sp, #8]
  20221a:	601a      	str	r2, [r3, #0]
}
  20221c:	bf00      	nop
  20221e:	b004      	add	sp, #16
  202220:	4770      	bx	lr
  202222:	bf00      	nop
	...

00202230 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
  202230:	b084      	sub	sp, #16
  202232:	9003      	str	r0, [sp, #12]
  202234:	9102      	str	r1, [sp, #8]
  202236:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
  202238:	9b02      	ldr	r3, [sp, #8]
  20223a:	9a01      	ldr	r2, [sp, #4]
  20223c:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
  20223e:	9b02      	ldr	r3, [sp, #8]
  202240:	9a03      	ldr	r2, [sp, #12]
  202242:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
  202244:	9b02      	ldr	r3, [sp, #8]
  202246:	681b      	ldr	r3, [r3, #0]
  202248:	685a      	ldr	r2, [r3, #4]
  20224a:	9b02      	ldr	r3, [sp, #8]
  20224c:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
  20224e:	9b02      	ldr	r3, [sp, #8]
  202250:	685b      	ldr	r3, [r3, #4]
  202252:	9a02      	ldr	r2, [sp, #8]
  202254:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
  202256:	9b03      	ldr	r3, [sp, #12]
  202258:	9a02      	ldr	r2, [sp, #8]
  20225a:	605a      	str	r2, [r3, #4]
}
  20225c:	bf00      	nop
  20225e:	b004      	add	sp, #16
  202260:	4770      	bx	lr
  202262:	bf00      	nop
	...

00202270 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
  202270:	b500      	push	{lr}
  202272:	b087      	sub	sp, #28
  202274:	9003      	str	r0, [sp, #12]
  202276:	9102      	str	r1, [sp, #8]
  202278:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  20227a:	9b03      	ldr	r3, [sp, #12]
  20227c:	681b      	ldr	r3, [r3, #0]
  20227e:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
  202280:	e007      	b.n	202292 <ch_dlist_insert+0x22>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
  202282:	9b05      	ldr	r3, [sp, #20]
  202284:	689b      	ldr	r3, [r3, #8]
  202286:	9a01      	ldr	r2, [sp, #4]
  202288:	1ad3      	subs	r3, r2, r3
  20228a:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
  20228c:	9b05      	ldr	r3, [sp, #20]
  20228e:	681b      	ldr	r3, [r3, #0]
  202290:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
  202292:	9b05      	ldr	r3, [sp, #20]
  202294:	689b      	ldr	r3, [r3, #8]
  202296:	9a01      	ldr	r2, [sp, #4]
  202298:	429a      	cmp	r2, r3
  20229a:	bf8c      	ite	hi
  20229c:	2301      	movhi	r3, #1
  20229e:	2300      	movls	r3, #0
  2022a0:	b2db      	uxtb	r3, r3
  2022a2:	2b00      	cmp	r3, #0
  2022a4:	d1ed      	bne.n	202282 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
  2022a6:	9a01      	ldr	r2, [sp, #4]
  2022a8:	9902      	ldr	r1, [sp, #8]
  2022aa:	9805      	ldr	r0, [sp, #20]
  2022ac:	f7ff ffc0 	bl	202230 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
  2022b0:	9b05      	ldr	r3, [sp, #20]
  2022b2:	689a      	ldr	r2, [r3, #8]
  2022b4:	9b01      	ldr	r3, [sp, #4]
  2022b6:	1ad2      	subs	r2, r2, r3
  2022b8:	9b05      	ldr	r3, [sp, #20]
  2022ba:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
  2022bc:	9b03      	ldr	r3, [sp, #12]
  2022be:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  2022c2:	609a      	str	r2, [r3, #8]
}
  2022c4:	bf00      	nop
  2022c6:	b007      	add	sp, #28
  2022c8:	f85d fb04 	ldr.w	pc, [sp], #4
  2022cc:	0000      	movs	r0, r0
	...

002022d0 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
  2022d0:	b084      	sub	sp, #16
  2022d2:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
  2022d4:	9b01      	ldr	r3, [sp, #4]
  2022d6:	681b      	ldr	r3, [r3, #0]
  2022d8:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
  2022da:	9b03      	ldr	r3, [sp, #12]
  2022dc:	681a      	ldr	r2, [r3, #0]
  2022de:	9b01      	ldr	r3, [sp, #4]
  2022e0:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
  2022e2:	9b01      	ldr	r3, [sp, #4]
  2022e4:	681b      	ldr	r3, [r3, #0]
  2022e6:	9a01      	ldr	r2, [sp, #4]
  2022e8:	605a      	str	r2, [r3, #4]

  return dlp;
  2022ea:	9b03      	ldr	r3, [sp, #12]
}
  2022ec:	4618      	mov	r0, r3
  2022ee:	b004      	add	sp, #16
  2022f0:	4770      	bx	lr
  2022f2:	bf00      	nop
	...

00202300 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
  202300:	b082      	sub	sp, #8
  202302:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
  202304:	9b01      	ldr	r3, [sp, #4]
  202306:	685b      	ldr	r3, [r3, #4]
  202308:	9a01      	ldr	r2, [sp, #4]
  20230a:	6812      	ldr	r2, [r2, #0]
  20230c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
  20230e:	9b01      	ldr	r3, [sp, #4]
  202310:	681b      	ldr	r3, [r3, #0]
  202312:	9a01      	ldr	r2, [sp, #4]
  202314:	6852      	ldr	r2, [r2, #4]
  202316:	605a      	str	r2, [r3, #4]

  return dlp;
  202318:	9b01      	ldr	r3, [sp, #4]
}
  20231a:	4618      	mov	r0, r3
  20231c:	b002      	add	sp, #8
  20231e:	4770      	bx	lr

00202320 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
  202320:	b500      	push	{lr}
  202322:	b083      	sub	sp, #12
  202324:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
  202326:	9801      	ldr	r0, [sp, #4]
  202328:	f7fe fae2 	bl	2008f0 <stStartAlarm>
}
  20232c:	bf00      	nop
  20232e:	b003      	add	sp, #12
  202330:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00202340 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
  202340:	b508      	push	{r3, lr}

  stStopAlarm();
  202342:	f7fe fae5 	bl	200910 <stStopAlarm>
}
  202346:	bf00      	nop
  202348:	bd08      	pop	{r3, pc}
  20234a:	bf00      	nop
  20234c:	0000      	movs	r0, r0
	...

00202350 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
  202350:	b500      	push	{lr}
  202352:	b083      	sub	sp, #12
  202354:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
  202356:	9801      	ldr	r0, [sp, #4]
  202358:	f7fe fae2 	bl	200920 <stSetAlarm>
}
  20235c:	bf00      	nop
  20235e:	b003      	add	sp, #12
  202360:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00202370 <port_timer_get_time.lto_priv.0>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
  202370:	b508      	push	{r3, lr}

  return stGetCounter();
  202372:	f7fe fab5 	bl	2008e0 <stGetCounter>
  202376:	4603      	mov	r3, r0
}
  202378:	4618      	mov	r0, r3
  20237a:	bd08      	pop	{r3, pc}
  20237c:	0000      	movs	r0, r0
	...

00202380 <chSysLockFromISR.lto_priv.3>:
static inline void chSysLockFromISR(void) {
  202380:	b082      	sub	sp, #8
  202382:	2330      	movs	r3, #48	@ 0x30
  202384:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202386:	9b01      	ldr	r3, [sp, #4]
  202388:	f383 8811 	msr	BASEPRI, r3
}
  20238c:	bf00      	nop
}
  20238e:	bf00      	nop
}
  202390:	bf00      	nop
}
  202392:	bf00      	nop
  202394:	b002      	add	sp, #8
  202396:	4770      	bx	lr
	...

002023a0 <chSysUnlockFromISR.lto_priv.3>:
static inline void chSysUnlockFromISR(void) {
  2023a0:	b082      	sub	sp, #8
  2023a2:	2300      	movs	r3, #0
  2023a4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2023a6:	9b01      	ldr	r3, [sp, #4]
  2023a8:	f383 8811 	msr	BASEPRI, r3
}
  2023ac:	bf00      	nop
}
  2023ae:	bf00      	nop
}
  2023b0:	bf00      	nop
}
  2023b2:	bf00      	nop
  2023b4:	b002      	add	sp, #8
  2023b6:	4770      	bx	lr
	...

002023c0 <chVTGetSystemTimeX.lto_priv.0>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
  2023c0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
  2023c2:	f7ff ffd5 	bl	202370 <port_timer_get_time.lto_priv.0>
  2023c6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  2023c8:	4618      	mov	r0, r3
  2023ca:	bd08      	pop	{r3, pc}
  2023cc:	0000      	movs	r0, r0
	...

002023d0 <vt_set_alarm>:
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(virtual_timers_list_t *vtlp,
                         systime_t now,
                         sysinterval_t delay) {
  2023d0:	b500      	push	{lr}
  2023d2:	b089      	sub	sp, #36	@ 0x24
  2023d4:	9003      	str	r0, [sp, #12]
  2023d6:	9102      	str	r1, [sp, #8]
  2023d8:	9201      	str	r2, [sp, #4]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = vtlp->lastdelta;
  2023da:	9b03      	ldr	r3, [sp, #12]
  2023dc:	691b      	ldr	r3, [r3, #16]
  2023de:	9307      	str	r3, [sp, #28]

  if (delay < currdelta) {
  2023e0:	9a01      	ldr	r2, [sp, #4]
  2023e2:	9b07      	ldr	r3, [sp, #28]
  2023e4:	429a      	cmp	r2, r3
  2023e6:	d201      	bcs.n	2023ec <vt_set_alarm+0x1c>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
  2023e8:	9b07      	ldr	r3, [sp, #28]
  2023ea:	9301      	str	r3, [sp, #4]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
  2023ec:	9901      	ldr	r1, [sp, #4]
  2023ee:	9802      	ldr	r0, [sp, #8]
  2023f0:	f7ff febe 	bl	202170 <chTimeAddX.lto_priv.0>
  2023f4:	4603      	mov	r3, r0
  2023f6:	4618      	mov	r0, r3
  2023f8:	f7ff ffaa 	bl	202350 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
  2023fc:	f7ff ffe0 	bl	2023c0 <chVTGetSystemTimeX.lto_priv.0>
  202400:	9006      	str	r0, [sp, #24]
    nowdelta = chTimeDiffX(now, newnow);
  202402:	9906      	ldr	r1, [sp, #24]
  202404:	9802      	ldr	r0, [sp, #8]
  202406:	f7ff fec3 	bl	202190 <chTimeDiffX.lto_priv.0>
  20240a:	9005      	str	r0, [sp, #20]
    if (likely(nowdelta < delay)) {
  20240c:	9a05      	ldr	r2, [sp, #20]
  20240e:	9b01      	ldr	r3, [sp, #4]
  202410:	429a      	cmp	r2, r3
  202412:	bf34      	ite	cc
  202414:	2301      	movcc	r3, #1
  202416:	2300      	movcs	r3, #0
  202418:	b2db      	uxtb	r3, r3
  20241a:	2b00      	cmp	r3, #0
  20241c:	d107      	bne.n	20242e <vt_set_alarm+0x5e>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
  20241e:	9b07      	ldr	r3, [sp, #28]
  202420:	3301      	adds	r3, #1
  202422:	9307      	str	r3, [sp, #28]

    /* Current time becomes the new "base" time.*/
    now = newnow;
  202424:	9b06      	ldr	r3, [sp, #24]
  202426:	9302      	str	r3, [sp, #8]
    delay = currdelta;
  202428:	9b07      	ldr	r3, [sp, #28]
  20242a:	9301      	str	r3, [sp, #4]
  while (true) {
  20242c:	e7de      	b.n	2023ec <vt_set_alarm+0x1c>
      break;
  20242e:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > vtlp->lastdelta) {
  202430:	9b03      	ldr	r3, [sp, #12]
  202432:	691b      	ldr	r3, [r3, #16]
  202434:	9a07      	ldr	r2, [sp, #28]
  202436:	429a      	cmp	r2, r3
  202438:	d905      	bls.n	202446 <vt_set_alarm+0x76>
    vtlp->lastdelta = currdelta;
  20243a:	9b03      	ldr	r3, [sp, #12]
  20243c:	9a07      	ldr	r2, [sp, #28]
  20243e:	611a      	str	r2, [r3, #16]
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
  202440:	2001      	movs	r0, #1
  202442:	f7ff fe85 	bl	202150 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
  202446:	bf00      	nop
  202448:	b009      	add	sp, #36	@ 0x24
  20244a:	f85d fb04 	ldr.w	pc, [sp], #4
  20244e:	bf00      	nop

00202450 <vt_insert_first>:
 * @param[in] delay     delay over @p now
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
  202450:	b500      	push	{lr}
  202452:	b087      	sub	sp, #28
  202454:	9003      	str	r0, [sp, #12]
  202456:	9102      	str	r1, [sp, #8]
  202458:	9201      	str	r2, [sp, #4]
  20245a:	9300      	str	r3, [sp, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
  20245c:	9b03      	ldr	r3, [sp, #12]
  20245e:	9a01      	ldr	r2, [sp, #4]
  202460:	60da      	str	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
  202462:	9b03      	ldr	r3, [sp, #12]
  202464:	9902      	ldr	r1, [sp, #8]
  202466:	9a00      	ldr	r2, [sp, #0]
  202468:	4618      	mov	r0, r3
  20246a:	f7ff fec1 	bl	2021f0 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = vtlp->lastdelta;
  20246e:	9b03      	ldr	r3, [sp, #12]
  202470:	691b      	ldr	r3, [r3, #16]
  202472:	9305      	str	r3, [sp, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
  202474:	9a00      	ldr	r2, [sp, #0]
  202476:	9b05      	ldr	r3, [sp, #20]
  202478:	429a      	cmp	r2, r3
  20247a:	d201      	bcs.n	202480 <vt_insert_first+0x30>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
  20247c:	9b05      	ldr	r3, [sp, #20]
  20247e:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
  202480:	9b03      	ldr	r3, [sp, #12]
  202482:	68db      	ldr	r3, [r3, #12]
  202484:	9900      	ldr	r1, [sp, #0]
  202486:	4618      	mov	r0, r3
  202488:	f7ff fe72 	bl	202170 <chTimeAddX.lto_priv.0>
  20248c:	4603      	mov	r3, r0
  20248e:	4618      	mov	r0, r3
  202490:	f7ff ff46 	bl	202320 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
  202494:	f7ff ff94 	bl	2023c0 <chVTGetSystemTimeX.lto_priv.0>
  202498:	9004      	str	r0, [sp, #16]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
  20249a:	9904      	ldr	r1, [sp, #16]
  20249c:	9801      	ldr	r0, [sp, #4]
  20249e:	f7ff fe77 	bl	202190 <chTimeDiffX.lto_priv.0>
  2024a2:	4602      	mov	r2, r0
  2024a4:	9b00      	ldr	r3, [sp, #0]
  2024a6:	4293      	cmp	r3, r2
  2024a8:	bf8c      	ite	hi
  2024aa:	2301      	movhi	r3, #1
  2024ac:	2300      	movls	r3, #0
  2024ae:	b2db      	uxtb	r3, r3
  2024b0:	2b00      	cmp	r3, #0
  2024b2:	d10f      	bne.n	2024d4 <vt_insert_first+0x84>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
  2024b4:	9b05      	ldr	r3, [sp, #20]
  2024b6:	3301      	adds	r3, #1
  2024b8:	9305      	str	r3, [sp, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
  2024ba:	9905      	ldr	r1, [sp, #20]
  2024bc:	9801      	ldr	r0, [sp, #4]
  2024be:	f7ff fe57 	bl	202170 <chTimeAddX.lto_priv.0>
  2024c2:	4603      	mov	r3, r0
  2024c4:	4618      	mov	r0, r3
  2024c6:	f7ff ff43 	bl	202350 <port_timer_set_alarm>

    /* Current time becomes the new "base" time.*/
    now = newnow;
  2024ca:	9b04      	ldr	r3, [sp, #16]
  2024cc:	9301      	str	r3, [sp, #4]
    delay = currdelta;
  2024ce:	9b05      	ldr	r3, [sp, #20]
  2024d0:	9300      	str	r3, [sp, #0]
  while (true) {
  2024d2:	e7df      	b.n	202494 <vt_insert_first+0x44>
      break;
  2024d4:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > vtlp->lastdelta) {
  2024d6:	9b03      	ldr	r3, [sp, #12]
  2024d8:	691b      	ldr	r3, [r3, #16]
  2024da:	9a05      	ldr	r2, [sp, #20]
  2024dc:	429a      	cmp	r2, r3
  2024de:	d905      	bls.n	2024ec <vt_insert_first+0x9c>
    vtlp->lastdelta = currdelta;
  2024e0:	9b03      	ldr	r3, [sp, #12]
  2024e2:	9a05      	ldr	r2, [sp, #20]
  2024e4:	611a      	str	r2, [r3, #16]
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
  2024e6:	2001      	movs	r0, #1
  2024e8:	f7ff fe32 	bl	202150 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
  2024ec:	bf00      	nop
  2024ee:	b007      	add	sp, #28
  2024f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00202500 <vt_enqueue>:
 * @param[in] vtp       pointer to a @p virtual_timer_t object
 * @param[in] delay     delay over current system time
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
  202500:	b500      	push	{lr}
  202502:	b089      	sub	sp, #36	@ 0x24
  202504:	9003      	str	r0, [sp, #12]
  202506:	9102      	str	r1, [sp, #8]
  202508:	9201      	str	r2, [sp, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
  20250a:	f7ff ff59 	bl	2023c0 <chVTGetSystemTimeX.lto_priv.0>
  20250e:	9006      	str	r0, [sp, #24]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
  202510:	9b03      	ldr	r3, [sp, #12]
  202512:	4618      	mov	r0, r3
  202514:	f7ff fe4c 	bl	2021b0 <ch_dlist_isempty>
  202518:	4603      	mov	r3, r0
  20251a:	2b00      	cmp	r3, #0
  20251c:	d006      	beq.n	20252c <vt_enqueue+0x2c>

      vt_insert_first(vtlp, vtp, now, delay);
  20251e:	9b01      	ldr	r3, [sp, #4]
  202520:	9a06      	ldr	r2, [sp, #24]
  202522:	9902      	ldr	r1, [sp, #8]
  202524:	9803      	ldr	r0, [sp, #12]
  202526:	f7ff ff93 	bl	202450 <vt_insert_first>

      return;
  20252a:	e021      	b.n	202570 <vt_enqueue+0x70>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
  20252c:	9b03      	ldr	r3, [sp, #12]
  20252e:	68db      	ldr	r3, [r3, #12]
  202530:	9906      	ldr	r1, [sp, #24]
  202532:	4618      	mov	r0, r3
  202534:	f7ff fe2c 	bl	202190 <chTimeDiffX.lto_priv.0>
  202538:	9005      	str	r0, [sp, #20]
    delta    = nowdelta + delay;
  20253a:	9a05      	ldr	r2, [sp, #20]
  20253c:	9b01      	ldr	r3, [sp, #4]
  20253e:	4413      	add	r3, r2
  202540:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
  202542:	9a07      	ldr	r2, [sp, #28]
  202544:	9b05      	ldr	r3, [sp, #20]
  202546:	429a      	cmp	r2, r3
  202548:	d201      	bcs.n	20254e <vt_enqueue+0x4e>
      delta = delay;
  20254a:	9b01      	ldr	r3, [sp, #4]
  20254c:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
  20254e:	9b03      	ldr	r3, [sp, #12]
  202550:	681b      	ldr	r3, [r3, #0]
  202552:	689b      	ldr	r3, [r3, #8]
  202554:	9a07      	ldr	r2, [sp, #28]
  202556:	429a      	cmp	r2, r3
  202558:	d204      	bcs.n	202564 <vt_enqueue+0x64>

      vt_set_alarm(vtlp, now, delay);
  20255a:	9a01      	ldr	r2, [sp, #4]
  20255c:	9906      	ldr	r1, [sp, #24]
  20255e:	9803      	ldr	r0, [sp, #12]
  202560:	f7ff ff36 	bl	2023d0 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
  202564:	9b03      	ldr	r3, [sp, #12]
  202566:	9902      	ldr	r1, [sp, #8]
  202568:	9a07      	ldr	r2, [sp, #28]
  20256a:	4618      	mov	r0, r3
  20256c:	f7ff fe80 	bl	202270 <ch_dlist_insert>
}
  202570:	b009      	add	sp, #36	@ 0x24
  202572:	f85d fb04 	ldr.w	pc, [sp], #4
  202576:	bf00      	nop
	...

00202580 <chVTObjectInit>:
 *
 * @param[out] vtp      pointer to a @p virtual_timer_t object
 *
 * @init
 */
void chVTObjectInit(virtual_timer_t *vtp) {
  202580:	b082      	sub	sp, #8
  202582:	9001      	str	r0, [sp, #4]

  vtp->dlist.next = NULL;
  202584:	9b01      	ldr	r3, [sp, #4]
  202586:	2200      	movs	r2, #0
  202588:	601a      	str	r2, [r3, #0]
}
  20258a:	bf00      	nop
  20258c:	b002      	add	sp, #8
  20258e:	4770      	bx	lr

00202590 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
  202590:	b500      	push	{lr}
  202592:	b087      	sub	sp, #28
  202594:	9003      	str	r0, [sp, #12]
  202596:	9102      	str	r1, [sp, #8]
  202598:	9201      	str	r2, [sp, #4]
  20259a:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
  20259c:	4b09      	ldr	r3, [pc, #36]	@ (2025c4 <chVTDoSetI+0x34>)
  20259e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  /* Timer initialization.*/
  vtp->par     = par;
  2025a0:	9b03      	ldr	r3, [sp, #12]
  2025a2:	9a00      	ldr	r2, [sp, #0]
  2025a4:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
  2025a6:	9b03      	ldr	r3, [sp, #12]
  2025a8:	9a01      	ldr	r2, [sp, #4]
  2025aa:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
  2025ac:	9b03      	ldr	r3, [sp, #12]
  2025ae:	2200      	movs	r2, #0
  2025b0:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
  2025b2:	9a02      	ldr	r2, [sp, #8]
  2025b4:	9903      	ldr	r1, [sp, #12]
  2025b6:	9805      	ldr	r0, [sp, #20]
  2025b8:	f7ff ffa2 	bl	202500 <vt_enqueue>
}
  2025bc:	bf00      	nop
  2025be:	b007      	add	sp, #28
  2025c0:	f85d fb04 	ldr.w	pc, [sp], #4
  2025c4:	200008a0 	.word	0x200008a0
	...

002025d0 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t object
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
  2025d0:	b500      	push	{lr}
  2025d2:	b087      	sub	sp, #28
  2025d4:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
  2025d6:	4b2e      	ldr	r3, [pc, #184]	@ (202690 <chVTDoResetI+0xc0>)
  2025d8:	9305      	str	r3, [sp, #20]
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
  2025da:	9b05      	ldr	r3, [sp, #20]
  2025dc:	9a01      	ldr	r2, [sp, #4]
  2025de:	4611      	mov	r1, r2
  2025e0:	4618      	mov	r0, r3
  2025e2:	f7ff fdf5 	bl	2021d0 <ch_dlist_isfirst>
  2025e6:	4603      	mov	r3, r0
  2025e8:	f083 0301 	eor.w	r3, r3, #1
  2025ec:	b2db      	uxtb	r3, r3
  2025ee:	2b00      	cmp	r3, #0
  2025f0:	d014      	beq.n	20261c <chVTDoResetI+0x4c>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
  2025f2:	9b01      	ldr	r3, [sp, #4]
  2025f4:	4618      	mov	r0, r3
  2025f6:	f7ff fe83 	bl	202300 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
  2025fa:	9b01      	ldr	r3, [sp, #4]
  2025fc:	681b      	ldr	r3, [r3, #0]
  2025fe:	6899      	ldr	r1, [r3, #8]
  202600:	9b01      	ldr	r3, [sp, #4]
  202602:	689a      	ldr	r2, [r3, #8]
  202604:	9b01      	ldr	r3, [sp, #4]
  202606:	681b      	ldr	r3, [r3, #0]
  202608:	440a      	add	r2, r1
  20260a:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
  20260c:	9b01      	ldr	r3, [sp, #4]
  20260e:	2200      	movs	r2, #0
  202610:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
  202612:	9b05      	ldr	r3, [sp, #20]
  202614:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  202618:	609a      	str	r2, [r3, #8]

    return;
  20261a:	e036      	b.n	20268a <chVTDoResetI+0xba>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
  20261c:	9b05      	ldr	r3, [sp, #20]
  20261e:	4618      	mov	r0, r3
  202620:	f7ff fe56 	bl	2022d0 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
  202624:	9b01      	ldr	r3, [sp, #4]
  202626:	2200      	movs	r2, #0
  202628:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
  20262a:	9b05      	ldr	r3, [sp, #20]
  20262c:	4618      	mov	r0, r3
  20262e:	f7ff fdbf 	bl	2021b0 <ch_dlist_isempty>
  202632:	4603      	mov	r3, r0
  202634:	2b00      	cmp	r3, #0
  202636:	d002      	beq.n	20263e <chVTDoResetI+0x6e>

    port_timer_stop_alarm();
  202638:	f7ff fe82 	bl	202340 <port_timer_stop_alarm>

    return;
  20263c:	e025      	b.n	20268a <chVTDoResetI+0xba>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
  20263e:	9b05      	ldr	r3, [sp, #20]
  202640:	681b      	ldr	r3, [r3, #0]
  202642:	6899      	ldr	r1, [r3, #8]
  202644:	9b01      	ldr	r3, [sp, #4]
  202646:	689a      	ldr	r2, [r3, #8]
  202648:	9b05      	ldr	r3, [sp, #20]
  20264a:	681b      	ldr	r3, [r3, #0]
  20264c:	440a      	add	r2, r1
  20264e:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
  202650:	f7ff feb6 	bl	2023c0 <chVTGetSystemTimeX.lto_priv.0>
  202654:	9004      	str	r0, [sp, #16]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
  202656:	9b05      	ldr	r3, [sp, #20]
  202658:	68db      	ldr	r3, [r3, #12]
  20265a:	9904      	ldr	r1, [sp, #16]
  20265c:	4618      	mov	r0, r3
  20265e:	f7ff fd97 	bl	202190 <chTimeDiffX.lto_priv.0>
  202662:	9003      	str	r0, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
  202664:	9b05      	ldr	r3, [sp, #20]
  202666:	681b      	ldr	r3, [r3, #0]
  202668:	689b      	ldr	r3, [r3, #8]
  20266a:	9a03      	ldr	r2, [sp, #12]
  20266c:	429a      	cmp	r2, r3
  20266e:	d20b      	bcs.n	202688 <chVTDoResetI+0xb8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
  202670:	9b05      	ldr	r3, [sp, #20]
  202672:	681b      	ldr	r3, [r3, #0]
  202674:	689a      	ldr	r2, [r3, #8]
  202676:	9b03      	ldr	r3, [sp, #12]
  202678:	1ad3      	subs	r3, r2, r3
  20267a:	9302      	str	r3, [sp, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(vtlp, now, delta);
  20267c:	9a02      	ldr	r2, [sp, #8]
  20267e:	9904      	ldr	r1, [sp, #16]
  202680:	9805      	ldr	r0, [sp, #20]
  202682:	f7ff fea5 	bl	2023d0 <vt_set_alarm>
  202686:	e000      	b.n	20268a <chVTDoResetI+0xba>
    return;
  202688:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  20268a:	b007      	add	sp, #28
  20268c:	f85d fb04 	ldr.w	pc, [sp], #4
  202690:	200008a0 	.word	0x200008a0
	...

002026a0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
  2026a0:	b500      	push	{lr}
  2026a2:	b089      	sub	sp, #36	@ 0x24
  virtual_timers_list_t *vtlp = &currcore->vtlist;
  2026a4:	4b4d      	ldr	r3, [pc, #308]	@ (2027dc <chVTDoTickI+0x13c>)
  2026a6:	9305      	str	r3, [sp, #20]
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
  2026a8:	9b05      	ldr	r3, [sp, #20]
  2026aa:	681b      	ldr	r3, [r3, #0]
  2026ac:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
  2026ae:	f7ff fe87 	bl	2023c0 <chVTGetSystemTimeX.lto_priv.0>
  2026b2:	9003      	str	r0, [sp, #12]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
  2026b4:	9b05      	ldr	r3, [sp, #20]
  2026b6:	68db      	ldr	r3, [r3, #12]
  2026b8:	9903      	ldr	r1, [sp, #12]
  2026ba:	4618      	mov	r0, r3
  2026bc:	f7ff fd68 	bl	202190 <chTimeDiffX.lto_priv.0>
  2026c0:	9002      	str	r0, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
  2026c2:	9b04      	ldr	r3, [sp, #16]
  2026c4:	689b      	ldr	r3, [r3, #8]
  2026c6:	9a02      	ldr	r2, [sp, #8]
  2026c8:	429a      	cmp	r2, r3
  2026ca:	d366      	bcc.n	20279a <chVTDoTickI+0xfa>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
  2026cc:	9b05      	ldr	r3, [sp, #20]
  2026ce:	68da      	ldr	r2, [r3, #12]
  2026d0:	9b04      	ldr	r3, [sp, #16]
  2026d2:	689b      	ldr	r3, [r3, #8]
  2026d4:	4619      	mov	r1, r3
  2026d6:	4610      	mov	r0, r2
  2026d8:	f7ff fd4a 	bl	202170 <chTimeAddX.lto_priv.0>
  2026dc:	9001      	str	r0, [sp, #4]
    vtlp->lasttime = lasttime;
  2026de:	9b05      	ldr	r3, [sp, #20]
  2026e0:	9a01      	ldr	r2, [sp, #4]
  2026e2:	60da      	str	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
  2026e4:	9b04      	ldr	r3, [sp, #16]
  2026e6:	4618      	mov	r0, r3
  2026e8:	f7ff fe0a 	bl	202300 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
  2026ec:	9b04      	ldr	r3, [sp, #16]
  2026ee:	2200      	movs	r2, #0
  2026f0:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
  2026f2:	9b05      	ldr	r3, [sp, #20]
  2026f4:	4618      	mov	r0, r3
  2026f6:	f7ff fd5b 	bl	2021b0 <ch_dlist_isempty>
  2026fa:	4603      	mov	r3, r0
  2026fc:	2b00      	cmp	r3, #0
  2026fe:	d001      	beq.n	202704 <chVTDoTickI+0x64>
      port_timer_stop_alarm();
  202700:	f7ff fe1e 	bl	202340 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
  202704:	f7ff fe4c 	bl	2023a0 <chSysUnlockFromISR.lto_priv.3>

    vtp->func(vtp, vtp->par);
  202708:	9b04      	ldr	r3, [sp, #16]
  20270a:	68db      	ldr	r3, [r3, #12]
  20270c:	9a04      	ldr	r2, [sp, #16]
  20270e:	6912      	ldr	r2, [r2, #16]
  202710:	4611      	mov	r1, r2
  202712:	9804      	ldr	r0, [sp, #16]
  202714:	4798      	blx	r3

    chSysLockFromISR();
  202716:	f7ff fe33 	bl	202380 <chSysLockFromISR.lto_priv.3>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
  20271a:	9b04      	ldr	r3, [sp, #16]
  20271c:	695b      	ldr	r3, [r3, #20]
  20271e:	2b00      	cmp	r3, #0
  202720:	bf14      	ite	ne
  202722:	2301      	movne	r3, #1
  202724:	2300      	moveq	r3, #0
  202726:	b2db      	uxtb	r3, r3
  202728:	2b00      	cmp	r3, #0
  20272a:	d0bd      	beq.n	2026a8 <chVTDoTickI+0x8>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
  20272c:	f7ff fe48 	bl	2023c0 <chVTGetSystemTimeX.lto_priv.0>
  202730:	9003      	str	r0, [sp, #12]
      nowdelta = chTimeDiffX(lasttime, now);
  202732:	9903      	ldr	r1, [sp, #12]
  202734:	9801      	ldr	r0, [sp, #4]
  202736:	f7ff fd2b 	bl	202190 <chTimeDiffX.lto_priv.0>
  20273a:	9002      	str	r0, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
  20273c:	9b04      	ldr	r3, [sp, #16]
  20273e:	695b      	ldr	r3, [r3, #20]
  202740:	9a02      	ldr	r2, [sp, #8]
  202742:	429a      	cmp	r2, r3
  202744:	d905      	bls.n	202752 <chVTDoTickI+0xb2>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
  202746:	2002      	movs	r0, #2
  202748:	f7ff fd02 	bl	202150 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
  20274c:	2300      	movs	r3, #0
  20274e:	9306      	str	r3, [sp, #24]
  202750:	e004      	b.n	20275c <chVTDoTickI+0xbc>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
  202752:	9b04      	ldr	r3, [sp, #16]
  202754:	695a      	ldr	r2, [r3, #20]
  202756:	9b02      	ldr	r3, [sp, #8]
  202758:	1ad3      	subs	r3, r2, r3
  20275a:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
  20275c:	9b05      	ldr	r3, [sp, #20]
  20275e:	4618      	mov	r0, r3
  202760:	f7ff fd26 	bl	2021b0 <ch_dlist_isempty>
  202764:	4603      	mov	r3, r0
  202766:	2b00      	cmp	r3, #0
  202768:	d006      	beq.n	202778 <chVTDoTickI+0xd8>

        vt_insert_first(vtlp, vtp, now, delay);
  20276a:	9b06      	ldr	r3, [sp, #24]
  20276c:	9a03      	ldr	r2, [sp, #12]
  20276e:	9904      	ldr	r1, [sp, #16]
  202770:	9805      	ldr	r0, [sp, #20]
  202772:	f7ff fe6d 	bl	202450 <vt_insert_first>

        return;
  202776:	e02d      	b.n	2027d4 <chVTDoTickI+0x134>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
  202778:	9a02      	ldr	r2, [sp, #8]
  20277a:	9b06      	ldr	r3, [sp, #24]
  20277c:	4413      	add	r3, r2
  20277e:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
  202780:	9a07      	ldr	r2, [sp, #28]
  202782:	9b02      	ldr	r3, [sp, #8]
  202784:	429a      	cmp	r2, r3
  202786:	d201      	bcs.n	20278c <chVTDoTickI+0xec>
        delta = delay;
  202788:	9b06      	ldr	r3, [sp, #24]
  20278a:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
  20278c:	9b05      	ldr	r3, [sp, #20]
  20278e:	9904      	ldr	r1, [sp, #16]
  202790:	9a07      	ldr	r2, [sp, #28]
  202792:	4618      	mov	r0, r3
  202794:	f7ff fd6c 	bl	202270 <ch_dlist_insert>
  while (true) {
  202798:	e786      	b.n	2026a8 <chVTDoTickI+0x8>
      break;
  20279a:	bf00      	nop
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
  20279c:	9b05      	ldr	r3, [sp, #20]
  20279e:	4618      	mov	r0, r3
  2027a0:	f7ff fd06 	bl	2021b0 <ch_dlist_isempty>
  2027a4:	4603      	mov	r3, r0
  2027a6:	2b00      	cmp	r3, #0
  2027a8:	d113      	bne.n	2027d2 <chVTDoTickI+0x132>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  2027aa:	9b05      	ldr	r3, [sp, #20]
  2027ac:	68da      	ldr	r2, [r3, #12]
  2027ae:	9b02      	ldr	r3, [sp, #8]
  2027b0:	441a      	add	r2, r3
  2027b2:	9b05      	ldr	r3, [sp, #20]
  2027b4:	60da      	str	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
  2027b6:	9b04      	ldr	r3, [sp, #16]
  2027b8:	689a      	ldr	r2, [r3, #8]
  2027ba:	9b02      	ldr	r3, [sp, #8]
  2027bc:	1ad2      	subs	r2, r2, r3
  2027be:	9b04      	ldr	r3, [sp, #16]
  2027c0:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(vtlp, now, vtp->dlist.delta);
  2027c2:	9b04      	ldr	r3, [sp, #16]
  2027c4:	689b      	ldr	r3, [r3, #8]
  2027c6:	461a      	mov	r2, r3
  2027c8:	9903      	ldr	r1, [sp, #12]
  2027ca:	9805      	ldr	r0, [sp, #20]
  2027cc:	f7ff fe00 	bl	2023d0 <vt_set_alarm>
  2027d0:	e000      	b.n	2027d4 <chVTDoTickI+0x134>
    return;
  2027d2:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  2027d4:	b009      	add	sp, #36	@ 0x24
  2027d6:	f85d fb04 	ldr.w	pc, [sp], #4
  2027da:	bf00      	nop
  2027dc:	200008a0 	.word	0x200008a0

002027e0 <chVTGetTimeStampI>:
 *
 * @return              The time stamp.
 *
 * @iclass
 */
systimestamp_t chVTGetTimeStampI(void) {
  2027e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  2027e2:	b087      	sub	sp, #28
  os_instance_t * oip = currcore;
  2027e4:	4b12      	ldr	r3, [pc, #72]	@ (202830 <chVTGetTimeStampI+0x50>)
  2027e6:	9305      	str	r3, [sp, #20]
  systime_t now;

  chDbgCheckClassI();

  /* Current system time.*/
  now = chVTGetSystemTimeX();
  2027e8:	f7ff fdea 	bl	2023c0 <chVTGetSystemTimeX.lto_priv.0>
  2027ec:	9004      	str	r0, [sp, #16]

  /* Last time stamp generated.*/
  last = oip->vtlist.laststamp;
  2027ee:	9b05      	ldr	r3, [sp, #20]
  2027f0:	e9d3 230a 	ldrd	r2, r3, [r3, #40]	@ 0x28
  2027f4:	e9cd 2302 	strd	r2, r3, [sp, #8]

  /* Interval between the last time stamp and current time used for a new
     time stamp. Note that this fails if the interval is larger than a
     systime_t type.*/
  stamp = last + (systimestamp_t)chTimeDiffX((systime_t)last, now);
  2027f8:	9b02      	ldr	r3, [sp, #8]
  2027fa:	9904      	ldr	r1, [sp, #16]
  2027fc:	4618      	mov	r0, r3
  2027fe:	f7ff fcc7 	bl	202190 <chTimeDiffX.lto_priv.0>
  202802:	4603      	mov	r3, r0
  202804:	2200      	movs	r2, #0
  202806:	461c      	mov	r4, r3
  202808:	4615      	mov	r5, r2
  20280a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  20280e:	1916      	adds	r6, r2, r4
  202810:	eb43 0705 	adc.w	r7, r3, r5
  202814:	e9cd 6700 	strd	r6, r7, [sp]

  chDbgAssert(oip->vtlist.laststamp <= stamp, "wrapped");

  /* Storing the new stamp.*/
  oip->vtlist.laststamp = stamp;
  202818:	9905      	ldr	r1, [sp, #20]
  20281a:	e9dd 2300 	ldrd	r2, r3, [sp]
  20281e:	e9c1 230a 	strd	r2, r3, [r1, #40]	@ 0x28

  return stamp;
  202822:	e9dd 2300 	ldrd	r2, r3, [sp]
}
  202826:	4610      	mov	r0, r2
  202828:	4619      	mov	r1, r3
  20282a:	b007      	add	sp, #28
  20282c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20282e:	bf00      	nop
  202830:	20000890 	.word	0x20000890
	...

00202840 <ch_queue_dequeue.lto_priv.0>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
  202840:	b082      	sub	sp, #8
  202842:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
  202844:	9b01      	ldr	r3, [sp, #4]
  202846:	685b      	ldr	r3, [r3, #4]
  202848:	9a01      	ldr	r2, [sp, #4]
  20284a:	6812      	ldr	r2, [r2, #0]
  20284c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
  20284e:	9b01      	ldr	r3, [sp, #4]
  202850:	681b      	ldr	r3, [r3, #0]
  202852:	9a01      	ldr	r2, [sp, #4]
  202854:	6852      	ldr	r2, [r2, #4]
  202856:	605a      	str	r2, [r3, #4]
  return p;
  202858:	9b01      	ldr	r3, [sp, #4]
}
  20285a:	4618      	mov	r0, r3
  20285c:	b002      	add	sp, #8
  20285e:	4770      	bx	lr

00202860 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  202860:	b084      	sub	sp, #16
  202862:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
  202864:	9b01      	ldr	r3, [sp, #4]
  202866:	681b      	ldr	r3, [r3, #0]
  202868:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
  20286a:	9b03      	ldr	r3, [sp, #12]
  20286c:	681a      	ldr	r2, [r3, #0]
  20286e:	9b01      	ldr	r3, [sp, #4]
  202870:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
  202872:	9b01      	ldr	r3, [sp, #4]
  202874:	681b      	ldr	r3, [r3, #0]
  202876:	9a01      	ldr	r2, [sp, #4]
  202878:	605a      	str	r2, [r3, #4]
  return p;
  20287a:	9b03      	ldr	r3, [sp, #12]
}
  20287c:	4618      	mov	r0, r3
  20287e:	b004      	add	sp, #16
  202880:	4770      	bx	lr
  202882:	bf00      	nop
	...

00202890 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
  202890:	b082      	sub	sp, #8
  202892:	9001      	str	r0, [sp, #4]
  202894:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
  202896:	9b01      	ldr	r3, [sp, #4]
  202898:	681b      	ldr	r3, [r3, #0]
  20289a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
  20289c:	9b01      	ldr	r3, [sp, #4]
  20289e:	689a      	ldr	r2, [r3, #8]
  2028a0:	9b00      	ldr	r3, [sp, #0]
  2028a2:	689b      	ldr	r3, [r3, #8]
  2028a4:	429a      	cmp	r2, r3
  2028a6:	bf2c      	ite	cs
  2028a8:	2301      	movcs	r3, #1
  2028aa:	2300      	movcc	r3, #0
  2028ac:	b2db      	uxtb	r3, r3
  2028ae:	2b00      	cmp	r3, #0
  2028b0:	d1f1      	bne.n	202896 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
  2028b2:	9b00      	ldr	r3, [sp, #0]
  2028b4:	9a01      	ldr	r2, [sp, #4]
  2028b6:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
  2028b8:	9b01      	ldr	r3, [sp, #4]
  2028ba:	685a      	ldr	r2, [r3, #4]
  2028bc:	9b00      	ldr	r3, [sp, #0]
  2028be:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
  2028c0:	9b00      	ldr	r3, [sp, #0]
  2028c2:	685b      	ldr	r3, [r3, #4]
  2028c4:	9a00      	ldr	r2, [sp, #0]
  2028c6:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
  2028c8:	9b01      	ldr	r3, [sp, #4]
  2028ca:	9a00      	ldr	r2, [sp, #0]
  2028cc:	605a      	str	r2, [r3, #4]
  return p;
  2028ce:	9b00      	ldr	r3, [sp, #0]
}
  2028d0:	4618      	mov	r0, r3
  2028d2:	b002      	add	sp, #8
  2028d4:	4770      	bx	lr
  2028d6:	bf00      	nop
	...

002028e0 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
  2028e0:	b082      	sub	sp, #8
  2028e2:	9001      	str	r0, [sp, #4]
  2028e4:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
  2028e6:	9b01      	ldr	r3, [sp, #4]
  2028e8:	681b      	ldr	r3, [r3, #0]
  2028ea:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
  2028ec:	9b01      	ldr	r3, [sp, #4]
  2028ee:	689a      	ldr	r2, [r3, #8]
  2028f0:	9b00      	ldr	r3, [sp, #0]
  2028f2:	689b      	ldr	r3, [r3, #8]
  2028f4:	429a      	cmp	r2, r3
  2028f6:	bf8c      	ite	hi
  2028f8:	2301      	movhi	r3, #1
  2028fa:	2300      	movls	r3, #0
  2028fc:	b2db      	uxtb	r3, r3
  2028fe:	2b00      	cmp	r3, #0
  202900:	d1f1      	bne.n	2028e6 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
  202902:	9b00      	ldr	r3, [sp, #0]
  202904:	9a01      	ldr	r2, [sp, #4]
  202906:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
  202908:	9b01      	ldr	r3, [sp, #4]
  20290a:	685a      	ldr	r2, [r3, #4]
  20290c:	9b00      	ldr	r3, [sp, #0]
  20290e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
  202910:	9b00      	ldr	r3, [sp, #0]
  202912:	685b      	ldr	r3, [r3, #4]
  202914:	9a00      	ldr	r2, [sp, #0]
  202916:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
  202918:	9b01      	ldr	r3, [sp, #4]
  20291a:	9a00      	ldr	r2, [sp, #0]
  20291c:	605a      	str	r2, [r3, #4]
  return p;
  20291e:	9b00      	ldr	r3, [sp, #0]
}
  202920:	4618      	mov	r0, r3
  202922:	b002      	add	sp, #8
  202924:	4770      	bx	lr
  202926:	bf00      	nop
	...

00202930 <chSysLockFromISR.lto_priv.4>:
static inline void chSysLockFromISR(void) {
  202930:	b082      	sub	sp, #8
  202932:	2330      	movs	r3, #48	@ 0x30
  202934:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202936:	9b01      	ldr	r3, [sp, #4]
  202938:	f383 8811 	msr	BASEPRI, r3
}
  20293c:	bf00      	nop
}
  20293e:	bf00      	nop
}
  202940:	bf00      	nop
}
  202942:	bf00      	nop
  202944:	b002      	add	sp, #8
  202946:	4770      	bx	lr
	...

00202950 <chSysUnlockFromISR.lto_priv.4>:
static inline void chSysUnlockFromISR(void) {
  202950:	b082      	sub	sp, #8
  202952:	2300      	movs	r3, #0
  202954:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202956:	9b01      	ldr	r3, [sp, #4]
  202958:	f383 8811 	msr	BASEPRI, r3
}
  20295c:	bf00      	nop
}
  20295e:	bf00      	nop
}
  202960:	bf00      	nop
}
  202962:	bf00      	nop
  202964:	b002      	add	sp, #8
  202966:	4770      	bx	lr
	...

00202970 <chVTIsArmedI.lto_priv.0>:
 * @param[in] vtp       pointer to a @p virtual_timer_t object
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
  202970:	b082      	sub	sp, #8
  202972:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->dlist.next != NULL);
  202974:	9b01      	ldr	r3, [sp, #4]
  202976:	681b      	ldr	r3, [r3, #0]
  202978:	2b00      	cmp	r3, #0
  20297a:	bf14      	ite	ne
  20297c:	2301      	movne	r3, #1
  20297e:	2300      	moveq	r3, #0
  202980:	b2db      	uxtb	r3, r3
}
  202982:	4618      	mov	r0, r3
  202984:	b002      	add	sp, #8
  202986:	4770      	bx	lr
	...

00202990 <chSemFastSignalI.lto_priv.0>:
 *
 * @param[in] sp        pointer to a @p semaphore_t object
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
  202990:	b082      	sub	sp, #8
  202992:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->cnt++;
  202994:	9b01      	ldr	r3, [sp, #4]
  202996:	689b      	ldr	r3, [r3, #8]
  202998:	1c5a      	adds	r2, r3, #1
  20299a:	9b01      	ldr	r3, [sp, #4]
  20299c:	609a      	str	r2, [r3, #8]
}
  20299e:	bf00      	nop
  2029a0:	b002      	add	sp, #8
  2029a2:	4770      	bx	lr
	...

002029b0 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
  2029b0:	b500      	push	{lr}
  2029b2:	b083      	sub	sp, #12
  2029b4:	9001      	str	r0, [sp, #4]

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
  2029b6:	9b01      	ldr	r3, [sp, #4]
  2029b8:	2200      	movs	r2, #0
  2029ba:	771a      	strb	r2, [r3, #28]

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
  2029bc:	9b01      	ldr	r3, [sp, #4]
  2029be:	691b      	ldr	r3, [r3, #16]
  2029c0:	461a      	mov	r2, r3
  2029c2:	9b01      	ldr	r3, [sp, #4]
  2029c4:	4619      	mov	r1, r3
  2029c6:	4610      	mov	r0, r2
  2029c8:	f7ff ff62 	bl	202890 <ch_pqueue_insert_behind>
  2029cc:	4603      	mov	r3, r0
                                           &tp->hdr.pqueue));
}
  2029ce:	4618      	mov	r0, r3
  2029d0:	b003      	add	sp, #12
  2029d2:	f85d fb04 	ldr.w	pc, [sp], #4
  2029d6:	bf00      	nop
	...

002029e0 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
  2029e0:	b500      	push	{lr}
  2029e2:	b083      	sub	sp, #12
  2029e4:	9001      	str	r0, [sp, #4]

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
  2029e6:	9b01      	ldr	r3, [sp, #4]
  2029e8:	2200      	movs	r2, #0
  2029ea:	771a      	strb	r2, [r3, #28]

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
  2029ec:	9b01      	ldr	r3, [sp, #4]
  2029ee:	691b      	ldr	r3, [r3, #16]
  2029f0:	461a      	mov	r2, r3
  2029f2:	9b01      	ldr	r3, [sp, #4]
  2029f4:	4619      	mov	r1, r3
  2029f6:	4610      	mov	r0, r2
  2029f8:	f7ff ff72 	bl	2028e0 <ch_pqueue_insert_ahead>
  2029fc:	4603      	mov	r3, r0
                                          &tp->hdr.pqueue));
}
  2029fe:	4618      	mov	r0, r3
  202a00:	b003      	add	sp, #12
  202a02:	f85d fb04 	ldr.w	pc, [sp], #4
  202a06:	bf00      	nop
	...

00202a10 <__sch_reschedule_behind>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @notapi
 */
static void __sch_reschedule_behind(void) {
  202a10:	b500      	push	{lr}
  202a12:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
  202a14:	4b0d      	ldr	r3, [pc, #52]	@ (202a4c <__sch_reschedule_behind+0x3c>)
  202a16:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
  202a18:	9b03      	ldr	r3, [sp, #12]
  202a1a:	68db      	ldr	r3, [r3, #12]
  202a1c:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  202a1e:	9b03      	ldr	r3, [sp, #12]
  202a20:	4618      	mov	r0, r3
  202a22:	f7ff ff1d 	bl	202860 <ch_pqueue_remove_highest>
  202a26:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
  202a28:	9b01      	ldr	r3, [sp, #4]
  202a2a:	2201      	movs	r2, #1
  202a2c:	771a      	strb	r2, [r3, #28]
  __instance_set_currthread(oip, ntp);
  202a2e:	9b03      	ldr	r3, [sp, #12]
  202a30:	9a01      	ldr	r2, [sp, #4]
  202a32:	60da      	str	r2, [r3, #12]
  /* It went behind peers so it gets a new time quantum.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Placing in ready list behind peers.*/
  otp = __sch_ready_behind(otp);
  202a34:	9802      	ldr	r0, [sp, #8]
  202a36:	f7ff ffbb 	bl	2029b0 <__sch_ready_behind>
  202a3a:	9002      	str	r0, [sp, #8]

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
  202a3c:	9902      	ldr	r1, [sp, #8]
  202a3e:	9801      	ldr	r0, [sp, #4]
  202a40:	f7fd fc70 	bl	200324 <__port_switch>
}
  202a44:	bf00      	nop
  202a46:	b005      	add	sp, #20
  202a48:	f85d fb04 	ldr.w	pc, [sp], #4
  202a4c:	20000890 	.word	0x20000890

00202a50 <__sch_reschedule_ahead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @notapi
 */
static void __sch_reschedule_ahead(void) {
  202a50:	b500      	push	{lr}
  202a52:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
  202a54:	4b0d      	ldr	r3, [pc, #52]	@ (202a8c <__sch_reschedule_ahead+0x3c>)
  202a56:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
  202a58:	9b03      	ldr	r3, [sp, #12]
  202a5a:	68db      	ldr	r3, [r3, #12]
  202a5c:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  202a5e:	9b03      	ldr	r3, [sp, #12]
  202a60:	4618      	mov	r0, r3
  202a62:	f7ff fefd 	bl	202860 <ch_pqueue_remove_highest>
  202a66:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
  202a68:	9b01      	ldr	r3, [sp, #4]
  202a6a:	2201      	movs	r2, #1
  202a6c:	771a      	strb	r2, [r3, #28]
  __instance_set_currthread(oip, ntp);
  202a6e:	9b03      	ldr	r3, [sp, #12]
  202a70:	9a01      	ldr	r2, [sp, #4]
  202a72:	60da      	str	r2, [r3, #12]
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = __sch_ready_ahead(otp);
  202a74:	9802      	ldr	r0, [sp, #8]
  202a76:	f7ff ffb3 	bl	2029e0 <__sch_ready_ahead>
  202a7a:	9002      	str	r0, [sp, #8]

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
  202a7c:	9902      	ldr	r1, [sp, #8]
  202a7e:	9801      	ldr	r0, [sp, #4]
  202a80:	f7fd fc50 	bl	200324 <__port_switch>
}
  202a84:	bf00      	nop
  202a86:	b005      	add	sp, #20
  202a88:	f85d fb04 	ldr.w	pc, [sp], #4
  202a8c:	20000890 	.word	0x20000890

00202a90 <__sch_wakeup>:

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
  202a90:	b500      	push	{lr}
  202a92:	b085      	sub	sp, #20
  202a94:	9001      	str	r0, [sp, #4]
  202a96:	9100      	str	r1, [sp, #0]
  thread_t *tp = threadref(p);
  202a98:	9b00      	ldr	r3, [sp, #0]
  202a9a:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
  202a9c:	f7ff ff48 	bl	202930 <chSysLockFromISR.lto_priv.4>
  switch (tp->state) {
  202aa0:	9b03      	ldr	r3, [sp, #12]
  202aa2:	7f1b      	ldrb	r3, [r3, #28]
  202aa4:	2b0c      	cmp	r3, #12
  202aa6:	d82f      	bhi.n	202b08 <__sch_wakeup+0x78>
  202aa8:	a201      	add	r2, pc, #4	@ (adr r2, 202ab0 <__sch_wakeup+0x20>)
  202aaa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  202aae:	bf00      	nop
  202ab0:	00202ae5 	.word	0x00202ae5
  202ab4:	00202b09 	.word	0x00202b09
  202ab8:	00202b09 	.word	0x00202b09
  202abc:	00202aeb 	.word	0x00202aeb
  202ac0:	00202aff 	.word	0x00202aff
  202ac4:	00202af5 	.word	0x00202af5
  202ac8:	00202b09 	.word	0x00202b09
  202acc:	00202aff 	.word	0x00202aff
  202ad0:	00202b09 	.word	0x00202b09
  202ad4:	00202b09 	.word	0x00202b09
  202ad8:	00202b09 	.word	0x00202b09
  202adc:	00202b09 	.word	0x00202b09
  202ae0:	00202aff 	.word	0x00202aff
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
  202ae4:	f7ff ff34 	bl	202950 <chSysUnlockFromISR.lto_priv.4>
    return;
  202ae8:	e019      	b.n	202b1e <__sch_wakeup+0x8e>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
  202aea:	9b03      	ldr	r3, [sp, #12]
  202aec:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  202aee:	2200      	movs	r2, #0
  202af0:	601a      	str	r2, [r3, #0]
    break;
  202af2:	e00a      	b.n	202b0a <__sch_wakeup+0x7a>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
  202af4:	9b03      	ldr	r3, [sp, #12]
  202af6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  202af8:	4618      	mov	r0, r3
  202afa:	f7ff ff49 	bl	202990 <chSemFastSignalI.lto_priv.0>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
  202afe:	9b03      	ldr	r3, [sp, #12]
  202b00:	4618      	mov	r0, r3
  202b02:	f7ff fe9d 	bl	202840 <ch_queue_dequeue.lto_priv.0>
    break;
  202b06:	e000      	b.n	202b0a <__sch_wakeup+0x7a>
  default:
    /* Any other state, nothing to do.*/
    break;
  202b08:	bf00      	nop
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
  202b0a:	9b03      	ldr	r3, [sp, #12]
  202b0c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  202b10:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  202b12:	9803      	ldr	r0, [sp, #12]
  202b14:	f7ff ff4c 	bl	2029b0 <__sch_ready_behind>
  chSysUnlockFromISR();
  202b18:	f7ff ff1a 	bl	202950 <chSysUnlockFromISR.lto_priv.4>

  return;
  202b1c:	bf00      	nop
}
  202b1e:	b005      	add	sp, #20
  202b20:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00202b30 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
  202b30:	b500      	push	{lr}
  202b32:	b083      	sub	sp, #12
  202b34:	9001      	str	r0, [sp, #4]
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
  202b36:	9801      	ldr	r0, [sp, #4]
  202b38:	f7ff ff3a 	bl	2029b0 <__sch_ready_behind>
  202b3c:	4603      	mov	r3, r0
}
  202b3e:	4618      	mov	r0, r3
  202b40:	b003      	add	sp, #12
  202b42:	f85d fb04 	ldr.w	pc, [sp], #4
  202b46:	bf00      	nop
	...

00202b50 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  202b50:	b500      	push	{lr}
  202b52:	b087      	sub	sp, #28
  202b54:	4603      	mov	r3, r0
  202b56:	f88d 3007 	strb.w	r3, [sp, #7]
  os_instance_t *oip = currcore;
  202b5a:	4b0e      	ldr	r3, [pc, #56]	@ (202b94 <chSchGoSleepS+0x44>)
  202b5c:	9304      	str	r3, [sp, #16]
  thread_t *otp = __instance_get_currthread(oip);
  202b5e:	9b04      	ldr	r3, [sp, #16]
  202b60:	68db      	ldr	r3, [r3, #12]
  202b62:	9303      	str	r3, [sp, #12]

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
  202b64:	9b03      	ldr	r3, [sp, #12]
  202b66:	f89d 2007 	ldrb.w	r2, [sp, #7]
  202b6a:	771a      	strb	r2, [r3, #28]
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  202b6c:	9b04      	ldr	r3, [sp, #16]
  202b6e:	4618      	mov	r0, r3
  202b70:	f7ff fe76 	bl	202860 <ch_pqueue_remove_highest>
  202b74:	9005      	str	r0, [sp, #20]
  ntp->state = CH_STATE_CURRENT;
  202b76:	9b05      	ldr	r3, [sp, #20]
  202b78:	2201      	movs	r2, #1
  202b7a:	771a      	strb	r2, [r3, #28]
  __instance_set_currthread(oip, ntp);
  202b7c:	9b04      	ldr	r3, [sp, #16]
  202b7e:	9a05      	ldr	r2, [sp, #20]
  202b80:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
  202b82:	9903      	ldr	r1, [sp, #12]
  202b84:	9805      	ldr	r0, [sp, #20]
  202b86:	f7fd fbcd 	bl	200324 <__port_switch>
}
  202b8a:	bf00      	nop
  202b8c:	b007      	add	sp, #28
  202b8e:	f85d fb04 	ldr.w	pc, [sp], #4
  202b92:	bf00      	nop
  202b94:	20000890 	.word	0x20000890
	...

00202ba0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
  202ba0:	b500      	push	{lr}
  202ba2:	b08b      	sub	sp, #44	@ 0x2c
  202ba4:	4603      	mov	r3, r0
  202ba6:	9100      	str	r1, [sp, #0]
  202ba8:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *tp = __instance_get_currthread(currcore);
  202bac:	4b14      	ldr	r3, [pc, #80]	@ (202c00 <chSchGoSleepTimeoutS+0x60>)
  202bae:	68db      	ldr	r3, [r3, #12]
  202bb0:	9309      	str	r3, [sp, #36]	@ 0x24

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
  202bb2:	9b00      	ldr	r3, [sp, #0]
  202bb4:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  202bb8:	d016      	beq.n	202be8 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
  202bba:	a803      	add	r0, sp, #12
  202bbc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  202bbe:	4a11      	ldr	r2, [pc, #68]	@ (202c04 <chSchGoSleepTimeoutS+0x64>)
  202bc0:	9900      	ldr	r1, [sp, #0]
  202bc2:	f7ff fce5 	bl	202590 <chVTDoSetI>
    chSchGoSleepS(newstate);
  202bc6:	f89d 3007 	ldrb.w	r3, [sp, #7]
  202bca:	4618      	mov	r0, r3
  202bcc:	f7ff ffc0 	bl	202b50 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
  202bd0:	ab03      	add	r3, sp, #12
  202bd2:	4618      	mov	r0, r3
  202bd4:	f7ff fecc 	bl	202970 <chVTIsArmedI.lto_priv.0>
  202bd8:	4603      	mov	r3, r0
  202bda:	2b00      	cmp	r3, #0
  202bdc:	d009      	beq.n	202bf2 <chSchGoSleepTimeoutS+0x52>
      chVTDoResetI(&vt);
  202bde:	ab03      	add	r3, sp, #12
  202be0:	4618      	mov	r0, r3
  202be2:	f7ff fcf5 	bl	2025d0 <chVTDoResetI>
  202be6:	e004      	b.n	202bf2 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
  202be8:	f89d 3007 	ldrb.w	r3, [sp, #7]
  202bec:	4618      	mov	r0, r3
  202bee:	f7ff ffaf 	bl	202b50 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
  202bf2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  202bf4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
}
  202bf6:	4618      	mov	r0, r3
  202bf8:	b00b      	add	sp, #44	@ 0x2c
  202bfa:	f85d fb04 	ldr.w	pc, [sp], #4
  202bfe:	bf00      	nop
  202c00:	20000890 	.word	0x20000890
  202c04:	00202a91 	.word	0x00202a91
	...

00202c10 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  202c10:	b500      	push	{lr}
  202c12:	b085      	sub	sp, #20
  202c14:	9001      	str	r0, [sp, #4]
  202c16:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
  202c18:	4b14      	ldr	r3, [pc, #80]	@ (202c6c <chSchWakeupS+0x5c>)
  202c1a:	9302      	str	r3, [sp, #8]
  thread_t *otp = __instance_get_currthread(oip);
  202c1c:	9b02      	ldr	r3, [sp, #8]
  202c1e:	68db      	ldr	r3, [r3, #12]
  202c20:	9303      	str	r3, [sp, #12]
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
  202c22:	9b01      	ldr	r3, [sp, #4]
  202c24:	9a00      	ldr	r2, [sp, #0]
  202c26:	635a      	str	r2, [r3, #52]	@ 0x34
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
  202c28:	9b01      	ldr	r3, [sp, #4]
  202c2a:	689a      	ldr	r2, [r3, #8]
  202c2c:	9b03      	ldr	r3, [sp, #12]
  202c2e:	689b      	ldr	r3, [r3, #8]
  202c30:	429a      	cmp	r2, r3
  202c32:	bf94      	ite	ls
  202c34:	2301      	movls	r3, #1
  202c36:	2300      	movhi	r3, #0
  202c38:	b2db      	uxtb	r3, r3
  202c3a:	2b00      	cmp	r3, #0
  202c3c:	d003      	beq.n	202c46 <chSchWakeupS+0x36>
    (void) __sch_ready_behind(ntp);
  202c3e:	9801      	ldr	r0, [sp, #4]
  202c40:	f7ff feb6 	bl	2029b0 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
  202c44:	e00d      	b.n	202c62 <chSchWakeupS+0x52>
    otp = __sch_ready_ahead(otp);
  202c46:	9803      	ldr	r0, [sp, #12]
  202c48:	f7ff feca 	bl	2029e0 <__sch_ready_ahead>
  202c4c:	9003      	str	r0, [sp, #12]
    ntp->state = CH_STATE_CURRENT;
  202c4e:	9b01      	ldr	r3, [sp, #4]
  202c50:	2201      	movs	r2, #1
  202c52:	771a      	strb	r2, [r3, #28]
    __instance_set_currthread(oip, ntp);
  202c54:	9b02      	ldr	r3, [sp, #8]
  202c56:	9a01      	ldr	r2, [sp, #4]
  202c58:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
  202c5a:	9903      	ldr	r1, [sp, #12]
  202c5c:	9801      	ldr	r0, [sp, #4]
  202c5e:	f7fd fb61 	bl	200324 <__port_switch>
}
  202c62:	bf00      	nop
  202c64:	b005      	add	sp, #20
  202c66:	f85d fb04 	ldr.w	pc, [sp], #4
  202c6a:	bf00      	nop
  202c6c:	20000890 	.word	0x20000890

00202c70 <chSchRescheduleS>:
 * @note    Only local threads are considered, other cores are signaled
 *          and perform a reschedule locally.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
  202c70:	b500      	push	{lr}
  202c72:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
  202c74:	4b0b      	ldr	r3, [pc, #44]	@ (202ca4 <chSchRescheduleS+0x34>)
  202c76:	9301      	str	r3, [sp, #4]
  thread_t *tp = __instance_get_currthread(oip);
  202c78:	9b01      	ldr	r3, [sp, #4]
  202c7a:	68db      	ldr	r3, [r3, #12]
  202c7c:	9300      	str	r3, [sp, #0]

  chDbgCheckClassS();

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
  202c7e:	9b01      	ldr	r3, [sp, #4]
  202c80:	681b      	ldr	r3, [r3, #0]
  202c82:	689a      	ldr	r2, [r3, #8]
  202c84:	9b00      	ldr	r3, [sp, #0]
  202c86:	689b      	ldr	r3, [r3, #8]
  202c88:	429a      	cmp	r2, r3
  202c8a:	bf8c      	ite	hi
  202c8c:	2301      	movhi	r3, #1
  202c8e:	2300      	movls	r3, #0
  202c90:	b2db      	uxtb	r3, r3
  202c92:	2b00      	cmp	r3, #0
  202c94:	d001      	beq.n	202c9a <chSchRescheduleS+0x2a>
    __sch_reschedule_ahead();
  202c96:	f7ff fedb 	bl	202a50 <__sch_reschedule_ahead>
  }
}
  202c9a:	bf00      	nop
  202c9c:	b003      	add	sp, #12
  202c9e:	f85d fb04 	ldr.w	pc, [sp], #4
  202ca2:	bf00      	nop
  202ca4:	20000890 	.word	0x20000890
	...

00202cb0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  202cb0:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
  202cb2:	4b0b      	ldr	r3, [pc, #44]	@ (202ce0 <chSchIsPreemptionRequired+0x30>)
  202cb4:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
  202cb6:	9b03      	ldr	r3, [sp, #12]
  202cb8:	68db      	ldr	r3, [r3, #12]
  202cba:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
  202cbc:	9b03      	ldr	r3, [sp, #12]
  202cbe:	681b      	ldr	r3, [r3, #0]
  202cc0:	689b      	ldr	r3, [r3, #8]
  202cc2:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
  202cc4:	9b02      	ldr	r3, [sp, #8]
  202cc6:	689b      	ldr	r3, [r3, #8]
  202cc8:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
  202cca:	9a01      	ldr	r2, [sp, #4]
  202ccc:	9b00      	ldr	r3, [sp, #0]
  202cce:	429a      	cmp	r2, r3
  202cd0:	bf8c      	ite	hi
  202cd2:	2301      	movhi	r3, #1
  202cd4:	2300      	movls	r3, #0
  202cd6:	b2db      	uxtb	r3, r3
#endif
}
  202cd8:	4618      	mov	r0, r3
  202cda:	b004      	add	sp, #16
  202cdc:	4770      	bx	lr
  202cde:	bf00      	nop
  202ce0:	20000890 	.word	0x20000890
	...

00202cf0 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
  202cf0:	b500      	push	{lr}
  202cf2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
  202cf4:	4b0d      	ldr	r3, [pc, #52]	@ (202d2c <chSchDoPreemption+0x3c>)
  202cf6:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
  202cf8:	9b03      	ldr	r3, [sp, #12]
  202cfa:	68db      	ldr	r3, [r3, #12]
  202cfc:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  202cfe:	9b03      	ldr	r3, [sp, #12]
  202d00:	4618      	mov	r0, r3
  202d02:	f7ff fdad 	bl	202860 <ch_pqueue_remove_highest>
  202d06:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
  202d08:	9b01      	ldr	r3, [sp, #4]
  202d0a:	2201      	movs	r2, #1
  202d0c:	771a      	strb	r2, [r3, #28]
  __instance_set_currthread(oip, ntp);
  202d0e:	9b03      	ldr	r3, [sp, #12]
  202d10:	9a01      	ldr	r2, [sp, #4]
  202d12:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
  202d14:	9802      	ldr	r0, [sp, #8]
  202d16:	f7ff fe63 	bl	2029e0 <__sch_ready_ahead>
  202d1a:	9002      	str	r0, [sp, #8]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
  202d1c:	9902      	ldr	r1, [sp, #8]
  202d1e:	9801      	ldr	r0, [sp, #4]
  202d20:	f7fd fb00 	bl	200324 <__port_switch>
}
  202d24:	bf00      	nop
  202d26:	b005      	add	sp, #20
  202d28:	f85d fb04 	ldr.w	pc, [sp], #4
  202d2c:	20000890 	.word	0x20000890

00202d30 <chSchDoYieldS>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal or higher priority, if any.
 *
 * @sclass
 */
void chSchDoYieldS(void) {
  202d30:	b500      	push	{lr}
  202d32:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
  202d34:	4b0b      	ldr	r3, [pc, #44]	@ (202d64 <chSchDoYieldS+0x34>)
  202d36:	9301      	str	r3, [sp, #4]
  thread_t *tp = __instance_get_currthread(oip);
  202d38:	9b01      	ldr	r3, [sp, #4]
  202d3a:	68db      	ldr	r3, [r3, #12]
  202d3c:	9300      	str	r3, [sp, #0]

  chDbgCheckClassS();

  /* If this function has been called then it is likely there are threads
     at same priority level.*/
  if (likely(firstprio(&oip->rlist.pqueue) >= tp->hdr.pqueue.prio)) {
  202d3e:	9b01      	ldr	r3, [sp, #4]
  202d40:	681b      	ldr	r3, [r3, #0]
  202d42:	689a      	ldr	r2, [r3, #8]
  202d44:	9b00      	ldr	r3, [sp, #0]
  202d46:	689b      	ldr	r3, [r3, #8]
  202d48:	429a      	cmp	r2, r3
  202d4a:	bf2c      	ite	cs
  202d4c:	2301      	movcs	r3, #1
  202d4e:	2300      	movcc	r3, #0
  202d50:	b2db      	uxtb	r3, r3
  202d52:	2b00      	cmp	r3, #0
  202d54:	d001      	beq.n	202d5a <chSchDoYieldS+0x2a>
    __sch_reschedule_behind();
  202d56:	f7ff fe5b 	bl	202a10 <__sch_reschedule_behind>
  }
}
  202d5a:	bf00      	nop
  202d5c:	b003      	add	sp, #12
  202d5e:	f85d fb04 	ldr.w	pc, [sp], #4
  202d62:	bf00      	nop
  202d64:	20000890 	.word	0x20000890
	...

00202d70 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to a @p rfcu_t object
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
  202d70:	b082      	sub	sp, #8
  202d72:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
  202d74:	9b01      	ldr	r3, [sp, #4]
  202d76:	2200      	movs	r2, #0
  202d78:	601a      	str	r2, [r3, #0]
}
  202d7a:	bf00      	nop
  202d7c:	b002      	add	sp, #8
  202d7e:	4770      	bx	lr

00202d80 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to a @p system_debug_t object
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
  202d80:	b082      	sub	sp, #8
  202d82:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
  202d84:	9b01      	ldr	r3, [sp, #4]
  202d86:	2200      	movs	r2, #0
  202d88:	601a      	str	r2, [r3, #0]
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
  sdp->lock_cnt = (cnt_t)1;
#endif
}
  202d8a:	bf00      	nop
  202d8c:	b002      	add	sp, #8
  202d8e:	4770      	bx	lr

00202d90 <ch_queue_init.lto_priv.0>:
static inline void ch_queue_init(ch_queue_t *qp) {
  202d90:	b082      	sub	sp, #8
  202d92:	9001      	str	r0, [sp, #4]
  qp->next = qp;
  202d94:	9b01      	ldr	r3, [sp, #4]
  202d96:	9a01      	ldr	r2, [sp, #4]
  202d98:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
  202d9a:	9b01      	ldr	r3, [sp, #4]
  202d9c:	9a01      	ldr	r2, [sp, #4]
  202d9e:	605a      	str	r2, [r3, #4]
}
  202da0:	bf00      	nop
  202da2:	b002      	add	sp, #8
  202da4:	4770      	bx	lr
  202da6:	bf00      	nop
	...

00202db0 <ch_queue_insert.lto_priv.0>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
  202db0:	b082      	sub	sp, #8
  202db2:	9001      	str	r0, [sp, #4]
  202db4:	9100      	str	r1, [sp, #0]
  p->next       = qp;
  202db6:	9b00      	ldr	r3, [sp, #0]
  202db8:	9a01      	ldr	r2, [sp, #4]
  202dba:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
  202dbc:	9b01      	ldr	r3, [sp, #4]
  202dbe:	685a      	ldr	r2, [r3, #4]
  202dc0:	9b00      	ldr	r3, [sp, #0]
  202dc2:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
  202dc4:	9b00      	ldr	r3, [sp, #0]
  202dc6:	685b      	ldr	r3, [r3, #4]
  202dc8:	9a00      	ldr	r2, [sp, #0]
  202dca:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
  202dcc:	9b01      	ldr	r3, [sp, #4]
  202dce:	9a00      	ldr	r2, [sp, #0]
  202dd0:	605a      	str	r2, [r3, #4]
}
  202dd2:	bf00      	nop
  202dd4:	b002      	add	sp, #8
  202dd6:	4770      	bx	lr
	...

00202de0 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
  202de0:	b082      	sub	sp, #8
  202de2:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
  202de4:	9b01      	ldr	r3, [sp, #4]
  202de6:	9a01      	ldr	r2, [sp, #4]
  202de8:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
  202dea:	9b01      	ldr	r3, [sp, #4]
  202dec:	9a01      	ldr	r2, [sp, #4]
  202dee:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
  202df0:	9b01      	ldr	r3, [sp, #4]
  202df2:	2200      	movs	r2, #0
  202df4:	609a      	str	r2, [r3, #8]
}
  202df6:	bf00      	nop
  202df8:	b002      	add	sp, #8
  202dfa:	4770      	bx	lr
  202dfc:	0000      	movs	r0, r0
	...

00202e00 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
  202e00:	b082      	sub	sp, #8
  202e02:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
  202e04:	9b01      	ldr	r3, [sp, #4]
  202e06:	9a01      	ldr	r2, [sp, #4]
  202e08:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
  202e0a:	9b01      	ldr	r3, [sp, #4]
  202e0c:	9a01      	ldr	r2, [sp, #4]
  202e0e:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
  202e10:	9b01      	ldr	r3, [sp, #4]
  202e12:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  202e16:	609a      	str	r2, [r3, #8]
}
  202e18:	bf00      	nop
  202e1a:	b002      	add	sp, #8
  202e1c:	4770      	bx	lr
  202e1e:	bf00      	nop

00202e20 <port_timer_get_time.lto_priv.1>:
static inline systime_t port_timer_get_time(void) {
  202e20:	b508      	push	{r3, lr}
  return stGetCounter();
  202e22:	f7fd fd5d 	bl	2008e0 <stGetCounter>
  202e26:	4603      	mov	r3, r0
}
  202e28:	4618      	mov	r0, r3
  202e2a:	bd08      	pop	{r3, pc}
  202e2c:	0000      	movs	r0, r0
	...

00202e30 <chVTGetSystemTimeX.lto_priv.1>:
static inline systime_t chVTGetSystemTimeX(void) {
  202e30:	b508      	push	{r3, lr}
  return port_timer_get_time();
  202e32:	f7ff fff5 	bl	202e20 <port_timer_get_time.lto_priv.1>
  202e36:	4603      	mov	r3, r0
}
  202e38:	4618      	mov	r0, r3
  202e3a:	bd08      	pop	{r3, pc}
  202e3c:	0000      	movs	r0, r0
	...

00202e40 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
  202e40:	b530      	push	{r4, r5, lr}
  202e42:	b083      	sub	sp, #12
  202e44:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
  202e46:	9b01      	ldr	r3, [sp, #4]
  202e48:	4618      	mov	r0, r3
  202e4a:	f7ff ffd9 	bl	202e00 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
  202e4e:	9b01      	ldr	r3, [sp, #4]
  202e50:	2200      	movs	r2, #0
  202e52:	60da      	str	r2, [r3, #12]
  vtlp->lastdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
  202e54:	9b01      	ldr	r3, [sp, #4]
  202e56:	2202      	movs	r2, #2
  202e58:	611a      	str	r2, [r3, #16]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
  202e5a:	f7ff ffe9 	bl	202e30 <chVTGetSystemTimeX.lto_priv.1>
  202e5e:	4603      	mov	r3, r0
  202e60:	2200      	movs	r2, #0
  202e62:	461c      	mov	r4, r3
  202e64:	4615      	mov	r5, r2
  202e66:	9b01      	ldr	r3, [sp, #4]
  202e68:	e9c3 4506 	strd	r4, r5, [r3, #24]
#endif
}
  202e6c:	bf00      	nop
  202e6e:	b003      	add	sp, #12
  202e70:	bd30      	pop	{r4, r5, pc}
  202e72:	bf00      	nop
	...

00202e80 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
  202e80:	b500      	push	{lr}
  202e82:	b083      	sub	sp, #12
  202e84:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
  202e86:	9b01      	ldr	r3, [sp, #4]
  202e88:	4618      	mov	r0, r3
  202e8a:	f7ff ff81 	bl	202d90 <ch_queue_init.lto_priv.0>
}
  202e8e:	bf00      	nop
  202e90:	b003      	add	sp, #12
  202e92:	f85d fb04 	ldr.w	pc, [sp], #4
  202e96:	bf00      	nop
	...

00202ea0 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
  202ea0:	b082      	sub	sp, #8
  202ea2:	9001      	str	r0, [sp, #4]
__STATIC_FORCEINLINE void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
  202ea4:	bf00      	nop
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
  202ea6:	bf00      	nop
  202ea8:	e7fc      	b.n	202ea4 <__idle_thread+0x4>
  202eaa:	bf00      	nop
  202eac:	0000      	movs	r0, r0
	...

00202eb0 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to an @p os_instance_config_t object
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
  202eb0:	b500      	push	{lr}
  202eb2:	b093      	sub	sp, #76	@ 0x4c
  202eb4:	9001      	str	r0, [sp, #4]
  202eb6:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
  202eb8:	2300      	movs	r3, #0
  202eba:	9311      	str	r3, [sp, #68]	@ 0x44
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
  202ebc:	4a34      	ldr	r2, [pc, #208]	@ (202f90 <chInstanceObjectInit+0xe0>)
  202ebe:	9b11      	ldr	r3, [sp, #68]	@ 0x44
  202ec0:	009b      	lsls	r3, r3, #2
  202ec2:	4413      	add	r3, r2
  202ec4:	9a01      	ldr	r2, [sp, #4]
  202ec6:	605a      	str	r2, [r3, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
  202ec8:	9b01      	ldr	r3, [sp, #4]
  202eca:	9a11      	ldr	r2, [sp, #68]	@ 0x44
  202ecc:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
  202ece:	9b01      	ldr	r3, [sp, #4]
  202ed0:	9a00      	ldr	r2, [sp, #0]
  202ed2:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Port initialization for the current instance.*/
  port_init(oip);
  202ed4:	9801      	ldr	r0, [sp, #4]
  202ed6:	f004 f8f3 	bl	2070c0 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
  202eda:	9b01      	ldr	r3, [sp, #4]
  202edc:	4618      	mov	r0, r3
  202ede:	f7ff ff7f 	bl	202de0 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
  202ee2:	9b01      	ldr	r3, [sp, #4]
  202ee4:	3330      	adds	r3, #48	@ 0x30
  202ee6:	4618      	mov	r0, r3
  202ee8:	f7ff ffca 	bl	202e80 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
  202eec:	9b01      	ldr	r3, [sp, #4]
  202eee:	333c      	adds	r3, #60	@ 0x3c
  202ef0:	4618      	mov	r0, r3
  202ef2:	f7ff ff3d 	bl	202d70 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
  202ef6:	9b01      	ldr	r3, [sp, #4]
  202ef8:	3310      	adds	r3, #16
  202efa:	4618      	mov	r0, r3
  202efc:	f7ff ffa0 	bl	202e40 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
  202f00:	9b01      	ldr	r3, [sp, #4]
  202f02:	33e4      	adds	r3, #228	@ 0xe4
  202f04:	4618      	mov	r0, r3
  202f06:	f7ff ff3b 	bl	202d80 <__dbg_object_init>

  /* Now this instructions flow becomes the main thread or the idle thread
     depending on the CH_CFG_NO_IDLE_THREAD setting.*/
  {
#if CH_CFG_NO_IDLE_THREAD == FALSE
    const THD_DECL(main_thd_desc,
  202f0a:	4b22      	ldr	r3, [pc, #136]	@ (202f94 <chInstanceObjectInit+0xe4>)
  202f0c:	9303      	str	r3, [sp, #12]
  202f0e:	9b00      	ldr	r3, [sp, #0]
  202f10:	685b      	ldr	r3, [r3, #4]
  202f12:	9304      	str	r3, [sp, #16]
  202f14:	9b00      	ldr	r3, [sp, #0]
  202f16:	689b      	ldr	r3, [r3, #8]
  202f18:	9305      	str	r3, [sp, #20]
  202f1a:	2380      	movs	r3, #128	@ 0x80
  202f1c:	9306      	str	r3, [sp, #24]
  202f1e:	2300      	movs	r3, #0
  202f20:	9307      	str	r3, [sp, #28]
  202f22:	2300      	movs	r3, #0
  202f24:	9308      	str	r3, [sp, #32]
  202f26:	9b01      	ldr	r3, [sp, #4]
  202f28:	9309      	str	r3, [sp, #36]	@ 0x24
                   "main", oicp->cstack_base, oicp->cstack_end,
                   NORMALPRIO, NULL, NULL, oip
    );

    oip->rlist.current = chThdObjectInit(&oip->mainthread, &main_thd_desc);
  202f2a:	9b01      	ldr	r3, [sp, #4]
  202f2c:	3394      	adds	r3, #148	@ 0x94
  202f2e:	aa03      	add	r2, sp, #12
  202f30:	4611      	mov	r1, r2
  202f32:	4618      	mov	r0, r3
  202f34:	f000 f93c 	bl	2031b0 <chThdObjectInit>
  202f38:	4602      	mov	r2, r0
  202f3a:	9b01      	ldr	r3, [sp, #4]
  202f3c:	60da      	str	r2, [r3, #12]
    oip->rlist.current = chThdObjectInit(&oip->idlethread, &idle_thd_desc);
#endif
  }

#if CH_CFG_USE_REGISTRY == TRUE
  REG_INSERT(oip, oip->rlist.current);
  202f3e:	9b01      	ldr	r3, [sp, #4]
  202f40:	f103 0230 	add.w	r2, r3, #48	@ 0x30
  202f44:	9b01      	ldr	r3, [sp, #4]
  202f46:	68db      	ldr	r3, [r3, #12]
  202f48:	3324      	adds	r3, #36	@ 0x24
  202f4a:	4619      	mov	r1, r3
  202f4c:	4610      	mov	r0, r2
  202f4e:	f7ff ff2f 	bl	202db0 <ch_queue_insert.lto_priv.0>
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
  202f52:	9b01      	ldr	r3, [sp, #4]
  202f54:	68db      	ldr	r3, [r3, #12]
  202f56:	2201      	movs	r2, #1
  202f58:	771a      	strb	r2, [r3, #28]
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    const THD_DECL(idle_thd_desc,
  202f5a:	4b0f      	ldr	r3, [pc, #60]	@ (202f98 <chInstanceObjectInit+0xe8>)
  202f5c:	930a      	str	r3, [sp, #40]	@ 0x28
  202f5e:	9b00      	ldr	r3, [sp, #0]
  202f60:	68db      	ldr	r3, [r3, #12]
  202f62:	930b      	str	r3, [sp, #44]	@ 0x2c
  202f64:	9b00      	ldr	r3, [sp, #0]
  202f66:	691b      	ldr	r3, [r3, #16]
  202f68:	930c      	str	r3, [sp, #48]	@ 0x30
  202f6a:	2301      	movs	r3, #1
  202f6c:	930d      	str	r3, [sp, #52]	@ 0x34
  202f6e:	4b0b      	ldr	r3, [pc, #44]	@ (202f9c <chInstanceObjectInit+0xec>)
  202f70:	930e      	str	r3, [sp, #56]	@ 0x38
  202f72:	2300      	movs	r3, #0
  202f74:	930f      	str	r3, [sp, #60]	@ 0x3c
  202f76:	9b01      	ldr	r3, [sp, #4]
  202f78:	9310      	str	r3, [sp, #64]	@ 0x40
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdSpawnRunningI(&oip->idlethread, &idle_thd_desc);
  202f7a:	9b01      	ldr	r3, [sp, #4]
  202f7c:	3344      	adds	r3, #68	@ 0x44
  202f7e:	aa0a      	add	r2, sp, #40	@ 0x28
  202f80:	4611      	mov	r1, r2
  202f82:	4618      	mov	r0, r3
  202f84:	f000 f994 	bl	2032b0 <chThdSpawnRunningI>
  }
#endif /* CH_CFG_NO_IDLE_THREAD == FALSE */
}
  202f88:	bf00      	nop
  202f8a:	b013      	add	sp, #76	@ 0x4c
  202f8c:	f85d fb04 	ldr.w	pc, [sp], #4
  202f90:	20000880 	.word	0x20000880
  202f94:	08010b98 	.word	0x08010b98
  202f98:	08010ba0 	.word	0x08010ba0
  202f9c:	00202ea1 	.word	0x00202ea1

00202fa0 <chTimeDiffX.lto_priv.1>:
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
  202fa0:	b082      	sub	sp, #8
  202fa2:	9001      	str	r0, [sp, #4]
  202fa4:	9100      	str	r1, [sp, #0]
  return (sysinterval_t)((systime_t)(end - start));
  202fa6:	9a00      	ldr	r2, [sp, #0]
  202fa8:	9b01      	ldr	r3, [sp, #4]
  202faa:	1ad3      	subs	r3, r2, r3
}
  202fac:	4618      	mov	r0, r3
  202fae:	b002      	add	sp, #8
  202fb0:	4770      	bx	lr
  202fb2:	bf00      	nop
	...

00202fc0 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
  202fc0:	b082      	sub	sp, #8
  202fc2:	9001      	str	r0, [sp, #4]
  lp->next = lp;
  202fc4:	9b01      	ldr	r3, [sp, #4]
  202fc6:	9a01      	ldr	r2, [sp, #4]
  202fc8:	601a      	str	r2, [r3, #0]
}
  202fca:	bf00      	nop
  202fcc:	b002      	add	sp, #8
  202fce:	4770      	bx	lr

00202fd0 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
  202fd0:	b082      	sub	sp, #8
  202fd2:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
  202fd4:	9b01      	ldr	r3, [sp, #4]
  202fd6:	681b      	ldr	r3, [r3, #0]
  202fd8:	9a01      	ldr	r2, [sp, #4]
  202fda:	429a      	cmp	r2, r3
  202fdc:	bf14      	ite	ne
  202fde:	2301      	movne	r3, #1
  202fe0:	2300      	moveq	r3, #0
  202fe2:	b2db      	uxtb	r3, r3
}
  202fe4:	4618      	mov	r0, r3
  202fe6:	b002      	add	sp, #8
  202fe8:	4770      	bx	lr
  202fea:	bf00      	nop
  202fec:	0000      	movs	r0, r0
	...

00202ff0 <ch_list_link>:
static inline void ch_list_link(ch_list_t *lp, ch_list_t *p) {
  202ff0:	b082      	sub	sp, #8
  202ff2:	9001      	str	r0, [sp, #4]
  202ff4:	9100      	str	r1, [sp, #0]
  p->next = lp->next;
  202ff6:	9b01      	ldr	r3, [sp, #4]
  202ff8:	681a      	ldr	r2, [r3, #0]
  202ffa:	9b00      	ldr	r3, [sp, #0]
  202ffc:	601a      	str	r2, [r3, #0]
  lp->next = p;
  202ffe:	9b01      	ldr	r3, [sp, #4]
  203000:	9a00      	ldr	r2, [sp, #0]
  203002:	601a      	str	r2, [r3, #0]
}
  203004:	bf00      	nop
  203006:	b002      	add	sp, #8
  203008:	4770      	bx	lr
  20300a:	bf00      	nop
  20300c:	0000      	movs	r0, r0
	...

00203010 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
  203010:	b084      	sub	sp, #16
  203012:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
  203014:	9b01      	ldr	r3, [sp, #4]
  203016:	681b      	ldr	r3, [r3, #0]
  203018:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
  20301a:	9b03      	ldr	r3, [sp, #12]
  20301c:	681a      	ldr	r2, [r3, #0]
  20301e:	9b01      	ldr	r3, [sp, #4]
  203020:	601a      	str	r2, [r3, #0]
  return p;
  203022:	9b03      	ldr	r3, [sp, #12]
}
  203024:	4618      	mov	r0, r3
  203026:	b004      	add	sp, #16
  203028:	4770      	bx	lr
  20302a:	bf00      	nop
  20302c:	0000      	movs	r0, r0
	...

00203030 <ch_queue_init.lto_priv.1>:
static inline void ch_queue_init(ch_queue_t *qp) {
  203030:	b082      	sub	sp, #8
  203032:	9001      	str	r0, [sp, #4]
  qp->next = qp;
  203034:	9b01      	ldr	r3, [sp, #4]
  203036:	9a01      	ldr	r2, [sp, #4]
  203038:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
  20303a:	9b01      	ldr	r3, [sp, #4]
  20303c:	9a01      	ldr	r2, [sp, #4]
  20303e:	605a      	str	r2, [r3, #4]
}
  203040:	bf00      	nop
  203042:	b002      	add	sp, #8
  203044:	4770      	bx	lr
  203046:	bf00      	nop
	...

00203050 <ch_queue_notempty.lto_priv.0>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
  203050:	b082      	sub	sp, #8
  203052:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
  203054:	9b01      	ldr	r3, [sp, #4]
  203056:	681b      	ldr	r3, [r3, #0]
  203058:	9a01      	ldr	r2, [sp, #4]
  20305a:	429a      	cmp	r2, r3
  20305c:	bf14      	ite	ne
  20305e:	2301      	movne	r3, #1
  203060:	2300      	moveq	r3, #0
  203062:	b2db      	uxtb	r3, r3
}
  203064:	4618      	mov	r0, r3
  203066:	b002      	add	sp, #8
  203068:	4770      	bx	lr
  20306a:	bf00      	nop
  20306c:	0000      	movs	r0, r0
	...

00203070 <ch_queue_insert.lto_priv.1>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
  203070:	b082      	sub	sp, #8
  203072:	9001      	str	r0, [sp, #4]
  203074:	9100      	str	r1, [sp, #0]
  p->next       = qp;
  203076:	9b00      	ldr	r3, [sp, #0]
  203078:	9a01      	ldr	r2, [sp, #4]
  20307a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
  20307c:	9b01      	ldr	r3, [sp, #4]
  20307e:	685a      	ldr	r2, [r3, #4]
  203080:	9b00      	ldr	r3, [sp, #0]
  203082:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
  203084:	9b00      	ldr	r3, [sp, #0]
  203086:	685b      	ldr	r3, [r3, #4]
  203088:	9a00      	ldr	r2, [sp, #0]
  20308a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
  20308c:	9b01      	ldr	r3, [sp, #4]
  20308e:	9a00      	ldr	r2, [sp, #0]
  203090:	605a      	str	r2, [r3, #4]
}
  203092:	bf00      	nop
  203094:	b002      	add	sp, #8
  203096:	4770      	bx	lr
	...

002030a0 <ch_queue_fifo_remove.lto_priv.0>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  2030a0:	b084      	sub	sp, #16
  2030a2:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
  2030a4:	9b01      	ldr	r3, [sp, #4]
  2030a6:	681b      	ldr	r3, [r3, #0]
  2030a8:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
  2030aa:	9b03      	ldr	r3, [sp, #12]
  2030ac:	681a      	ldr	r2, [r3, #0]
  2030ae:	9b01      	ldr	r3, [sp, #4]
  2030b0:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
  2030b2:	9b01      	ldr	r3, [sp, #4]
  2030b4:	681b      	ldr	r3, [r3, #0]
  2030b6:	9a01      	ldr	r2, [sp, #4]
  2030b8:	605a      	str	r2, [r3, #4]
  return p;
  2030ba:	9b03      	ldr	r3, [sp, #12]
}
  2030bc:	4618      	mov	r0, r3
  2030be:	b004      	add	sp, #16
  2030c0:	4770      	bx	lr
  2030c2:	bf00      	nop
	...

002030d0 <ch_queue_dequeue.lto_priv.1>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
  2030d0:	b082      	sub	sp, #8
  2030d2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
  2030d4:	9b01      	ldr	r3, [sp, #4]
  2030d6:	685b      	ldr	r3, [r3, #4]
  2030d8:	9a01      	ldr	r2, [sp, #4]
  2030da:	6812      	ldr	r2, [r2, #0]
  2030dc:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
  2030de:	9b01      	ldr	r3, [sp, #4]
  2030e0:	681b      	ldr	r3, [r3, #0]
  2030e2:	9a01      	ldr	r2, [sp, #4]
  2030e4:	6852      	ldr	r2, [r2, #4]
  2030e6:	605a      	str	r2, [r3, #4]
  return p;
  2030e8:	9b01      	ldr	r3, [sp, #4]
}
  2030ea:	4618      	mov	r0, r3
  2030ec:	b002      	add	sp, #8
  2030ee:	4770      	bx	lr

002030f0 <port_timer_get_time.lto_priv.2>:
static inline systime_t port_timer_get_time(void) {
  2030f0:	b508      	push	{r3, lr}
  return stGetCounter();
  2030f2:	f7fd fbf5 	bl	2008e0 <stGetCounter>
  2030f6:	4603      	mov	r3, r0
}
  2030f8:	4618      	mov	r0, r3
  2030fa:	bd08      	pop	{r3, pc}
  2030fc:	0000      	movs	r0, r0
	...

00203100 <chSysLock.lto_priv.4>:
static inline void chSysLock(void) {
  203100:	b082      	sub	sp, #8
  203102:	2330      	movs	r3, #48	@ 0x30
  203104:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203106:	9b01      	ldr	r3, [sp, #4]
  203108:	f383 8811 	msr	BASEPRI, r3
}
  20310c:	bf00      	nop
}
  20310e:	bf00      	nop
}
  203110:	bf00      	nop
  203112:	b002      	add	sp, #8
  203114:	4770      	bx	lr
  203116:	bf00      	nop
	...

00203120 <chSysUnlock.lto_priv.4>:
static inline void chSysUnlock(void) {
  203120:	b082      	sub	sp, #8
  203122:	2300      	movs	r3, #0
  203124:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203126:	9b01      	ldr	r3, [sp, #4]
  203128:	f383 8811 	msr	BASEPRI, r3
}
  20312c:	bf00      	nop
}
  20312e:	bf00      	nop
}
  203130:	bf00      	nop
  203132:	b002      	add	sp, #8
  203134:	4770      	bx	lr
  203136:	bf00      	nop
	...

00203140 <chVTGetSystemTimeX.lto_priv.2>:
static inline systime_t chVTGetSystemTimeX(void) {
  203140:	b508      	push	{r3, lr}
  return port_timer_get_time();
  203142:	f7ff ffd5 	bl	2030f0 <port_timer_get_time.lto_priv.2>
  203146:	4603      	mov	r3, r0
}
  203148:	4618      	mov	r0, r3
  20314a:	bd08      	pop	{r3, pc}
  20314c:	0000      	movs	r0, r0
	...

00203150 <chThdGetSelfX.lto_priv.0>:
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
  203150:	4b01      	ldr	r3, [pc, #4]	@ (203158 <chThdGetSelfX.lto_priv.0+0x8>)
  203152:	68db      	ldr	r3, [r3, #12]
}
  203154:	4618      	mov	r0, r3
  203156:	4770      	bx	lr
  203158:	20000890 	.word	0x20000890
  20315c:	00000000 	.word	0x00000000

00203160 <chThdSleepS>:
 *                        state.
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
  203160:	b500      	push	{lr}
  203162:	b083      	sub	sp, #12
  203164:	9001      	str	r0, [sp, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
  203166:	9901      	ldr	r1, [sp, #4]
  203168:	2008      	movs	r0, #8
  20316a:	f7ff fd19 	bl	202ba0 <chSchGoSleepTimeoutS>
}
  20316e:	bf00      	nop
  203170:	b003      	add	sp, #12
  203172:	f85d fb04 	ldr.w	pc, [sp], #4
  203176:	bf00      	nop
	...

00203180 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to a @p threads_queue_t object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  203180:	b500      	push	{lr}
  203182:	b085      	sub	sp, #20
  203184:	9001      	str	r0, [sp, #4]
  203186:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(ch_queue_notempty(&tqp->queue), "empty queue");

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));
  203188:	9b01      	ldr	r3, [sp, #4]
  20318a:	4618      	mov	r0, r3
  20318c:	f7ff ff88 	bl	2030a0 <ch_queue_fifo_remove.lto_priv.0>
  203190:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
  203192:	9b03      	ldr	r3, [sp, #12]
  203194:	9a00      	ldr	r2, [sp, #0]
  203196:	635a      	str	r2, [r3, #52]	@ 0x34
  (void) chSchReadyI(tp);
  203198:	9803      	ldr	r0, [sp, #12]
  20319a:	f7ff fcc9 	bl	202b30 <chSchReadyI>
}
  20319e:	bf00      	nop
  2031a0:	b005      	add	sp, #20
  2031a2:	f85d fb04 	ldr.w	pc, [sp], #4
  2031a6:	bf00      	nop
	...

002031b0 <chThdObjectInit>:
 * @return              The same thread pointer passed as parameter.
 *
 * @init
 */
thread_t *chThdObjectInit(thread_t *tp,
                          const thread_descriptor_t *tdp) {
  2031b0:	b500      	push	{lr}
  2031b2:	b083      	sub	sp, #12
  2031b4:	9001      	str	r0, [sp, #4]
  2031b6:	9100      	str	r1, [sp, #0]

  chDbgCheck(tp != NULL);
  chDbgCheck(tdp != NULL);

  /* Stack boundaries.*/
  tp->wabase = (void *)tdp->wbase;
  2031b8:	9b00      	ldr	r3, [sp, #0]
  2031ba:	685a      	ldr	r2, [r3, #4]
  2031bc:	9b01      	ldr	r3, [sp, #4]
  2031be:	615a      	str	r2, [r3, #20]
  tp->waend  = (void *)tdp->wend;
  2031c0:	9b00      	ldr	r3, [sp, #0]
  2031c2:	689a      	ldr	r2, [r3, #8]
  2031c4:	9b01      	ldr	r3, [sp, #4]
  2031c6:	619a      	str	r2, [r3, #24]

  /* Thread-related fields.*/
  tp->hdr.pqueue.prio   = tdp->prio;
  2031c8:	9b00      	ldr	r3, [sp, #0]
  2031ca:	68da      	ldr	r2, [r3, #12]
  2031cc:	9b01      	ldr	r3, [sp, #4]
  2031ce:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
  2031d0:	9b01      	ldr	r3, [sp, #4]
  2031d2:	2202      	movs	r2, #2
  2031d4:	771a      	strb	r2, [r3, #28]
  tp->flags             = (tmode_t)0;
  2031d6:	9b01      	ldr	r3, [sp, #4]
  2031d8:	2200      	movs	r2, #0
  2031da:	775a      	strb	r2, [r3, #29]
  if (tdp->owner != NULL) {
  2031dc:	9b00      	ldr	r3, [sp, #0]
  2031de:	699b      	ldr	r3, [r3, #24]
  2031e0:	2b00      	cmp	r3, #0
  2031e2:	d004      	beq.n	2031ee <chThdObjectInit+0x3e>
    tp->owner           = tdp->owner;
  2031e4:	9b00      	ldr	r3, [sp, #0]
  2031e6:	699a      	ldr	r2, [r3, #24]
  2031e8:	9b01      	ldr	r3, [sp, #4]
  2031ea:	611a      	str	r2, [r3, #16]
  2031ec:	e002      	b.n	2031f4 <chThdObjectInit+0x44>
  }
  else {
    tp->owner           = currcore;
  2031ee:	9b01      	ldr	r3, [sp, #4]
  2031f0:	4a13      	ldr	r2, [pc, #76]	@ (203240 <chThdObjectInit+0x90>)
  2031f2:	611a      	str	r2, [r3, #16]
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->dispose           = NULL;
  2031f4:	9b01      	ldr	r3, [sp, #4]
  2031f6:	2200      	movs	r2, #0
  2031f8:	62da      	str	r2, [r3, #44]	@ 0x2c
  tp->object            = NULL;
  2031fa:	9b01      	ldr	r3, [sp, #4]
  2031fc:	2200      	movs	r2, #0
  2031fe:	631a      	str	r2, [r3, #48]	@ 0x30
#endif
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
  203200:	9b01      	ldr	r3, [sp, #4]
  203202:	3338      	adds	r3, #56	@ 0x38
  203204:	4618      	mov	r0, r3
  203206:	f7ff fedb 	bl	202fc0 <ch_list_init>
#endif

  /* Mutex-related fields.*/
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = tdp->prio;
  20320a:	9b00      	ldr	r3, [sp, #0]
  20320c:	68da      	ldr	r2, [r3, #12]
  20320e:	9b01      	ldr	r3, [sp, #4]
  203210:	64da      	str	r2, [r3, #76]	@ 0x4c
  tp->mtxlist           = NULL;
  203212:	9b01      	ldr	r3, [sp, #4]
  203214:	2200      	movs	r2, #0
  203216:	649a      	str	r2, [r3, #72]	@ 0x48
#endif

  /* Events-related fields.*/
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
  203218:	9b01      	ldr	r3, [sp, #4]
  20321a:	2200      	movs	r2, #0
  20321c:	645a      	str	r2, [r3, #68]	@ 0x44
  tp->time              = (systime_t)0;
#endif

  /* Registry-related fields.*/
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
  20321e:	9b01      	ldr	r3, [sp, #4]
  203220:	2201      	movs	r2, #1
  203222:	779a      	strb	r2, [r3, #30]
  tp->name              = tdp->name;
  203224:	9b00      	ldr	r3, [sp, #0]
  203226:	681a      	ldr	r2, [r3, #0]
  203228:	9b01      	ldr	r3, [sp, #4]
  20322a:	621a      	str	r2, [r3, #32]
#endif

  /* Messages-related fields.*/
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
  20322c:	9b01      	ldr	r3, [sp, #4]
  20322e:	333c      	adds	r3, #60	@ 0x3c
  203230:	4618      	mov	r0, r3
  203232:	f7ff fefd 	bl	203030 <ch_queue_init.lto_priv.1>
#endif

  /* Custom thread initialization code.*/
  CH_CFG_THREAD_INIT_HOOK(tp);

  return tp;
  203236:	9b01      	ldr	r3, [sp, #4]
}
  203238:	4618      	mov	r0, r3
  20323a:	b003      	add	sp, #12
  20323c:	f85d fb04 	ldr.w	pc, [sp], #4
  203240:	20000890 	.word	0x20000890
	...

00203250 <chThdSpawnSuspendedI>:
 * @return              Reference to the @p thread_t object.
 *
 * @api
 */
thread_t *chThdSpawnSuspendedI(thread_t *tp,
                               const thread_descriptor_t *tdp) {
  203250:	b500      	push	{lr}
  203252:	b083      	sub	sp, #12
  203254:	9001      	str	r0, [sp, #4]
  203256:	9100      	str	r1, [sp, #0]
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_STACK_SIZE(0)));

  /* Thread object initialization.*/
  tp = chThdObjectInit(tp, tdp);
  203258:	9900      	ldr	r1, [sp, #0]
  20325a:	9801      	ldr	r0, [sp, #4]
  20325c:	f7ff ffa8 	bl	2031b0 <chThdObjectInit>
  203260:	9001      	str	r0, [sp, #4]

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tp->wabase, tp->waend, tdp->funcp, tdp->arg);
  203262:	9b01      	ldr	r3, [sp, #4]
  203264:	699b      	ldr	r3, [r3, #24]
  203266:	f1a3 0264 	sub.w	r2, r3, #100	@ 0x64
  20326a:	9b01      	ldr	r3, [sp, #4]
  20326c:	60da      	str	r2, [r3, #12]
  20326e:	9b00      	ldr	r3, [sp, #0]
  203270:	691a      	ldr	r2, [r3, #16]
  203272:	9b01      	ldr	r3, [sp, #4]
  203274:	68db      	ldr	r3, [r3, #12]
  203276:	641a      	str	r2, [r3, #64]	@ 0x40
  203278:	9b00      	ldr	r3, [sp, #0]
  20327a:	695a      	ldr	r2, [r3, #20]
  20327c:	9b01      	ldr	r3, [sp, #4]
  20327e:	68db      	ldr	r3, [r3, #12]
  203280:	645a      	str	r2, [r3, #68]	@ 0x44
  203282:	9b01      	ldr	r3, [sp, #4]
  203284:	68db      	ldr	r3, [r3, #12]
  203286:	4a08      	ldr	r2, [pc, #32]	@ (2032a8 <chThdSpawnSuspendedI+0x58>)
  203288:	661a      	str	r2, [r3, #96]	@ 0x60

  /* Registry-related fields.*/
#if CH_CFG_USE_REGISTRY == TRUE
  REG_INSERT(tp->owner, tp);
  20328a:	9b01      	ldr	r3, [sp, #4]
  20328c:	691b      	ldr	r3, [r3, #16]
  20328e:	f103 0230 	add.w	r2, r3, #48	@ 0x30
  203292:	9b01      	ldr	r3, [sp, #4]
  203294:	3324      	adds	r3, #36	@ 0x24
  203296:	4619      	mov	r1, r3
  203298:	4610      	mov	r0, r2
  20329a:	f7ff fee9 	bl	203070 <ch_queue_insert.lto_priv.1>
#endif

  return tp;
  20329e:	9b01      	ldr	r3, [sp, #4]
}
  2032a0:	4618      	mov	r0, r3
  2032a2:	b003      	add	sp, #12
  2032a4:	f85d fb04 	ldr.w	pc, [sp], #4
  2032a8:	0020033d 	.word	0x0020033d
  2032ac:	00000000 	.word	0x00000000

002032b0 <chThdSpawnRunningI>:
 * @param[in] tdp       pointer to a @p thread_descriptor_t object
 * @return              Reference to the @p thread_t object.
 *
 * @iclass
 */
thread_t *chThdSpawnRunningI(thread_t *tp, const thread_descriptor_t *tdp) {
  2032b0:	b500      	push	{lr}
  2032b2:	b083      	sub	sp, #12
  2032b4:	9001      	str	r0, [sp, #4]
  2032b6:	9100      	str	r1, [sp, #0]

  return chSchReadyI(chThdSpawnSuspendedI(tp, tdp));
  2032b8:	9900      	ldr	r1, [sp, #0]
  2032ba:	9801      	ldr	r0, [sp, #4]
  2032bc:	f7ff ffc8 	bl	203250 <chThdSpawnSuspendedI>
  2032c0:	4603      	mov	r3, r0
  2032c2:	4618      	mov	r0, r3
  2032c4:	f7ff fc34 	bl	202b30 <chSchReadyI>
  2032c8:	4603      	mov	r3, r0
}
  2032ca:	4618      	mov	r0, r3
  2032cc:	b003      	add	sp, #12
  2032ce:	f85d fb04 	ldr.w	pc, [sp], #4
  2032d2:	bf00      	nop
	...

002032e0 <chThdCreateSuspendedI>:
 * @param[in] tdp       pointer to a @p thread_descriptor_t object
 * @return              Reference to the @p thread_t object.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  2032e0:	b500      	push	{lr}
  2032e2:	b087      	sub	sp, #28
  2032e4:	9001      	str	r0, [sp, #4]

  /* Stack area addresses.
     The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure must be aligned to the required
     stack alignment because it represents the stack top.*/
  stkbase = (uint8_t *)tdp->wbase;
  2032e6:	9b01      	ldr	r3, [sp, #4]
  2032e8:	685b      	ldr	r3, [r3, #4]
  2032ea:	9304      	str	r3, [sp, #16]
  stktop  = (uint8_t *)tdp->wend -
  2032ec:	9b01      	ldr	r3, [sp, #4]
  2032ee:	689b      	ldr	r3, [r3, #8]
  2032f0:	3b60      	subs	r3, #96	@ 0x60
  2032f2:	9303      	str	r3, [sp, #12]
            MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN);
  chDbgCheck(MEM_IS_ALIGNED(stkbase, PORT_WORKING_AREA_ALIGN) &&
             MEM_IS_ALIGNED(stktop, PORT_STACK_ALIGN));

  /* The thread object is initialized but not started.*/
  tp = chThdObjectInit(threadref(stktop), tdp);
  2032f4:	9901      	ldr	r1, [sp, #4]
  2032f6:	9803      	ldr	r0, [sp, #12]
  2032f8:	f7ff ff5a 	bl	2031b0 <chThdObjectInit>
  2032fc:	9005      	str	r0, [sp, #20]

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, stkbase, tp, tdp->funcp, tdp->arg);
  2032fe:	9b05      	ldr	r3, [sp, #20]
  203300:	f1a3 0264 	sub.w	r2, r3, #100	@ 0x64
  203304:	9b05      	ldr	r3, [sp, #20]
  203306:	60da      	str	r2, [r3, #12]
  203308:	9b01      	ldr	r3, [sp, #4]
  20330a:	691a      	ldr	r2, [r3, #16]
  20330c:	9b05      	ldr	r3, [sp, #20]
  20330e:	68db      	ldr	r3, [r3, #12]
  203310:	641a      	str	r2, [r3, #64]	@ 0x40
  203312:	9b01      	ldr	r3, [sp, #4]
  203314:	695a      	ldr	r2, [r3, #20]
  203316:	9b05      	ldr	r3, [sp, #20]
  203318:	68db      	ldr	r3, [r3, #12]
  20331a:	645a      	str	r2, [r3, #68]	@ 0x44
  20331c:	9b05      	ldr	r3, [sp, #20]
  20331e:	68db      	ldr	r3, [r3, #12]
  203320:	4a08      	ldr	r2, [pc, #32]	@ (203344 <chThdCreateSuspendedI+0x64>)
  203322:	661a      	str	r2, [r3, #96]	@ 0x60

#if CH_CFG_USE_REGISTRY == TRUE
  REG_INSERT(tp->owner, tp);
  203324:	9b05      	ldr	r3, [sp, #20]
  203326:	691b      	ldr	r3, [r3, #16]
  203328:	f103 0230 	add.w	r2, r3, #48	@ 0x30
  20332c:	9b05      	ldr	r3, [sp, #20]
  20332e:	3324      	adds	r3, #36	@ 0x24
  203330:	4619      	mov	r1, r3
  203332:	4610      	mov	r0, r2
  203334:	f7ff fe9c 	bl	203070 <ch_queue_insert.lto_priv.1>
#endif

  return tp;
  203338:	9b05      	ldr	r3, [sp, #20]
}
  20333a:	4618      	mov	r0, r3
  20333c:	b007      	add	sp, #28
  20333e:	f85d fb04 	ldr.w	pc, [sp], #4
  203342:	bf00      	nop
  203344:	0020033d 	.word	0x0020033d
	...

00203350 <chThdCreate>:
 * @param[in] tdp       pointer to a @p thread_descriptor_t object
 * @return              Reference to the @p thread_t object.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  203350:	b500      	push	{lr}
  203352:	b085      	sub	sp, #20
  203354:	9001      	str	r0, [sp, #4]

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)tdp->wbase, (uint8_t *)tdp->wend);
#endif

  chSysLock();
  203356:	f7ff fed3 	bl	203100 <chSysLock.lto_priv.4>
  tp = chThdCreateSuspendedI(tdp);
  20335a:	9801      	ldr	r0, [sp, #4]
  20335c:	f7ff ffc0 	bl	2032e0 <chThdCreateSuspendedI>
  203360:	9003      	str	r0, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
  203362:	2100      	movs	r1, #0
  203364:	9803      	ldr	r0, [sp, #12]
  203366:	f7ff fc53 	bl	202c10 <chSchWakeupS>
  chSysUnlock();
  20336a:	f7ff fed9 	bl	203120 <chSysUnlock.lto_priv.4>

  return tp;
  20336e:	9b03      	ldr	r3, [sp, #12]
}
  203370:	4618      	mov	r0, r3
  203372:	b005      	add	sp, #20
  203374:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00203380 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(stkline_t *wbase, size_t wsize,
                            tprio_t prio, tfunc_t func, void *arg) {
  203380:	b500      	push	{lr}
  203382:	b091      	sub	sp, #68	@ 0x44
  203384:	9003      	str	r0, [sp, #12]
  203386:	9102      	str	r1, [sp, #8]
  203388:	9201      	str	r2, [sp, #4]
  20338a:	9300      	str	r3, [sp, #0]
  chDbgAssert(chRegFindThreadByWorkingArea(wbase) == NULL,
              "working area in use");
#endif

  /* Working area end address.*/
  wend = (uint8_t *)wbase + wsize;
  20338c:	9a03      	ldr	r2, [sp, #12]
  20338e:	9b02      	ldr	r3, [sp, #8]
  203390:	4413      	add	r3, r2
  203392:	930e      	str	r3, [sp, #56]	@ 0x38

  /* Stack area addresses.
     The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure must be aligned to the required
     stack alignment because it represents the stack top.*/
  stkbase = (uint8_t *)wbase;
  203394:	9b03      	ldr	r3, [sp, #12]
  203396:	930d      	str	r3, [sp, #52]	@ 0x34
  stktop  = wend - MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN);
  203398:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  20339a:	3b60      	subs	r3, #96	@ 0x60
  20339c:	930c      	str	r3, [sp, #48]	@ 0x30
  /* Filling the thread stack area.*/
  __thd_stackfill(stkbase, stktop);
#endif

  /* Initializing the thread_t structure using the passed parameters.*/
  THD_DESC_DECL(desc, "noname", wbase, wend, prio, func, arg, currcore, NULL);
  20339e:	4b1e      	ldr	r3, [pc, #120]	@ (203418 <chThdCreateStatic+0x98>)
  2033a0:	9305      	str	r3, [sp, #20]
  2033a2:	9b03      	ldr	r3, [sp, #12]
  2033a4:	9306      	str	r3, [sp, #24]
  2033a6:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  2033a8:	9307      	str	r3, [sp, #28]
  2033aa:	9b01      	ldr	r3, [sp, #4]
  2033ac:	9308      	str	r3, [sp, #32]
  2033ae:	9b00      	ldr	r3, [sp, #0]
  2033b0:	9309      	str	r3, [sp, #36]	@ 0x24
  2033b2:	9b12      	ldr	r3, [sp, #72]	@ 0x48
  2033b4:	930a      	str	r3, [sp, #40]	@ 0x28
  2033b6:	4b19      	ldr	r3, [pc, #100]	@ (20341c <chThdCreateStatic+0x9c>)
  2033b8:	930b      	str	r3, [sp, #44]	@ 0x2c
  tp = chThdObjectInit(threadref(stktop), &desc);
  2033ba:	ab05      	add	r3, sp, #20
  2033bc:	4619      	mov	r1, r3
  2033be:	980c      	ldr	r0, [sp, #48]	@ 0x30
  2033c0:	f7ff fef6 	bl	2031b0 <chThdObjectInit>
  2033c4:	900f      	str	r0, [sp, #60]	@ 0x3c

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wbase, tp, func, arg);
  2033c6:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  2033c8:	f1a3 0264 	sub.w	r2, r3, #100	@ 0x64
  2033cc:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  2033ce:	60da      	str	r2, [r3, #12]
  2033d0:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  2033d2:	68db      	ldr	r3, [r3, #12]
  2033d4:	9a00      	ldr	r2, [sp, #0]
  2033d6:	641a      	str	r2, [r3, #64]	@ 0x40
  2033d8:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  2033da:	68db      	ldr	r3, [r3, #12]
  2033dc:	9a12      	ldr	r2, [sp, #72]	@ 0x48
  2033de:	645a      	str	r2, [r3, #68]	@ 0x44
  2033e0:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  2033e2:	68db      	ldr	r3, [r3, #12]
  2033e4:	4a0e      	ldr	r2, [pc, #56]	@ (203420 <chThdCreateStatic+0xa0>)
  2033e6:	661a      	str	r2, [r3, #96]	@ 0x60

  chSysLock();
  2033e8:	f7ff fe8a 	bl	203100 <chSysLock.lto_priv.4>

#if CH_CFG_USE_REGISTRY == TRUE
  REG_INSERT(tp->owner, tp);
  2033ec:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  2033ee:	691b      	ldr	r3, [r3, #16]
  2033f0:	f103 0230 	add.w	r2, r3, #48	@ 0x30
  2033f4:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  2033f6:	3324      	adds	r3, #36	@ 0x24
  2033f8:	4619      	mov	r1, r3
  2033fa:	4610      	mov	r0, r2
  2033fc:	f7ff fe38 	bl	203070 <ch_queue_insert.lto_priv.1>
#endif

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
  203400:	2100      	movs	r1, #0
  203402:	980f      	ldr	r0, [sp, #60]	@ 0x3c
  203404:	f7ff fc04 	bl	202c10 <chSchWakeupS>
  chSysUnlock();
  203408:	f7ff fe8a 	bl	203120 <chSysUnlock.lto_priv.4>

  return tp;
  20340c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
}
  20340e:	4618      	mov	r0, r3
  203410:	b011      	add	sp, #68	@ 0x44
  203412:	f85d fb04 	ldr.w	pc, [sp], #4
  203416:	bf00      	nop
  203418:	08010ba8 	.word	0x08010ba8
  20341c:	20000890 	.word	0x20000890
  203420:	0020033d 	.word	0x0020033d
	...

00203430 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
  203430:	b500      	push	{lr}
  203432:	b083      	sub	sp, #12
  203434:	9001      	str	r0, [sp, #4]

  chSysLock();
  203436:	f7ff fe63 	bl	203100 <chSysLock.lto_priv.4>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  tp->refs--;
  20343a:	9b01      	ldr	r3, [sp, #4]
  20343c:	7f9b      	ldrb	r3, [r3, #30]
  20343e:	3b01      	subs	r3, #1
  203440:	b2da      	uxtb	r2, r3
  203442:	9b01      	ldr	r3, [sp, #4]
  203444:	779a      	strb	r2, [r3, #30]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
  203446:	9b01      	ldr	r3, [sp, #4]
  203448:	7f9b      	ldrb	r3, [r3, #30]
  20344a:	2b00      	cmp	r3, #0
  20344c:	d113      	bne.n	203476 <chThdRelease+0x46>
  20344e:	9b01      	ldr	r3, [sp, #4]
  203450:	7f1b      	ldrb	r3, [r3, #28]
  203452:	2b0f      	cmp	r3, #15
  203454:	d10f      	bne.n	203476 <chThdRelease+0x46>

    /* Removing from registry.*/
    REG_REMOVE(tp);
  203456:	9b01      	ldr	r3, [sp, #4]
  203458:	3324      	adds	r3, #36	@ 0x24
  20345a:	4618      	mov	r0, r3
  20345c:	f7ff fe38 	bl	2030d0 <ch_queue_dequeue.lto_priv.1>
    chSysUnlock();
  203460:	f7ff fe5e 	bl	203120 <chSysUnlock.lto_priv.4>

#if (CH_CFG_USE_DYNAMIC == TRUE) || defined(__DOXYGEN__)
    /* Calling thread dispose function, if any.*/
    if (tp->dispose != NULL) {
  203464:	9b01      	ldr	r3, [sp, #4]
  203466:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  203468:	2b00      	cmp	r3, #0
  20346a:	d007      	beq.n	20347c <chThdRelease+0x4c>
      tp->dispose(tp);
  20346c:	9b01      	ldr	r3, [sp, #4]
  20346e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  203470:	9801      	ldr	r0, [sp, #4]
  203472:	4798      	blx	r3
    }
#endif

    return;
  203474:	e002      	b.n	20347c <chThdRelease+0x4c>
  }
  chSysUnlock();
  203476:	f7ff fe53 	bl	203120 <chSysUnlock.lto_priv.4>
  20347a:	e000      	b.n	20347e <chThdRelease+0x4e>
    return;
  20347c:	bf00      	nop
}
  20347e:	b003      	add	sp, #12
  203480:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00203490 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
  203490:	b500      	push	{lr}
  203492:	b083      	sub	sp, #12
  203494:	9001      	str	r0, [sp, #4]

  chSysLock();
  203496:	f7ff fe33 	bl	203100 <chSysLock.lto_priv.4>
  chThdExitS(msg);
  20349a:	9801      	ldr	r0, [sp, #4]
  20349c:	f000 f808 	bl	2034b0 <chThdExitS>
  /* The thread never returns here.*/
}
  2034a0:	bf00      	nop
  2034a2:	b003      	add	sp, #12
  2034a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002034b0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  2034b0:	b500      	push	{lr}
  2034b2:	b085      	sub	sp, #20
  2034b4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  2034b6:	f7ff fe4b 	bl	203150 <chThdGetSelfX.lto_priv.0>
  2034ba:	9003      	str	r0, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
  2034bc:	9b03      	ldr	r3, [sp, #12]
  2034be:	9a01      	ldr	r2, [sp, #4]
  2034c0:	635a      	str	r2, [r3, #52]	@ 0x34
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
  2034c2:	e008      	b.n	2034d6 <chThdExitS+0x26>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
  2034c4:	9b03      	ldr	r3, [sp, #12]
  2034c6:	3338      	adds	r3, #56	@ 0x38
  2034c8:	4618      	mov	r0, r3
  2034ca:	f7ff fda1 	bl	203010 <ch_list_unlink>
  2034ce:	4603      	mov	r3, r0
  2034d0:	4618      	mov	r0, r3
  2034d2:	f7ff fb2d 	bl	202b30 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
  2034d6:	9b03      	ldr	r3, [sp, #12]
  2034d8:	3338      	adds	r3, #56	@ 0x38
  2034da:	4618      	mov	r0, r3
  2034dc:	f7ff fd78 	bl	202fd0 <ch_list_notempty>
  2034e0:	4603      	mov	r3, r0
  2034e2:	2b00      	cmp	r3, #0
  2034e4:	d1ee      	bne.n	2034c4 <chThdExitS+0x14>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
  2034e6:	9b03      	ldr	r3, [sp, #12]
  2034e8:	7f9b      	ldrb	r3, [r3, #30]
  2034ea:	2b00      	cmp	r3, #0
  2034ec:	bf0c      	ite	eq
  2034ee:	2301      	moveq	r3, #1
  2034f0:	2300      	movne	r3, #0
  2034f2:	b2db      	uxtb	r3, r3
  2034f4:	2b00      	cmp	r3, #0
  2034f6:	d008      	beq.n	20350a <chThdExitS+0x5a>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Threads without a dispose callback are immediately removed from the
       registry because there is no memory to be recovered.*/
    if (currtp->dispose == NULL) {
  2034f8:	9b03      	ldr	r3, [sp, #12]
  2034fa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  2034fc:	2b00      	cmp	r3, #0
  2034fe:	d104      	bne.n	20350a <chThdExitS+0x5a>
      REG_REMOVE(currtp);
  203500:	9b03      	ldr	r3, [sp, #12]
  203502:	3324      	adds	r3, #36	@ 0x24
  203504:	4618      	mov	r0, r3
  203506:	f7ff fde3 	bl	2030d0 <ch_queue_dequeue.lto_priv.1>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
  20350a:	200f      	movs	r0, #15
  20350c:	f7ff fb20 	bl	202b50 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
  203510:	bf00      	nop
  203512:	b005      	add	sp, #20
  203514:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00203520 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
  203520:	b500      	push	{lr}
  203522:	b085      	sub	sp, #20
  203524:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  203526:	f7ff fe13 	bl	203150 <chThdGetSelfX.lto_priv.0>
  20352a:	9002      	str	r0, [sp, #8]
  msg_t msg;

  chDbgCheck(tp != NULL);

  chSysLock();
  20352c:	f7ff fde8 	bl	203100 <chSysLock.lto_priv.4>
  chDbgAssert(tp != currtp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
#endif

  if (likely(tp->state != CH_STATE_FINAL)) {
  203530:	9b01      	ldr	r3, [sp, #4]
  203532:	7f1b      	ldrb	r3, [r3, #28]
  203534:	2b0f      	cmp	r3, #15
  203536:	bf14      	ite	ne
  203538:	2301      	movne	r3, #1
  20353a:	2300      	moveq	r3, #0
  20353c:	b2db      	uxtb	r3, r3
  20353e:	2b00      	cmp	r3, #0
  203540:	d009      	beq.n	203556 <chThdWait+0x36>
    ch_list_link(&tp->waiting, &currtp->hdr.list);
  203542:	9b01      	ldr	r3, [sp, #4]
  203544:	3338      	adds	r3, #56	@ 0x38
  203546:	9a02      	ldr	r2, [sp, #8]
  203548:	4611      	mov	r1, r2
  20354a:	4618      	mov	r0, r3
  20354c:	f7ff fd50 	bl	202ff0 <ch_list_link>
    chSchGoSleepS(CH_STATE_WTEXIT);
  203550:	2009      	movs	r0, #9
  203552:	f7ff fafd 	bl	202b50 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
  203556:	9b01      	ldr	r3, [sp, #4]
  203558:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  20355a:	9303      	str	r3, [sp, #12]
  chSysUnlock();
  20355c:	f7ff fde0 	bl	203120 <chSysUnlock.lto_priv.4>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
  203560:	9801      	ldr	r0, [sp, #4]
  203562:	f7ff ff65 	bl	203430 <chThdRelease>
#endif

  return msg;
  203566:	9b03      	ldr	r3, [sp, #12]
}
  203568:	4618      	mov	r0, r3
  20356a:	b005      	add	sp, #20
  20356c:	f85d fb04 	ldr.w	pc, [sp], #4

00203570 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
  203570:	b500      	push	{lr}
  203572:	b085      	sub	sp, #20
  203574:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  203576:	f7ff fdeb 	bl	203150 <chThdGetSelfX.lto_priv.0>
  20357a:	9003      	str	r0, [sp, #12]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
  20357c:	f7ff fdc0 	bl	203100 <chSysLock.lto_priv.4>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currtp->realprio;
  203580:	9b03      	ldr	r3, [sp, #12]
  203582:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
  203584:	9302      	str	r3, [sp, #8]
  if ((currtp->hdr.pqueue.prio == currtp->realprio) ||
  203586:	9b03      	ldr	r3, [sp, #12]
  203588:	689a      	ldr	r2, [r3, #8]
  20358a:	9b03      	ldr	r3, [sp, #12]
  20358c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
  20358e:	429a      	cmp	r2, r3
  203590:	d004      	beq.n	20359c <chThdSetPriority+0x2c>
      (newprio > currtp->hdr.pqueue.prio)) {
  203592:	9b03      	ldr	r3, [sp, #12]
  203594:	689b      	ldr	r3, [r3, #8]
  if ((currtp->hdr.pqueue.prio == currtp->realprio) ||
  203596:	9a01      	ldr	r2, [sp, #4]
  203598:	429a      	cmp	r2, r3
  20359a:	d902      	bls.n	2035a2 <chThdSetPriority+0x32>
    currtp->hdr.pqueue.prio = newprio;
  20359c:	9b03      	ldr	r3, [sp, #12]
  20359e:	9a01      	ldr	r2, [sp, #4]
  2035a0:	609a      	str	r2, [r3, #8]
  }
  currtp->realprio = newprio;
  2035a2:	9b03      	ldr	r3, [sp, #12]
  2035a4:	9a01      	ldr	r2, [sp, #4]
  2035a6:	64da      	str	r2, [r3, #76]	@ 0x4c
#else
  oldprio = currtp->hdr.pqueue.prio;
  currtp->hdr.pqueue.prio = newprio;
#endif
  chSchRescheduleS();
  2035a8:	f7ff fb62 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  2035ac:	f7ff fdb8 	bl	203120 <chSysUnlock.lto_priv.4>

  return oldprio;
  2035b0:	9b02      	ldr	r3, [sp, #8]
}
  2035b2:	4618      	mov	r0, r3
  2035b4:	b005      	add	sp, #20
  2035b6:	f85d fb04 	ldr.w	pc, [sp], #4
  2035ba:	bf00      	nop
  2035bc:	0000      	movs	r0, r0
	...

002035c0 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(thread_t *tp) {
  2035c0:	b500      	push	{lr}
  2035c2:	b083      	sub	sp, #12
  2035c4:	9001      	str	r0, [sp, #4]

  chSysLock();
  2035c6:	f7ff fd9b 	bl	203100 <chSysLock.lto_priv.4>
  tp->flags |= CH_FLAGS_TERMINATE;
  2035ca:	9b01      	ldr	r3, [sp, #4]
  2035cc:	7f5b      	ldrb	r3, [r3, #29]
  2035ce:	f063 037f 	orn	r3, r3, #127	@ 0x7f
  2035d2:	b2da      	uxtb	r2, r3
  2035d4:	9b01      	ldr	r3, [sp, #4]
  2035d6:	775a      	strb	r2, [r3, #29]
  chSysUnlock();
  2035d8:	f7ff fda2 	bl	203120 <chSysUnlock.lto_priv.4>
}
  2035dc:	bf00      	nop
  2035de:	b003      	add	sp, #12
  2035e0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002035f0 <chThdSleep>:
 *                        state.
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
  2035f0:	b500      	push	{lr}
  2035f2:	b083      	sub	sp, #12
  2035f4:	9001      	str	r0, [sp, #4]

  chSysLock();
  2035f6:	f7ff fd83 	bl	203100 <chSysLock.lto_priv.4>
  chThdSleepS(time);
  2035fa:	9801      	ldr	r0, [sp, #4]
  2035fc:	f7ff fdb0 	bl	203160 <chThdSleepS>
  chSysUnlock();
  203600:	f7ff fd8e 	bl	203120 <chSysUnlock.lto_priv.4>
}
  203604:	bf00      	nop
  203606:	b003      	add	sp, #12
  203608:	f85d fb04 	ldr.w	pc, [sp], #4
  20360c:	0000      	movs	r0, r0
	...

00203610 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
  203610:	b500      	push	{lr}
  203612:	b085      	sub	sp, #20
  203614:	9001      	str	r0, [sp, #4]
  sysinterval_t interval;

  chSysLock();
  203616:	f7ff fd73 	bl	203100 <chSysLock.lto_priv.4>
  interval = chTimeDiffX(chVTGetSystemTimeX(), time);
  20361a:	f7ff fd91 	bl	203140 <chVTGetSystemTimeX.lto_priv.2>
  20361e:	4603      	mov	r3, r0
  203620:	9901      	ldr	r1, [sp, #4]
  203622:	4618      	mov	r0, r3
  203624:	f7ff fcbc 	bl	202fa0 <chTimeDiffX.lto_priv.1>
  203628:	9003      	str	r0, [sp, #12]
  if (likely(interval > (sysinterval_t)0)) {
  20362a:	9b03      	ldr	r3, [sp, #12]
  20362c:	2b00      	cmp	r3, #0
  20362e:	bf14      	ite	ne
  203630:	2301      	movne	r3, #1
  203632:	2300      	moveq	r3, #0
  203634:	b2db      	uxtb	r3, r3
  203636:	2b00      	cmp	r3, #0
  203638:	d002      	beq.n	203640 <chThdSleepUntil+0x30>
    chThdSleepS(interval);
  20363a:	9803      	ldr	r0, [sp, #12]
  20363c:	f7ff fd90 	bl	203160 <chThdSleepS>
  }
  chSysUnlock();
  203640:	f7ff fd6e 	bl	203120 <chSysUnlock.lto_priv.4>
}
  203644:	bf00      	nop
  203646:	b005      	add	sp, #20
  203648:	f85d fb04 	ldr.w	pc, [sp], #4
  20364c:	0000      	movs	r0, r0
	...

00203650 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
  203650:	b508      	push	{r3, lr}

  chSysLock();
  203652:	f7ff fd55 	bl	203100 <chSysLock.lto_priv.4>
  chSchDoYieldS();
  203656:	f7ff fb6b 	bl	202d30 <chSchDoYieldS>
  chSysUnlock();
  20365a:	f7ff fd61 	bl	203120 <chSysUnlock.lto_priv.4>
}
  20365e:	bf00      	nop
  203660:	bd08      	pop	{r3, pc}
  203662:	bf00      	nop
	...

00203670 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
  203670:	b500      	push	{lr}
  203672:	b085      	sub	sp, #20
  203674:	9001      	str	r0, [sp, #4]
  203676:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
  203678:	f7ff fd6a 	bl	203150 <chThdGetSelfX.lto_priv.0>
  20367c:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  if (unlikely(TIME_IMMEDIATE == timeout)) {
  20367e:	9b00      	ldr	r3, [sp, #0]
  203680:	2b00      	cmp	r3, #0
  203682:	bf0c      	ite	eq
  203684:	2301      	moveq	r3, #1
  203686:	2300      	movne	r3, #0
  203688:	b2db      	uxtb	r3, r3
  20368a:	2b00      	cmp	r3, #0
  20368c:	d002      	beq.n	203694 <chThdSuspendTimeoutS+0x24>
    return MSG_TIMEOUT;
  20368e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  203692:	e00a      	b.n	2036aa <chThdSuspendTimeoutS+0x3a>
  }

  *trp = tp;
  203694:	9b01      	ldr	r3, [sp, #4]
  203696:	9a03      	ldr	r2, [sp, #12]
  203698:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
  20369a:	9b03      	ldr	r3, [sp, #12]
  20369c:	9a01      	ldr	r2, [sp, #4]
  20369e:	635a      	str	r2, [r3, #52]	@ 0x34

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
  2036a0:	9900      	ldr	r1, [sp, #0]
  2036a2:	2003      	movs	r0, #3
  2036a4:	f7ff fa7c 	bl	202ba0 <chSchGoSleepTimeoutS>
  2036a8:	4603      	mov	r3, r0
}
  2036aa:	4618      	mov	r0, r3
  2036ac:	b005      	add	sp, #20
  2036ae:	f85d fb04 	ldr.w	pc, [sp], #4
  2036b2:	bf00      	nop
	...

002036c0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
  2036c0:	b500      	push	{lr}
  2036c2:	b085      	sub	sp, #20
  2036c4:	9001      	str	r0, [sp, #4]
  2036c6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
  2036c8:	9b01      	ldr	r3, [sp, #4]
  2036ca:	681b      	ldr	r3, [r3, #0]
  2036cc:	2b00      	cmp	r3, #0
  2036ce:	d00b      	beq.n	2036e8 <chThdResumeI+0x28>
    thread_t *tp = *trp;
  2036d0:	9b01      	ldr	r3, [sp, #4]
  2036d2:	681b      	ldr	r3, [r3, #0]
  2036d4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
  2036d6:	9b01      	ldr	r3, [sp, #4]
  2036d8:	2200      	movs	r2, #0
  2036da:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
  2036dc:	9b03      	ldr	r3, [sp, #12]
  2036de:	9a00      	ldr	r2, [sp, #0]
  2036e0:	635a      	str	r2, [r3, #52]	@ 0x34
    (void) chSchReadyI(tp);
  2036e2:	9803      	ldr	r0, [sp, #12]
  2036e4:	f7ff fa24 	bl	202b30 <chSchReadyI>
  }
}
  2036e8:	bf00      	nop
  2036ea:	b005      	add	sp, #20
  2036ec:	f85d fb04 	ldr.w	pc, [sp], #4

002036f0 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
  2036f0:	b500      	push	{lr}
  2036f2:	b085      	sub	sp, #20
  2036f4:	9001      	str	r0, [sp, #4]
  2036f6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
  2036f8:	9b01      	ldr	r3, [sp, #4]
  2036fa:	681b      	ldr	r3, [r3, #0]
  2036fc:	2b00      	cmp	r3, #0
  2036fe:	d009      	beq.n	203714 <chThdResumeS+0x24>
    thread_t *tp = *trp;
  203700:	9b01      	ldr	r3, [sp, #4]
  203702:	681b      	ldr	r3, [r3, #0]
  203704:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
  203706:	9b01      	ldr	r3, [sp, #4]
  203708:	2200      	movs	r2, #0
  20370a:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
  20370c:	9900      	ldr	r1, [sp, #0]
  20370e:	9803      	ldr	r0, [sp, #12]
  203710:	f7ff fa7e 	bl	202c10 <chSchWakeupS>
  }
}
  203714:	bf00      	nop
  203716:	b005      	add	sp, #20
  203718:	f85d fb04 	ldr.w	pc, [sp], #4
  20371c:	0000      	movs	r0, r0
	...

00203720 <chThdResume>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
  203720:	b500      	push	{lr}
  203722:	b083      	sub	sp, #12
  203724:	9001      	str	r0, [sp, #4]
  203726:	9100      	str	r1, [sp, #0]

  chSysLock();
  203728:	f7ff fcea 	bl	203100 <chSysLock.lto_priv.4>
  chThdResumeS(trp, msg);
  20372c:	9900      	ldr	r1, [sp, #0]
  20372e:	9801      	ldr	r0, [sp, #4]
  203730:	f7ff ffde 	bl	2036f0 <chThdResumeS>
  chSysUnlock();
  203734:	f7ff fcf4 	bl	203120 <chSysUnlock.lto_priv.4>
}
  203738:	bf00      	nop
  20373a:	b003      	add	sp, #12
  20373c:	f85d fb04 	ldr.w	pc, [sp], #4

00203740 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to a @p threads_queue_t object
 *
 * @init
 */
void chThdQueueObjectInit(threads_queue_t *tqp) {
  203740:	b500      	push	{lr}
  203742:	b083      	sub	sp, #12
  203744:	9001      	str	r0, [sp, #4]

  chDbgCheck(tqp);

  ch_queue_init(&tqp->queue);
  203746:	9b01      	ldr	r3, [sp, #4]
  203748:	4618      	mov	r0, r3
  20374a:	f7ff fc71 	bl	203030 <ch_queue_init.lto_priv.1>
}
  20374e:	bf00      	nop
  203750:	b003      	add	sp, #12
  203752:	f85d fb04 	ldr.w	pc, [sp], #4
  203756:	bf00      	nop
	...

00203760 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
  203760:	b500      	push	{lr}
  203762:	b085      	sub	sp, #20
  203764:	9001      	str	r0, [sp, #4]
  203766:	9100      	str	r1, [sp, #0]
  thread_t *currtp = chThdGetSelfX();
  203768:	f7ff fcf2 	bl	203150 <chThdGetSelfX.lto_priv.0>
  20376c:	9003      	str	r0, [sp, #12]

  if (unlikely(TIME_IMMEDIATE == timeout)) {
  20376e:	9b00      	ldr	r3, [sp, #0]
  203770:	2b00      	cmp	r3, #0
  203772:	bf0c      	ite	eq
  203774:	2301      	moveq	r3, #1
  203776:	2300      	movne	r3, #0
  203778:	b2db      	uxtb	r3, r3
  20377a:	2b00      	cmp	r3, #0
  20377c:	d002      	beq.n	203784 <chThdEnqueueTimeoutS+0x24>
    return MSG_TIMEOUT;
  20377e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  203782:	e009      	b.n	203798 <chThdEnqueueTimeoutS+0x38>
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);
  203784:	9b01      	ldr	r3, [sp, #4]
  203786:	9903      	ldr	r1, [sp, #12]
  203788:	4618      	mov	r0, r3
  20378a:	f7ff fc71 	bl	203070 <ch_queue_insert.lto_priv.1>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  20378e:	9900      	ldr	r1, [sp, #0]
  203790:	2004      	movs	r0, #4
  203792:	f7ff fa05 	bl	202ba0 <chSchGoSleepTimeoutS>
  203796:	4603      	mov	r3, r0
}
  203798:	4618      	mov	r0, r3
  20379a:	b005      	add	sp, #20
  20379c:	f85d fb04 	ldr.w	pc, [sp], #4

002037a0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to a @p threads_queue_t object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  2037a0:	b500      	push	{lr}
  2037a2:	b083      	sub	sp, #12
  2037a4:	9001      	str	r0, [sp, #4]
  2037a6:	9100      	str	r1, [sp, #0]

  if (ch_queue_notempty(&tqp->queue)) {
  2037a8:	9b01      	ldr	r3, [sp, #4]
  2037aa:	4618      	mov	r0, r3
  2037ac:	f7ff fc50 	bl	203050 <ch_queue_notempty.lto_priv.0>
  2037b0:	4603      	mov	r3, r0
  2037b2:	2b00      	cmp	r3, #0
  2037b4:	d003      	beq.n	2037be <chThdDequeueNextI+0x1e>
    chThdDoDequeueNextI(tqp, msg);
  2037b6:	9900      	ldr	r1, [sp, #0]
  2037b8:	9801      	ldr	r0, [sp, #4]
  2037ba:	f7ff fce1 	bl	203180 <chThdDoDequeueNextI>
  }
}
  2037be:	bf00      	nop
  2037c0:	b003      	add	sp, #12
  2037c2:	f85d fb04 	ldr.w	pc, [sp], #4
  2037c6:	bf00      	nop
	...

002037d0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to a @p threads_queue_t object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
  2037d0:	b500      	push	{lr}
  2037d2:	b083      	sub	sp, #12
  2037d4:	9001      	str	r0, [sp, #4]
  2037d6:	9100      	str	r1, [sp, #0]

  while (ch_queue_notempty(&tqp->queue)) {
  2037d8:	e003      	b.n	2037e2 <chThdDequeueAllI+0x12>
    chThdDoDequeueNextI(tqp, msg);
  2037da:	9900      	ldr	r1, [sp, #0]
  2037dc:	9801      	ldr	r0, [sp, #4]
  2037de:	f7ff fccf 	bl	203180 <chThdDoDequeueNextI>
  while (ch_queue_notempty(&tqp->queue)) {
  2037e2:	9b01      	ldr	r3, [sp, #4]
  2037e4:	4618      	mov	r0, r3
  2037e6:	f7ff fc33 	bl	203050 <ch_queue_notempty.lto_priv.0>
  2037ea:	4603      	mov	r3, r0
  2037ec:	2b00      	cmp	r3, #0
  2037ee:	d1f4      	bne.n	2037da <chThdDequeueAllI+0xa>
  }
}
  2037f0:	bf00      	nop
  2037f2:	bf00      	nop
  2037f4:	b003      	add	sp, #12
  2037f6:	f85d fb04 	ldr.w	pc, [sp], #4
  2037fa:	bf00      	nop
  2037fc:	0000      	movs	r0, r0
	...

00203800 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
  203800:	b4f0      	push	{r4, r5, r6, r7}
  203802:	b084      	sub	sp, #16
  203804:	9003      	str	r0, [sp, #12]
  203806:	9102      	str	r1, [sp, #8]
  203808:	9201      	str	r2, [sp, #4]

  tmp->n++;
  20380a:	9b03      	ldr	r3, [sp, #12]
  20380c:	68db      	ldr	r3, [r3, #12]
  20380e:	1c5a      	adds	r2, r3, #1
  203810:	9b03      	ldr	r3, [sp, #12]
  203812:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
  203814:	9b03      	ldr	r3, [sp, #12]
  203816:	689b      	ldr	r3, [r3, #8]
  203818:	9a02      	ldr	r2, [sp, #8]
  20381a:	1ad2      	subs	r2, r2, r3
  20381c:	9b01      	ldr	r3, [sp, #4]
  20381e:	1ad2      	subs	r2, r2, r3
  203820:	9b03      	ldr	r3, [sp, #12]
  203822:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
  203824:	9b03      	ldr	r3, [sp, #12]
  203826:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
  20382a:	9903      	ldr	r1, [sp, #12]
  20382c:	6889      	ldr	r1, [r1, #8]
  20382e:	2000      	movs	r0, #0
  203830:	460c      	mov	r4, r1
  203832:	4605      	mov	r5, r0
  203834:	1916      	adds	r6, r2, r4
  203836:	eb43 0705 	adc.w	r7, r3, r5
  20383a:	9b03      	ldr	r3, [sp, #12]
  20383c:	e9c3 6704 	strd	r6, r7, [r3, #16]
  if (tmp->last > tmp->worst) {
  203840:	9b03      	ldr	r3, [sp, #12]
  203842:	689a      	ldr	r2, [r3, #8]
  203844:	9b03      	ldr	r3, [sp, #12]
  203846:	685b      	ldr	r3, [r3, #4]
  203848:	429a      	cmp	r2, r3
  20384a:	d903      	bls.n	203854 <tm_stop+0x54>
    tmp->worst = tmp->last;
  20384c:	9b03      	ldr	r3, [sp, #12]
  20384e:	689a      	ldr	r2, [r3, #8]
  203850:	9b03      	ldr	r3, [sp, #12]
  203852:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
  203854:	9b03      	ldr	r3, [sp, #12]
  203856:	689a      	ldr	r2, [r3, #8]
  203858:	9b03      	ldr	r3, [sp, #12]
  20385a:	681b      	ldr	r3, [r3, #0]
  20385c:	429a      	cmp	r2, r3
  20385e:	d203      	bcs.n	203868 <tm_stop+0x68>
    tmp->best = tmp->last;
  203860:	9b03      	ldr	r3, [sp, #12]
  203862:	689a      	ldr	r2, [r3, #8]
  203864:	9b03      	ldr	r3, [sp, #12]
  203866:	601a      	str	r2, [r3, #0]
  }
}
  203868:	bf00      	nop
  20386a:	b004      	add	sp, #16
  20386c:	bcf0      	pop	{r4, r5, r6, r7}
  20386e:	4770      	bx	lr

00203870 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p time_measurement_t object
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
  203870:	b082      	sub	sp, #8
  203872:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
  203874:	9b01      	ldr	r3, [sp, #4]
  203876:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20387a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
  20387c:	9b01      	ldr	r3, [sp, #4]
  20387e:	2200      	movs	r2, #0
  203880:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
  203882:	9b01      	ldr	r3, [sp, #4]
  203884:	2200      	movs	r2, #0
  203886:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
  203888:	9b01      	ldr	r3, [sp, #4]
  20388a:	2200      	movs	r2, #0
  20388c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
  20388e:	9901      	ldr	r1, [sp, #4]
  203890:	f04f 0200 	mov.w	r2, #0
  203894:	f04f 0300 	mov.w	r3, #0
  203898:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
  20389c:	bf00      	nop
  20389e:	b002      	add	sp, #8
  2038a0:	4770      	bx	lr
  2038a2:	bf00      	nop
	...

002038b0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t object
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
  2038b0:	b082      	sub	sp, #8
  2038b2:	9001      	str	r0, [sp, #4]
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
  2038b4:	4b03      	ldr	r3, [pc, #12]	@ (2038c4 <chTMStartMeasurementX+0x14>)
  2038b6:	685a      	ldr	r2, [r3, #4]

  tmp->last = chSysGetRealtimeCounterX();
  2038b8:	9b01      	ldr	r3, [sp, #4]
  2038ba:	609a      	str	r2, [r3, #8]
}
  2038bc:	bf00      	nop
  2038be:	b002      	add	sp, #8
  2038c0:	4770      	bx	lr
  2038c2:	bf00      	nop
  2038c4:	e0001000 	.word	0xe0001000
	...

002038d0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t object
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
  2038d0:	b500      	push	{lr}
  2038d2:	b083      	sub	sp, #12
  2038d4:	9001      	str	r0, [sp, #4]
  2038d6:	4b06      	ldr	r3, [pc, #24]	@ (2038f0 <chTMStopMeasurementX+0x20>)
  2038d8:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
  2038da:	4a06      	ldr	r2, [pc, #24]	@ (2038f4 <chTMStopMeasurementX+0x24>)
  2038dc:	6892      	ldr	r2, [r2, #8]
  2038de:	4619      	mov	r1, r3
  2038e0:	9801      	ldr	r0, [sp, #4]
  2038e2:	f7ff ff8d 	bl	203800 <tm_stop>
}
  2038e6:	bf00      	nop
  2038e8:	b003      	add	sp, #12
  2038ea:	f85d fb04 	ldr.w	pc, [sp], #4
  2038ee:	bf00      	nop
  2038f0:	e0001000 	.word	0xe0001000
  2038f4:	20000880 	.word	0x20000880
	...

00203900 <ch_queue_init.lto_priv.2>:
static inline void ch_queue_init(ch_queue_t *qp) {
  203900:	b082      	sub	sp, #8
  203902:	9001      	str	r0, [sp, #4]
  qp->next = qp;
  203904:	9b01      	ldr	r3, [sp, #4]
  203906:	9a01      	ldr	r2, [sp, #4]
  203908:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
  20390a:	9b01      	ldr	r3, [sp, #4]
  20390c:	9a01      	ldr	r2, [sp, #4]
  20390e:	605a      	str	r2, [r3, #4]
}
  203910:	bf00      	nop
  203912:	b002      	add	sp, #8
  203914:	4770      	bx	lr
  203916:	bf00      	nop
	...

00203920 <ch_queue_notempty.lto_priv.1>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
  203920:	b082      	sub	sp, #8
  203922:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
  203924:	9b01      	ldr	r3, [sp, #4]
  203926:	681b      	ldr	r3, [r3, #0]
  203928:	9a01      	ldr	r2, [sp, #4]
  20392a:	429a      	cmp	r2, r3
  20392c:	bf14      	ite	ne
  20392e:	2301      	movne	r3, #1
  203930:	2300      	moveq	r3, #0
  203932:	b2db      	uxtb	r3, r3
}
  203934:	4618      	mov	r0, r3
  203936:	b002      	add	sp, #8
  203938:	4770      	bx	lr
  20393a:	bf00      	nop
  20393c:	0000      	movs	r0, r0
	...

00203940 <ch_queue_insert.lto_priv.2>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
  203940:	b082      	sub	sp, #8
  203942:	9001      	str	r0, [sp, #4]
  203944:	9100      	str	r1, [sp, #0]
  p->next       = qp;
  203946:	9b00      	ldr	r3, [sp, #0]
  203948:	9a01      	ldr	r2, [sp, #4]
  20394a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
  20394c:	9b01      	ldr	r3, [sp, #4]
  20394e:	685a      	ldr	r2, [r3, #4]
  203950:	9b00      	ldr	r3, [sp, #0]
  203952:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
  203954:	9b00      	ldr	r3, [sp, #0]
  203956:	685b      	ldr	r3, [r3, #4]
  203958:	9a00      	ldr	r2, [sp, #0]
  20395a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
  20395c:	9b01      	ldr	r3, [sp, #4]
  20395e:	9a00      	ldr	r2, [sp, #0]
  203960:	605a      	str	r2, [r3, #4]
}
  203962:	bf00      	nop
  203964:	b002      	add	sp, #8
  203966:	4770      	bx	lr
	...

00203970 <ch_queue_fifo_remove.lto_priv.1>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  203970:	b084      	sub	sp, #16
  203972:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
  203974:	9b01      	ldr	r3, [sp, #4]
  203976:	681b      	ldr	r3, [r3, #0]
  203978:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
  20397a:	9b03      	ldr	r3, [sp, #12]
  20397c:	681a      	ldr	r2, [r3, #0]
  20397e:	9b01      	ldr	r3, [sp, #4]
  203980:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
  203982:	9b01      	ldr	r3, [sp, #4]
  203984:	681b      	ldr	r3, [r3, #0]
  203986:	9a01      	ldr	r2, [sp, #4]
  203988:	605a      	str	r2, [r3, #4]
  return p;
  20398a:	9b03      	ldr	r3, [sp, #12]
}
  20398c:	4618      	mov	r0, r3
  20398e:	b004      	add	sp, #16
  203990:	4770      	bx	lr
  203992:	bf00      	nop
	...

002039a0 <ch_queue_lifo_remove>:
static inline ch_queue_t *ch_queue_lifo_remove(ch_queue_t *qp) {
  2039a0:	b084      	sub	sp, #16
  2039a2:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->prev;
  2039a4:	9b01      	ldr	r3, [sp, #4]
  2039a6:	685b      	ldr	r3, [r3, #4]
  2039a8:	9303      	str	r3, [sp, #12]
  qp->prev       = p->prev;
  2039aa:	9b03      	ldr	r3, [sp, #12]
  2039ac:	685a      	ldr	r2, [r3, #4]
  2039ae:	9b01      	ldr	r3, [sp, #4]
  2039b0:	605a      	str	r2, [r3, #4]
  qp->prev->next = qp;
  2039b2:	9b01      	ldr	r3, [sp, #4]
  2039b4:	685b      	ldr	r3, [r3, #4]
  2039b6:	9a01      	ldr	r2, [sp, #4]
  2039b8:	601a      	str	r2, [r3, #0]
  return p;
  2039ba:	9b03      	ldr	r3, [sp, #12]
}
  2039bc:	4618      	mov	r0, r3
  2039be:	b004      	add	sp, #16
  2039c0:	4770      	bx	lr
  2039c2:	bf00      	nop
	...

002039d0 <chSysLock.lto_priv.6>:
static inline void chSysLock(void) {
  2039d0:	b082      	sub	sp, #8
  2039d2:	2330      	movs	r3, #48	@ 0x30
  2039d4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2039d6:	9b01      	ldr	r3, [sp, #4]
  2039d8:	f383 8811 	msr	BASEPRI, r3
}
  2039dc:	bf00      	nop
}
  2039de:	bf00      	nop
}
  2039e0:	bf00      	nop
  2039e2:	b002      	add	sp, #8
  2039e4:	4770      	bx	lr
  2039e6:	bf00      	nop
	...

002039f0 <chSysUnlock.lto_priv.6>:
static inline void chSysUnlock(void) {
  2039f0:	b082      	sub	sp, #8
  2039f2:	2300      	movs	r3, #0
  2039f4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2039f6:	9b01      	ldr	r3, [sp, #4]
  2039f8:	f383 8811 	msr	BASEPRI, r3
}
  2039fc:	bf00      	nop
}
  2039fe:	bf00      	nop
}
  203a00:	bf00      	nop
  203a02:	b002      	add	sp, #8
  203a04:	4770      	bx	lr
  203a06:	bf00      	nop
	...

00203a10 <chThdGetSelfX.lto_priv.1>:
  return __sch_get_currthread();
  203a10:	4b01      	ldr	r3, [pc, #4]	@ (203a18 <chThdGetSelfX.lto_priv.1+0x8>)
  203a12:	68db      	ldr	r3, [r3, #12]
}
  203a14:	4618      	mov	r0, r3
  203a16:	4770      	bx	lr
  203a18:	20000890 	.word	0x20000890
  203a1c:	00000000 	.word	0x00000000

00203a20 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
  203a20:	b500      	push	{lr}
  203a22:	b083      	sub	sp, #12
  203a24:	9001      	str	r0, [sp, #4]
  203a26:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  ch_queue_init(&sp->queue);
  203a28:	9b01      	ldr	r3, [sp, #4]
  203a2a:	4618      	mov	r0, r3
  203a2c:	f7ff ff68 	bl	203900 <ch_queue_init.lto_priv.2>
  sp->cnt = n;
  203a30:	9b01      	ldr	r3, [sp, #4]
  203a32:	9a00      	ldr	r2, [sp, #0]
  203a34:	609a      	str	r2, [r3, #8]
}
  203a36:	bf00      	nop
  203a38:	b003      	add	sp, #12
  203a3a:	f85d fb04 	ldr.w	pc, [sp], #4
  203a3e:	bf00      	nop

00203a40 <chSemResetWithMessage>:
 *                      be non-negative.
 * @param[in] msg       message to be sent
 *
 * @api
 */
void chSemResetWithMessage(semaphore_t *sp, cnt_t n, msg_t msg) {
  203a40:	b500      	push	{lr}
  203a42:	b085      	sub	sp, #20
  203a44:	9003      	str	r0, [sp, #12]
  203a46:	9102      	str	r1, [sp, #8]
  203a48:	9201      	str	r2, [sp, #4]

  chSysLock();
  203a4a:	f7ff ffc1 	bl	2039d0 <chSysLock.lto_priv.6>
  chSemResetWithMessageI(sp, n, msg);
  203a4e:	9a01      	ldr	r2, [sp, #4]
  203a50:	9902      	ldr	r1, [sp, #8]
  203a52:	9803      	ldr	r0, [sp, #12]
  203a54:	f000 f80c 	bl	203a70 <chSemResetWithMessageI>
  chSchRescheduleS();
  203a58:	f7ff f90a 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  203a5c:	f7ff ffc8 	bl	2039f0 <chSysUnlock.lto_priv.6>
}
  203a60:	bf00      	nop
  203a62:	b005      	add	sp, #20
  203a64:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00203a70 <chSemResetWithMessageI>:
 *                      be non-negative.
 * @param[in] msg       message to be sent
 *
 * @iclass
 */
void chSemResetWithMessageI(semaphore_t *sp, cnt_t n, msg_t msg) {
  203a70:	b500      	push	{lr}
  203a72:	b085      	sub	sp, #20
  203a74:	9003      	str	r0, [sp, #12]
  203a76:	9102      	str	r1, [sp, #8]
  203a78:	9201      	str	r2, [sp, #4]
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  sp->cnt = n;
  203a7a:	9b03      	ldr	r3, [sp, #12]
  203a7c:	9a02      	ldr	r2, [sp, #8]
  203a7e:	609a      	str	r2, [r3, #8]
  while (ch_queue_notempty(&sp->queue)) {
  203a80:	e00a      	b.n	203a98 <chSemResetWithMessageI+0x28>
    chSchReadyI(threadref(ch_queue_lifo_remove(&sp->queue)))->u.rdymsg = msg;
  203a82:	9b03      	ldr	r3, [sp, #12]
  203a84:	4618      	mov	r0, r3
  203a86:	f7ff ff8b 	bl	2039a0 <ch_queue_lifo_remove>
  203a8a:	4603      	mov	r3, r0
  203a8c:	4618      	mov	r0, r3
  203a8e:	f7ff f84f 	bl	202b30 <chSchReadyI>
  203a92:	4602      	mov	r2, r0
  203a94:	9b01      	ldr	r3, [sp, #4]
  203a96:	6353      	str	r3, [r2, #52]	@ 0x34
  while (ch_queue_notempty(&sp->queue)) {
  203a98:	9b03      	ldr	r3, [sp, #12]
  203a9a:	4618      	mov	r0, r3
  203a9c:	f7ff ff40 	bl	203920 <ch_queue_notempty.lto_priv.1>
  203aa0:	4603      	mov	r3, r0
  203aa2:	2b00      	cmp	r3, #0
  203aa4:	d1ed      	bne.n	203a82 <chSemResetWithMessageI+0x12>
  }
}
  203aa6:	bf00      	nop
  203aa8:	bf00      	nop
  203aaa:	b005      	add	sp, #20
  203aac:	f85d fb04 	ldr.w	pc, [sp], #4

00203ab0 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
  203ab0:	b500      	push	{lr}
  203ab2:	b085      	sub	sp, #20
  203ab4:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
  203ab6:	f7ff ff8b 	bl	2039d0 <chSysLock.lto_priv.6>
  msg = chSemWaitS(sp);
  203aba:	9801      	ldr	r0, [sp, #4]
  203abc:	f000 f808 	bl	203ad0 <chSemWaitS>
  203ac0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
  203ac2:	f7ff ff95 	bl	2039f0 <chSysUnlock.lto_priv.6>

  return msg;
  203ac6:	9b03      	ldr	r3, [sp, #12]
}
  203ac8:	4618      	mov	r0, r3
  203aca:	b005      	add	sp, #20
  203acc:	f85d fb04 	ldr.w	pc, [sp], #4

00203ad0 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(semaphore_t *sp) {
  203ad0:	b500      	push	{lr}
  203ad2:	b085      	sub	sp, #20
  203ad4:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
  203ad6:	9b01      	ldr	r3, [sp, #4]
  203ad8:	689b      	ldr	r3, [r3, #8]
  203ada:	1e5a      	subs	r2, r3, #1
  203adc:	9b01      	ldr	r3, [sp, #4]
  203ade:	609a      	str	r2, [r3, #8]
  203ae0:	9b01      	ldr	r3, [sp, #4]
  203ae2:	689b      	ldr	r3, [r3, #8]
  203ae4:	2b00      	cmp	r3, #0
  203ae6:	da11      	bge.n	203b0c <chSemWaitS+0x3c>
    thread_t *currtp = chThdGetSelfX();
  203ae8:	f7ff ff92 	bl	203a10 <chThdGetSelfX.lto_priv.1>
  203aec:	9003      	str	r0, [sp, #12]
    currtp->u.wtsemp = sp;
  203aee:	9b03      	ldr	r3, [sp, #12]
  203af0:	9a01      	ldr	r2, [sp, #4]
  203af2:	635a      	str	r2, [r3, #52]	@ 0x34
    sem_insert(&sp->queue, currtp);
  203af4:	9b01      	ldr	r3, [sp, #4]
  203af6:	9a03      	ldr	r2, [sp, #12]
  203af8:	4611      	mov	r1, r2
  203afa:	4618      	mov	r0, r3
  203afc:	f7ff ff20 	bl	203940 <ch_queue_insert.lto_priv.2>
    chSchGoSleepS(CH_STATE_WTSEM);
  203b00:	2005      	movs	r0, #5
  203b02:	f7ff f825 	bl	202b50 <chSchGoSleepS>

    return currtp->u.rdymsg;
  203b06:	9b03      	ldr	r3, [sp, #12]
  203b08:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  203b0a:	e000      	b.n	203b0e <chSemWaitS+0x3e>
  }

  return MSG_OK;
  203b0c:	2300      	movs	r3, #0
}
  203b0e:	4618      	mov	r0, r3
  203b10:	b005      	add	sp, #20
  203b12:	f85d fb04 	ldr.w	pc, [sp], #4
  203b16:	bf00      	nop
	...

00203b20 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, sysinterval_t timeout) {
  203b20:	b500      	push	{lr}
  203b22:	b085      	sub	sp, #20
  203b24:	9001      	str	r0, [sp, #4]
  203b26:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
  203b28:	f7ff ff52 	bl	2039d0 <chSysLock.lto_priv.6>
  msg = chSemWaitTimeoutS(sp, timeout);
  203b2c:	9900      	ldr	r1, [sp, #0]
  203b2e:	9801      	ldr	r0, [sp, #4]
  203b30:	f000 f80e 	bl	203b50 <chSemWaitTimeoutS>
  203b34:	9003      	str	r0, [sp, #12]
  chSysUnlock();
  203b36:	f7ff ff5b 	bl	2039f0 <chSysUnlock.lto_priv.6>

  return msg;
  203b3a:	9b03      	ldr	r3, [sp, #12]
}
  203b3c:	4618      	mov	r0, r3
  203b3e:	b005      	add	sp, #20
  203b40:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00203b50 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, sysinterval_t timeout) {
  203b50:	b500      	push	{lr}
  203b52:	b085      	sub	sp, #20
  203b54:	9001      	str	r0, [sp, #4]
  203b56:	9100      	str	r1, [sp, #0]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
  203b58:	9b01      	ldr	r3, [sp, #4]
  203b5a:	689b      	ldr	r3, [r3, #8]
  203b5c:	1e5a      	subs	r2, r3, #1
  203b5e:	9b01      	ldr	r3, [sp, #4]
  203b60:	609a      	str	r2, [r3, #8]
  203b62:	9b01      	ldr	r3, [sp, #4]
  203b64:	689b      	ldr	r3, [r3, #8]
  203b66:	2b00      	cmp	r3, #0
  203b68:	da21      	bge.n	203bae <chSemWaitTimeoutS+0x5e>
    if (unlikely(TIME_IMMEDIATE == timeout)) {
  203b6a:	9b00      	ldr	r3, [sp, #0]
  203b6c:	2b00      	cmp	r3, #0
  203b6e:	bf0c      	ite	eq
  203b70:	2301      	moveq	r3, #1
  203b72:	2300      	movne	r3, #0
  203b74:	b2db      	uxtb	r3, r3
  203b76:	2b00      	cmp	r3, #0
  203b78:	d007      	beq.n	203b8a <chSemWaitTimeoutS+0x3a>
      sp->cnt++;
  203b7a:	9b01      	ldr	r3, [sp, #4]
  203b7c:	689b      	ldr	r3, [r3, #8]
  203b7e:	1c5a      	adds	r2, r3, #1
  203b80:	9b01      	ldr	r3, [sp, #4]
  203b82:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
  203b84:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  203b88:	e012      	b.n	203bb0 <chSemWaitTimeoutS+0x60>
    }
    thread_t *currtp = chThdGetSelfX();
  203b8a:	f7ff ff41 	bl	203a10 <chThdGetSelfX.lto_priv.1>
  203b8e:	9003      	str	r0, [sp, #12]
    currtp->u.wtsemp = sp;
  203b90:	9b03      	ldr	r3, [sp, #12]
  203b92:	9a01      	ldr	r2, [sp, #4]
  203b94:	635a      	str	r2, [r3, #52]	@ 0x34
    sem_insert(&sp->queue, currtp);
  203b96:	9b01      	ldr	r3, [sp, #4]
  203b98:	9a03      	ldr	r2, [sp, #12]
  203b9a:	4611      	mov	r1, r2
  203b9c:	4618      	mov	r0, r3
  203b9e:	f7ff fecf 	bl	203940 <ch_queue_insert.lto_priv.2>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
  203ba2:	9900      	ldr	r1, [sp, #0]
  203ba4:	2005      	movs	r0, #5
  203ba6:	f7fe fffb 	bl	202ba0 <chSchGoSleepTimeoutS>
  203baa:	4603      	mov	r3, r0
  203bac:	e000      	b.n	203bb0 <chSemWaitTimeoutS+0x60>
  }

  return MSG_OK;
  203bae:	2300      	movs	r3, #0
}
  203bb0:	4618      	mov	r0, r3
  203bb2:	b005      	add	sp, #20
  203bb4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00203bc0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t object
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
  203bc0:	b500      	push	{lr}
  203bc2:	b083      	sub	sp, #12
  203bc4:	9001      	str	r0, [sp, #4]

  chDbgCheck(sp != NULL);

  chSysLock();
  203bc6:	f7ff ff03 	bl	2039d0 <chSysLock.lto_priv.6>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");
  if (++sp->cnt <= (cnt_t)0) {
  203bca:	9b01      	ldr	r3, [sp, #4]
  203bcc:	689b      	ldr	r3, [r3, #8]
  203bce:	1c5a      	adds	r2, r3, #1
  203bd0:	9b01      	ldr	r3, [sp, #4]
  203bd2:	609a      	str	r2, [r3, #8]
  203bd4:	9b01      	ldr	r3, [sp, #4]
  203bd6:	689b      	ldr	r3, [r3, #8]
  203bd8:	2b00      	cmp	r3, #0
  203bda:	dc08      	bgt.n	203bee <chSemSignal+0x2e>
    chSchWakeupS(threadref(ch_queue_fifo_remove(&sp->queue)), MSG_OK);
  203bdc:	9b01      	ldr	r3, [sp, #4]
  203bde:	4618      	mov	r0, r3
  203be0:	f7ff fec6 	bl	203970 <ch_queue_fifo_remove.lto_priv.1>
  203be4:	4603      	mov	r3, r0
  203be6:	2100      	movs	r1, #0
  203be8:	4618      	mov	r0, r3
  203bea:	f7ff f811 	bl	202c10 <chSchWakeupS>
  }
  chSysUnlock();
  203bee:	f7ff feff 	bl	2039f0 <chSysUnlock.lto_priv.6>
}
  203bf2:	bf00      	nop
  203bf4:	b003      	add	sp, #12
  203bf6:	f85d fb04 	ldr.w	pc, [sp], #4
  203bfa:	bf00      	nop
  203bfc:	0000      	movs	r0, r0
	...

00203c00 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t object
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
  203c00:	b500      	push	{lr}
  203c02:	b085      	sub	sp, #20
  203c04:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
  203c06:	9b01      	ldr	r3, [sp, #4]
  203c08:	689b      	ldr	r3, [r3, #8]
  203c0a:	1c5a      	adds	r2, r3, #1
  203c0c:	9b01      	ldr	r3, [sp, #4]
  203c0e:	609a      	str	r2, [r3, #8]
  203c10:	9b01      	ldr	r3, [sp, #4]
  203c12:	689b      	ldr	r3, [r3, #8]
  203c14:	2b00      	cmp	r3, #0
  203c16:	dc0a      	bgt.n	203c2e <chSemSignalI+0x2e>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = threadref(ch_queue_fifo_remove(&sp->queue));
  203c18:	9b01      	ldr	r3, [sp, #4]
  203c1a:	4618      	mov	r0, r3
  203c1c:	f7ff fea8 	bl	203970 <ch_queue_fifo_remove.lto_priv.1>
  203c20:	9003      	str	r0, [sp, #12]
    tp->u.rdymsg = MSG_OK;
  203c22:	9b03      	ldr	r3, [sp, #12]
  203c24:	2200      	movs	r2, #0
  203c26:	635a      	str	r2, [r3, #52]	@ 0x34
    (void) chSchReadyI(tp);
  203c28:	9803      	ldr	r0, [sp, #12]
  203c2a:	f7fe ff81 	bl	202b30 <chSchReadyI>
  }
}
  203c2e:	bf00      	nop
  203c30:	b005      	add	sp, #20
  203c32:	f85d fb04 	ldr.w	pc, [sp], #4
  203c36:	bf00      	nop
	...

00203c40 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
  203c40:	b500      	push	{lr}
  203c42:	b083      	sub	sp, #12
  203c44:	9001      	str	r0, [sp, #4]
  203c46:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
  203c48:	e016      	b.n	203c78 <chSemAddCounterI+0x38>
    if (++sp->cnt <= (cnt_t)0) {
  203c4a:	9b01      	ldr	r3, [sp, #4]
  203c4c:	689b      	ldr	r3, [r3, #8]
  203c4e:	1c5a      	adds	r2, r3, #1
  203c50:	9b01      	ldr	r3, [sp, #4]
  203c52:	609a      	str	r2, [r3, #8]
  203c54:	9b01      	ldr	r3, [sp, #4]
  203c56:	689b      	ldr	r3, [r3, #8]
  203c58:	2b00      	cmp	r3, #0
  203c5a:	dc0a      	bgt.n	203c72 <chSemAddCounterI+0x32>
      chSchReadyI(threadref(ch_queue_fifo_remove(&sp->queue)))->u.rdymsg = MSG_OK;
  203c5c:	9b01      	ldr	r3, [sp, #4]
  203c5e:	4618      	mov	r0, r3
  203c60:	f7ff fe86 	bl	203970 <ch_queue_fifo_remove.lto_priv.1>
  203c64:	4603      	mov	r3, r0
  203c66:	4618      	mov	r0, r3
  203c68:	f7fe ff62 	bl	202b30 <chSchReadyI>
  203c6c:	4603      	mov	r3, r0
  203c6e:	2200      	movs	r2, #0
  203c70:	635a      	str	r2, [r3, #52]	@ 0x34
    }
    n--;
  203c72:	9b00      	ldr	r3, [sp, #0]
  203c74:	3b01      	subs	r3, #1
  203c76:	9300      	str	r3, [sp, #0]
  while (n > (cnt_t)0) {
  203c78:	9b00      	ldr	r3, [sp, #0]
  203c7a:	2b00      	cmp	r3, #0
  203c7c:	dce5      	bgt.n	203c4a <chSemAddCounterI+0xa>
  }
}
  203c7e:	bf00      	nop
  203c80:	bf00      	nop
  203c82:	b003      	add	sp, #12
  203c84:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00203c90 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
  203c90:	b500      	push	{lr}
  203c92:	b085      	sub	sp, #20
  203c94:	9001      	str	r0, [sp, #4]
  203c96:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chDbgCheck((sps != NULL) && (spw != NULL));

  chSysLock();
  203c98:	f7ff fe9a 	bl	2039d0 <chSysLock.lto_priv.6>
              ((sps->cnt < (cnt_t)0) && ch_queue_notempty(&sps->queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && ch_queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && ch_queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
  203c9c:	9b01      	ldr	r3, [sp, #4]
  203c9e:	689b      	ldr	r3, [r3, #8]
  203ca0:	1c5a      	adds	r2, r3, #1
  203ca2:	9b01      	ldr	r3, [sp, #4]
  203ca4:	609a      	str	r2, [r3, #8]
  203ca6:	9b01      	ldr	r3, [sp, #4]
  203ca8:	689b      	ldr	r3, [r3, #8]
  203caa:	2b00      	cmp	r3, #0
  203cac:	dc0a      	bgt.n	203cc4 <chSemSignalWait+0x34>
    chSchReadyI(threadref(ch_queue_fifo_remove(&sps->queue)))->u.rdymsg = MSG_OK;
  203cae:	9b01      	ldr	r3, [sp, #4]
  203cb0:	4618      	mov	r0, r3
  203cb2:	f7ff fe5d 	bl	203970 <ch_queue_fifo_remove.lto_priv.1>
  203cb6:	4603      	mov	r3, r0
  203cb8:	4618      	mov	r0, r3
  203cba:	f7fe ff39 	bl	202b30 <chSchReadyI>
  203cbe:	4603      	mov	r3, r0
  203cc0:	2200      	movs	r2, #0
  203cc2:	635a      	str	r2, [r3, #52]	@ 0x34
  }
  if (--spw->cnt < (cnt_t)0) {
  203cc4:	9b00      	ldr	r3, [sp, #0]
  203cc6:	689b      	ldr	r3, [r3, #8]
  203cc8:	1e5a      	subs	r2, r3, #1
  203cca:	9b00      	ldr	r3, [sp, #0]
  203ccc:	609a      	str	r2, [r3, #8]
  203cce:	9b00      	ldr	r3, [sp, #0]
  203cd0:	689b      	ldr	r3, [r3, #8]
  203cd2:	2b00      	cmp	r3, #0
  203cd4:	da12      	bge.n	203cfc <chSemSignalWait+0x6c>
    thread_t *currtp = chThdGetSelfX();
  203cd6:	f7ff fe9b 	bl	203a10 <chThdGetSelfX.lto_priv.1>
  203cda:	9002      	str	r0, [sp, #8]
    sem_insert(&spw->queue, currtp);
  203cdc:	9b00      	ldr	r3, [sp, #0]
  203cde:	9a02      	ldr	r2, [sp, #8]
  203ce0:	4611      	mov	r1, r2
  203ce2:	4618      	mov	r0, r3
  203ce4:	f7ff fe2c 	bl	203940 <ch_queue_insert.lto_priv.2>
    currtp->u.wtsemp = spw;
  203ce8:	9b02      	ldr	r3, [sp, #8]
  203cea:	9a00      	ldr	r2, [sp, #0]
  203cec:	635a      	str	r2, [r3, #52]	@ 0x34
    chSchGoSleepS(CH_STATE_WTSEM);
  203cee:	2005      	movs	r0, #5
  203cf0:	f7fe ff2e 	bl	202b50 <chSchGoSleepS>
    msg = currtp->u.rdymsg;
  203cf4:	9b02      	ldr	r3, [sp, #8]
  203cf6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  203cf8:	9303      	str	r3, [sp, #12]
  203cfa:	e003      	b.n	203d04 <chSemSignalWait+0x74>
  }
  else {
    chSchRescheduleS();
  203cfc:	f7fe ffb8 	bl	202c70 <chSchRescheduleS>
    msg = MSG_OK;
  203d00:	2300      	movs	r3, #0
  203d02:	9303      	str	r3, [sp, #12]
  }
  chSysUnlock();
  203d04:	f7ff fe74 	bl	2039f0 <chSysUnlock.lto_priv.6>

  return msg;
  203d08:	9b03      	ldr	r3, [sp, #12]
}
  203d0a:	4618      	mov	r0, r3
  203d0c:	b005      	add	sp, #20
  203d0e:	f85d fb04 	ldr.w	pc, [sp], #4
  203d12:	bf00      	nop
	...

00203d20 <ch_queue_init.lto_priv.3>:
static inline void ch_queue_init(ch_queue_t *qp) {
  203d20:	b082      	sub	sp, #8
  203d22:	9001      	str	r0, [sp, #4]
  qp->next = qp;
  203d24:	9b01      	ldr	r3, [sp, #4]
  203d26:	9a01      	ldr	r2, [sp, #4]
  203d28:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
  203d2a:	9b01      	ldr	r3, [sp, #4]
  203d2c:	9a01      	ldr	r2, [sp, #4]
  203d2e:	605a      	str	r2, [r3, #4]
}
  203d30:	bf00      	nop
  203d32:	b002      	add	sp, #8
  203d34:	4770      	bx	lr
  203d36:	bf00      	nop
	...

00203d40 <ch_queue_notempty.lto_priv.2>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
  203d40:	b082      	sub	sp, #8
  203d42:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
  203d44:	9b01      	ldr	r3, [sp, #4]
  203d46:	681b      	ldr	r3, [r3, #0]
  203d48:	9a01      	ldr	r2, [sp, #4]
  203d4a:	429a      	cmp	r2, r3
  203d4c:	bf14      	ite	ne
  203d4e:	2301      	movne	r3, #1
  203d50:	2300      	moveq	r3, #0
  203d52:	b2db      	uxtb	r3, r3
}
  203d54:	4618      	mov	r0, r3
  203d56:	b002      	add	sp, #8
  203d58:	4770      	bx	lr
  203d5a:	bf00      	nop
  203d5c:	0000      	movs	r0, r0
	...

00203d60 <ch_queue_fifo_remove.lto_priv.2>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  203d60:	b084      	sub	sp, #16
  203d62:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
  203d64:	9b01      	ldr	r3, [sp, #4]
  203d66:	681b      	ldr	r3, [r3, #0]
  203d68:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
  203d6a:	9b03      	ldr	r3, [sp, #12]
  203d6c:	681a      	ldr	r2, [r3, #0]
  203d6e:	9b01      	ldr	r3, [sp, #4]
  203d70:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
  203d72:	9b01      	ldr	r3, [sp, #4]
  203d74:	681b      	ldr	r3, [r3, #0]
  203d76:	9a01      	ldr	r2, [sp, #4]
  203d78:	605a      	str	r2, [r3, #4]
  return p;
  203d7a:	9b03      	ldr	r3, [sp, #12]
}
  203d7c:	4618      	mov	r0, r3
  203d7e:	b004      	add	sp, #16
  203d80:	4770      	bx	lr
  203d82:	bf00      	nop
	...

00203d90 <ch_queue_dequeue.lto_priv.2>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
  203d90:	b082      	sub	sp, #8
  203d92:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
  203d94:	9b01      	ldr	r3, [sp, #4]
  203d96:	685b      	ldr	r3, [r3, #4]
  203d98:	9a01      	ldr	r2, [sp, #4]
  203d9a:	6812      	ldr	r2, [r2, #0]
  203d9c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
  203d9e:	9b01      	ldr	r3, [sp, #4]
  203da0:	681b      	ldr	r3, [r3, #0]
  203da2:	9a01      	ldr	r2, [sp, #4]
  203da4:	6852      	ldr	r2, [r2, #4]
  203da6:	605a      	str	r2, [r3, #4]
  return p;
  203da8:	9b01      	ldr	r3, [sp, #4]
}
  203daa:	4618      	mov	r0, r3
  203dac:	b002      	add	sp, #8
  203dae:	4770      	bx	lr

00203db0 <chSysLock.lto_priv.7>:
static inline void chSysLock(void) {
  203db0:	b082      	sub	sp, #8
  203db2:	2330      	movs	r3, #48	@ 0x30
  203db4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203db6:	9b01      	ldr	r3, [sp, #4]
  203db8:	f383 8811 	msr	BASEPRI, r3
}
  203dbc:	bf00      	nop
}
  203dbe:	bf00      	nop
}
  203dc0:	bf00      	nop
  203dc2:	b002      	add	sp, #8
  203dc4:	4770      	bx	lr
  203dc6:	bf00      	nop
	...

00203dd0 <chSysUnlock.lto_priv.7>:
static inline void chSysUnlock(void) {
  203dd0:	b082      	sub	sp, #8
  203dd2:	2300      	movs	r3, #0
  203dd4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203dd6:	9b01      	ldr	r3, [sp, #4]
  203dd8:	f383 8811 	msr	BASEPRI, r3
}
  203ddc:	bf00      	nop
}
  203dde:	bf00      	nop
}
  203de0:	bf00      	nop
  203de2:	b002      	add	sp, #8
  203de4:	4770      	bx	lr
  203de6:	bf00      	nop
	...

00203df0 <ch_sch_prio_insert.lto_priv.0>:
/*===========================================================================*/

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
  203df0:	b084      	sub	sp, #16
  203df2:	9001      	str	r0, [sp, #4]
  203df4:	9100      	str	r1, [sp, #0]

  ch_queue_t *cp = qp;
  203df6:	9b01      	ldr	r3, [sp, #4]
  203df8:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->next;
  203dfa:	9b03      	ldr	r3, [sp, #12]
  203dfc:	681b      	ldr	r3, [r3, #0]
  203dfe:	9303      	str	r3, [sp, #12]
  } while ((cp != qp) &&
  203e00:	9a03      	ldr	r2, [sp, #12]
  203e02:	9b01      	ldr	r3, [sp, #4]
  203e04:	429a      	cmp	r2, r3
  203e06:	d005      	beq.n	203e14 <ch_sch_prio_insert.lto_priv.0+0x24>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
  203e08:	9b03      	ldr	r3, [sp, #12]
  203e0a:	689a      	ldr	r2, [r3, #8]
  203e0c:	9b00      	ldr	r3, [sp, #0]
  203e0e:	689b      	ldr	r3, [r3, #8]
  } while ((cp != qp) &&
  203e10:	429a      	cmp	r2, r3
  203e12:	d2f2      	bcs.n	203dfa <ch_sch_prio_insert.lto_priv.0+0xa>
  tp->next       = cp;
  203e14:	9b00      	ldr	r3, [sp, #0]
  203e16:	9a03      	ldr	r2, [sp, #12]
  203e18:	601a      	str	r2, [r3, #0]
  tp->prev       = cp->prev;
  203e1a:	9b03      	ldr	r3, [sp, #12]
  203e1c:	685a      	ldr	r2, [r3, #4]
  203e1e:	9b00      	ldr	r3, [sp, #0]
  203e20:	605a      	str	r2, [r3, #4]
  tp->prev->next = tp;
  203e22:	9b00      	ldr	r3, [sp, #0]
  203e24:	685b      	ldr	r3, [r3, #4]
  203e26:	9a00      	ldr	r2, [sp, #0]
  203e28:	601a      	str	r2, [r3, #0]
  cp->prev       = tp;
  203e2a:	9b03      	ldr	r3, [sp, #12]
  203e2c:	9a00      	ldr	r2, [sp, #0]
  203e2e:	605a      	str	r2, [r3, #4]
}
  203e30:	bf00      	nop
  203e32:	b004      	add	sp, #16
  203e34:	4770      	bx	lr
  203e36:	bf00      	nop
	...

00203e40 <chThdGetSelfX.lto_priv.2>:
  return __sch_get_currthread();
  203e40:	4b01      	ldr	r3, [pc, #4]	@ (203e48 <chThdGetSelfX.lto_priv.2+0x8>)
  203e42:	68db      	ldr	r3, [r3, #12]
}
  203e44:	4618      	mov	r0, r3
  203e46:	4770      	bx	lr
  203e48:	20000890 	.word	0x20000890
  203e4c:	00000000 	.word	0x00000000

00203e50 <chMtxQueueNotEmptyS>:
 * @param[out] mp       pointer to a @p mutex_t object
 * @return              The mutex queue status.
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
  203e50:	b500      	push	{lr}
  203e52:	b083      	sub	sp, #12
  203e54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();

  return ch_queue_notempty(&mp->queue);
  203e56:	9b01      	ldr	r3, [sp, #4]
  203e58:	4618      	mov	r0, r3
  203e5a:	f7ff ff71 	bl	203d40 <ch_queue_notempty.lto_priv.2>
  203e5e:	4603      	mov	r3, r0
}
  203e60:	4618      	mov	r0, r3
  203e62:	b003      	add	sp, #12
  203e64:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00203e70 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t object
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
  203e70:	b500      	push	{lr}
  203e72:	b083      	sub	sp, #12
  203e74:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  ch_queue_init(&mp->queue);
  203e76:	9b01      	ldr	r3, [sp, #4]
  203e78:	4618      	mov	r0, r3
  203e7a:	f7ff ff51 	bl	203d20 <ch_queue_init.lto_priv.3>
  mp->owner = NULL;
  203e7e:	9b01      	ldr	r3, [sp, #4]
  203e80:	2200      	movs	r2, #0
  203e82:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
  203e84:	bf00      	nop
  203e86:	b003      	add	sp, #12
  203e88:	f85d fb04 	ldr.w	pc, [sp], #4
  203e8c:	0000      	movs	r0, r0
	...

00203e90 <chMtxLock>:
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
  203e90:	b500      	push	{lr}
  203e92:	b083      	sub	sp, #12
  203e94:	9001      	str	r0, [sp, #4]

  chSysLock();
  203e96:	f7ff ff8b 	bl	203db0 <chSysLock.lto_priv.7>
  chMtxLockS(mp);
  203e9a:	9801      	ldr	r0, [sp, #4]
  203e9c:	f000 f808 	bl	203eb0 <chMtxLockS>
  chSysUnlock();
  203ea0:	f7ff ff96 	bl	203dd0 <chSysUnlock.lto_priv.7>
}
  203ea4:	bf00      	nop
  203ea6:	b003      	add	sp, #12
  203ea8:	f85d fb04 	ldr.w	pc, [sp], #4
  203eac:	0000      	movs	r0, r0
	...

00203eb0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  203eb0:	b510      	push	{r4, lr}
  203eb2:	b084      	sub	sp, #16
  203eb4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  203eb6:	f7ff ffc3 	bl	203e40 <chThdGetSelfX.lto_priv.2>
  203eba:	9003      	str	r0, [sp, #12]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
  203ebc:	9b01      	ldr	r3, [sp, #4]
  203ebe:	689b      	ldr	r3, [r3, #8]
  203ec0:	2b00      	cmp	r3, #0
  203ec2:	d04d      	beq.n	203f60 <chMtxLockS+0xb0>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
  203ec4:	9b01      	ldr	r3, [sp, #4]
  203ec6:	689b      	ldr	r3, [r3, #8]
  203ec8:	9302      	str	r3, [sp, #8]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
  203eca:	e036      	b.n	203f3a <chMtxLockS+0x8a>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
  203ecc:	9b03      	ldr	r3, [sp, #12]
  203ece:	689a      	ldr	r2, [r3, #8]
  203ed0:	9b02      	ldr	r3, [sp, #8]
  203ed2:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
  203ed4:	9b02      	ldr	r3, [sp, #8]
  203ed6:	7f1b      	ldrb	r3, [r3, #28]
  203ed8:	2b07      	cmp	r3, #7
  203eda:	d016      	beq.n	203f0a <chMtxLockS+0x5a>
  203edc:	2b07      	cmp	r3, #7
  203ede:	dc2a      	bgt.n	203f36 <chMtxLockS+0x86>
  203ee0:	2b00      	cmp	r3, #0
  203ee2:	d01f      	beq.n	203f24 <chMtxLockS+0x74>
  203ee4:	2b06      	cmp	r3, #6
  203ee6:	d126      	bne.n	203f36 <chMtxLockS+0x86>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
  203ee8:	9b02      	ldr	r3, [sp, #8]
  203eea:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  203eec:	461c      	mov	r4, r3
  203eee:	9b02      	ldr	r3, [sp, #8]
  203ef0:	4618      	mov	r0, r3
  203ef2:	f7ff ff4d 	bl	203d90 <ch_queue_dequeue.lto_priv.2>
  203ef6:	4603      	mov	r3, r0
  203ef8:	4619      	mov	r1, r3
  203efa:	4620      	mov	r0, r4
  203efc:	f7ff ff78 	bl	203df0 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          tp = tp->u.wtmtxp->owner;
  203f00:	9b02      	ldr	r3, [sp, #8]
  203f02:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  203f04:	689b      	ldr	r3, [r3, #8]
  203f06:	9302      	str	r3, [sp, #8]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
  203f08:	e017      	b.n	203f3a <chMtxLockS+0x8a>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
  203f0a:	9b02      	ldr	r3, [sp, #8]
  203f0c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  203f0e:	461c      	mov	r4, r3
  203f10:	9b02      	ldr	r3, [sp, #8]
  203f12:	4618      	mov	r0, r3
  203f14:	f7ff ff3c 	bl	203d90 <ch_queue_dequeue.lto_priv.2>
  203f18:	4603      	mov	r3, r0
  203f1a:	4619      	mov	r1, r3
  203f1c:	4620      	mov	r0, r4
  203f1e:	f7ff ff67 	bl	203df0 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          break;
  203f22:	e009      	b.n	203f38 <chMtxLockS+0x88>
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
  203f24:	9b02      	ldr	r3, [sp, #8]
  203f26:	4618      	mov	r0, r3
  203f28:	f7ff ff32 	bl	203d90 <ch_queue_dequeue.lto_priv.2>
  203f2c:	4603      	mov	r3, r0
  203f2e:	4618      	mov	r0, r3
  203f30:	f7fe fdfe 	bl	202b30 <chSchReadyI>
          break;
  203f34:	e000      	b.n	203f38 <chMtxLockS+0x88>
        default:
          /* Nothing to do for other states.*/
          break;
  203f36:	bf00      	nop
        }
        break;
  203f38:	e005      	b.n	203f46 <chMtxLockS+0x96>
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
  203f3a:	9b02      	ldr	r3, [sp, #8]
  203f3c:	689a      	ldr	r2, [r3, #8]
  203f3e:	9b03      	ldr	r3, [sp, #12]
  203f40:	689b      	ldr	r3, [r3, #8]
  203f42:	429a      	cmp	r2, r3
  203f44:	d3c2      	bcc.n	203ecc <chMtxLockS+0x1c>
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
  203f46:	9b01      	ldr	r3, [sp, #4]
  203f48:	9a03      	ldr	r2, [sp, #12]
  203f4a:	4611      	mov	r1, r2
  203f4c:	4618      	mov	r0, r3
  203f4e:	f7ff ff4f 	bl	203df0 <ch_sch_prio_insert.lto_priv.0>
      currtp->u.wtmtxp = mp;
  203f52:	9b03      	ldr	r3, [sp, #12]
  203f54:	9a01      	ldr	r2, [sp, #4]
  203f56:	635a      	str	r2, [r3, #52]	@ 0x34
      chSchGoSleepS(CH_STATE_WTMTX);
  203f58:	2006      	movs	r0, #6
  203f5a:	f7fe fdf9 	bl	202b50 <chSchGoSleepS>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
  203f5e:	e009      	b.n	203f74 <chMtxLockS+0xc4>
    mp->owner = currtp;
  203f60:	9b01      	ldr	r3, [sp, #4]
  203f62:	9a03      	ldr	r2, [sp, #12]
  203f64:	609a      	str	r2, [r3, #8]
    mp->next = currtp->mtxlist;
  203f66:	9b03      	ldr	r3, [sp, #12]
  203f68:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
  203f6a:	9b01      	ldr	r3, [sp, #4]
  203f6c:	60da      	str	r2, [r3, #12]
    currtp->mtxlist = mp;
  203f6e:	9b03      	ldr	r3, [sp, #12]
  203f70:	9a01      	ldr	r2, [sp, #4]
  203f72:	649a      	str	r2, [r3, #72]	@ 0x48
}
  203f74:	bf00      	nop
  203f76:	b004      	add	sp, #16
  203f78:	bd10      	pop	{r4, pc}
  203f7a:	bf00      	nop
  203f7c:	0000      	movs	r0, r0
	...

00203f80 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
  203f80:	b500      	push	{lr}
  203f82:	b085      	sub	sp, #20
  203f84:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
  203f86:	f7ff ff13 	bl	203db0 <chSysLock.lto_priv.7>
  b = chMtxTryLockS(mp);
  203f8a:	9801      	ldr	r0, [sp, #4]
  203f8c:	f000 f810 	bl	203fb0 <chMtxTryLockS>
  203f90:	4603      	mov	r3, r0
  203f92:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
  203f96:	f7ff ff1b 	bl	203dd0 <chSysUnlock.lto_priv.7>

  return b;
  203f9a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
  203f9e:	4618      	mov	r0, r3
  203fa0:	b005      	add	sp, #20
  203fa2:	f85d fb04 	ldr.w	pc, [sp], #4
  203fa6:	bf00      	nop
	...

00203fb0 <chMtxTryLockS>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @sclass
 */
bool chMtxTryLockS(mutex_t *mp) {
  203fb0:	b500      	push	{lr}
  203fb2:	b085      	sub	sp, #20
  203fb4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  203fb6:	f7ff ff43 	bl	203e40 <chThdGetSelfX.lto_priv.2>
  203fba:	9003      	str	r0, [sp, #12]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
  203fbc:	9b01      	ldr	r3, [sp, #4]
  203fbe:	689b      	ldr	r3, [r3, #8]
  203fc0:	2b00      	cmp	r3, #0
  203fc2:	d001      	beq.n	203fc8 <chMtxTryLockS+0x18>
    if (mp->owner == currtp) {
      mp->cnt++;
      return true;
    }
#endif
    return false;
  203fc4:	2300      	movs	r3, #0
  203fc6:	e00a      	b.n	203fde <chMtxTryLockS+0x2e>

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currtp;
  203fc8:	9b01      	ldr	r3, [sp, #4]
  203fca:	9a03      	ldr	r2, [sp, #12]
  203fcc:	609a      	str	r2, [r3, #8]
  mp->next = currtp->mtxlist;
  203fce:	9b03      	ldr	r3, [sp, #12]
  203fd0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
  203fd2:	9b01      	ldr	r3, [sp, #4]
  203fd4:	60da      	str	r2, [r3, #12]
  currtp->mtxlist = mp;
  203fd6:	9b03      	ldr	r3, [sp, #12]
  203fd8:	9a01      	ldr	r2, [sp, #4]
  203fda:	649a      	str	r2, [r3, #72]	@ 0x48
  return true;
  203fdc:	2301      	movs	r3, #1
}
  203fde:	4618      	mov	r0, r3
  203fe0:	b005      	add	sp, #20
  203fe2:	f85d fb04 	ldr.w	pc, [sp], #4
  203fe6:	bf00      	nop
	...

00203ff0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  203ff0:	b500      	push	{lr}
  203ff2:	b087      	sub	sp, #28
  203ff4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  203ff6:	f7ff ff23 	bl	203e40 <chThdGetSelfX.lto_priv.2>
  203ffa:	9003      	str	r0, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);

  chSysLock();
  203ffc:	f7ff fed8 	bl	203db0 <chSysLock.lto_priv.7>
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
  204000:	9b01      	ldr	r3, [sp, #4]
  204002:	68da      	ldr	r2, [r3, #12]
  204004:	9b03      	ldr	r3, [sp, #12]
  204006:	649a      	str	r2, [r3, #72]	@ 0x48

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
  204008:	9801      	ldr	r0, [sp, #4]
  20400a:	f7ff ff21 	bl	203e50 <chMtxQueueNotEmptyS>
  20400e:	4603      	mov	r3, r0
  204010:	2b00      	cmp	r3, #0
  204012:	d034      	beq.n	20407e <chMtxUnlock+0x8e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
  204014:	9b03      	ldr	r3, [sp, #12]
  204016:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
  204018:	9305      	str	r3, [sp, #20]
      lmp = currtp->mtxlist;
  20401a:	9b03      	ldr	r3, [sp, #12]
  20401c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
  20401e:	9304      	str	r3, [sp, #16]
      while (lmp != NULL) {
  204020:	e012      	b.n	204048 <chMtxUnlock+0x58>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
  204022:	9804      	ldr	r0, [sp, #16]
  204024:	f7ff ff14 	bl	203e50 <chMtxQueueNotEmptyS>
  204028:	4603      	mov	r3, r0
  20402a:	2b00      	cmp	r3, #0
  20402c:	d009      	beq.n	204042 <chMtxUnlock+0x52>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
  20402e:	9b04      	ldr	r3, [sp, #16]
  204030:	681b      	ldr	r3, [r3, #0]
  204032:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
  204034:	9a05      	ldr	r2, [sp, #20]
  204036:	429a      	cmp	r2, r3
  204038:	d203      	bcs.n	204042 <chMtxUnlock+0x52>
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
  20403a:	9b04      	ldr	r3, [sp, #16]
  20403c:	681b      	ldr	r3, [r3, #0]
  20403e:	689b      	ldr	r3, [r3, #8]
  204040:	9305      	str	r3, [sp, #20]
        }
        lmp = lmp->next;
  204042:	9b04      	ldr	r3, [sp, #16]
  204044:	68db      	ldr	r3, [r3, #12]
  204046:	9304      	str	r3, [sp, #16]
      while (lmp != NULL) {
  204048:	9b04      	ldr	r3, [sp, #16]
  20404a:	2b00      	cmp	r3, #0
  20404c:	d1e9      	bne.n	204022 <chMtxUnlock+0x32>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
  20404e:	9b03      	ldr	r3, [sp, #12]
  204050:	9a05      	ldr	r2, [sp, #20]
  204052:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
  204054:	9b01      	ldr	r3, [sp, #4]
  204056:	4618      	mov	r0, r3
  204058:	f7ff fe82 	bl	203d60 <ch_queue_fifo_remove.lto_priv.2>
  20405c:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
  20405e:	9b01      	ldr	r3, [sp, #4]
  204060:	9a02      	ldr	r2, [sp, #8]
  204062:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
  204064:	9b02      	ldr	r3, [sp, #8]
  204066:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
  204068:	9b01      	ldr	r3, [sp, #4]
  20406a:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
  20406c:	9b02      	ldr	r3, [sp, #8]
  20406e:	9a01      	ldr	r2, [sp, #4]
  204070:	649a      	str	r2, [r3, #72]	@ 0x48

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
  204072:	9802      	ldr	r0, [sp, #8]
  204074:	f7fe fd5c 	bl	202b30 <chSchReadyI>
      chSchRescheduleS();
  204078:	f7fe fdfa 	bl	202c70 <chSchRescheduleS>
  20407c:	e002      	b.n	204084 <chMtxUnlock+0x94>
    }
    else {
      mp->owner = NULL;
  20407e:	9b01      	ldr	r3, [sp, #4]
  204080:	2200      	movs	r2, #0
  204082:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
  204084:	f7ff fea4 	bl	203dd0 <chSysUnlock.lto_priv.7>
}
  204088:	bf00      	nop
  20408a:	b007      	add	sp, #28
  20408c:	f85d fb04 	ldr.w	pc, [sp], #4

00204090 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  204090:	b500      	push	{lr}
  204092:	b087      	sub	sp, #28
  204094:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  204096:	f7ff fed3 	bl	203e40 <chThdGetSelfX.lto_priv.2>
  20409a:	9003      	str	r0, [sp, #12]
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
  20409c:	9b01      	ldr	r3, [sp, #4]
  20409e:	68da      	ldr	r2, [r3, #12]
  2040a0:	9b03      	ldr	r3, [sp, #12]
  2040a2:	649a      	str	r2, [r3, #72]	@ 0x48

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
  2040a4:	9801      	ldr	r0, [sp, #4]
  2040a6:	f7ff fed3 	bl	203e50 <chMtxQueueNotEmptyS>
  2040aa:	4603      	mov	r3, r0
  2040ac:	2b00      	cmp	r3, #0
  2040ae:	d032      	beq.n	204116 <chMtxUnlockS+0x86>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
  2040b0:	9b03      	ldr	r3, [sp, #12]
  2040b2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
  2040b4:	9304      	str	r3, [sp, #16]
      lmp = currtp->mtxlist;
  2040b6:	9b03      	ldr	r3, [sp, #12]
  2040b8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
  2040ba:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
  2040bc:	e012      	b.n	2040e4 <chMtxUnlockS+0x54>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
  2040be:	9805      	ldr	r0, [sp, #20]
  2040c0:	f7ff fec6 	bl	203e50 <chMtxQueueNotEmptyS>
  2040c4:	4603      	mov	r3, r0
  2040c6:	2b00      	cmp	r3, #0
  2040c8:	d009      	beq.n	2040de <chMtxUnlockS+0x4e>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
  2040ca:	9b05      	ldr	r3, [sp, #20]
  2040cc:	681b      	ldr	r3, [r3, #0]
  2040ce:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
  2040d0:	9a04      	ldr	r2, [sp, #16]
  2040d2:	429a      	cmp	r2, r3
  2040d4:	d203      	bcs.n	2040de <chMtxUnlockS+0x4e>
          newprio = threadref(lmp->queue.next)->hdr.pqueue.prio;
  2040d6:	9b05      	ldr	r3, [sp, #20]
  2040d8:	681b      	ldr	r3, [r3, #0]
  2040da:	689b      	ldr	r3, [r3, #8]
  2040dc:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
  2040de:	9b05      	ldr	r3, [sp, #20]
  2040e0:	68db      	ldr	r3, [r3, #12]
  2040e2:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
  2040e4:	9b05      	ldr	r3, [sp, #20]
  2040e6:	2b00      	cmp	r3, #0
  2040e8:	d1e9      	bne.n	2040be <chMtxUnlockS+0x2e>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
  2040ea:	9b03      	ldr	r3, [sp, #12]
  2040ec:	9a04      	ldr	r2, [sp, #16]
  2040ee:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
  2040f0:	9b01      	ldr	r3, [sp, #4]
  2040f2:	4618      	mov	r0, r3
  2040f4:	f7ff fe34 	bl	203d60 <ch_queue_fifo_remove.lto_priv.2>
  2040f8:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
  2040fa:	9b01      	ldr	r3, [sp, #4]
  2040fc:	9a02      	ldr	r2, [sp, #8]
  2040fe:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
  204100:	9b02      	ldr	r3, [sp, #8]
  204102:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
  204104:	9b01      	ldr	r3, [sp, #4]
  204106:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
  204108:	9b02      	ldr	r3, [sp, #8]
  20410a:	9a01      	ldr	r2, [sp, #4]
  20410c:	649a      	str	r2, [r3, #72]	@ 0x48
      (void) chSchReadyI(tp);
  20410e:	9802      	ldr	r0, [sp, #8]
  204110:	f7fe fd0e 	bl	202b30 <chSchReadyI>
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
  204114:	e002      	b.n	20411c <chMtxUnlockS+0x8c>
      mp->owner = NULL;
  204116:	9b01      	ldr	r3, [sp, #4]
  204118:	2200      	movs	r2, #0
  20411a:	609a      	str	r2, [r3, #8]
}
  20411c:	bf00      	nop
  20411e:	b007      	add	sp, #28
  204120:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00204130 <chMtxUnlockAllS>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @sclass
 */
void chMtxUnlockAllS(void) {
  204130:	b500      	push	{lr}
  204132:	b085      	sub	sp, #20
  thread_t *currtp = chThdGetSelfX();
  204134:	f7ff fe84 	bl	203e40 <chThdGetSelfX.lto_priv.2>
  204138:	9003      	str	r0, [sp, #12]

  if (currtp->mtxlist != NULL) {
  20413a:	9b03      	ldr	r3, [sp, #12]
  20413c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
  20413e:	2b00      	cmp	r3, #0
  204140:	d02c      	beq.n	20419c <chMtxUnlockAllS+0x6c>
    do {
      mutex_t *mp = currtp->mtxlist;
  204142:	9b03      	ldr	r3, [sp, #12]
  204144:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
  204146:	9302      	str	r3, [sp, #8]
      currtp->mtxlist = mp->next;
  204148:	9b02      	ldr	r3, [sp, #8]
  20414a:	68da      	ldr	r2, [r3, #12]
  20414c:	9b03      	ldr	r3, [sp, #12]
  20414e:	649a      	str	r2, [r3, #72]	@ 0x48
      if (chMtxQueueNotEmptyS(mp)) {
  204150:	9802      	ldr	r0, [sp, #8]
  204152:	f7ff fe7d 	bl	203e50 <chMtxQueueNotEmptyS>
  204156:	4603      	mov	r3, r0
  204158:	2b00      	cmp	r3, #0
  20415a:	d012      	beq.n	204182 <chMtxUnlockAllS+0x52>
        thread_t *tp;
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        tp = threadref(ch_queue_fifo_remove(&mp->queue));
  20415c:	9b02      	ldr	r3, [sp, #8]
  20415e:	4618      	mov	r0, r3
  204160:	f7ff fdfe 	bl	203d60 <ch_queue_fifo_remove.lto_priv.2>
  204164:	9001      	str	r0, [sp, #4]
        mp->owner   = tp;
  204166:	9b02      	ldr	r3, [sp, #8]
  204168:	9a01      	ldr	r2, [sp, #4]
  20416a:	609a      	str	r2, [r3, #8]
        mp->next    = tp->mtxlist;
  20416c:	9b01      	ldr	r3, [sp, #4]
  20416e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
  204170:	9b02      	ldr	r3, [sp, #8]
  204172:	60da      	str	r2, [r3, #12]
        tp->mtxlist = mp;
  204174:	9b01      	ldr	r3, [sp, #4]
  204176:	9a02      	ldr	r2, [sp, #8]
  204178:	649a      	str	r2, [r3, #72]	@ 0x48
        (void) chSchReadyI(tp);
  20417a:	9801      	ldr	r0, [sp, #4]
  20417c:	f7fe fcd8 	bl	202b30 <chSchReadyI>
  204180:	e002      	b.n	204188 <chMtxUnlockAllS+0x58>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
  204182:	9b02      	ldr	r3, [sp, #8]
  204184:	2200      	movs	r2, #0
  204186:	609a      	str	r2, [r3, #8]
      }
    } while (currtp->mtxlist != NULL);
  204188:	9b03      	ldr	r3, [sp, #12]
  20418a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
  20418c:	2b00      	cmp	r3, #0
  20418e:	d1d8      	bne.n	204142 <chMtxUnlockAllS+0x12>
    currtp->hdr.pqueue.prio = currtp->realprio;
  204190:	9b03      	ldr	r3, [sp, #12]
  204192:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
  204194:	9b03      	ldr	r3, [sp, #12]
  204196:	609a      	str	r2, [r3, #8]
    chSchRescheduleS();
  204198:	f7fe fd6a 	bl	202c70 <chSchRescheduleS>
  }
}
  20419c:	bf00      	nop
  20419e:	b005      	add	sp, #20
  2041a0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002041b0 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  2041b0:	b508      	push	{r3, lr}

  chSysLock();
  2041b2:	f7ff fdfd 	bl	203db0 <chSysLock.lto_priv.7>
  chMtxUnlockAllS();
  2041b6:	f7ff ffbb 	bl	204130 <chMtxUnlockAllS>
  chSysUnlock();
  2041ba:	f7ff fe09 	bl	203dd0 <chSysUnlock.lto_priv.7>
}
  2041be:	bf00      	nop
  2041c0:	bd08      	pop	{r3, pc}
  2041c2:	bf00      	nop
	...

002041d0 <ch_queue_init.lto_priv.4>:
static inline void ch_queue_init(ch_queue_t *qp) {
  2041d0:	b082      	sub	sp, #8
  2041d2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
  2041d4:	9b01      	ldr	r3, [sp, #4]
  2041d6:	9a01      	ldr	r2, [sp, #4]
  2041d8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
  2041da:	9b01      	ldr	r3, [sp, #4]
  2041dc:	9a01      	ldr	r2, [sp, #4]
  2041de:	605a      	str	r2, [r3, #4]
}
  2041e0:	bf00      	nop
  2041e2:	b002      	add	sp, #8
  2041e4:	4770      	bx	lr
  2041e6:	bf00      	nop
	...

002041f0 <ch_queue_notempty.lto_priv.3>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
  2041f0:	b082      	sub	sp, #8
  2041f2:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
  2041f4:	9b01      	ldr	r3, [sp, #4]
  2041f6:	681b      	ldr	r3, [r3, #0]
  2041f8:	9a01      	ldr	r2, [sp, #4]
  2041fa:	429a      	cmp	r2, r3
  2041fc:	bf14      	ite	ne
  2041fe:	2301      	movne	r3, #1
  204200:	2300      	moveq	r3, #0
  204202:	b2db      	uxtb	r3, r3
}
  204204:	4618      	mov	r0, r3
  204206:	b002      	add	sp, #8
  204208:	4770      	bx	lr
  20420a:	bf00      	nop
  20420c:	0000      	movs	r0, r0
	...

00204210 <ch_queue_fifo_remove.lto_priv.3>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  204210:	b084      	sub	sp, #16
  204212:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
  204214:	9b01      	ldr	r3, [sp, #4]
  204216:	681b      	ldr	r3, [r3, #0]
  204218:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
  20421a:	9b03      	ldr	r3, [sp, #12]
  20421c:	681a      	ldr	r2, [r3, #0]
  20421e:	9b01      	ldr	r3, [sp, #4]
  204220:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
  204222:	9b01      	ldr	r3, [sp, #4]
  204224:	681b      	ldr	r3, [r3, #0]
  204226:	9a01      	ldr	r2, [sp, #4]
  204228:	605a      	str	r2, [r3, #4]
  return p;
  20422a:	9b03      	ldr	r3, [sp, #12]
}
  20422c:	4618      	mov	r0, r3
  20422e:	b004      	add	sp, #16
  204230:	4770      	bx	lr
  204232:	bf00      	nop
	...

00204240 <chSysLock.lto_priv.8>:
static inline void chSysLock(void) {
  204240:	b082      	sub	sp, #8
  204242:	2330      	movs	r3, #48	@ 0x30
  204244:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204246:	9b01      	ldr	r3, [sp, #4]
  204248:	f383 8811 	msr	BASEPRI, r3
}
  20424c:	bf00      	nop
}
  20424e:	bf00      	nop
}
  204250:	bf00      	nop
  204252:	b002      	add	sp, #8
  204254:	4770      	bx	lr
  204256:	bf00      	nop
	...

00204260 <chSysUnlock.lto_priv.8>:
static inline void chSysUnlock(void) {
  204260:	b082      	sub	sp, #8
  204262:	2300      	movs	r3, #0
  204264:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204266:	9b01      	ldr	r3, [sp, #4]
  204268:	f383 8811 	msr	BASEPRI, r3
}
  20426c:	bf00      	nop
}
  20426e:	bf00      	nop
}
  204270:	bf00      	nop
  204272:	b002      	add	sp, #8
  204274:	4770      	bx	lr
  204276:	bf00      	nop
	...

00204280 <ch_sch_prio_insert.lto_priv.1>:
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
  204280:	b084      	sub	sp, #16
  204282:	9001      	str	r0, [sp, #4]
  204284:	9100      	str	r1, [sp, #0]
  ch_queue_t *cp = qp;
  204286:	9b01      	ldr	r3, [sp, #4]
  204288:	9303      	str	r3, [sp, #12]
    cp = cp->next;
  20428a:	9b03      	ldr	r3, [sp, #12]
  20428c:	681b      	ldr	r3, [r3, #0]
  20428e:	9303      	str	r3, [sp, #12]
  } while ((cp != qp) &&
  204290:	9a03      	ldr	r2, [sp, #12]
  204292:	9b01      	ldr	r3, [sp, #4]
  204294:	429a      	cmp	r2, r3
  204296:	d005      	beq.n	2042a4 <ch_sch_prio_insert.lto_priv.1+0x24>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
  204298:	9b03      	ldr	r3, [sp, #12]
  20429a:	689a      	ldr	r2, [r3, #8]
  20429c:	9b00      	ldr	r3, [sp, #0]
  20429e:	689b      	ldr	r3, [r3, #8]
  } while ((cp != qp) &&
  2042a0:	429a      	cmp	r2, r3
  2042a2:	d2f2      	bcs.n	20428a <ch_sch_prio_insert.lto_priv.1+0xa>
  tp->next       = cp;
  2042a4:	9b00      	ldr	r3, [sp, #0]
  2042a6:	9a03      	ldr	r2, [sp, #12]
  2042a8:	601a      	str	r2, [r3, #0]
  tp->prev       = cp->prev;
  2042aa:	9b03      	ldr	r3, [sp, #12]
  2042ac:	685a      	ldr	r2, [r3, #4]
  2042ae:	9b00      	ldr	r3, [sp, #0]
  2042b0:	605a      	str	r2, [r3, #4]
  tp->prev->next = tp;
  2042b2:	9b00      	ldr	r3, [sp, #0]
  2042b4:	685b      	ldr	r3, [r3, #4]
  2042b6:	9a00      	ldr	r2, [sp, #0]
  2042b8:	601a      	str	r2, [r3, #0]
  cp->prev       = tp;
  2042ba:	9b03      	ldr	r3, [sp, #12]
  2042bc:	9a00      	ldr	r2, [sp, #0]
  2042be:	605a      	str	r2, [r3, #4]
}
  2042c0:	bf00      	nop
  2042c2:	b004      	add	sp, #16
  2042c4:	4770      	bx	lr
  2042c6:	bf00      	nop
	...

002042d0 <chThdGetSelfX.lto_priv.3>:
  return __sch_get_currthread();
  2042d0:	4b01      	ldr	r3, [pc, #4]	@ (2042d8 <chThdGetSelfX.lto_priv.3+0x8>)
  2042d2:	68db      	ldr	r3, [r3, #12]
}
  2042d4:	4618      	mov	r0, r3
  2042d6:	4770      	bx	lr
  2042d8:	20000890 	.word	0x20000890
  2042dc:	00000000 	.word	0x00000000

002042e0 <chMtxGetNextMutexX>:
 * @return              A pointer to the next mutex in the stack.
 * @retval NULL         if the stack is empty.
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {
  2042e0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->mtxlist;
  2042e2:	f7ff fff5 	bl	2042d0 <chThdGetSelfX.lto_priv.3>
  2042e6:	4603      	mov	r3, r0
  2042e8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
}
  2042ea:	4618      	mov	r0, r3
  2042ec:	bd08      	pop	{r3, pc}
  2042ee:	bf00      	nop

002042f0 <chCondObjectInit>:
 *
 * @param[out] cp       pointer to a @p condition_variable_t object
 *
 * @init
 */
void chCondObjectInit(condition_variable_t *cp) {
  2042f0:	b500      	push	{lr}
  2042f2:	b083      	sub	sp, #12
  2042f4:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  ch_queue_init(&cp->queue);
  2042f6:	9b01      	ldr	r3, [sp, #4]
  2042f8:	4618      	mov	r0, r3
  2042fa:	f7ff ff69 	bl	2041d0 <ch_queue_init.lto_priv.4>
}
  2042fe:	bf00      	nop
  204300:	b003      	add	sp, #12
  204302:	f85d fb04 	ldr.w	pc, [sp], #4
  204306:	bf00      	nop
	...

00204310 <chCondSignal>:
 *
 * @param[in] cp        pointer to a @p condition_variable_t object
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
  204310:	b500      	push	{lr}
  204312:	b083      	sub	sp, #12
  204314:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  chSysLock();
  204316:	f7ff ff93 	bl	204240 <chSysLock.lto_priv.8>
  if (ch_queue_notempty(&cp->queue)) {
  20431a:	9b01      	ldr	r3, [sp, #4]
  20431c:	4618      	mov	r0, r3
  20431e:	f7ff ff67 	bl	2041f0 <ch_queue_notempty.lto_priv.3>
  204322:	4603      	mov	r3, r0
  204324:	2b00      	cmp	r3, #0
  204326:	d008      	beq.n	20433a <chCondSignal+0x2a>
    chSchWakeupS(threadref(ch_queue_fifo_remove(&cp->queue)), MSG_OK);
  204328:	9b01      	ldr	r3, [sp, #4]
  20432a:	4618      	mov	r0, r3
  20432c:	f7ff ff70 	bl	204210 <ch_queue_fifo_remove.lto_priv.3>
  204330:	4603      	mov	r3, r0
  204332:	2100      	movs	r1, #0
  204334:	4618      	mov	r0, r3
  204336:	f7fe fc6b 	bl	202c10 <chSchWakeupS>
  }
  chSysUnlock();
  20433a:	f7ff ff91 	bl	204260 <chSysUnlock.lto_priv.8>
}
  20433e:	bf00      	nop
  204340:	b003      	add	sp, #12
  204342:	f85d fb04 	ldr.w	pc, [sp], #4
  204346:	bf00      	nop
	...

00204350 <chCondSignalI>:
 *
 * @param[in] cp        pointer to a @p condition_variable_t object
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
  204350:	b500      	push	{lr}
  204352:	b085      	sub	sp, #20
  204354:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (ch_queue_notempty(&cp->queue)) {
  204356:	9b01      	ldr	r3, [sp, #4]
  204358:	4618      	mov	r0, r3
  20435a:	f7ff ff49 	bl	2041f0 <ch_queue_notempty.lto_priv.3>
  20435e:	4603      	mov	r3, r0
  204360:	2b00      	cmp	r3, #0
  204362:	d00a      	beq.n	20437a <chCondSignalI+0x2a>
    thread_t *tp = threadref(ch_queue_fifo_remove(&cp->queue));
  204364:	9b01      	ldr	r3, [sp, #4]
  204366:	4618      	mov	r0, r3
  204368:	f7ff ff52 	bl	204210 <ch_queue_fifo_remove.lto_priv.3>
  20436c:	9003      	str	r0, [sp, #12]
    tp->u.rdymsg = MSG_OK;
  20436e:	9b03      	ldr	r3, [sp, #12]
  204370:	2200      	movs	r2, #0
  204372:	635a      	str	r2, [r3, #52]	@ 0x34
    (void) chSchReadyI(tp);
  204374:	9803      	ldr	r0, [sp, #12]
  204376:	f7fe fbdb 	bl	202b30 <chSchReadyI>
  }
}
  20437a:	bf00      	nop
  20437c:	b005      	add	sp, #20
  20437e:	f85d fb04 	ldr.w	pc, [sp], #4
  204382:	bf00      	nop
	...

00204390 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to a @p condition_variable_t object
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
  204390:	b500      	push	{lr}
  204392:	b083      	sub	sp, #12
  204394:	9001      	str	r0, [sp, #4]

  chSysLock();
  204396:	f7ff ff53 	bl	204240 <chSysLock.lto_priv.8>
  chCondBroadcastI(cp);
  20439a:	9801      	ldr	r0, [sp, #4]
  20439c:	f000 f808 	bl	2043b0 <chCondBroadcastI>
  chSchRescheduleS();
  2043a0:	f7fe fc66 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  2043a4:	f7ff ff5c 	bl	204260 <chSysUnlock.lto_priv.8>
}
  2043a8:	bf00      	nop
  2043aa:	b003      	add	sp, #12
  2043ac:	f85d fb04 	ldr.w	pc, [sp], #4

002043b0 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to a @p condition_variable_t object
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
  2043b0:	b500      	push	{lr}
  2043b2:	b083      	sub	sp, #12
  2043b4:	9001      	str	r0, [sp, #4]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (ch_queue_notempty(&cp->queue)) {
  2043b6:	e00b      	b.n	2043d0 <chCondBroadcastI+0x20>
    chSchReadyI(threadref(ch_queue_fifo_remove(&cp->queue)))->u.rdymsg = MSG_RESET;
  2043b8:	9b01      	ldr	r3, [sp, #4]
  2043ba:	4618      	mov	r0, r3
  2043bc:	f7ff ff28 	bl	204210 <ch_queue_fifo_remove.lto_priv.3>
  2043c0:	4603      	mov	r3, r0
  2043c2:	4618      	mov	r0, r3
  2043c4:	f7fe fbb4 	bl	202b30 <chSchReadyI>
  2043c8:	4603      	mov	r3, r0
  2043ca:	f06f 0201 	mvn.w	r2, #1
  2043ce:	635a      	str	r2, [r3, #52]	@ 0x34
  while (ch_queue_notempty(&cp->queue)) {
  2043d0:	9b01      	ldr	r3, [sp, #4]
  2043d2:	4618      	mov	r0, r3
  2043d4:	f7ff ff0c 	bl	2041f0 <ch_queue_notempty.lto_priv.3>
  2043d8:	4603      	mov	r3, r0
  2043da:	2b00      	cmp	r3, #0
  2043dc:	d1ec      	bne.n	2043b8 <chCondBroadcastI+0x8>
  }
}
  2043de:	bf00      	nop
  2043e0:	bf00      	nop
  2043e2:	b003      	add	sp, #12
  2043e4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002043f0 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
  2043f0:	b500      	push	{lr}
  2043f2:	b085      	sub	sp, #20
  2043f4:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
  2043f6:	f7ff ff23 	bl	204240 <chSysLock.lto_priv.8>
  msg = chCondWaitS(cp);
  2043fa:	9801      	ldr	r0, [sp, #4]
  2043fc:	f000 f808 	bl	204410 <chCondWaitS>
  204400:	9003      	str	r0, [sp, #12]
  chSysUnlock();
  204402:	f7ff ff2d 	bl	204260 <chSysUnlock.lto_priv.8>
  return msg;
  204406:	9b03      	ldr	r3, [sp, #12]
}
  204408:	4618      	mov	r0, r3
  20440a:	b005      	add	sp, #20
  20440c:	f85d fb04 	ldr.w	pc, [sp], #4

00204410 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  204410:	b500      	push	{lr}
  204412:	b087      	sub	sp, #28
  204414:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  204416:	f7ff ff5b 	bl	2042d0 <chThdGetSelfX.lto_priv.3>
  20441a:	9004      	str	r0, [sp, #16]
  mutex_t *mp = chMtxGetNextMutexX();
  20441c:	f7ff ff60 	bl	2042e0 <chMtxGetNextMutexX>
  204420:	9005      	str	r0, [sp, #20]
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
  204422:	9805      	ldr	r0, [sp, #20]
  204424:	f7ff fe34 	bl	204090 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currtp->u.wtobjp = cp;
  204428:	9b04      	ldr	r3, [sp, #16]
  20442a:	9a01      	ldr	r2, [sp, #4]
  20442c:	635a      	str	r2, [r3, #52]	@ 0x34
  ch_sch_prio_insert(&cp->queue, &currtp->hdr.queue);
  20442e:	9b01      	ldr	r3, [sp, #4]
  204430:	9a04      	ldr	r2, [sp, #16]
  204432:	4611      	mov	r1, r2
  204434:	4618      	mov	r0, r3
  204436:	f7ff ff23 	bl	204280 <ch_sch_prio_insert.lto_priv.1>
  chSchGoSleepS(CH_STATE_WTCOND);
  20443a:	2007      	movs	r0, #7
  20443c:	f7fe fb88 	bl	202b50 <chSchGoSleepS>
  msg = currtp->u.rdymsg;
  204440:	9b04      	ldr	r3, [sp, #16]
  204442:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  204444:	9303      	str	r3, [sp, #12]
  chMtxLockS(mp);
  204446:	9805      	ldr	r0, [sp, #20]
  204448:	f7ff fd32 	bl	203eb0 <chMtxLockS>

  return msg;
  20444c:	9b03      	ldr	r3, [sp, #12]
}
  20444e:	4618      	mov	r0, r3
  204450:	b007      	add	sp, #28
  204452:	f85d fb04 	ldr.w	pc, [sp], #4
  204456:	bf00      	nop
	...

00204460 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, sysinterval_t timeout) {
  204460:	b500      	push	{lr}
  204462:	b085      	sub	sp, #20
  204464:	9001      	str	r0, [sp, #4]
  204466:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
  204468:	f7ff feea 	bl	204240 <chSysLock.lto_priv.8>
  msg = chCondWaitTimeoutS(cp, timeout);
  20446c:	9900      	ldr	r1, [sp, #0]
  20446e:	9801      	ldr	r0, [sp, #4]
  204470:	f000 f80e 	bl	204490 <chCondWaitTimeoutS>
  204474:	9003      	str	r0, [sp, #12]
  chSysUnlock();
  204476:	f7ff fef3 	bl	204260 <chSysUnlock.lto_priv.8>

  return msg;
  20447a:	9b03      	ldr	r3, [sp, #12]
}
  20447c:	4618      	mov	r0, r3
  20447e:	b005      	add	sp, #20
  204480:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00204490 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, sysinterval_t timeout) {
  204490:	b500      	push	{lr}
  204492:	b087      	sub	sp, #28
  204494:	9001      	str	r0, [sp, #4]
  204496:	9100      	str	r1, [sp, #0]
  thread_t *currtp = chThdGetSelfX();
  204498:	f7ff ff1a 	bl	2042d0 <chThdGetSelfX.lto_priv.3>
  20449c:	9005      	str	r0, [sp, #20]
  mutex_t *mp = chMtxGetNextMutexX();
  20449e:	f7ff ff1f 	bl	2042e0 <chMtxGetNextMutexX>
  2044a2:	9004      	str	r0, [sp, #16]
  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (timeout != TIME_IMMEDIATE));
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
  2044a4:	9804      	ldr	r0, [sp, #16]
  2044a6:	f7ff fdf3 	bl	204090 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currtp->u.wtobjp = cp;
  2044aa:	9b05      	ldr	r3, [sp, #20]
  2044ac:	9a01      	ldr	r2, [sp, #4]
  2044ae:	635a      	str	r2, [r3, #52]	@ 0x34
  ch_sch_prio_insert(&cp->queue, &currtp->hdr.queue);
  2044b0:	9b01      	ldr	r3, [sp, #4]
  2044b2:	9a05      	ldr	r2, [sp, #20]
  2044b4:	4611      	mov	r1, r2
  2044b6:	4618      	mov	r0, r3
  2044b8:	f7ff fee2 	bl	204280 <ch_sch_prio_insert.lto_priv.1>
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, timeout);
  2044bc:	9900      	ldr	r1, [sp, #0]
  2044be:	2007      	movs	r0, #7
  2044c0:	f7fe fb6e 	bl	202ba0 <chSchGoSleepTimeoutS>
  2044c4:	9003      	str	r0, [sp, #12]
  if (msg != MSG_TIMEOUT) {
  2044c6:	9b03      	ldr	r3, [sp, #12]
  2044c8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  2044cc:	d002      	beq.n	2044d4 <chCondWaitTimeoutS+0x44>
    chMtxLockS(mp);
  2044ce:	9804      	ldr	r0, [sp, #16]
  2044d0:	f7ff fcee 	bl	203eb0 <chMtxLockS>
  }

  return msg;
  2044d4:	9b03      	ldr	r3, [sp, #12]
}
  2044d6:	4618      	mov	r0, r3
  2044d8:	b007      	add	sp, #28
  2044da:	f85d fb04 	ldr.w	pc, [sp], #4
  2044de:	bf00      	nop

002044e0 <chSysLock.lto_priv.9>:
static inline void chSysLock(void) {
  2044e0:	b082      	sub	sp, #8
  2044e2:	2330      	movs	r3, #48	@ 0x30
  2044e4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2044e6:	9b01      	ldr	r3, [sp, #4]
  2044e8:	f383 8811 	msr	BASEPRI, r3
}
  2044ec:	bf00      	nop
}
  2044ee:	bf00      	nop
}
  2044f0:	bf00      	nop
  2044f2:	b002      	add	sp, #8
  2044f4:	4770      	bx	lr
  2044f6:	bf00      	nop
	...

00204500 <chSysUnlock.lto_priv.9>:
static inline void chSysUnlock(void) {
  204500:	b082      	sub	sp, #8
  204502:	2300      	movs	r3, #0
  204504:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204506:	9b01      	ldr	r3, [sp, #4]
  204508:	f383 8811 	msr	BASEPRI, r3
}
  20450c:	bf00      	nop
}
  20450e:	bf00      	nop
}
  204510:	bf00      	nop
  204512:	b002      	add	sp, #8
  204514:	4770      	bx	lr
  204516:	bf00      	nop
	...

00204520 <chThdGetSelfX.lto_priv.4>:
  return __sch_get_currthread();
  204520:	4b01      	ldr	r3, [pc, #4]	@ (204528 <chThdGetSelfX.lto_priv.4+0x8>)
  204522:	68db      	ldr	r3, [r3, #12]
}
  204524:	4618      	mov	r0, r3
  204526:	4770      	bx	lr
  204528:	20000890 	.word	0x20000890
  20452c:	00000000 	.word	0x00000000

00204530 <chEvtAddEventsI>:
 * @param[in] events    the events to be added
 * @return              The mask of currently pending events.
 *
 * @iclass
 */
static inline eventmask_t chEvtAddEventsI(eventmask_t events) {
  204530:	b082      	sub	sp, #8
  204532:	9001      	str	r0, [sp, #4]

  return __sch_get_currthread()->epending |= events;
  204534:	4b05      	ldr	r3, [pc, #20]	@ (20454c <chEvtAddEventsI+0x1c>)
  204536:	68db      	ldr	r3, [r3, #12]
  204538:	6c59      	ldr	r1, [r3, #68]	@ 0x44
  20453a:	4b04      	ldr	r3, [pc, #16]	@ (20454c <chEvtAddEventsI+0x1c>)
  20453c:	68db      	ldr	r3, [r3, #12]
  20453e:	9a01      	ldr	r2, [sp, #4]
  204540:	430a      	orrs	r2, r1
  204542:	645a      	str	r2, [r3, #68]	@ 0x44
  204544:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
}
  204546:	4618      	mov	r0, r3
  204548:	b002      	add	sp, #8
  20454a:	4770      	bx	lr
  20454c:	20000890 	.word	0x20000890

00204550 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to an @p event_source_t object
 *
 * @init
 */
void chEvtObjectInit(event_source_t *esp) {
  204550:	b082      	sub	sp, #8
  204552:	9001      	str	r0, [sp, #4]

  chDbgCheck(esp != NULL);

  esp->next = (event_listener_t *)esp;
  204554:	9b01      	ldr	r3, [sp, #4]
  204556:	9a01      	ldr	r2, [sp, #4]
  204558:	601a      	str	r2, [r3, #0]
}
  20455a:	bf00      	nop
  20455c:	b002      	add	sp, #8
  20455e:	4770      	bx	lr

00204560 <chEvtRegisterMaskWithFlagsI>:
 * @iclass
 */
void chEvtRegisterMaskWithFlagsI(event_source_t *esp,
                                 event_listener_t *elp,
                                 eventmask_t events,
                                 eventflags_t wflags) {
  204560:	b500      	push	{lr}
  204562:	b087      	sub	sp, #28
  204564:	9003      	str	r0, [sp, #12]
  204566:	9102      	str	r1, [sp, #8]
  204568:	9201      	str	r2, [sp, #4]
  20456a:	9300      	str	r3, [sp, #0]
  thread_t *currtp = chThdGetSelfX();
  20456c:	f7ff ffd8 	bl	204520 <chThdGetSelfX.lto_priv.4>
  204570:	9005      	str	r0, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((esp != NULL) && (elp != NULL));

  elp->next     = esp->next;
  204572:	9b03      	ldr	r3, [sp, #12]
  204574:	681a      	ldr	r2, [r3, #0]
  204576:	9b02      	ldr	r3, [sp, #8]
  204578:	601a      	str	r2, [r3, #0]
  esp->next     = elp;
  20457a:	9b03      	ldr	r3, [sp, #12]
  20457c:	9a02      	ldr	r2, [sp, #8]
  20457e:	601a      	str	r2, [r3, #0]
  elp->listener = currtp;
  204580:	9b02      	ldr	r3, [sp, #8]
  204582:	9a05      	ldr	r2, [sp, #20]
  204584:	605a      	str	r2, [r3, #4]
  elp->events   = events;
  204586:	9b02      	ldr	r3, [sp, #8]
  204588:	9a01      	ldr	r2, [sp, #4]
  20458a:	609a      	str	r2, [r3, #8]
  elp->flags    = (eventflags_t)0;
  20458c:	9b02      	ldr	r3, [sp, #8]
  20458e:	2200      	movs	r2, #0
  204590:	60da      	str	r2, [r3, #12]
  elp->wflags   = wflags;
  204592:	9b02      	ldr	r3, [sp, #8]
  204594:	9a00      	ldr	r2, [sp, #0]
  204596:	611a      	str	r2, [r3, #16]
}
  204598:	bf00      	nop
  20459a:	b007      	add	sp, #28
  20459c:	f85d fb04 	ldr.w	pc, [sp], #4

002045a0 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
  2045a0:	b500      	push	{lr}
  2045a2:	b085      	sub	sp, #20
  2045a4:	9003      	str	r0, [sp, #12]
  2045a6:	9102      	str	r1, [sp, #8]
  2045a8:	9201      	str	r2, [sp, #4]
  2045aa:	9300      	str	r3, [sp, #0]

  chSysLock();
  2045ac:	f7ff ff98 	bl	2044e0 <chSysLock.lto_priv.9>
  chEvtRegisterMaskWithFlagsI(esp, elp, events, wflags);
  2045b0:	9b00      	ldr	r3, [sp, #0]
  2045b2:	9a01      	ldr	r2, [sp, #4]
  2045b4:	9902      	ldr	r1, [sp, #8]
  2045b6:	9803      	ldr	r0, [sp, #12]
  2045b8:	f7ff ffd2 	bl	204560 <chEvtRegisterMaskWithFlagsI>
  chSysUnlock();
  2045bc:	f7ff ffa0 	bl	204500 <chSysUnlock.lto_priv.9>
}
  2045c0:	bf00      	nop
  2045c2:	b005      	add	sp, #20
  2045c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002045d0 <chEvtUnregister>:
 * @param[in] esp       pointer to an @p event_source_t object
 * @param[in] elp       pointer to an @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
  2045d0:	b500      	push	{lr}
  2045d2:	b085      	sub	sp, #20
  2045d4:	9001      	str	r0, [sp, #4]
  2045d6:	9100      	str	r1, [sp, #0]
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  2045d8:	9b01      	ldr	r3, [sp, #4]
  2045da:	9303      	str	r3, [sp, #12]
  /*lint -restore*/
  chSysLock();
  2045dc:	f7ff ff80 	bl	2044e0 <chSysLock.lto_priv.9>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  2045e0:	e00c      	b.n	2045fc <chEvtUnregister+0x2c>
  /*lint -restore*/
    if (p->next == elp) {
  2045e2:	9b03      	ldr	r3, [sp, #12]
  2045e4:	681b      	ldr	r3, [r3, #0]
  2045e6:	9a00      	ldr	r2, [sp, #0]
  2045e8:	429a      	cmp	r2, r3
  2045ea:	d104      	bne.n	2045f6 <chEvtUnregister+0x26>
      p->next = elp->next;
  2045ec:	9b00      	ldr	r3, [sp, #0]
  2045ee:	681a      	ldr	r2, [r3, #0]
  2045f0:	9b03      	ldr	r3, [sp, #12]
  2045f2:	601a      	str	r2, [r3, #0]
      break;
  2045f4:	e007      	b.n	204606 <chEvtUnregister+0x36>
    }
    p = p->next;
  2045f6:	9b03      	ldr	r3, [sp, #12]
  2045f8:	681b      	ldr	r3, [r3, #0]
  2045fa:	9303      	str	r3, [sp, #12]
  while (p->next != (event_listener_t *)esp) {
  2045fc:	9b03      	ldr	r3, [sp, #12]
  2045fe:	681b      	ldr	r3, [r3, #0]
  204600:	9a01      	ldr	r2, [sp, #4]
  204602:	429a      	cmp	r2, r3
  204604:	d1ed      	bne.n	2045e2 <chEvtUnregister+0x12>
  }
  chSysUnlock();
  204606:	f7ff ff7b 	bl	204500 <chSysUnlock.lto_priv.9>
}
  20460a:	bf00      	nop
  20460c:	b005      	add	sp, #20
  20460e:	f85d fb04 	ldr.w	pc, [sp], #4
  204612:	bf00      	nop
	...

00204620 <chEvtGetAndClearEventsI>:
 * @param[in] events    the events to be cleared
 * @return              The mask of pending events that were cleared.
 *
 * @iclass
 */
eventmask_t chEvtGetAndClearEventsI(eventmask_t events) {
  204620:	b500      	push	{lr}
  204622:	b085      	sub	sp, #20
  204624:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  204626:	f7ff ff7b 	bl	204520 <chThdGetSelfX.lto_priv.4>
  20462a:	9003      	str	r0, [sp, #12]
  eventmask_t m;

  chDbgCheckClassI();

  m = currtp->epending & events;
  20462c:	9b03      	ldr	r3, [sp, #12]
  20462e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  204630:	9a01      	ldr	r2, [sp, #4]
  204632:	4013      	ands	r3, r2
  204634:	9302      	str	r3, [sp, #8]
  currtp->epending &= ~events;
  204636:	9b03      	ldr	r3, [sp, #12]
  204638:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  20463a:	9b01      	ldr	r3, [sp, #4]
  20463c:	43db      	mvns	r3, r3
  20463e:	401a      	ands	r2, r3
  204640:	9b03      	ldr	r3, [sp, #12]
  204642:	645a      	str	r2, [r3, #68]	@ 0x44

  return m;
  204644:	9b02      	ldr	r3, [sp, #8]
}
  204646:	4618      	mov	r0, r3
  204648:	b005      	add	sp, #20
  20464a:	f85d fb04 	ldr.w	pc, [sp], #4
  20464e:	bf00      	nop

00204650 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The mask of pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  204650:	b500      	push	{lr}
  204652:	b085      	sub	sp, #20
  204654:	9001      	str	r0, [sp, #4]
  eventmask_t m;

  chSysLock();
  204656:	f7ff ff43 	bl	2044e0 <chSysLock.lto_priv.9>
  m = chEvtGetAndClearEventsI(events);
  20465a:	9801      	ldr	r0, [sp, #4]
  20465c:	f7ff ffe0 	bl	204620 <chEvtGetAndClearEventsI>
  204660:	9003      	str	r0, [sp, #12]
  chSysUnlock();
  204662:	f7ff ff4d 	bl	204500 <chSysUnlock.lto_priv.9>

  return m;
  204666:	9b03      	ldr	r3, [sp, #12]
}
  204668:	4618      	mov	r0, r3
  20466a:	b005      	add	sp, #20
  20466c:	f85d fb04 	ldr.w	pc, [sp], #4

00204670 <chEvtAddEvents>:
 * @param[in] events    the events to be added
 * @return              The mask of currently pending events.
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {
  204670:	b500      	push	{lr}
  204672:	b085      	sub	sp, #20
  204674:	9001      	str	r0, [sp, #4]
  eventmask_t newevt;

  chSysLock();
  204676:	f7ff ff33 	bl	2044e0 <chSysLock.lto_priv.9>
  newevt = chEvtAddEventsI(events);
  20467a:	9801      	ldr	r0, [sp, #4]
  20467c:	f7ff ff58 	bl	204530 <chEvtAddEventsI>
  204680:	9003      	str	r0, [sp, #12]
  chSysUnlock();
  204682:	f7ff ff3d 	bl	204500 <chSysUnlock.lto_priv.9>

  return newevt;
  204686:	9b03      	ldr	r3, [sp, #12]
}
  204688:	4618      	mov	r0, r3
  20468a:	b005      	add	sp, #20
  20468c:	f85d fb04 	ldr.w	pc, [sp], #4

00204690 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
  204690:	b500      	push	{lr}
  204692:	b083      	sub	sp, #12
  204694:	9001      	str	r0, [sp, #4]
  204696:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  204698:	9b01      	ldr	r3, [sp, #4]
  20469a:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  20469c:	9b00      	ldr	r3, [sp, #0]
  20469e:	431a      	orrs	r2, r3
  2046a0:	9b01      	ldr	r3, [sp, #4]
  2046a2:	645a      	str	r2, [r3, #68]	@ 0x44
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
  2046a4:	9b01      	ldr	r3, [sp, #4]
  2046a6:	7f1b      	ldrb	r3, [r3, #28]
  2046a8:	2b0a      	cmp	r3, #10
  2046aa:	d106      	bne.n	2046ba <chEvtSignalI+0x2a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  2046ac:	9b01      	ldr	r3, [sp, #4]
  2046ae:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  2046b0:	9b01      	ldr	r3, [sp, #4]
  2046b2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  2046b4:	4013      	ands	r3, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
  2046b6:	2b00      	cmp	r3, #0
  2046b8:	d10c      	bne.n	2046d4 <chEvtSignalI+0x44>
      ((tp->state == CH_STATE_WTANDEVT) &&
  2046ba:	9b01      	ldr	r3, [sp, #4]
  2046bc:	7f1b      	ldrb	r3, [r3, #28]
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  2046be:	2b0b      	cmp	r3, #11
  2046c0:	d10e      	bne.n	2046e0 <chEvtSignalI+0x50>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
  2046c2:	9b01      	ldr	r3, [sp, #4]
  2046c4:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  2046c6:	9b01      	ldr	r3, [sp, #4]
  2046c8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  2046ca:	401a      	ands	r2, r3
  2046cc:	9b01      	ldr	r3, [sp, #4]
  2046ce:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
      ((tp->state == CH_STATE_WTANDEVT) &&
  2046d0:	429a      	cmp	r2, r3
  2046d2:	d105      	bne.n	2046e0 <chEvtSignalI+0x50>
    tp->u.rdymsg = MSG_OK;
  2046d4:	9b01      	ldr	r3, [sp, #4]
  2046d6:	2200      	movs	r2, #0
  2046d8:	635a      	str	r2, [r3, #52]	@ 0x34
    (void) chSchReadyI(tp);
  2046da:	9801      	ldr	r0, [sp, #4]
  2046dc:	f7fe fa28 	bl	202b30 <chSchReadyI>
  }
}
  2046e0:	bf00      	nop
  2046e2:	b003      	add	sp, #12
  2046e4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002046f0 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
  2046f0:	b500      	push	{lr}
  2046f2:	b083      	sub	sp, #12
  2046f4:	9001      	str	r0, [sp, #4]
  2046f6:	9100      	str	r1, [sp, #0]

  chDbgCheck(tp != NULL);

  chSysLock();
  2046f8:	f7ff fef2 	bl	2044e0 <chSysLock.lto_priv.9>
  chEvtSignalI(tp, events);
  2046fc:	9900      	ldr	r1, [sp, #0]
  2046fe:	9801      	ldr	r0, [sp, #4]
  204700:	f7ff ffc6 	bl	204690 <chEvtSignalI>
  chSchRescheduleS();
  204704:	f7fe fab4 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  204708:	f7ff fefa 	bl	204500 <chSysUnlock.lto_priv.9>
}
  20470c:	bf00      	nop
  20470e:	b003      	add	sp, #12
  204710:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00204720 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to an @p event_source_t object
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  204720:	b500      	push	{lr}
  204722:	b085      	sub	sp, #20
  204724:	9001      	str	r0, [sp, #4]
  204726:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  204728:	9b01      	ldr	r3, [sp, #4]
  20472a:	681b      	ldr	r3, [r3, #0]
  20472c:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  20472e:	e019      	b.n	204764 <chEvtBroadcastFlagsI+0x44>
  /*lint -restore*/
    elp->flags |= flags;
  204730:	9b03      	ldr	r3, [sp, #12]
  204732:	68da      	ldr	r2, [r3, #12]
  204734:	9b00      	ldr	r3, [sp, #0]
  204736:	431a      	orrs	r2, r3
  204738:	9b03      	ldr	r3, [sp, #12]
  20473a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
  20473c:	9b00      	ldr	r3, [sp, #0]
  20473e:	2b00      	cmp	r3, #0
  204740:	d005      	beq.n	20474e <chEvtBroadcastFlagsI+0x2e>
        ((flags & elp->wflags) != (eventflags_t)0)) {
  204742:	9b03      	ldr	r3, [sp, #12]
  204744:	691a      	ldr	r2, [r3, #16]
  204746:	9b00      	ldr	r3, [sp, #0]
  204748:	4013      	ands	r3, r2
    if ((flags == (eventflags_t)0) ||
  20474a:	2b00      	cmp	r3, #0
  20474c:	d007      	beq.n	20475e <chEvtBroadcastFlagsI+0x3e>
      chEvtSignalI(elp->listener, elp->events);
  20474e:	9b03      	ldr	r3, [sp, #12]
  204750:	685a      	ldr	r2, [r3, #4]
  204752:	9b03      	ldr	r3, [sp, #12]
  204754:	689b      	ldr	r3, [r3, #8]
  204756:	4619      	mov	r1, r3
  204758:	4610      	mov	r0, r2
  20475a:	f7ff ff99 	bl	204690 <chEvtSignalI>
    }
    elp = elp->next;
  20475e:	9b03      	ldr	r3, [sp, #12]
  204760:	681b      	ldr	r3, [r3, #0]
  204762:	9303      	str	r3, [sp, #12]
  while (elp != (event_listener_t *)esp) {
  204764:	9a03      	ldr	r2, [sp, #12]
  204766:	9b01      	ldr	r3, [sp, #4]
  204768:	429a      	cmp	r2, r3
  20476a:	d1e1      	bne.n	204730 <chEvtBroadcastFlagsI+0x10>
  }
}
  20476c:	bf00      	nop
  20476e:	bf00      	nop
  204770:	b005      	add	sp, #20
  204772:	f85d fb04 	ldr.w	pc, [sp], #4
  204776:	bf00      	nop
	...

00204780 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to an @p event_source_t object
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
  204780:	b500      	push	{lr}
  204782:	b083      	sub	sp, #12
  204784:	9001      	str	r0, [sp, #4]
  204786:	9100      	str	r1, [sp, #0]

  chSysLock();
  204788:	f7ff feaa 	bl	2044e0 <chSysLock.lto_priv.9>
  chEvtBroadcastFlagsI(esp, flags);
  20478c:	9900      	ldr	r1, [sp, #0]
  20478e:	9801      	ldr	r0, [sp, #4]
  204790:	f7ff ffc6 	bl	204720 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
  204794:	f7fe fa6c 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  204798:	f7ff feb2 	bl	204500 <chSysUnlock.lto_priv.9>
}
  20479c:	bf00      	nop
  20479e:	b003      	add	sp, #12
  2047a0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002047b0 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
  2047b0:	b500      	push	{lr}
  2047b2:	b085      	sub	sp, #20
  2047b4:	9001      	str	r0, [sp, #4]
  2047b6:	9100      	str	r1, [sp, #0]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  2047b8:	2300      	movs	r3, #0
  2047ba:	9303      	str	r3, [sp, #12]
  while (events != (eventmask_t)0) {
  2047bc:	e019      	b.n	2047f2 <chEvtDispatch+0x42>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
  2047be:	9b03      	ldr	r3, [sp, #12]
  2047c0:	9a00      	ldr	r2, [sp, #0]
  2047c2:	fa22 f303 	lsr.w	r3, r2, r3
  2047c6:	f003 0301 	and.w	r3, r3, #1
  2047ca:	2b00      	cmp	r3, #0
  2047cc:	d00e      	beq.n	2047ec <chEvtDispatch+0x3c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
  2047ce:	9b03      	ldr	r3, [sp, #12]
  2047d0:	2201      	movs	r2, #1
  2047d2:	fa02 f303 	lsl.w	r3, r2, r3
  2047d6:	43db      	mvns	r3, r3
  2047d8:	9a00      	ldr	r2, [sp, #0]
  2047da:	4013      	ands	r3, r2
  2047dc:	9300      	str	r3, [sp, #0]
      handlers[eid](eid);
  2047de:	9b03      	ldr	r3, [sp, #12]
  2047e0:	009b      	lsls	r3, r3, #2
  2047e2:	9a01      	ldr	r2, [sp, #4]
  2047e4:	4413      	add	r3, r2
  2047e6:	681b      	ldr	r3, [r3, #0]
  2047e8:	9803      	ldr	r0, [sp, #12]
  2047ea:	4798      	blx	r3
    }
    eid++;
  2047ec:	9b03      	ldr	r3, [sp, #12]
  2047ee:	3301      	adds	r3, #1
  2047f0:	9303      	str	r3, [sp, #12]
  while (events != (eventmask_t)0) {
  2047f2:	9b00      	ldr	r3, [sp, #0]
  2047f4:	2b00      	cmp	r3, #0
  2047f6:	d1e2      	bne.n	2047be <chEvtDispatch+0xe>
  }
}
  2047f8:	bf00      	nop
  2047fa:	bf00      	nop
  2047fc:	b005      	add	sp, #20
  2047fe:	f85d fb04 	ldr.w	pc, [sp], #4
  204802:	bf00      	nop
	...

00204810 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  204810:	b500      	push	{lr}
  204812:	b085      	sub	sp, #20
  204814:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  204816:	f7ff fe83 	bl	204520 <chThdGetSelfX.lto_priv.4>
  20481a:	9002      	str	r0, [sp, #8]
  eventmask_t m;

  chSysLock();
  20481c:	f7ff fe60 	bl	2044e0 <chSysLock.lto_priv.9>
  m = currtp->epending & events;
  204820:	9b02      	ldr	r3, [sp, #8]
  204822:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  204824:	9a01      	ldr	r2, [sp, #4]
  204826:	4013      	ands	r3, r2
  204828:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
  20482a:	9b03      	ldr	r3, [sp, #12]
  20482c:	2b00      	cmp	r3, #0
  20482e:	d10a      	bne.n	204846 <chEvtWaitOne+0x36>
    currtp->u.ewmask = events;
  204830:	9b02      	ldr	r3, [sp, #8]
  204832:	9a01      	ldr	r2, [sp, #4]
  204834:	635a      	str	r2, [r3, #52]	@ 0x34
    chSchGoSleepS(CH_STATE_WTOREVT);
  204836:	200a      	movs	r0, #10
  204838:	f7fe f98a 	bl	202b50 <chSchGoSleepS>
    m = currtp->epending & events;
  20483c:	9b02      	ldr	r3, [sp, #8]
  20483e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  204840:	9a01      	ldr	r2, [sp, #4]
  204842:	4013      	ands	r3, r2
  204844:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
  204846:	9b03      	ldr	r3, [sp, #12]
  204848:	425b      	negs	r3, r3
  20484a:	9a03      	ldr	r2, [sp, #12]
  20484c:	4013      	ands	r3, r2
  20484e:	9303      	str	r3, [sp, #12]
  currtp->epending &= ~m;
  204850:	9b02      	ldr	r3, [sp, #8]
  204852:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  204854:	9b03      	ldr	r3, [sp, #12]
  204856:	43db      	mvns	r3, r3
  204858:	401a      	ands	r2, r3
  20485a:	9b02      	ldr	r3, [sp, #8]
  20485c:	645a      	str	r2, [r3, #68]	@ 0x44
  chSysUnlock();
  20485e:	f7ff fe4f 	bl	204500 <chSysUnlock.lto_priv.9>

  return m;
  204862:	9b03      	ldr	r3, [sp, #12]
}
  204864:	4618      	mov	r0, r3
  204866:	b005      	add	sp, #20
  204868:	f85d fb04 	ldr.w	pc, [sp], #4
  20486c:	0000      	movs	r0, r0
	...

00204870 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  204870:	b500      	push	{lr}
  204872:	b085      	sub	sp, #20
  204874:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  204876:	f7ff fe53 	bl	204520 <chThdGetSelfX.lto_priv.4>
  20487a:	9002      	str	r0, [sp, #8]
  eventmask_t m;

  chSysLock();
  20487c:	f7ff fe30 	bl	2044e0 <chSysLock.lto_priv.9>
  m = currtp->epending & events;
  204880:	9b02      	ldr	r3, [sp, #8]
  204882:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  204884:	9a01      	ldr	r2, [sp, #4]
  204886:	4013      	ands	r3, r2
  204888:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
  20488a:	9b03      	ldr	r3, [sp, #12]
  20488c:	2b00      	cmp	r3, #0
  20488e:	d10a      	bne.n	2048a6 <chEvtWaitAny+0x36>
    currtp->u.ewmask = events;
  204890:	9b02      	ldr	r3, [sp, #8]
  204892:	9a01      	ldr	r2, [sp, #4]
  204894:	635a      	str	r2, [r3, #52]	@ 0x34
    chSchGoSleepS(CH_STATE_WTOREVT);
  204896:	200a      	movs	r0, #10
  204898:	f7fe f95a 	bl	202b50 <chSchGoSleepS>
    m = currtp->epending & events;
  20489c:	9b02      	ldr	r3, [sp, #8]
  20489e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  2048a0:	9a01      	ldr	r2, [sp, #4]
  2048a2:	4013      	ands	r3, r2
  2048a4:	9303      	str	r3, [sp, #12]
  }
  currtp->epending &= ~m;
  2048a6:	9b02      	ldr	r3, [sp, #8]
  2048a8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  2048aa:	9b03      	ldr	r3, [sp, #12]
  2048ac:	43db      	mvns	r3, r3
  2048ae:	401a      	ands	r2, r3
  2048b0:	9b02      	ldr	r3, [sp, #8]
  2048b2:	645a      	str	r2, [r3, #68]	@ 0x44
  chSysUnlock();
  2048b4:	f7ff fe24 	bl	204500 <chSysUnlock.lto_priv.9>

  return m;
  2048b8:	9b03      	ldr	r3, [sp, #12]
}
  2048ba:	4618      	mov	r0, r3
  2048bc:	b005      	add	sp, #20
  2048be:	f85d fb04 	ldr.w	pc, [sp], #4
  2048c2:	bf00      	nop
	...

002048d0 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  2048d0:	b500      	push	{lr}
  2048d2:	b085      	sub	sp, #20
  2048d4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
  2048d6:	f7ff fe23 	bl	204520 <chThdGetSelfX.lto_priv.4>
  2048da:	9003      	str	r0, [sp, #12]

  chSysLock();
  2048dc:	f7ff fe00 	bl	2044e0 <chSysLock.lto_priv.9>
  if ((currtp->epending & events) != events) {
  2048e0:	9b03      	ldr	r3, [sp, #12]
  2048e2:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  2048e4:	9b01      	ldr	r3, [sp, #4]
  2048e6:	4013      	ands	r3, r2
  2048e8:	9a01      	ldr	r2, [sp, #4]
  2048ea:	429a      	cmp	r2, r3
  2048ec:	d005      	beq.n	2048fa <chEvtWaitAll+0x2a>
    currtp->u.ewmask = events;
  2048ee:	9b03      	ldr	r3, [sp, #12]
  2048f0:	9a01      	ldr	r2, [sp, #4]
  2048f2:	635a      	str	r2, [r3, #52]	@ 0x34
    chSchGoSleepS(CH_STATE_WTANDEVT);
  2048f4:	200b      	movs	r0, #11
  2048f6:	f7fe f92b 	bl	202b50 <chSchGoSleepS>
  }
  currtp->epending &= ~events;
  2048fa:	9b03      	ldr	r3, [sp, #12]
  2048fc:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  2048fe:	9b01      	ldr	r3, [sp, #4]
  204900:	43db      	mvns	r3, r3
  204902:	401a      	ands	r2, r3
  204904:	9b03      	ldr	r3, [sp, #12]
  204906:	645a      	str	r2, [r3, #68]	@ 0x44
  chSysUnlock();
  204908:	f7ff fdfa 	bl	204500 <chSysUnlock.lto_priv.9>

  return events;
  20490c:	9b01      	ldr	r3, [sp, #4]
}
  20490e:	4618      	mov	r0, r3
  204910:	b005      	add	sp, #20
  204912:	f85d fb04 	ldr.w	pc, [sp], #4
  204916:	bf00      	nop
	...

00204920 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
  204920:	b500      	push	{lr}
  204922:	b085      	sub	sp, #20
  204924:	9001      	str	r0, [sp, #4]
  204926:	9100      	str	r1, [sp, #0]
  thread_t *currtp = chThdGetSelfX();
  204928:	f7ff fdfa 	bl	204520 <chThdGetSelfX.lto_priv.4>
  20492c:	9002      	str	r0, [sp, #8]
  eventmask_t m;

  chSysLock();
  20492e:	f7ff fdd7 	bl	2044e0 <chSysLock.lto_priv.9>
  m = currtp->epending & events;
  204932:	9b02      	ldr	r3, [sp, #8]
  204934:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  204936:	9a01      	ldr	r2, [sp, #4]
  204938:	4013      	ands	r3, r2
  20493a:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
  20493c:	9b03      	ldr	r3, [sp, #12]
  20493e:	2b00      	cmp	r3, #0
  204940:	d119      	bne.n	204976 <chEvtWaitOneTimeout+0x56>
    if (TIME_IMMEDIATE == timeout) {
  204942:	9b00      	ldr	r3, [sp, #0]
  204944:	2b00      	cmp	r3, #0
  204946:	d103      	bne.n	204950 <chEvtWaitOneTimeout+0x30>
      chSysUnlock();
  204948:	f7ff fdda 	bl	204500 <chSysUnlock.lto_priv.9>
      return (eventmask_t)0;
  20494c:	2300      	movs	r3, #0
  20494e:	e021      	b.n	204994 <chEvtWaitOneTimeout+0x74>
    }
    currtp->u.ewmask = events;
  204950:	9b02      	ldr	r3, [sp, #8]
  204952:	9a01      	ldr	r2, [sp, #4]
  204954:	635a      	str	r2, [r3, #52]	@ 0x34
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
  204956:	9900      	ldr	r1, [sp, #0]
  204958:	200a      	movs	r0, #10
  20495a:	f7fe f921 	bl	202ba0 <chSchGoSleepTimeoutS>
  20495e:	4603      	mov	r3, r0
  204960:	2b00      	cmp	r3, #0
  204962:	da03      	bge.n	20496c <chEvtWaitOneTimeout+0x4c>
      chSysUnlock();
  204964:	f7ff fdcc 	bl	204500 <chSysUnlock.lto_priv.9>
      return (eventmask_t)0;
  204968:	2300      	movs	r3, #0
  20496a:	e013      	b.n	204994 <chEvtWaitOneTimeout+0x74>
    }
    m = currtp->epending & events;
  20496c:	9b02      	ldr	r3, [sp, #8]
  20496e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  204970:	9a01      	ldr	r2, [sp, #4]
  204972:	4013      	ands	r3, r2
  204974:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
  204976:	9b03      	ldr	r3, [sp, #12]
  204978:	425b      	negs	r3, r3
  20497a:	9a03      	ldr	r2, [sp, #12]
  20497c:	4013      	ands	r3, r2
  20497e:	9303      	str	r3, [sp, #12]
  currtp->epending &= ~m;
  204980:	9b02      	ldr	r3, [sp, #8]
  204982:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  204984:	9b03      	ldr	r3, [sp, #12]
  204986:	43db      	mvns	r3, r3
  204988:	401a      	ands	r2, r3
  20498a:	9b02      	ldr	r3, [sp, #8]
  20498c:	645a      	str	r2, [r3, #68]	@ 0x44
  chSysUnlock();
  20498e:	f7ff fdb7 	bl	204500 <chSysUnlock.lto_priv.9>

  return m;
  204992:	9b03      	ldr	r3, [sp, #12]
}
  204994:	4618      	mov	r0, r3
  204996:	b005      	add	sp, #20
  204998:	f85d fb04 	ldr.w	pc, [sp], #4
  20499c:	0000      	movs	r0, r0
	...

002049a0 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, sysinterval_t timeout) {
  2049a0:	b500      	push	{lr}
  2049a2:	b085      	sub	sp, #20
  2049a4:	9001      	str	r0, [sp, #4]
  2049a6:	9100      	str	r1, [sp, #0]
  thread_t *currtp = chThdGetSelfX();
  2049a8:	f7ff fdba 	bl	204520 <chThdGetSelfX.lto_priv.4>
  2049ac:	9002      	str	r0, [sp, #8]
  eventmask_t m;

  chSysLock();
  2049ae:	f7ff fd97 	bl	2044e0 <chSysLock.lto_priv.9>
  m = currtp->epending & events;
  2049b2:	9b02      	ldr	r3, [sp, #8]
  2049b4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  2049b6:	9a01      	ldr	r2, [sp, #4]
  2049b8:	4013      	ands	r3, r2
  2049ba:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
  2049bc:	9b03      	ldr	r3, [sp, #12]
  2049be:	2b00      	cmp	r3, #0
  2049c0:	d119      	bne.n	2049f6 <chEvtWaitAnyTimeout+0x56>
    if (TIME_IMMEDIATE == timeout) {
  2049c2:	9b00      	ldr	r3, [sp, #0]
  2049c4:	2b00      	cmp	r3, #0
  2049c6:	d103      	bne.n	2049d0 <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
  2049c8:	f7ff fd9a 	bl	204500 <chSysUnlock.lto_priv.9>
      return (eventmask_t)0;
  2049cc:	2300      	movs	r3, #0
  2049ce:	e01c      	b.n	204a0a <chEvtWaitAnyTimeout+0x6a>
    }
    currtp->u.ewmask = events;
  2049d0:	9b02      	ldr	r3, [sp, #8]
  2049d2:	9a01      	ldr	r2, [sp, #4]
  2049d4:	635a      	str	r2, [r3, #52]	@ 0x34
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
  2049d6:	9900      	ldr	r1, [sp, #0]
  2049d8:	200a      	movs	r0, #10
  2049da:	f7fe f8e1 	bl	202ba0 <chSchGoSleepTimeoutS>
  2049de:	4603      	mov	r3, r0
  2049e0:	2b00      	cmp	r3, #0
  2049e2:	da03      	bge.n	2049ec <chEvtWaitAnyTimeout+0x4c>
      chSysUnlock();
  2049e4:	f7ff fd8c 	bl	204500 <chSysUnlock.lto_priv.9>
      return (eventmask_t)0;
  2049e8:	2300      	movs	r3, #0
  2049ea:	e00e      	b.n	204a0a <chEvtWaitAnyTimeout+0x6a>
    }
    m = currtp->epending & events;
  2049ec:	9b02      	ldr	r3, [sp, #8]
  2049ee:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  2049f0:	9a01      	ldr	r2, [sp, #4]
  2049f2:	4013      	ands	r3, r2
  2049f4:	9303      	str	r3, [sp, #12]
  }
  currtp->epending &= ~m;
  2049f6:	9b02      	ldr	r3, [sp, #8]
  2049f8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  2049fa:	9b03      	ldr	r3, [sp, #12]
  2049fc:	43db      	mvns	r3, r3
  2049fe:	401a      	ands	r2, r3
  204a00:	9b02      	ldr	r3, [sp, #8]
  204a02:	645a      	str	r2, [r3, #68]	@ 0x44
  chSysUnlock();
  204a04:	f7ff fd7c 	bl	204500 <chSysUnlock.lto_priv.9>

  return m;
  204a08:	9b03      	ldr	r3, [sp, #12]
}
  204a0a:	4618      	mov	r0, r3
  204a0c:	b005      	add	sp, #20
  204a0e:	f85d fb04 	ldr.w	pc, [sp], #4
  204a12:	bf00      	nop
	...

00204a20 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, sysinterval_t timeout) {
  204a20:	b500      	push	{lr}
  204a22:	b085      	sub	sp, #20
  204a24:	9001      	str	r0, [sp, #4]
  204a26:	9100      	str	r1, [sp, #0]
  thread_t *currtp = chThdGetSelfX();
  204a28:	f7ff fd7a 	bl	204520 <chThdGetSelfX.lto_priv.4>
  204a2c:	9003      	str	r0, [sp, #12]

  chSysLock();
  204a2e:	f7ff fd57 	bl	2044e0 <chSysLock.lto_priv.9>
  if ((currtp->epending & events) != events) {
  204a32:	9b03      	ldr	r3, [sp, #12]
  204a34:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  204a36:	9b01      	ldr	r3, [sp, #4]
  204a38:	4013      	ands	r3, r2
  204a3a:	9a01      	ldr	r2, [sp, #4]
  204a3c:	429a      	cmp	r2, r3
  204a3e:	d014      	beq.n	204a6a <chEvtWaitAllTimeout+0x4a>
    if (TIME_IMMEDIATE == timeout) {
  204a40:	9b00      	ldr	r3, [sp, #0]
  204a42:	2b00      	cmp	r3, #0
  204a44:	d103      	bne.n	204a4e <chEvtWaitAllTimeout+0x2e>
      chSysUnlock();
  204a46:	f7ff fd5b 	bl	204500 <chSysUnlock.lto_priv.9>
      return (eventmask_t)0;
  204a4a:	2300      	movs	r3, #0
  204a4c:	e017      	b.n	204a7e <chEvtWaitAllTimeout+0x5e>
    }
    currtp->u.ewmask = events;
  204a4e:	9b03      	ldr	r3, [sp, #12]
  204a50:	9a01      	ldr	r2, [sp, #4]
  204a52:	635a      	str	r2, [r3, #52]	@ 0x34
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
  204a54:	9900      	ldr	r1, [sp, #0]
  204a56:	200b      	movs	r0, #11
  204a58:	f7fe f8a2 	bl	202ba0 <chSchGoSleepTimeoutS>
  204a5c:	4603      	mov	r3, r0
  204a5e:	2b00      	cmp	r3, #0
  204a60:	da03      	bge.n	204a6a <chEvtWaitAllTimeout+0x4a>
      chSysUnlock();
  204a62:	f7ff fd4d 	bl	204500 <chSysUnlock.lto_priv.9>
      return (eventmask_t)0;
  204a66:	2300      	movs	r3, #0
  204a68:	e009      	b.n	204a7e <chEvtWaitAllTimeout+0x5e>
    }
  }
  currtp->epending &= ~events;
  204a6a:	9b03      	ldr	r3, [sp, #12]
  204a6c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  204a6e:	9b01      	ldr	r3, [sp, #4]
  204a70:	43db      	mvns	r3, r3
  204a72:	401a      	ands	r2, r3
  204a74:	9b03      	ldr	r3, [sp, #12]
  204a76:	645a      	str	r2, [r3, #68]	@ 0x44
  chSysUnlock();
  204a78:	f7ff fd42 	bl	204500 <chSysUnlock.lto_priv.9>

  return events;
  204a7c:	9b01      	ldr	r3, [sp, #4]
}
  204a7e:	4618      	mov	r0, r3
  204a80:	b005      	add	sp, #20
  204a82:	f85d fb04 	ldr.w	pc, [sp], #4
  204a86:	bf00      	nop
	...

00204a90 <ch_queue_insert.lto_priv.3>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
  204a90:	b082      	sub	sp, #8
  204a92:	9001      	str	r0, [sp, #4]
  204a94:	9100      	str	r1, [sp, #0]
  p->next       = qp;
  204a96:	9b00      	ldr	r3, [sp, #0]
  204a98:	9a01      	ldr	r2, [sp, #4]
  204a9a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
  204a9c:	9b01      	ldr	r3, [sp, #4]
  204a9e:	685a      	ldr	r2, [r3, #4]
  204aa0:	9b00      	ldr	r3, [sp, #0]
  204aa2:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
  204aa4:	9b00      	ldr	r3, [sp, #0]
  204aa6:	685b      	ldr	r3, [r3, #4]
  204aa8:	9a00      	ldr	r2, [sp, #0]
  204aaa:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
  204aac:	9b01      	ldr	r3, [sp, #4]
  204aae:	9a00      	ldr	r2, [sp, #0]
  204ab0:	605a      	str	r2, [r3, #4]
}
  204ab2:	bf00      	nop
  204ab4:	b002      	add	sp, #8
  204ab6:	4770      	bx	lr
	...

00204ac0 <ch_queue_fifo_remove.lto_priv.4>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  204ac0:	b084      	sub	sp, #16
  204ac2:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
  204ac4:	9b01      	ldr	r3, [sp, #4]
  204ac6:	681b      	ldr	r3, [r3, #0]
  204ac8:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
  204aca:	9b03      	ldr	r3, [sp, #12]
  204acc:	681a      	ldr	r2, [r3, #0]
  204ace:	9b01      	ldr	r3, [sp, #4]
  204ad0:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
  204ad2:	9b01      	ldr	r3, [sp, #4]
  204ad4:	681b      	ldr	r3, [r3, #0]
  204ad6:	9a01      	ldr	r2, [sp, #4]
  204ad8:	605a      	str	r2, [r3, #4]
  return p;
  204ada:	9b03      	ldr	r3, [sp, #12]
}
  204adc:	4618      	mov	r0, r3
  204ade:	b004      	add	sp, #16
  204ae0:	4770      	bx	lr
  204ae2:	bf00      	nop
	...

00204af0 <chSysLock.lto_priv.10>:
static inline void chSysLock(void) {
  204af0:	b082      	sub	sp, #8
  204af2:	2330      	movs	r3, #48	@ 0x30
  204af4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204af6:	9b01      	ldr	r3, [sp, #4]
  204af8:	f383 8811 	msr	BASEPRI, r3
}
  204afc:	bf00      	nop
}
  204afe:	bf00      	nop
}
  204b00:	bf00      	nop
  204b02:	b002      	add	sp, #8
  204b04:	4770      	bx	lr
  204b06:	bf00      	nop
	...

00204b10 <chSysUnlock.lto_priv.10>:
static inline void chSysUnlock(void) {
  204b10:	b082      	sub	sp, #8
  204b12:	2300      	movs	r3, #0
  204b14:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204b16:	9b01      	ldr	r3, [sp, #4]
  204b18:	f383 8811 	msr	BASEPRI, r3
}
  204b1c:	bf00      	nop
}
  204b1e:	bf00      	nop
}
  204b20:	bf00      	nop
  204b22:	b002      	add	sp, #8
  204b24:	4770      	bx	lr
  204b26:	bf00      	nop
	...

00204b30 <chThdGetSelfX.lto_priv.5>:
  return __sch_get_currthread();
  204b30:	4b01      	ldr	r3, [pc, #4]	@ (204b38 <chThdGetSelfX.lto_priv.5+0x8>)
  204b32:	68db      	ldr	r3, [r3, #12]
}
  204b34:	4618      	mov	r0, r3
  204b36:	4770      	bx	lr
  204b38:	20000890 	.word	0x20000890
  204b3c:	00000000 	.word	0x00000000

00204b40 <chMsgIsPendingI>:
 * @param[in] tp        pointer to the thread
 * @return              The pending messages status.
 *
 * @iclass
 */
static inline bool chMsgIsPendingI(thread_t *tp) {
  204b40:	b082      	sub	sp, #8
  204b42:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(tp->msgqueue.next != &tp->msgqueue);
  204b44:	9b01      	ldr	r3, [sp, #4]
  204b46:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
  204b48:	9b01      	ldr	r3, [sp, #4]
  204b4a:	333c      	adds	r3, #60	@ 0x3c
  204b4c:	429a      	cmp	r2, r3
  204b4e:	bf14      	ite	ne
  204b50:	2301      	movne	r3, #1
  204b52:	2300      	moveq	r3, #0
  204b54:	b2db      	uxtb	r3, r3
}
  204b56:	4618      	mov	r0, r3
  204b58:	b002      	add	sp, #8
  204b5a:	4770      	bx	lr
  204b5c:	0000      	movs	r0, r0
	...

00204b60 <chMsgReleaseS>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {
  204b60:	b500      	push	{lr}
  204b62:	b083      	sub	sp, #12
  204b64:	9001      	str	r0, [sp, #4]
  204b66:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
  204b68:	9900      	ldr	r1, [sp, #0]
  204b6a:	9801      	ldr	r0, [sp, #4]
  204b6c:	f7fe f850 	bl	202c10 <chSchWakeupS>
}
  204b70:	bf00      	nop
  204b72:	b003      	add	sp, #12
  204b74:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00204b80 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
  204b80:	b500      	push	{lr}
  204b82:	b085      	sub	sp, #20
  204b84:	9001      	str	r0, [sp, #4]
  204b86:	9100      	str	r1, [sp, #0]
  thread_t *currtp = chThdGetSelfX();
  204b88:	f7ff ffd2 	bl	204b30 <chThdGetSelfX.lto_priv.5>
  204b8c:	9003      	str	r0, [sp, #12]

  chDbgCheck(tp != NULL);

  chSysLock();
  204b8e:	f7ff ffaf 	bl	204af0 <chSysLock.lto_priv.10>
  currtp->u.sentmsg = msg;
  204b92:	9b03      	ldr	r3, [sp, #12]
  204b94:	9a00      	ldr	r2, [sp, #0]
  204b96:	635a      	str	r2, [r3, #52]	@ 0x34
  __ch_msg_insert(&tp->msgqueue, currtp);
  204b98:	9b01      	ldr	r3, [sp, #4]
  204b9a:	333c      	adds	r3, #60	@ 0x3c
  204b9c:	9a03      	ldr	r2, [sp, #12]
  204b9e:	4611      	mov	r1, r2
  204ba0:	4618      	mov	r0, r3
  204ba2:	f7ff ff75 	bl	204a90 <ch_queue_insert.lto_priv.3>
  if (tp->state == CH_STATE_WTMSG) {
  204ba6:	9b01      	ldr	r3, [sp, #4]
  204ba8:	7f1b      	ldrb	r3, [r3, #28]
  204baa:	2b0e      	cmp	r3, #14
  204bac:	d102      	bne.n	204bb4 <chMsgSend+0x34>
    (void) chSchReadyI(tp);
  204bae:	9801      	ldr	r0, [sp, #4]
  204bb0:	f7fd ffbe 	bl	202b30 <chSchReadyI>
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
  204bb4:	200c      	movs	r0, #12
  204bb6:	f7fd ffcb 	bl	202b50 <chSchGoSleepS>
  msg = currtp->u.rdymsg;
  204bba:	9b03      	ldr	r3, [sp, #12]
  204bbc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  204bbe:	9300      	str	r3, [sp, #0]
  chSysUnlock();
  204bc0:	f7ff ffa6 	bl	204b10 <chSysUnlock.lto_priv.10>

  return msg;
  204bc4:	9b00      	ldr	r3, [sp, #0]
}
  204bc6:	4618      	mov	r0, r3
  204bc8:	b005      	add	sp, #20
  204bca:	f85d fb04 	ldr.w	pc, [sp], #4
  204bce:	bf00      	nop

00204bd0 <chMsgWaitS>:
 *
 * @return              A pointer to the thread carrying the message.
 *
 * @sclass
 */
thread_t *chMsgWaitS(void) {
  204bd0:	b500      	push	{lr}
  204bd2:	b083      	sub	sp, #12
  thread_t *currtp = chThdGetSelfX();
  204bd4:	f7ff ffac 	bl	204b30 <chThdGetSelfX.lto_priv.5>
  204bd8:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassS();

  if (!chMsgIsPendingI(currtp)) {
  204bda:	9801      	ldr	r0, [sp, #4]
  204bdc:	f7ff ffb0 	bl	204b40 <chMsgIsPendingI>
  204be0:	4603      	mov	r3, r0
  204be2:	f083 0301 	eor.w	r3, r3, #1
  204be6:	b2db      	uxtb	r3, r3
  204be8:	2b00      	cmp	r3, #0
  204bea:	d002      	beq.n	204bf2 <chMsgWaitS+0x22>
    chSchGoSleepS(CH_STATE_WTMSG);
  204bec:	200e      	movs	r0, #14
  204bee:	f7fd ffaf 	bl	202b50 <chSchGoSleepS>
  }
  tp = threadref(ch_queue_fifo_remove(&currtp->msgqueue));
  204bf2:	9b01      	ldr	r3, [sp, #4]
  204bf4:	333c      	adds	r3, #60	@ 0x3c
  204bf6:	4618      	mov	r0, r3
  204bf8:	f7ff ff62 	bl	204ac0 <ch_queue_fifo_remove.lto_priv.4>
  204bfc:	9000      	str	r0, [sp, #0]
  tp->state = CH_STATE_SNDMSG;
  204bfe:	9b00      	ldr	r3, [sp, #0]
  204c00:	220d      	movs	r2, #13
  204c02:	771a      	strb	r2, [r3, #28]

  return tp;
  204c04:	9b00      	ldr	r3, [sp, #0]
}
  204c06:	4618      	mov	r0, r3
  204c08:	b003      	add	sp, #12
  204c0a:	f85d fb04 	ldr.w	pc, [sp], #4
  204c0e:	bf00      	nop

00204c10 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
  204c10:	b500      	push	{lr}
  204c12:	b083      	sub	sp, #12
  204c14:	9001      	str	r0, [sp, #4]
  204c16:	9100      	str	r1, [sp, #0]

  chSysLock();
  204c18:	f7ff ff6a 	bl	204af0 <chSysLock.lto_priv.10>
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
  chMsgReleaseS(tp, msg);
  204c1c:	9900      	ldr	r1, [sp, #0]
  204c1e:	9801      	ldr	r0, [sp, #4]
  204c20:	f7ff ff9e 	bl	204b60 <chMsgReleaseS>
  chSysUnlock();
  204c24:	f7ff ff74 	bl	204b10 <chSysUnlock.lto_priv.10>
}
  204c28:	bf00      	nop
  204c2a:	b003      	add	sp, #12
  204c2c:	f85d fb04 	ldr.w	pc, [sp], #4

00204c30 <chSysLock.lto_priv.11>:
static inline void chSysLock(void) {
  204c30:	b082      	sub	sp, #8
  204c32:	2330      	movs	r3, #48	@ 0x30
  204c34:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204c36:	9b01      	ldr	r3, [sp, #4]
  204c38:	f383 8811 	msr	BASEPRI, r3
}
  204c3c:	bf00      	nop
}
  204c3e:	bf00      	nop
}
  204c40:	bf00      	nop
  204c42:	b002      	add	sp, #8
  204c44:	4770      	bx	lr
  204c46:	bf00      	nop
	...

00204c50 <chSysUnlock.lto_priv.11>:
static inline void chSysUnlock(void) {
  204c50:	b082      	sub	sp, #8
  204c52:	2300      	movs	r3, #0
  204c54:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204c56:	9b01      	ldr	r3, [sp, #4]
  204c58:	f383 8811 	msr	BASEPRI, r3
}
  204c5c:	bf00      	nop
}
  204c5e:	bf00      	nop
}
  204c60:	bf00      	nop
  204c62:	b002      	add	sp, #8
  204c64:	4770      	bx	lr
  204c66:	bf00      	nop
	...

00204c70 <chThdSetCallbackX>:
                                     void *object) {
  204c70:	b084      	sub	sp, #16
  204c72:	9003      	str	r0, [sp, #12]
  204c74:	9102      	str	r1, [sp, #8]
  204c76:	9201      	str	r2, [sp, #4]
  tp->dispose = dispose;
  204c78:	9b03      	ldr	r3, [sp, #12]
  204c7a:	9a02      	ldr	r2, [sp, #8]
  204c7c:	62da      	str	r2, [r3, #44]	@ 0x2c
  tp->object  = object;
  204c7e:	9b03      	ldr	r3, [sp, #12]
  204c80:	9a01      	ldr	r2, [sp, #4]
  204c82:	631a      	str	r2, [r3, #48]	@ 0x30
}
  204c84:	bf00      	nop
  204c86:	b004      	add	sp, #16
  204c88:	4770      	bx	lr
  204c8a:	bf00      	nop
  204c8c:	0000      	movs	r0, r0
	...

00204c90 <thd_heapfree>:
/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

#if (CH_CFG_USE_HEAP == TRUE) || defined(__DOXYGEN__)
static void thd_heapfree(thread_t *tp) {
  204c90:	b500      	push	{lr}
  204c92:	b083      	sub	sp, #12
  204c94:	9001      	str	r0, [sp, #4]

  chHeapFree((void *)tp->wabase);
  204c96:	9b01      	ldr	r3, [sp, #4]
  204c98:	695b      	ldr	r3, [r3, #20]
  204c9a:	4618      	mov	r0, r3
  204c9c:	f000 fd48 	bl	205730 <chHeapFree>
}
  204ca0:	bf00      	nop
  204ca2:	b003      	add	sp, #12
  204ca4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00204cb0 <thd_poolfree>:
#endif /* CH_CFG_USE_HEAP == TRUE */

#if (CH_CFG_USE_MEMPOOLS == TRUE) || defined(__DOXYGEN__)
static void thd_poolfree(thread_t *tp) {
  204cb0:	b500      	push	{lr}
  204cb2:	b083      	sub	sp, #12
  204cb4:	9001      	str	r0, [sp, #4]

  chPoolFree((memory_pool_t *)tp->object, (void *)tp->wabase);
  204cb6:	9b01      	ldr	r3, [sp, #4]
  204cb8:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
  204cba:	9b01      	ldr	r3, [sp, #4]
  204cbc:	695b      	ldr	r3, [r3, #20]
  204cbe:	4619      	mov	r1, r3
  204cc0:	4610      	mov	r0, r2
  204cc2:	f000 ff35 	bl	205b30 <chPoolFree>
}
  204cc6:	bf00      	nop
  204cc8:	b003      	add	sp, #12
  204cca:	f85d fb04 	ldr.w	pc, [sp], #4
  204cce:	bf00      	nop

00204cd0 <chThdCreateFromHeap>:
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
  204cd0:	b500      	push	{lr}
  204cd2:	b08f      	sub	sp, #60	@ 0x3c
  204cd4:	9003      	str	r0, [sp, #12]
  204cd6:	9102      	str	r1, [sp, #8]
  204cd8:	9201      	str	r2, [sp, #4]
  204cda:	9300      	str	r3, [sp, #0]
  thread_t *tp;
  void *wbase, *wend;

  wbase = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  204cdc:	2220      	movs	r2, #32
  204cde:	9902      	ldr	r1, [sp, #8]
  204ce0:	9803      	ldr	r0, [sp, #12]
  204ce2:	f000 fc55 	bl	205590 <chHeapAllocAligned>
  204ce6:	900d      	str	r0, [sp, #52]	@ 0x34
  if (wbase == NULL) {
  204ce8:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  204cea:	2b00      	cmp	r3, #0
  204cec:	d101      	bne.n	204cf2 <chThdCreateFromHeap+0x22>
    return NULL;
  204cee:	2300      	movs	r3, #0
  204cf0:	e024      	b.n	204d3c <chThdCreateFromHeap+0x6c>
  }
  wend = (void *)((uint8_t *)wbase + size);
  204cf2:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
  204cf4:	9b02      	ldr	r3, [sp, #8]
  204cf6:	4413      	add	r3, r2
  204cf8:	930c      	str	r3, [sp, #48]	@ 0x30

  thread_descriptor_t td = __THD_DECL_DATA(name, wbase, wend, prio,
  204cfa:	9b01      	ldr	r3, [sp, #4]
  204cfc:	9304      	str	r3, [sp, #16]
  204cfe:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  204d00:	9305      	str	r3, [sp, #20]
  204d02:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
  204d04:	9306      	str	r3, [sp, #24]
  204d06:	9b00      	ldr	r3, [sp, #0]
  204d08:	9307      	str	r3, [sp, #28]
  204d0a:	9b10      	ldr	r3, [sp, #64]	@ 0x40
  204d0c:	9308      	str	r3, [sp, #32]
  204d0e:	9b11      	ldr	r3, [sp, #68]	@ 0x44
  204d10:	9309      	str	r3, [sp, #36]	@ 0x24
  204d12:	2300      	movs	r3, #0
  204d14:	930a      	str	r3, [sp, #40]	@ 0x28

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wbase, (uint8_t *)wend);
#endif

  chSysLock();
  204d16:	f7ff ff8b 	bl	204c30 <chSysLock.lto_priv.11>
  tp = chThdCreateSuspendedI(&td);
  204d1a:	ab04      	add	r3, sp, #16
  204d1c:	4618      	mov	r0, r3
  204d1e:	f7fe fadf 	bl	2032e0 <chThdCreateSuspendedI>
  204d22:	900b      	str	r0, [sp, #44]	@ 0x2c
  chThdSetCallbackX(tp, thd_heapfree, NULL);
  204d24:	2200      	movs	r2, #0
  204d26:	4907      	ldr	r1, [pc, #28]	@ (204d44 <chThdCreateFromHeap+0x74>)
  204d28:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  204d2a:	f7ff ffa1 	bl	204c70 <chThdSetCallbackX>
  chSchWakeupS(tp, MSG_OK);
  204d2e:	2100      	movs	r1, #0
  204d30:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  204d32:	f7fd ff6d 	bl	202c10 <chSchWakeupS>
  chSysUnlock();
  204d36:	f7ff ff8b 	bl	204c50 <chSysUnlock.lto_priv.11>

  return tp;
  204d3a:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
}
  204d3c:	4618      	mov	r0, r3
  204d3e:	b00f      	add	sp, #60	@ 0x3c
  204d40:	f85d fb04 	ldr.w	pc, [sp], #4
  204d44:	00204c91 	.word	0x00204c91
	...

00204d50 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
                                    tprio_t prio, tfunc_t pf, void *arg) {
  204d50:	b500      	push	{lr}
  204d52:	b08f      	sub	sp, #60	@ 0x3c
  204d54:	9003      	str	r0, [sp, #12]
  204d56:	9102      	str	r1, [sp, #8]
  204d58:	9201      	str	r2, [sp, #4]
  204d5a:	9300      	str	r3, [sp, #0]
  thread_t *tp;
  void *wbase, *wend;

  chDbgCheck(mp != NULL);

  wbase = chPoolAlloc(mp);
  204d5c:	9803      	ldr	r0, [sp, #12]
  204d5e:	f000 fec7 	bl	205af0 <chPoolAlloc>
  204d62:	900d      	str	r0, [sp, #52]	@ 0x34
  if (wbase == NULL) {
  204d64:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  204d66:	2b00      	cmp	r3, #0
  204d68:	d101      	bne.n	204d6e <chThdCreateFromMemoryPool+0x1e>
    return NULL;
  204d6a:	2300      	movs	r3, #0
  204d6c:	e025      	b.n	204dba <chThdCreateFromMemoryPool+0x6a>
  }
  wend = (void *)((uint8_t *)wbase + mp->object_size);
  204d6e:	9b03      	ldr	r3, [sp, #12]
  204d70:	685b      	ldr	r3, [r3, #4]
  204d72:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
  204d74:	4413      	add	r3, r2
  204d76:	930c      	str	r3, [sp, #48]	@ 0x30

  thread_descriptor_t td = __THD_DECL_DATA(name, wbase, wend, prio,
  204d78:	9b02      	ldr	r3, [sp, #8]
  204d7a:	9304      	str	r3, [sp, #16]
  204d7c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  204d7e:	9305      	str	r3, [sp, #20]
  204d80:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
  204d82:	9306      	str	r3, [sp, #24]
  204d84:	9b01      	ldr	r3, [sp, #4]
  204d86:	9307      	str	r3, [sp, #28]
  204d88:	9b00      	ldr	r3, [sp, #0]
  204d8a:	9308      	str	r3, [sp, #32]
  204d8c:	9b10      	ldr	r3, [sp, #64]	@ 0x40
  204d8e:	9309      	str	r3, [sp, #36]	@ 0x24
  204d90:	2300      	movs	r3, #0
  204d92:	930a      	str	r3, [sp, #40]	@ 0x28

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wbase, (uint8_t *)wend);
#endif

  chSysLock();
  204d94:	f7ff ff4c 	bl	204c30 <chSysLock.lto_priv.11>
  tp = chThdCreateSuspendedI(&td);
  204d98:	ab04      	add	r3, sp, #16
  204d9a:	4618      	mov	r0, r3
  204d9c:	f7fe faa0 	bl	2032e0 <chThdCreateSuspendedI>
  204da0:	900b      	str	r0, [sp, #44]	@ 0x2c
  chThdSetCallbackX(tp, thd_poolfree, (void *)mp);
  204da2:	9a03      	ldr	r2, [sp, #12]
  204da4:	4907      	ldr	r1, [pc, #28]	@ (204dc4 <chThdCreateFromMemoryPool+0x74>)
  204da6:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  204da8:	f7ff ff62 	bl	204c70 <chThdSetCallbackX>
  chSchWakeupS(tp, MSG_OK);
  204dac:	2100      	movs	r1, #0
  204dae:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  204db0:	f7fd ff2e 	bl	202c10 <chSchWakeupS>
  chSysUnlock();
  204db4:	f7ff ff4c 	bl	204c50 <chSysUnlock.lto_priv.11>

  return tp;
  204db8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
}
  204dba:	4618      	mov	r0, r3
  204dbc:	b00f      	add	sp, #60	@ 0x3c
  204dbe:	f85d fb04 	ldr.w	pc, [sp], #4
  204dc2:	bf00      	nop
  204dc4:	00204cb1 	.word	0x00204cb1
	...

00204dd0 <chMemIsSpaceWithinX.lto_priv.0>:
 *
 * @xclass
 */
static inline bool chMemIsSpaceWithinX(const memory_area_t *map,
                                       const void *p,
                                       size_t size) {
  204dd0:	b088      	sub	sp, #32
  204dd2:	9003      	str	r0, [sp, #12]
  204dd4:	9102      	str	r1, [sp, #8]
  204dd6:	9201      	str	r2, [sp, #4]
  const uint8_t *mem_base = (const uint8_t *)map->base;
  204dd8:	9b03      	ldr	r3, [sp, #12]
  204dda:	681b      	ldr	r3, [r3, #0]
  204ddc:	9307      	str	r3, [sp, #28]
  const uint8_t *mem_end  = mem_base + map->size - (size_t)1;
  204dde:	9b03      	ldr	r3, [sp, #12]
  204de0:	685b      	ldr	r3, [r3, #4]
  204de2:	3b01      	subs	r3, #1
  204de4:	9a07      	ldr	r2, [sp, #28]
  204de6:	4413      	add	r3, r2
  204de8:	9306      	str	r3, [sp, #24]
  const uint8_t *base     = (const uint8_t *)p;
  204dea:	9b02      	ldr	r3, [sp, #8]
  204dec:	9305      	str	r3, [sp, #20]
  const uint8_t *end      = base + size - (size_t)1;
  204dee:	9b01      	ldr	r3, [sp, #4]
  204df0:	3b01      	subs	r3, #1
  204df2:	9a05      	ldr	r2, [sp, #20]
  204df4:	4413      	add	r3, r2
  204df6:	9304      	str	r3, [sp, #16]

  chDbgAssert((mem_base <= mem_end) && (base <= end), "invalid memory area");

  return (bool)((base <= end) && (base >= mem_base) && (end <= mem_end));
  204df8:	9a05      	ldr	r2, [sp, #20]
  204dfa:	9b04      	ldr	r3, [sp, #16]
  204dfc:	429a      	cmp	r2, r3
  204dfe:	d809      	bhi.n	204e14 <chMemIsSpaceWithinX.lto_priv.0+0x44>
  204e00:	9a05      	ldr	r2, [sp, #20]
  204e02:	9b07      	ldr	r3, [sp, #28]
  204e04:	429a      	cmp	r2, r3
  204e06:	d305      	bcc.n	204e14 <chMemIsSpaceWithinX.lto_priv.0+0x44>
  204e08:	9a04      	ldr	r2, [sp, #16]
  204e0a:	9b06      	ldr	r3, [sp, #24]
  204e0c:	429a      	cmp	r2, r3
  204e0e:	d801      	bhi.n	204e14 <chMemIsSpaceWithinX.lto_priv.0+0x44>
  204e10:	2301      	movs	r3, #1
  204e12:	e000      	b.n	204e16 <chMemIsSpaceWithinX.lto_priv.0+0x46>
  204e14:	2300      	movs	r3, #0
  204e16:	f003 0301 	and.w	r3, r3, #1
  204e1a:	b2db      	uxtb	r3, r3
}
  204e1c:	4618      	mov	r0, r3
  204e1e:	b008      	add	sp, #32
  204e20:	4770      	bx	lr
  204e22:	bf00      	nop
	...

00204e30 <chMemIsSpaceContainedX>:
 *
 * @xclass
 */
bool chMemIsSpaceContainedX(const memory_area_t areas[],
                            const void *p,
                            size_t size) {
  204e30:	b500      	push	{lr}
  204e32:	b087      	sub	sp, #28
  204e34:	9003      	str	r0, [sp, #12]
  204e36:	9102      	str	r1, [sp, #8]
  204e38:	9201      	str	r2, [sp, #4]
  const memory_area_t *map = &areas[0];
  204e3a:	9b03      	ldr	r3, [sp, #12]
  204e3c:	9305      	str	r3, [sp, #20]

  chDbgCheck(p != NULL);

  /* Scanning the array of the valid areas for a mismatch.*/
  while (map->base != (uint8_t *)-1) {
  204e3e:	e00c      	b.n	204e5a <chMemIsSpaceContainedX+0x2a>
    if (chMemIsSpaceWithinX(map, p, size)) {
  204e40:	9a01      	ldr	r2, [sp, #4]
  204e42:	9902      	ldr	r1, [sp, #8]
  204e44:	9805      	ldr	r0, [sp, #20]
  204e46:	f7ff ffc3 	bl	204dd0 <chMemIsSpaceWithinX.lto_priv.0>
  204e4a:	4603      	mov	r3, r0
  204e4c:	2b00      	cmp	r3, #0
  204e4e:	d001      	beq.n	204e54 <chMemIsSpaceContainedX+0x24>
      return true;
  204e50:	2301      	movs	r3, #1
  204e52:	e008      	b.n	204e66 <chMemIsSpaceContainedX+0x36>
    }
    map++;
  204e54:	9b05      	ldr	r3, [sp, #20]
  204e56:	3308      	adds	r3, #8
  204e58:	9305      	str	r3, [sp, #20]
  while (map->base != (uint8_t *)-1) {
  204e5a:	9b05      	ldr	r3, [sp, #20]
  204e5c:	681b      	ldr	r3, [r3, #0]
  204e5e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  204e62:	d1ed      	bne.n	204e40 <chMemIsSpaceContainedX+0x10>
  }

  return false;
  204e64:	2300      	movs	r3, #0
}
  204e66:	4618      	mov	r0, r3
  204e68:	b007      	add	sp, #28
  204e6a:	f85d fb04 	ldr.w	pc, [sp], #4
  204e6e:	bf00      	nop

00204e70 <chMemIsAddressExecutableX>:
 *                      system-defined executable areas.
 * @retval false        if the address check failed.
 *
 * @xclass
 */
bool chMemIsAddressExecutableX(const void *p) {
  204e70:	b500      	push	{lr}
  204e72:	b083      	sub	sp, #12
  204e74:	9001      	str	r0, [sp, #4]
  if (!MEM_IS_VALID_FUNCTION(p)) {
  /*lint -restore*/
    return false;
  }

  return chMemIsSpaceContainedX(__ch_mem_executable_areas, p, 1);
  204e76:	2201      	movs	r2, #1
  204e78:	9901      	ldr	r1, [sp, #4]
  204e7a:	4804      	ldr	r0, [pc, #16]	@ (204e8c <chMemIsAddressExecutableX+0x1c>)
  204e7c:	f7ff ffd8 	bl	204e30 <chMemIsSpaceContainedX>
  204e80:	4603      	mov	r3, r0
}
  204e82:	4618      	mov	r0, r3
  204e84:	b003      	add	sp, #12
  204e86:	f85d fb04 	ldr.w	pc, [sp], #4
  204e8a:	bf00      	nop
  204e8c:	080121d4 	.word	0x080121d4

00204e90 <chSysLock.lto_priv.12>:
static inline void chSysLock(void) {
  204e90:	b082      	sub	sp, #8
  204e92:	2330      	movs	r3, #48	@ 0x30
  204e94:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204e96:	9b01      	ldr	r3, [sp, #4]
  204e98:	f383 8811 	msr	BASEPRI, r3
}
  204e9c:	bf00      	nop
}
  204e9e:	bf00      	nop
}
  204ea0:	bf00      	nop
  204ea2:	b002      	add	sp, #8
  204ea4:	4770      	bx	lr
  204ea6:	bf00      	nop
	...

00204eb0 <chSysUnlock.lto_priv.12>:
static inline void chSysUnlock(void) {
  204eb0:	b082      	sub	sp, #8
  204eb2:	2300      	movs	r3, #0
  204eb4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204eb6:	9b01      	ldr	r3, [sp, #4]
  204eb8:	f383 8811 	msr	BASEPRI, r3
}
  204ebc:	bf00      	nop
}
  204ebe:	bf00      	nop
}
  204ec0:	bf00      	nop
  204ec2:	b002      	add	sp, #8
  204ec4:	4770      	bx	lr
  204ec6:	bf00      	nop
	...

00204ed0 <chMBGetSizeI.lto_priv.0>:
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 * @return              The size of the mailbox.
 *
 * @iclass
 */
static inline size_t chMBGetSizeI(const mailbox_t *mbp) {
  204ed0:	b082      	sub	sp, #8
  204ed2:	9001      	str	r0, [sp, #4]

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (size_t)(mbp->top - mbp->buffer);
  204ed4:	9b01      	ldr	r3, [sp, #4]
  204ed6:	685a      	ldr	r2, [r3, #4]
  204ed8:	9b01      	ldr	r3, [sp, #4]
  204eda:	681b      	ldr	r3, [r3, #0]
  204edc:	1ad3      	subs	r3, r2, r3
  204ede:	109b      	asrs	r3, r3, #2
  /*lint -restore*/
}
  204ee0:	4618      	mov	r0, r3
  204ee2:	b002      	add	sp, #8
  204ee4:	4770      	bx	lr
  204ee6:	bf00      	nop
	...

00204ef0 <chMBGetUsedCountI.lto_priv.0>:
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 * @return              The number of queued messages.
 *
 * @iclass
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {
  204ef0:	b082      	sub	sp, #8
  204ef2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return mbp->cnt;
  204ef4:	9b01      	ldr	r3, [sp, #4]
  204ef6:	691b      	ldr	r3, [r3, #16]
}
  204ef8:	4618      	mov	r0, r3
  204efa:	b002      	add	sp, #8
  204efc:	4770      	bx	lr
  204efe:	bf00      	nop

00204f00 <chMBGetFreeCountI.lto_priv.0>:
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline size_t chMBGetFreeCountI(const mailbox_t *mbp) {
  204f00:	b510      	push	{r4, lr}
  204f02:	b082      	sub	sp, #8
  204f04:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  204f06:	9801      	ldr	r0, [sp, #4]
  204f08:	f7ff ffe2 	bl	204ed0 <chMBGetSizeI.lto_priv.0>
  204f0c:	4604      	mov	r4, r0
  204f0e:	9801      	ldr	r0, [sp, #4]
  204f10:	f7ff ffee 	bl	204ef0 <chMBGetUsedCountI.lto_priv.0>
  204f14:	4603      	mov	r3, r0
  204f16:	1ae3      	subs	r3, r4, r3
}
  204f18:	4618      	mov	r0, r3
  204f1a:	b002      	add	sp, #8
  204f1c:	bd10      	pop	{r4, pc}
  204f1e:	bf00      	nop

00204f20 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, size_t n) {
  204f20:	b500      	push	{lr}
  204f22:	b085      	sub	sp, #20
  204f24:	9003      	str	r0, [sp, #12]
  204f26:	9102      	str	r1, [sp, #8]
  204f28:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (size_t)0));

  mbp->buffer = buf;
  204f2a:	9b03      	ldr	r3, [sp, #12]
  204f2c:	9a02      	ldr	r2, [sp, #8]
  204f2e:	601a      	str	r2, [r3, #0]
  mbp->top    = &buf[n];
  204f30:	9b01      	ldr	r3, [sp, #4]
  204f32:	009b      	lsls	r3, r3, #2
  204f34:	9a02      	ldr	r2, [sp, #8]
  204f36:	441a      	add	r2, r3
  204f38:	9b03      	ldr	r3, [sp, #12]
  204f3a:	605a      	str	r2, [r3, #4]
  mbp->rdptr  = buf;
  204f3c:	9b03      	ldr	r3, [sp, #12]
  204f3e:	9a02      	ldr	r2, [sp, #8]
  204f40:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
  204f42:	9b03      	ldr	r3, [sp, #12]
  204f44:	9a02      	ldr	r2, [sp, #8]
  204f46:	609a      	str	r2, [r3, #8]
  mbp->cnt    = (size_t)0;
  204f48:	9b03      	ldr	r3, [sp, #12]
  204f4a:	2200      	movs	r2, #0
  204f4c:	611a      	str	r2, [r3, #16]
  mbp->reset  = false;
  204f4e:	9b03      	ldr	r3, [sp, #12]
  204f50:	2200      	movs	r2, #0
  204f52:	751a      	strb	r2, [r3, #20]
  chThdQueueObjectInit(&mbp->qw);
  204f54:	9b03      	ldr	r3, [sp, #12]
  204f56:	3318      	adds	r3, #24
  204f58:	4618      	mov	r0, r3
  204f5a:	f7fe fbf1 	bl	203740 <chThdQueueObjectInit>
  chThdQueueObjectInit(&mbp->qr);
  204f5e:	9b03      	ldr	r3, [sp, #12]
  204f60:	3320      	adds	r3, #32
  204f62:	4618      	mov	r0, r3
  204f64:	f7fe fbec 	bl	203740 <chThdQueueObjectInit>
}
  204f68:	bf00      	nop
  204f6a:	b005      	add	sp, #20
  204f6c:	f85d fb04 	ldr.w	pc, [sp], #4

00204f70 <chMBReset>:
 *
 * @param[in] mbp       pointer to a @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
  204f70:	b500      	push	{lr}
  204f72:	b083      	sub	sp, #12
  204f74:	9001      	str	r0, [sp, #4]

  chSysLock();
  204f76:	f7ff ff8b 	bl	204e90 <chSysLock.lto_priv.12>
  chMBResetI(mbp);
  204f7a:	9801      	ldr	r0, [sp, #4]
  204f7c:	f000 f808 	bl	204f90 <chMBResetI>
  chSchRescheduleS();
  204f80:	f7fd fe76 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  204f84:	f7ff ff94 	bl	204eb0 <chSysUnlock.lto_priv.12>
}
  204f88:	bf00      	nop
  204f8a:	b003      	add	sp, #12
  204f8c:	f85d fb04 	ldr.w	pc, [sp], #4

00204f90 <chMBResetI>:
 *
 * @param[in] mbp       pointer to a @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
  204f90:	b500      	push	{lr}
  204f92:	b083      	sub	sp, #12
  204f94:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
  204f96:	9b01      	ldr	r3, [sp, #4]
  204f98:	681a      	ldr	r2, [r3, #0]
  204f9a:	9b01      	ldr	r3, [sp, #4]
  204f9c:	609a      	str	r2, [r3, #8]
  mbp->rdptr = mbp->buffer;
  204f9e:	9b01      	ldr	r3, [sp, #4]
  204fa0:	681a      	ldr	r2, [r3, #0]
  204fa2:	9b01      	ldr	r3, [sp, #4]
  204fa4:	60da      	str	r2, [r3, #12]
  mbp->cnt   = (size_t)0;
  204fa6:	9b01      	ldr	r3, [sp, #4]
  204fa8:	2200      	movs	r2, #0
  204faa:	611a      	str	r2, [r3, #16]
  mbp->reset = true;
  204fac:	9b01      	ldr	r3, [sp, #4]
  204fae:	2201      	movs	r2, #1
  204fb0:	751a      	strb	r2, [r3, #20]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
  204fb2:	9b01      	ldr	r3, [sp, #4]
  204fb4:	3318      	adds	r3, #24
  204fb6:	f06f 0101 	mvn.w	r1, #1
  204fba:	4618      	mov	r0, r3
  204fbc:	f7fe fc08 	bl	2037d0 <chThdDequeueAllI>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
  204fc0:	9b01      	ldr	r3, [sp, #4]
  204fc2:	3320      	adds	r3, #32
  204fc4:	f06f 0101 	mvn.w	r1, #1
  204fc8:	4618      	mov	r0, r3
  204fca:	f7fe fc01 	bl	2037d0 <chThdDequeueAllI>
}
  204fce:	bf00      	nop
  204fd0:	b003      	add	sp, #12
  204fd2:	f85d fb04 	ldr.w	pc, [sp], #4
  204fd6:	bf00      	nop
	...

00204fe0 <chMBPostTimeout>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
  204fe0:	b500      	push	{lr}
  204fe2:	b087      	sub	sp, #28
  204fe4:	9003      	str	r0, [sp, #12]
  204fe6:	9102      	str	r1, [sp, #8]
  204fe8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
  204fea:	f7ff ff51 	bl	204e90 <chSysLock.lto_priv.12>
  rdymsg = chMBPostTimeoutS(mbp, msg, timeout);
  204fee:	9a01      	ldr	r2, [sp, #4]
  204ff0:	9902      	ldr	r1, [sp, #8]
  204ff2:	9803      	ldr	r0, [sp, #12]
  204ff4:	f000 f80c 	bl	205010 <chMBPostTimeoutS>
  204ff8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
  204ffa:	f7ff ff59 	bl	204eb0 <chSysUnlock.lto_priv.12>

  return rdymsg;
  204ffe:	9b05      	ldr	r3, [sp, #20]
}
  205000:	4618      	mov	r0, r3
  205002:	b007      	add	sp, #28
  205004:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205010 <chMBPostTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostTimeoutS(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
  205010:	b500      	push	{lr}
  205012:	b087      	sub	sp, #28
  205014:	9003      	str	r0, [sp, #12]
  205016:	9102      	str	r1, [sp, #8]
  205018:	9201      	str	r2, [sp, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
  20501a:	9b03      	ldr	r3, [sp, #12]
  20501c:	7d1b      	ldrb	r3, [r3, #20]
  20501e:	2b00      	cmp	r3, #0
  205020:	d002      	beq.n	205028 <chMBPostTimeoutS+0x18>
      return MSG_RESET;
  205022:	f06f 0301 	mvn.w	r3, #1
  205026:	e030      	b.n	20508a <chMBPostTimeoutS+0x7a>
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
  205028:	9803      	ldr	r0, [sp, #12]
  20502a:	f7ff ff69 	bl	204f00 <chMBGetFreeCountI.lto_priv.0>
  20502e:	4603      	mov	r3, r0
  205030:	2b00      	cmp	r3, #0
  205032:	d01f      	beq.n	205074 <chMBPostTimeoutS+0x64>
      *mbp->wrptr++ = msg;
  205034:	9b03      	ldr	r3, [sp, #12]
  205036:	689b      	ldr	r3, [r3, #8]
  205038:	1d19      	adds	r1, r3, #4
  20503a:	9a03      	ldr	r2, [sp, #12]
  20503c:	6091      	str	r1, [r2, #8]
  20503e:	9a02      	ldr	r2, [sp, #8]
  205040:	601a      	str	r2, [r3, #0]
      if (mbp->wrptr >= mbp->top) {
  205042:	9b03      	ldr	r3, [sp, #12]
  205044:	689a      	ldr	r2, [r3, #8]
  205046:	9b03      	ldr	r3, [sp, #12]
  205048:	685b      	ldr	r3, [r3, #4]
  20504a:	429a      	cmp	r2, r3
  20504c:	d303      	bcc.n	205056 <chMBPostTimeoutS+0x46>
        mbp->wrptr = mbp->buffer;
  20504e:	9b03      	ldr	r3, [sp, #12]
  205050:	681a      	ldr	r2, [r3, #0]
  205052:	9b03      	ldr	r3, [sp, #12]
  205054:	609a      	str	r2, [r3, #8]
      }
      mbp->cnt++;
  205056:	9b03      	ldr	r3, [sp, #12]
  205058:	691b      	ldr	r3, [r3, #16]
  20505a:	1c5a      	adds	r2, r3, #1
  20505c:	9b03      	ldr	r3, [sp, #12]
  20505e:	611a      	str	r2, [r3, #16]

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qr, MSG_OK);
  205060:	9b03      	ldr	r3, [sp, #12]
  205062:	3320      	adds	r3, #32
  205064:	2100      	movs	r1, #0
  205066:	4618      	mov	r0, r3
  205068:	f7fe fb9a 	bl	2037a0 <chThdDequeueNextI>
      chSchRescheduleS();
  20506c:	f7fd fe00 	bl	202c70 <chSchRescheduleS>

      return MSG_OK;
  205070:	2300      	movs	r3, #0
  205072:	e00a      	b.n	20508a <chMBPostTimeoutS+0x7a>
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
  205074:	9b03      	ldr	r3, [sp, #12]
  205076:	3318      	adds	r3, #24
  205078:	9901      	ldr	r1, [sp, #4]
  20507a:	4618      	mov	r0, r3
  20507c:	f7fe fb70 	bl	203760 <chThdEnqueueTimeoutS>
  205080:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
  205082:	9b05      	ldr	r3, [sp, #20]
  205084:	2b00      	cmp	r3, #0
  205086:	d0c8      	beq.n	20501a <chMBPostTimeoutS+0xa>

  return rdymsg;
  205088:	9b05      	ldr	r3, [sp, #20]
}
  20508a:	4618      	mov	r0, r3
  20508c:	b007      	add	sp, #28
  20508e:	f85d fb04 	ldr.w	pc, [sp], #4
  205092:	bf00      	nop
	...

002050a0 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
  2050a0:	b500      	push	{lr}
  2050a2:	b083      	sub	sp, #12
  2050a4:	9001      	str	r0, [sp, #4]
  2050a6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
  2050a8:	9b01      	ldr	r3, [sp, #4]
  2050aa:	7d1b      	ldrb	r3, [r3, #20]
  2050ac:	2b00      	cmp	r3, #0
  2050ae:	d002      	beq.n	2050b6 <chMBPostI+0x16>
    return MSG_RESET;
  2050b0:	f06f 0301 	mvn.w	r3, #1
  2050b4:	e025      	b.n	205102 <chMBPostI+0x62>
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
  2050b6:	9801      	ldr	r0, [sp, #4]
  2050b8:	f7ff ff22 	bl	204f00 <chMBGetFreeCountI.lto_priv.0>
  2050bc:	4603      	mov	r3, r0
  2050be:	2b00      	cmp	r3, #0
  2050c0:	d01d      	beq.n	2050fe <chMBPostI+0x5e>
    *mbp->wrptr++ = msg;
  2050c2:	9b01      	ldr	r3, [sp, #4]
  2050c4:	689b      	ldr	r3, [r3, #8]
  2050c6:	1d19      	adds	r1, r3, #4
  2050c8:	9a01      	ldr	r2, [sp, #4]
  2050ca:	6091      	str	r1, [r2, #8]
  2050cc:	9a00      	ldr	r2, [sp, #0]
  2050ce:	601a      	str	r2, [r3, #0]
    if (mbp->wrptr >= mbp->top) {
  2050d0:	9b01      	ldr	r3, [sp, #4]
  2050d2:	689a      	ldr	r2, [r3, #8]
  2050d4:	9b01      	ldr	r3, [sp, #4]
  2050d6:	685b      	ldr	r3, [r3, #4]
  2050d8:	429a      	cmp	r2, r3
  2050da:	d303      	bcc.n	2050e4 <chMBPostI+0x44>
      mbp->wrptr = mbp->buffer;
  2050dc:	9b01      	ldr	r3, [sp, #4]
  2050de:	681a      	ldr	r2, [r3, #0]
  2050e0:	9b01      	ldr	r3, [sp, #4]
  2050e2:	609a      	str	r2, [r3, #8]
    }
    mbp->cnt++;
  2050e4:	9b01      	ldr	r3, [sp, #4]
  2050e6:	691b      	ldr	r3, [r3, #16]
  2050e8:	1c5a      	adds	r2, r3, #1
  2050ea:	9b01      	ldr	r3, [sp, #4]
  2050ec:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
  2050ee:	9b01      	ldr	r3, [sp, #4]
  2050f0:	3320      	adds	r3, #32
  2050f2:	2100      	movs	r1, #0
  2050f4:	4618      	mov	r0, r3
  2050f6:	f7fe fb53 	bl	2037a0 <chThdDequeueNextI>

    return MSG_OK;
  2050fa:	2300      	movs	r3, #0
  2050fc:	e001      	b.n	205102 <chMBPostI+0x62>
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
  2050fe:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
  205102:	4618      	mov	r0, r3
  205104:	b003      	add	sp, #12
  205106:	f85d fb04 	ldr.w	pc, [sp], #4
  20510a:	bf00      	nop
  20510c:	0000      	movs	r0, r0
	...

00205110 <chMBPostAheadTimeout>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAheadTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
  205110:	b500      	push	{lr}
  205112:	b087      	sub	sp, #28
  205114:	9003      	str	r0, [sp, #12]
  205116:	9102      	str	r1, [sp, #8]
  205118:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
  20511a:	f7ff feb9 	bl	204e90 <chSysLock.lto_priv.12>
  rdymsg = chMBPostAheadTimeoutS(mbp, msg, timeout);
  20511e:	9a01      	ldr	r2, [sp, #4]
  205120:	9902      	ldr	r1, [sp, #8]
  205122:	9803      	ldr	r0, [sp, #12]
  205124:	f000 f80c 	bl	205140 <chMBPostAheadTimeoutS>
  205128:	9005      	str	r0, [sp, #20]
  chSysUnlock();
  20512a:	f7ff fec1 	bl	204eb0 <chSysUnlock.lto_priv.12>

  return rdymsg;
  20512e:	9b05      	ldr	r3, [sp, #20]
}
  205130:	4618      	mov	r0, r3
  205132:	b007      	add	sp, #28
  205134:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205140 <chMBPostAheadTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadTimeoutS(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
  205140:	b500      	push	{lr}
  205142:	b087      	sub	sp, #28
  205144:	9003      	str	r0, [sp, #12]
  205146:	9102      	str	r1, [sp, #8]
  205148:	9201      	str	r2, [sp, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
  20514a:	9b03      	ldr	r3, [sp, #12]
  20514c:	7d1b      	ldrb	r3, [r3, #20]
  20514e:	2b00      	cmp	r3, #0
  205150:	d002      	beq.n	205158 <chMBPostAheadTimeoutS+0x18>
      return MSG_RESET;
  205152:	f06f 0301 	mvn.w	r3, #1
  205156:	e033      	b.n	2051c0 <chMBPostAheadTimeoutS+0x80>
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
  205158:	9803      	ldr	r0, [sp, #12]
  20515a:	f7ff fed1 	bl	204f00 <chMBGetFreeCountI.lto_priv.0>
  20515e:	4603      	mov	r3, r0
  205160:	2b00      	cmp	r3, #0
  205162:	d022      	beq.n	2051aa <chMBPostAheadTimeoutS+0x6a>
      if (--mbp->rdptr < mbp->buffer) {
  205164:	9b03      	ldr	r3, [sp, #12]
  205166:	68db      	ldr	r3, [r3, #12]
  205168:	1f1a      	subs	r2, r3, #4
  20516a:	9b03      	ldr	r3, [sp, #12]
  20516c:	60da      	str	r2, [r3, #12]
  20516e:	9b03      	ldr	r3, [sp, #12]
  205170:	68da      	ldr	r2, [r3, #12]
  205172:	9b03      	ldr	r3, [sp, #12]
  205174:	681b      	ldr	r3, [r3, #0]
  205176:	429a      	cmp	r2, r3
  205178:	d204      	bcs.n	205184 <chMBPostAheadTimeoutS+0x44>
        mbp->rdptr = mbp->top - 1;
  20517a:	9b03      	ldr	r3, [sp, #12]
  20517c:	685b      	ldr	r3, [r3, #4]
  20517e:	1f1a      	subs	r2, r3, #4
  205180:	9b03      	ldr	r3, [sp, #12]
  205182:	60da      	str	r2, [r3, #12]
      }
      *mbp->rdptr = msg;
  205184:	9b03      	ldr	r3, [sp, #12]
  205186:	68db      	ldr	r3, [r3, #12]
  205188:	9a02      	ldr	r2, [sp, #8]
  20518a:	601a      	str	r2, [r3, #0]
      mbp->cnt++;
  20518c:	9b03      	ldr	r3, [sp, #12]
  20518e:	691b      	ldr	r3, [r3, #16]
  205190:	1c5a      	adds	r2, r3, #1
  205192:	9b03      	ldr	r3, [sp, #12]
  205194:	611a      	str	r2, [r3, #16]

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qr, MSG_OK);
  205196:	9b03      	ldr	r3, [sp, #12]
  205198:	3320      	adds	r3, #32
  20519a:	2100      	movs	r1, #0
  20519c:	4618      	mov	r0, r3
  20519e:	f7fe faff 	bl	2037a0 <chThdDequeueNextI>
      chSchRescheduleS();
  2051a2:	f7fd fd65 	bl	202c70 <chSchRescheduleS>

      return MSG_OK;
  2051a6:	2300      	movs	r3, #0
  2051a8:	e00a      	b.n	2051c0 <chMBPostAheadTimeoutS+0x80>
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
  2051aa:	9b03      	ldr	r3, [sp, #12]
  2051ac:	3318      	adds	r3, #24
  2051ae:	9901      	ldr	r1, [sp, #4]
  2051b0:	4618      	mov	r0, r3
  2051b2:	f7fe fad5 	bl	203760 <chThdEnqueueTimeoutS>
  2051b6:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
  2051b8:	9b05      	ldr	r3, [sp, #20]
  2051ba:	2b00      	cmp	r3, #0
  2051bc:	d0c5      	beq.n	20514a <chMBPostAheadTimeoutS+0xa>

  return rdymsg;
  2051be:	9b05      	ldr	r3, [sp, #20]
}
  2051c0:	4618      	mov	r0, r3
  2051c2:	b007      	add	sp, #28
  2051c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002051d0 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
  2051d0:	b500      	push	{lr}
  2051d2:	b083      	sub	sp, #12
  2051d4:	9001      	str	r0, [sp, #4]
  2051d6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
  2051d8:	9b01      	ldr	r3, [sp, #4]
  2051da:	7d1b      	ldrb	r3, [r3, #20]
  2051dc:	2b00      	cmp	r3, #0
  2051de:	d002      	beq.n	2051e6 <chMBPostAheadI+0x16>
    return MSG_RESET;
  2051e0:	f06f 0301 	mvn.w	r3, #1
  2051e4:	e028      	b.n	205238 <chMBPostAheadI+0x68>
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
  2051e6:	9801      	ldr	r0, [sp, #4]
  2051e8:	f7ff fe8a 	bl	204f00 <chMBGetFreeCountI.lto_priv.0>
  2051ec:	4603      	mov	r3, r0
  2051ee:	2b00      	cmp	r3, #0
  2051f0:	d020      	beq.n	205234 <chMBPostAheadI+0x64>
    if (--mbp->rdptr < mbp->buffer) {
  2051f2:	9b01      	ldr	r3, [sp, #4]
  2051f4:	68db      	ldr	r3, [r3, #12]
  2051f6:	1f1a      	subs	r2, r3, #4
  2051f8:	9b01      	ldr	r3, [sp, #4]
  2051fa:	60da      	str	r2, [r3, #12]
  2051fc:	9b01      	ldr	r3, [sp, #4]
  2051fe:	68da      	ldr	r2, [r3, #12]
  205200:	9b01      	ldr	r3, [sp, #4]
  205202:	681b      	ldr	r3, [r3, #0]
  205204:	429a      	cmp	r2, r3
  205206:	d204      	bcs.n	205212 <chMBPostAheadI+0x42>
      mbp->rdptr = mbp->top - 1;
  205208:	9b01      	ldr	r3, [sp, #4]
  20520a:	685b      	ldr	r3, [r3, #4]
  20520c:	1f1a      	subs	r2, r3, #4
  20520e:	9b01      	ldr	r3, [sp, #4]
  205210:	60da      	str	r2, [r3, #12]
    }
    *mbp->rdptr = msg;
  205212:	9b01      	ldr	r3, [sp, #4]
  205214:	68db      	ldr	r3, [r3, #12]
  205216:	9a00      	ldr	r2, [sp, #0]
  205218:	601a      	str	r2, [r3, #0]
    mbp->cnt++;
  20521a:	9b01      	ldr	r3, [sp, #4]
  20521c:	691b      	ldr	r3, [r3, #16]
  20521e:	1c5a      	adds	r2, r3, #1
  205220:	9b01      	ldr	r3, [sp, #4]
  205222:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
  205224:	9b01      	ldr	r3, [sp, #4]
  205226:	3320      	adds	r3, #32
  205228:	2100      	movs	r1, #0
  20522a:	4618      	mov	r0, r3
  20522c:	f7fe fab8 	bl	2037a0 <chThdDequeueNextI>

    return MSG_OK;
  205230:	2300      	movs	r3, #0
  205232:	e001      	b.n	205238 <chMBPostAheadI+0x68>
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
  205234:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
  205238:	4618      	mov	r0, r3
  20523a:	b003      	add	sp, #12
  20523c:	f85d fb04 	ldr.w	pc, [sp], #4

00205240 <chMBFetchTimeout>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetchTimeout(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
  205240:	b500      	push	{lr}
  205242:	b087      	sub	sp, #28
  205244:	9003      	str	r0, [sp, #12]
  205246:	9102      	str	r1, [sp, #8]
  205248:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
  20524a:	f7ff fe21 	bl	204e90 <chSysLock.lto_priv.12>
  rdymsg = chMBFetchTimeoutS(mbp, msgp, timeout);
  20524e:	9a01      	ldr	r2, [sp, #4]
  205250:	9902      	ldr	r1, [sp, #8]
  205252:	9803      	ldr	r0, [sp, #12]
  205254:	f000 f80c 	bl	205270 <chMBFetchTimeoutS>
  205258:	9005      	str	r0, [sp, #20]
  chSysUnlock();
  20525a:	f7ff fe29 	bl	204eb0 <chSysUnlock.lto_priv.12>

  return rdymsg;
  20525e:	9b05      	ldr	r3, [sp, #20]
}
  205260:	4618      	mov	r0, r3
  205262:	b007      	add	sp, #28
  205264:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205270 <chMBFetchTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchTimeoutS(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
  205270:	b500      	push	{lr}
  205272:	b087      	sub	sp, #28
  205274:	9003      	str	r0, [sp, #12]
  205276:	9102      	str	r1, [sp, #8]
  205278:	9201      	str	r2, [sp, #4]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
  20527a:	9b03      	ldr	r3, [sp, #12]
  20527c:	7d1b      	ldrb	r3, [r3, #20]
  20527e:	2b00      	cmp	r3, #0
  205280:	d002      	beq.n	205288 <chMBFetchTimeoutS+0x18>
      return MSG_RESET;
  205282:	f06f 0301 	mvn.w	r3, #1
  205286:	e031      	b.n	2052ec <chMBFetchTimeoutS+0x7c>
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
  205288:	9803      	ldr	r0, [sp, #12]
  20528a:	f7ff fe31 	bl	204ef0 <chMBGetUsedCountI.lto_priv.0>
  20528e:	4603      	mov	r3, r0
  205290:	2b00      	cmp	r3, #0
  205292:	d020      	beq.n	2052d6 <chMBFetchTimeoutS+0x66>
      *msgp = *mbp->rdptr++;
  205294:	9b03      	ldr	r3, [sp, #12]
  205296:	68db      	ldr	r3, [r3, #12]
  205298:	1d19      	adds	r1, r3, #4
  20529a:	9a03      	ldr	r2, [sp, #12]
  20529c:	60d1      	str	r1, [r2, #12]
  20529e:	681a      	ldr	r2, [r3, #0]
  2052a0:	9b02      	ldr	r3, [sp, #8]
  2052a2:	601a      	str	r2, [r3, #0]
      if (mbp->rdptr >= mbp->top) {
  2052a4:	9b03      	ldr	r3, [sp, #12]
  2052a6:	68da      	ldr	r2, [r3, #12]
  2052a8:	9b03      	ldr	r3, [sp, #12]
  2052aa:	685b      	ldr	r3, [r3, #4]
  2052ac:	429a      	cmp	r2, r3
  2052ae:	d303      	bcc.n	2052b8 <chMBFetchTimeoutS+0x48>
        mbp->rdptr = mbp->buffer;
  2052b0:	9b03      	ldr	r3, [sp, #12]
  2052b2:	681a      	ldr	r2, [r3, #0]
  2052b4:	9b03      	ldr	r3, [sp, #12]
  2052b6:	60da      	str	r2, [r3, #12]
      }
      mbp->cnt--;
  2052b8:	9b03      	ldr	r3, [sp, #12]
  2052ba:	691b      	ldr	r3, [r3, #16]
  2052bc:	1e5a      	subs	r2, r3, #1
  2052be:	9b03      	ldr	r3, [sp, #12]
  2052c0:	611a      	str	r2, [r3, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
  2052c2:	9b03      	ldr	r3, [sp, #12]
  2052c4:	3318      	adds	r3, #24
  2052c6:	2100      	movs	r1, #0
  2052c8:	4618      	mov	r0, r3
  2052ca:	f7fe fa69 	bl	2037a0 <chThdDequeueNextI>
      chSchRescheduleS();
  2052ce:	f7fd fccf 	bl	202c70 <chSchRescheduleS>

      return MSG_OK;
  2052d2:	2300      	movs	r3, #0
  2052d4:	e00a      	b.n	2052ec <chMBFetchTimeoutS+0x7c>
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
  2052d6:	9b03      	ldr	r3, [sp, #12]
  2052d8:	3320      	adds	r3, #32
  2052da:	9901      	ldr	r1, [sp, #4]
  2052dc:	4618      	mov	r0, r3
  2052de:	f7fe fa3f 	bl	203760 <chThdEnqueueTimeoutS>
  2052e2:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
  2052e4:	9b05      	ldr	r3, [sp, #20]
  2052e6:	2b00      	cmp	r3, #0
  2052e8:	d0c7      	beq.n	20527a <chMBFetchTimeoutS+0xa>

  return rdymsg;
  2052ea:	9b05      	ldr	r3, [sp, #20]
}
  2052ec:	4618      	mov	r0, r3
  2052ee:	b007      	add	sp, #28
  2052f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205300 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
  205300:	b500      	push	{lr}
  205302:	b083      	sub	sp, #12
  205304:	9001      	str	r0, [sp, #4]
  205306:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
  205308:	9b01      	ldr	r3, [sp, #4]
  20530a:	7d1b      	ldrb	r3, [r3, #20]
  20530c:	2b00      	cmp	r3, #0
  20530e:	d002      	beq.n	205316 <chMBFetchI+0x16>
    return MSG_RESET;
  205310:	f06f 0301 	mvn.w	r3, #1
  205314:	e026      	b.n	205364 <chMBFetchI+0x64>
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (size_t)0) {
  205316:	9801      	ldr	r0, [sp, #4]
  205318:	f7ff fdea 	bl	204ef0 <chMBGetUsedCountI.lto_priv.0>
  20531c:	4603      	mov	r3, r0
  20531e:	2b00      	cmp	r3, #0
  205320:	d01e      	beq.n	205360 <chMBFetchI+0x60>
    *msgp = *mbp->rdptr++;
  205322:	9b01      	ldr	r3, [sp, #4]
  205324:	68db      	ldr	r3, [r3, #12]
  205326:	1d19      	adds	r1, r3, #4
  205328:	9a01      	ldr	r2, [sp, #4]
  20532a:	60d1      	str	r1, [r2, #12]
  20532c:	681a      	ldr	r2, [r3, #0]
  20532e:	9b00      	ldr	r3, [sp, #0]
  205330:	601a      	str	r2, [r3, #0]
    if (mbp->rdptr >= mbp->top) {
  205332:	9b01      	ldr	r3, [sp, #4]
  205334:	68da      	ldr	r2, [r3, #12]
  205336:	9b01      	ldr	r3, [sp, #4]
  205338:	685b      	ldr	r3, [r3, #4]
  20533a:	429a      	cmp	r2, r3
  20533c:	d303      	bcc.n	205346 <chMBFetchI+0x46>
      mbp->rdptr = mbp->buffer;
  20533e:	9b01      	ldr	r3, [sp, #4]
  205340:	681a      	ldr	r2, [r3, #0]
  205342:	9b01      	ldr	r3, [sp, #4]
  205344:	60da      	str	r2, [r3, #12]
    }
    mbp->cnt--;
  205346:	9b01      	ldr	r3, [sp, #4]
  205348:	691b      	ldr	r3, [r3, #16]
  20534a:	1e5a      	subs	r2, r3, #1
  20534c:	9b01      	ldr	r3, [sp, #4]
  20534e:	611a      	str	r2, [r3, #16]

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
  205350:	9b01      	ldr	r3, [sp, #4]
  205352:	3318      	adds	r3, #24
  205354:	2100      	movs	r1, #0
  205356:	4618      	mov	r0, r3
  205358:	f7fe fa22 	bl	2037a0 <chThdDequeueNextI>

    return MSG_OK;
  20535c:	2300      	movs	r3, #0
  20535e:	e001      	b.n	205364 <chMBFetchI+0x64>
  }

  /* No message, immediate timeout.*/
  return MSG_TIMEOUT;
  205360:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
  205364:	4618      	mov	r0, r3
  205366:	b003      	add	sp, #12
  205368:	f85d fb04 	ldr.w	pc, [sp], #4
  20536c:	0000      	movs	r0, r0
	...

00205370 <chSysLock.lto_priv.13>:
static inline void chSysLock(void) {
  205370:	b082      	sub	sp, #8
  205372:	2330      	movs	r3, #48	@ 0x30
  205374:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205376:	9b01      	ldr	r3, [sp, #4]
  205378:	f383 8811 	msr	BASEPRI, r3
}
  20537c:	bf00      	nop
}
  20537e:	bf00      	nop
}
  205380:	bf00      	nop
  205382:	b002      	add	sp, #8
  205384:	4770      	bx	lr
  205386:	bf00      	nop
	...

00205390 <chSysUnlock.lto_priv.13>:
static inline void chSysUnlock(void) {
  205390:	b082      	sub	sp, #8
  205392:	2300      	movs	r3, #0
  205394:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205396:	9b01      	ldr	r3, [sp, #4]
  205398:	f383 8811 	msr	BASEPRI, r3
}
  20539c:	bf00      	nop
}
  20539e:	bf00      	nop
}
  2053a0:	bf00      	nop
  2053a2:	b002      	add	sp, #8
  2053a4:	4770      	bx	lr
  2053a6:	bf00      	nop
	...

002053b0 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
  2053b0:	4b03      	ldr	r3, [pc, #12]	@ (2053c0 <__core_init+0x10>)
  2053b2:	4a04      	ldr	r2, [pc, #16]	@ (2053c4 <__core_init+0x14>)
  2053b4:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
  2053b6:	4b02      	ldr	r3, [pc, #8]	@ (2053c0 <__core_init+0x10>)
  2053b8:	4a03      	ldr	r2, [pc, #12]	@ (2053c8 <__core_init+0x18>)
  2053ba:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
  2053bc:	bf00      	nop
  2053be:	4770      	bx	lr
  2053c0:	20000b40 	.word	0x20000b40
  2053c4:	200200e0 	.word	0x200200e0
  2053c8:	20080000 	.word	0x20080000
  2053cc:	00000000 	.word	0x00000000

002053d0 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
  2053d0:	b086      	sub	sp, #24
  2053d2:	9003      	str	r0, [sp, #12]
  2053d4:	9102      	str	r1, [sp, #8]
  2053d6:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  2053d8:	4b10      	ldr	r3, [pc, #64]	@ (20541c <chCoreAllocFromTopI+0x4c>)
  2053da:	685a      	ldr	r2, [r3, #4]
  2053dc:	9b03      	ldr	r3, [sp, #12]
  2053de:	425b      	negs	r3, r3
  2053e0:	4413      	add	r3, r2
  2053e2:	461a      	mov	r2, r3
  2053e4:	9b02      	ldr	r3, [sp, #8]
  2053e6:	425b      	negs	r3, r3
  2053e8:	4013      	ands	r3, r2
  2053ea:	9305      	str	r3, [sp, #20]
  prev = p - offset;
  2053ec:	9b01      	ldr	r3, [sp, #4]
  2053ee:	425b      	negs	r3, r3
  2053f0:	9a05      	ldr	r2, [sp, #20]
  2053f2:	4413      	add	r3, r2
  2053f4:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
  2053f6:	4b09      	ldr	r3, [pc, #36]	@ (20541c <chCoreAllocFromTopI+0x4c>)
  2053f8:	681b      	ldr	r3, [r3, #0]
  2053fa:	9a04      	ldr	r2, [sp, #16]
  2053fc:	429a      	cmp	r2, r3
  2053fe:	d304      	bcc.n	20540a <chCoreAllocFromTopI+0x3a>
  205400:	4b06      	ldr	r3, [pc, #24]	@ (20541c <chCoreAllocFromTopI+0x4c>)
  205402:	685b      	ldr	r3, [r3, #4]
  205404:	9a04      	ldr	r2, [sp, #16]
  205406:	429a      	cmp	r2, r3
  205408:	d901      	bls.n	20540e <chCoreAllocFromTopI+0x3e>
    return NULL;
  20540a:	2300      	movs	r3, #0
  20540c:	e003      	b.n	205416 <chCoreAllocFromTopI+0x46>
  }

  ch_memcore.topmem = prev;
  20540e:	4a03      	ldr	r2, [pc, #12]	@ (20541c <chCoreAllocFromTopI+0x4c>)
  205410:	9b04      	ldr	r3, [sp, #16]
  205412:	6053      	str	r3, [r2, #4]

  return p;
  205414:	9b05      	ldr	r3, [sp, #20]
}
  205416:	4618      	mov	r0, r3
  205418:	b006      	add	sp, #24
  20541a:	4770      	bx	lr
  20541c:	20000b40 	.word	0x20000b40

00205420 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
  205420:	b500      	push	{lr}
  205422:	b087      	sub	sp, #28
  205424:	9003      	str	r0, [sp, #12]
  205426:	9102      	str	r1, [sp, #8]
  205428:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
  20542a:	f7ff ffa1 	bl	205370 <chSysLock.lto_priv.13>
  p = chCoreAllocFromTopI(size, align, offset);
  20542e:	9a01      	ldr	r2, [sp, #4]
  205430:	9902      	ldr	r1, [sp, #8]
  205432:	9803      	ldr	r0, [sp, #12]
  205434:	f7ff ffcc 	bl	2053d0 <chCoreAllocFromTopI>
  205438:	9005      	str	r0, [sp, #20]
  chSysUnlock();
  20543a:	f7ff ffa9 	bl	205390 <chSysUnlock.lto_priv.13>

  return p;
  20543e:	9b05      	ldr	r3, [sp, #20]
}
  205440:	4618      	mov	r0, r3
  205442:	b007      	add	sp, #28
  205444:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205450 <chCoreGetStatusX>:
 *
 * @param[in] map       Memory area representing available core space.
 *
 * @xclass
 */
void chCoreGetStatusX(memory_area_t *map) {
  205450:	b082      	sub	sp, #8
  205452:	9001      	str	r0, [sp, #4]

  map->base = ch_memcore.basemem;
  205454:	4b07      	ldr	r3, [pc, #28]	@ (205474 <chCoreGetStatusX+0x24>)
  205456:	681a      	ldr	r2, [r3, #0]
  205458:	9b01      	ldr	r3, [sp, #4]
  20545a:	601a      	str	r2, [r3, #0]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  map->size = (size_t)(ch_memcore.topmem - ch_memcore.basemem);
  20545c:	4b05      	ldr	r3, [pc, #20]	@ (205474 <chCoreGetStatusX+0x24>)
  20545e:	685a      	ldr	r2, [r3, #4]
  205460:	4b04      	ldr	r3, [pc, #16]	@ (205474 <chCoreGetStatusX+0x24>)
  205462:	681b      	ldr	r3, [r3, #0]
  205464:	1ad3      	subs	r3, r2, r3
  205466:	461a      	mov	r2, r3
  205468:	9b01      	ldr	r3, [sp, #4]
  20546a:	605a      	str	r2, [r3, #4]
  /*lint -restore*/
}
  20546c:	bf00      	nop
  20546e:	b002      	add	sp, #8
  205470:	4770      	bx	lr
  205472:	bf00      	nop
  205474:	20000b40 	.word	0x20000b40
	...

00205480 <chMemIsSpaceWithinX.lto_priv.1>:
                                       size_t size) {
  205480:	b088      	sub	sp, #32
  205482:	9003      	str	r0, [sp, #12]
  205484:	9102      	str	r1, [sp, #8]
  205486:	9201      	str	r2, [sp, #4]
  const uint8_t *mem_base = (const uint8_t *)map->base;
  205488:	9b03      	ldr	r3, [sp, #12]
  20548a:	681b      	ldr	r3, [r3, #0]
  20548c:	9307      	str	r3, [sp, #28]
  const uint8_t *mem_end  = mem_base + map->size - (size_t)1;
  20548e:	9b03      	ldr	r3, [sp, #12]
  205490:	685b      	ldr	r3, [r3, #4]
  205492:	3b01      	subs	r3, #1
  205494:	9a07      	ldr	r2, [sp, #28]
  205496:	4413      	add	r3, r2
  205498:	9306      	str	r3, [sp, #24]
  const uint8_t *base     = (const uint8_t *)p;
  20549a:	9b02      	ldr	r3, [sp, #8]
  20549c:	9305      	str	r3, [sp, #20]
  const uint8_t *end      = base + size - (size_t)1;
  20549e:	9b01      	ldr	r3, [sp, #4]
  2054a0:	3b01      	subs	r3, #1
  2054a2:	9a05      	ldr	r2, [sp, #20]
  2054a4:	4413      	add	r3, r2
  2054a6:	9304      	str	r3, [sp, #16]
  return (bool)((base <= end) && (base >= mem_base) && (end <= mem_end));
  2054a8:	9a05      	ldr	r2, [sp, #20]
  2054aa:	9b04      	ldr	r3, [sp, #16]
  2054ac:	429a      	cmp	r2, r3
  2054ae:	d809      	bhi.n	2054c4 <chMemIsSpaceWithinX.lto_priv.1+0x44>
  2054b0:	9a05      	ldr	r2, [sp, #20]
  2054b2:	9b07      	ldr	r3, [sp, #28]
  2054b4:	429a      	cmp	r2, r3
  2054b6:	d305      	bcc.n	2054c4 <chMemIsSpaceWithinX.lto_priv.1+0x44>
  2054b8:	9a04      	ldr	r2, [sp, #16]
  2054ba:	9b06      	ldr	r3, [sp, #24]
  2054bc:	429a      	cmp	r2, r3
  2054be:	d801      	bhi.n	2054c4 <chMemIsSpaceWithinX.lto_priv.1+0x44>
  2054c0:	2301      	movs	r3, #1
  2054c2:	e000      	b.n	2054c6 <chMemIsSpaceWithinX.lto_priv.1+0x46>
  2054c4:	2300      	movs	r3, #0
  2054c6:	f003 0301 	and.w	r3, r3, #1
  2054ca:	b2db      	uxtb	r3, r3
}
  2054cc:	4618      	mov	r0, r3
  2054ce:	b008      	add	sp, #32
  2054d0:	4770      	bx	lr
  2054d2:	bf00      	nop
	...

002054e0 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
  2054e0:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
  2054e2:	4b08      	ldr	r3, [pc, #32]	@ (205504 <__heap_init+0x24>)
  2054e4:	4a08      	ldr	r2, [pc, #32]	@ (205508 <__heap_init+0x28>)
  2054e6:	601a      	str	r2, [r3, #0]
  chCoreGetStatusX(&default_heap.area);
  2054e8:	4808      	ldr	r0, [pc, #32]	@ (20550c <__heap_init+0x2c>)
  2054ea:	f7ff ffb1 	bl	205450 <chCoreGetStatusX>
  H_FREE_NEXT(&default_heap.header) = NULL;
  2054ee:	4b05      	ldr	r3, [pc, #20]	@ (205504 <__heap_init+0x24>)
  2054f0:	2200      	movs	r2, #0
  2054f2:	60da      	str	r2, [r3, #12]
  H_FREE_PAGES(&default_heap.header) = 0;
  2054f4:	4b03      	ldr	r3, [pc, #12]	@ (205504 <__heap_init+0x24>)
  2054f6:	2200      	movs	r2, #0
  2054f8:	611a      	str	r2, [r3, #16]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
  2054fa:	4805      	ldr	r0, [pc, #20]	@ (205510 <__heap_init+0x30>)
  2054fc:	f7fe fcb8 	bl	203e70 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
  205500:	bf00      	nop
  205502:	bd08      	pop	{r3, pc}
  205504:	20000b48 	.word	0x20000b48
  205508:	00205421 	.word	0x00205421
  20550c:	20000b4c 	.word	0x20000b4c
  205510:	20000b5c 	.word	0x20000b5c
	...

00205520 <chHeapObjectInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  205520:	b500      	push	{lr}
  205522:	b087      	sub	sp, #28
  205524:	9003      	str	r0, [sp, #12]
  205526:	9102      	str	r1, [sp, #8]
  205528:	9201      	str	r2, [sp, #4]
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
  20552a:	9b02      	ldr	r3, [sp, #8]
  20552c:	3307      	adds	r3, #7
  20552e:	f023 0307 	bic.w	r3, r3, #7
  205532:	9305      	str	r3, [sp, #20]
  chDbgCheck((heapp != NULL) && (size > 0U));

  /* Adjusting the size in case the initial block was not correctly
     aligned.*/
  /*lint -save -e9033 [10.8] Required cast operations.*/
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
  205534:	9a05      	ldr	r2, [sp, #20]
  205536:	9b02      	ldr	r3, [sp, #8]
  205538:	1ad3      	subs	r3, r2, r3
  20553a:	461a      	mov	r2, r3
  20553c:	9b01      	ldr	r3, [sp, #4]
  20553e:	1a9b      	subs	r3, r3, r2
  205540:	9301      	str	r3, [sp, #4]
  /*lint restore*/

  /* Initializing the heap header.*/
  heapp->provider = NULL;
  205542:	9b03      	ldr	r3, [sp, #12]
  205544:	2200      	movs	r2, #0
  205546:	601a      	str	r2, [r3, #0]
  H_FREE_NEXT(&heapp->header) = hp;
  205548:	9b03      	ldr	r3, [sp, #12]
  20554a:	9a05      	ldr	r2, [sp, #20]
  20554c:	60da      	str	r2, [r3, #12]
  H_FREE_PAGES(&heapp->header) = 0;
  20554e:	9b03      	ldr	r3, [sp, #12]
  205550:	2200      	movs	r2, #0
  205552:	611a      	str	r2, [r3, #16]
  H_FREE_NEXT(hp) = NULL;
  205554:	9b05      	ldr	r3, [sp, #20]
  205556:	2200      	movs	r2, #0
  205558:	601a      	str	r2, [r3, #0]
  H_FREE_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
  20555a:	9b01      	ldr	r3, [sp, #4]
  20555c:	3b08      	subs	r3, #8
  20555e:	08da      	lsrs	r2, r3, #3
  205560:	9b05      	ldr	r3, [sp, #20]
  205562:	605a      	str	r2, [r3, #4]
  heapp->area.base = (uint8_t *)(void *)hp;
  205564:	9b03      	ldr	r3, [sp, #12]
  205566:	9a05      	ldr	r2, [sp, #20]
  205568:	605a      	str	r2, [r3, #4]
  heapp->area.size = H_FREE_FULLSIZE(hp);
  20556a:	9b05      	ldr	r3, [sp, #20]
  20556c:	685b      	ldr	r3, [r3, #4]
  20556e:	3301      	adds	r3, #1
  205570:	00da      	lsls	r2, r3, #3
  205572:	9b03      	ldr	r3, [sp, #12]
  205574:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->mtx);
  205576:	9b03      	ldr	r3, [sp, #12]
  205578:	3314      	adds	r3, #20
  20557a:	4618      	mov	r0, r3
  20557c:	f7fe fc78 	bl	203e70 <chMtxObjectInit>
#else
  chSemObjectInit(&heapp->sem, (cnt_t)1);
#endif
}
  205580:	bf00      	nop
  205582:	b007      	add	sp, #28
  205584:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205590 <chHeapAllocAligned>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
  205590:	b500      	push	{lr}
  205592:	b08d      	sub	sp, #52	@ 0x34
  205594:	9003      	str	r0, [sp, #12]
  205596:	9102      	str	r1, [sp, #8]
  205598:	9201      	str	r2, [sp, #4]
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
  20559a:	9b03      	ldr	r3, [sp, #12]
  20559c:	2b00      	cmp	r3, #0
  20559e:	d101      	bne.n	2055a4 <chHeapAllocAligned+0x14>
    heapp = &default_heap;
  2055a0:	4b62      	ldr	r3, [pc, #392]	@ (20572c <chHeapAllocAligned+0x19c>)
  2055a2:	9303      	str	r3, [sp, #12]
  }

  /* Minimum alignment is constrained by the heap header structure size.*/
  if (align < CH_HEAP_ALIGNMENT) {
  2055a4:	9b01      	ldr	r3, [sp, #4]
  2055a6:	2b07      	cmp	r3, #7
  2055a8:	d801      	bhi.n	2055ae <chHeapAllocAligned+0x1e>
    align = CH_HEAP_ALIGNMENT;
  2055aa:	2308      	movs	r3, #8
  2055ac:	9301      	str	r3, [sp, #4]
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
  2055ae:	9b02      	ldr	r3, [sp, #8]
  2055b0:	3307      	adds	r3, #7
  2055b2:	08db      	lsrs	r3, r3, #3
  2055b4:	9309      	str	r3, [sp, #36]	@ 0x24

  /* Taking heap mutex.*/
  H_LOCK(heapp);
  2055b6:	9b03      	ldr	r3, [sp, #12]
  2055b8:	3314      	adds	r3, #20
  2055ba:	4618      	mov	r0, r3
  2055bc:	f7fe fc68 	bl	203e90 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  2055c0:	9b03      	ldr	r3, [sp, #12]
  2055c2:	330c      	adds	r3, #12
  2055c4:	930b      	str	r3, [sp, #44]	@ 0x2c
  while (H_FREE_NEXT(qp) != NULL) {
  2055c6:	e087      	b.n	2056d8 <chHeapAllocAligned+0x148>

    /* Next free block.*/
    hp = H_FREE_NEXT(qp);
  2055c8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  2055ca:	681b      	ldr	r3, [r3, #0]
  2055cc:	930a      	str	r3, [sp, #40]	@ 0x28

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
  2055ce:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
  2055d0:	9b01      	ldr	r3, [sp, #4]
  2055d2:	4413      	add	r3, r2
  2055d4:	1dda      	adds	r2, r3, #7
  2055d6:	9b01      	ldr	r3, [sp, #4]
  2055d8:	425b      	negs	r3, r3
  2055da:	4013      	ands	r3, r2
  2055dc:	3b08      	subs	r3, #8
  2055de:	9308      	str	r3, [sp, #32]

    if ((ahp < H_FREE_LIMIT(hp)) && (pages <= NPAGES(H_FREE_LIMIT(hp), ahp + 1U))) {
  2055e0:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  2055e2:	685b      	ldr	r3, [r3, #4]
  2055e4:	3301      	adds	r3, #1
  2055e6:	00db      	lsls	r3, r3, #3
  2055e8:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
  2055ea:	4413      	add	r3, r2
  2055ec:	9a08      	ldr	r2, [sp, #32]
  2055ee:	429a      	cmp	r2, r3
  2055f0:	d270      	bcs.n	2056d4 <chHeapAllocAligned+0x144>
  2055f2:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  2055f4:	685b      	ldr	r3, [r3, #4]
  2055f6:	3301      	adds	r3, #1
  2055f8:	00db      	lsls	r3, r3, #3
  2055fa:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
  2055fc:	441a      	add	r2, r3
  2055fe:	9b08      	ldr	r3, [sp, #32]
  205600:	3308      	adds	r3, #8
  205602:	1ad3      	subs	r3, r2, r3
  205604:	10db      	asrs	r3, r3, #3
  205606:	461a      	mov	r2, r3
  205608:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  20560a:	4293      	cmp	r3, r2
  20560c:	d862      	bhi.n	2056d4 <chHeapAllocAligned+0x144>
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
  20560e:	9a08      	ldr	r2, [sp, #32]
  205610:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  205612:	429a      	cmp	r2, r3
  205614:	d92c      	bls.n	205670 <chHeapAllocAligned+0xe0>
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_FREE_LIMIT(hp), H_BLOCK(ahp));
  205616:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  205618:	685b      	ldr	r3, [r3, #4]
  20561a:	3301      	adds	r3, #1
  20561c:	00db      	lsls	r3, r3, #3
  20561e:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
  205620:	441a      	add	r2, r3
  205622:	9b08      	ldr	r3, [sp, #32]
  205624:	3308      	adds	r3, #8
  205626:	1ad3      	subs	r3, r2, r3
  205628:	10db      	asrs	r3, r3, #3
  20562a:	9306      	str	r3, [sp, #24]
        H_FREE_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
  20562c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20562e:	3308      	adds	r3, #8
  205630:	9a08      	ldr	r2, [sp, #32]
  205632:	1ad3      	subs	r3, r2, r3
  205634:	10db      	asrs	r3, r3, #3
  205636:	461a      	mov	r2, r3
  205638:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20563a:	605a      	str	r2, [r3, #4]
        if (bpages > pages) {
  20563c:	9a06      	ldr	r2, [sp, #24]
  20563e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  205640:	429a      	cmp	r2, r3
  205642:	d912      	bls.n	20566a <chHeapAllocAligned+0xda>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
  205644:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  205646:	3301      	adds	r3, #1
  205648:	00db      	lsls	r3, r3, #3
  20564a:	9a08      	ldr	r2, [sp, #32]
  20564c:	4413      	add	r3, r2
  20564e:	9305      	str	r3, [sp, #20]
          H_FREE_PAGES(fp) = (bpages - pages) - 1U;
  205650:	9a06      	ldr	r2, [sp, #24]
  205652:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  205654:	1ad3      	subs	r3, r2, r3
  205656:	1e5a      	subs	r2, r3, #1
  205658:	9b05      	ldr	r3, [sp, #20]
  20565a:	605a      	str	r2, [r3, #4]

          /* Linking the excess block.*/
          H_FREE_NEXT(fp) = H_FREE_NEXT(hp);
  20565c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20565e:	681a      	ldr	r2, [r3, #0]
  205660:	9b05      	ldr	r3, [sp, #20]
  205662:	601a      	str	r2, [r3, #0]
          H_FREE_NEXT(hp) = fp;
  205664:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  205666:	9a05      	ldr	r2, [sp, #20]
  205668:	601a      	str	r2, [r3, #0]
        }

        hp = ahp;
  20566a:	9b08      	ldr	r3, [sp, #32]
  20566c:	930a      	str	r3, [sp, #40]	@ 0x28
  20566e:	e023      	b.n	2056b8 <chHeapAllocAligned+0x128>
      }
      else {
        /* The block is already properly aligned.*/

        if (H_FREE_PAGES(hp) == pages) {
  205670:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  205672:	685b      	ldr	r3, [r3, #4]
  205674:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  205676:	429a      	cmp	r2, r3
  205678:	d104      	bne.n	205684 <chHeapAllocAligned+0xf4>
          /* Exact size, getting the whole block.*/
          H_FREE_NEXT(qp) = H_FREE_NEXT(hp);
  20567a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20567c:	681a      	ldr	r2, [r3, #0]
  20567e:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  205680:	601a      	str	r2, [r3, #0]
  205682:	e019      	b.n	2056b8 <chHeapAllocAligned+0x128>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
  205684:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  205686:	3301      	adds	r3, #1
  205688:	00db      	lsls	r3, r3, #3
  20568a:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
  20568c:	4413      	add	r3, r2
  20568e:	9307      	str	r3, [sp, #28]
          H_FREE_NEXT(fp) = H_FREE_NEXT(hp);
  205690:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  205692:	681a      	ldr	r2, [r3, #0]
  205694:	9b07      	ldr	r3, [sp, #28]
  205696:	601a      	str	r2, [r3, #0]
          H_FREE_PAGES(fp) = NPAGES(H_FREE_LIMIT(hp), H_BLOCK(fp));
  205698:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20569a:	685b      	ldr	r3, [r3, #4]
  20569c:	3301      	adds	r3, #1
  20569e:	00db      	lsls	r3, r3, #3
  2056a0:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
  2056a2:	441a      	add	r2, r3
  2056a4:	9b07      	ldr	r3, [sp, #28]
  2056a6:	3308      	adds	r3, #8
  2056a8:	1ad3      	subs	r3, r2, r3
  2056aa:	10db      	asrs	r3, r3, #3
  2056ac:	461a      	mov	r2, r3
  2056ae:	9b07      	ldr	r3, [sp, #28]
  2056b0:	605a      	str	r2, [r3, #4]
          H_FREE_NEXT(qp) = fp;
  2056b2:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  2056b4:	9a07      	ldr	r2, [sp, #28]
  2056b6:	601a      	str	r2, [r3, #0]
        }
      }

      /* Setting in the block owner heap and size.*/
      H_USED_SIZE(hp) = size;
  2056b8:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  2056ba:	9a02      	ldr	r2, [sp, #8]
  2056bc:	605a      	str	r2, [r3, #4]
      H_USED_HEAP(hp) = heapp;
  2056be:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  2056c0:	9a03      	ldr	r2, [sp, #12]
  2056c2:	601a      	str	r2, [r3, #0]

      /* Releasing heap mutex.*/
      H_UNLOCK(heapp);
  2056c4:	9b03      	ldr	r3, [sp, #12]
  2056c6:	3314      	adds	r3, #20
  2056c8:	4618      	mov	r0, r3
  2056ca:	f7fe fc91 	bl	203ff0 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
  2056ce:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  2056d0:	3308      	adds	r3, #8
  2056d2:	e026      	b.n	205722 <chHeapAllocAligned+0x192>
      /*lint -restore*/
    }

    /* Next in the free blocks list.*/
    qp = hp;
  2056d4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  2056d6:	930b      	str	r3, [sp, #44]	@ 0x2c
  while (H_FREE_NEXT(qp) != NULL) {
  2056d8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  2056da:	681b      	ldr	r3, [r3, #0]
  2056dc:	2b00      	cmp	r3, #0
  2056de:	f47f af73 	bne.w	2055c8 <chHeapAllocAligned+0x38>
  }

  /* Releasing heap mutex.*/
  H_UNLOCK(heapp);
  2056e2:	9b03      	ldr	r3, [sp, #12]
  2056e4:	3314      	adds	r3, #20
  2056e6:	4618      	mov	r0, r3
  2056e8:	f7fe fc82 	bl	203ff0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
  2056ec:	9b03      	ldr	r3, [sp, #12]
  2056ee:	681b      	ldr	r3, [r3, #0]
  2056f0:	2b00      	cmp	r3, #0
  2056f2:	d015      	beq.n	205720 <chHeapAllocAligned+0x190>
    ahp = heapp->provider(pages * CH_HEAP_ALIGNMENT,
  2056f4:	9b03      	ldr	r3, [sp, #12]
  2056f6:	681b      	ldr	r3, [r3, #0]
  2056f8:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  2056fa:	00d0      	lsls	r0, r2, #3
  2056fc:	2208      	movs	r2, #8
  2056fe:	9901      	ldr	r1, [sp, #4]
  205700:	4798      	blx	r3
  205702:	9008      	str	r0, [sp, #32]
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
  205704:	9b08      	ldr	r3, [sp, #32]
  205706:	2b00      	cmp	r3, #0
  205708:	d00a      	beq.n	205720 <chHeapAllocAligned+0x190>
      hp = ahp - 1U;
  20570a:	9b08      	ldr	r3, [sp, #32]
  20570c:	3b08      	subs	r3, #8
  20570e:	930a      	str	r3, [sp, #40]	@ 0x28
      H_USED_HEAP(hp) = heapp;
  205710:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  205712:	9a03      	ldr	r2, [sp, #12]
  205714:	601a      	str	r2, [r3, #0]
      H_USED_SIZE(hp) = size;
  205716:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  205718:	9a02      	ldr	r2, [sp, #8]
  20571a:	605a      	str	r2, [r3, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)ahp;
  20571c:	9b08      	ldr	r3, [sp, #32]
  20571e:	e000      	b.n	205722 <chHeapAllocAligned+0x192>
      /*lint -restore*/
    }
  }

  return NULL;
  205720:	2300      	movs	r3, #0
}
  205722:	4618      	mov	r0, r3
  205724:	b00d      	add	sp, #52	@ 0x34
  205726:	f85d fb04 	ldr.w	pc, [sp], #4
  20572a:	bf00      	nop
  20572c:	20000b48 	.word	0x20000b48

00205730 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
  205730:	b500      	push	{lr}
  205732:	b087      	sub	sp, #28
  205734:	9001      	str	r0, [sp, #4]
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  205736:	9b01      	ldr	r3, [sp, #4]
  205738:	3b08      	subs	r3, #8
  20573a:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_USED_HEAP(hp);
  20573c:	9b04      	ldr	r3, [sp, #16]
  20573e:	681b      	ldr	r3, [r3, #0]
  205740:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
  205742:	9b03      	ldr	r3, [sp, #12]
  205744:	330c      	adds	r3, #12
  205746:	9305      	str	r3, [sp, #20]
#if CH_CFG_HARDENING_LEVEL > 0
  memset((void *)p, 0, MEM_ALIGN_NEXT(H_USED_SIZE(hp), CH_HEAP_ALIGNMENT));
#endif

  /* Size is converted in number of elementary allocation units.*/
  H_FREE_PAGES(hp) = MEM_ALIGN_NEXT(H_USED_SIZE(hp),
  205748:	9b04      	ldr	r3, [sp, #16]
  20574a:	685b      	ldr	r3, [r3, #4]
  20574c:	3307      	adds	r3, #7
                                    CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
  20574e:	08da      	lsrs	r2, r3, #3
  H_FREE_PAGES(hp) = MEM_ALIGN_NEXT(H_USED_SIZE(hp),
  205750:	9b04      	ldr	r3, [sp, #16]
  205752:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex.*/
  H_LOCK(heapp);
  205754:	9b03      	ldr	r3, [sp, #12]
  205756:	3314      	adds	r3, #20
  205758:	4618      	mov	r0, r3
  20575a:	f7fe fb99 	bl	203e90 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_FREE_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
  20575e:	9b03      	ldr	r3, [sp, #12]
  205760:	330c      	adds	r3, #12
  205762:	9a05      	ldr	r2, [sp, #20]
  205764:	429a      	cmp	r2, r3
  205766:	d003      	beq.n	205770 <chHeapFree+0x40>
  205768:	9a04      	ldr	r2, [sp, #16]
  20576a:	9b05      	ldr	r3, [sp, #20]
  20576c:	429a      	cmp	r2, r3
  20576e:	d93d      	bls.n	2057ec <chHeapFree+0xbc>
        ((H_FREE_NEXT(qp) == NULL) || (hp < H_FREE_NEXT(qp)))) {
  205770:	9b05      	ldr	r3, [sp, #20]
  205772:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
  205774:	2b00      	cmp	r3, #0
  205776:	d004      	beq.n	205782 <chHeapFree+0x52>
        ((H_FREE_NEXT(qp) == NULL) || (hp < H_FREE_NEXT(qp)))) {
  205778:	9b05      	ldr	r3, [sp, #20]
  20577a:	681b      	ldr	r3, [r3, #0]
  20577c:	9a04      	ldr	r2, [sp, #16]
  20577e:	429a      	cmp	r2, r3
  205780:	d234      	bcs.n	2057ec <chHeapFree+0xbc>
      /* Insertion after qp.*/
      H_FREE_NEXT(hp) = H_FREE_NEXT(qp);
  205782:	9b05      	ldr	r3, [sp, #20]
  205784:	681a      	ldr	r2, [r3, #0]
  205786:	9b04      	ldr	r3, [sp, #16]
  205788:	601a      	str	r2, [r3, #0]
      H_FREE_NEXT(qp) = hp;
  20578a:	9b05      	ldr	r3, [sp, #20]
  20578c:	9a04      	ldr	r2, [sp, #16]
  20578e:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_FREE_LIMIT(hp) == H_FREE_NEXT(hp)) {
  205790:	9b04      	ldr	r3, [sp, #16]
  205792:	685b      	ldr	r3, [r3, #4]
  205794:	3301      	adds	r3, #1
  205796:	00db      	lsls	r3, r3, #3
  205798:	9a04      	ldr	r2, [sp, #16]
  20579a:	441a      	add	r2, r3
  20579c:	9b04      	ldr	r3, [sp, #16]
  20579e:	681b      	ldr	r3, [r3, #0]
  2057a0:	429a      	cmp	r2, r3
  2057a2:	d10d      	bne.n	2057c0 <chHeapFree+0x90>
        /* Merge with the next block.*/
        H_FREE_PAGES(hp) += H_FREE_PAGES(H_FREE_NEXT(hp)) + 1U;
  2057a4:	9b04      	ldr	r3, [sp, #16]
  2057a6:	685a      	ldr	r2, [r3, #4]
  2057a8:	9b04      	ldr	r3, [sp, #16]
  2057aa:	681b      	ldr	r3, [r3, #0]
  2057ac:	685b      	ldr	r3, [r3, #4]
  2057ae:	4413      	add	r3, r2
  2057b0:	1c5a      	adds	r2, r3, #1
  2057b2:	9b04      	ldr	r3, [sp, #16]
  2057b4:	605a      	str	r2, [r3, #4]
        H_FREE_NEXT(hp) = H_FREE_NEXT(H_FREE_NEXT(hp));
  2057b6:	9b04      	ldr	r3, [sp, #16]
  2057b8:	681b      	ldr	r3, [r3, #0]
  2057ba:	681a      	ldr	r2, [r3, #0]
  2057bc:	9b04      	ldr	r3, [sp, #16]
  2057be:	601a      	str	r2, [r3, #0]
      }
      if ((H_FREE_LIMIT(qp) == hp)) {
  2057c0:	9b05      	ldr	r3, [sp, #20]
  2057c2:	685b      	ldr	r3, [r3, #4]
  2057c4:	3301      	adds	r3, #1
  2057c6:	00db      	lsls	r3, r3, #3
  2057c8:	9a05      	ldr	r2, [sp, #20]
  2057ca:	4413      	add	r3, r2
  2057cc:	9a04      	ldr	r2, [sp, #16]
  2057ce:	429a      	cmp	r2, r3
  2057d0:	d110      	bne.n	2057f4 <chHeapFree+0xc4>
        /* Merge with the previous block.*/
        H_FREE_PAGES(qp) += H_FREE_PAGES(hp) + 1U;
  2057d2:	9b05      	ldr	r3, [sp, #20]
  2057d4:	685a      	ldr	r2, [r3, #4]
  2057d6:	9b04      	ldr	r3, [sp, #16]
  2057d8:	685b      	ldr	r3, [r3, #4]
  2057da:	4413      	add	r3, r2
  2057dc:	1c5a      	adds	r2, r3, #1
  2057de:	9b05      	ldr	r3, [sp, #20]
  2057e0:	605a      	str	r2, [r3, #4]
        H_FREE_NEXT(qp) = H_FREE_NEXT(hp);
  2057e2:	9b04      	ldr	r3, [sp, #16]
  2057e4:	681a      	ldr	r2, [r3, #0]
  2057e6:	9b05      	ldr	r3, [sp, #20]
  2057e8:	601a      	str	r2, [r3, #0]
      }
      break;
  2057ea:	e003      	b.n	2057f4 <chHeapFree+0xc4>
    }
    qp = H_FREE_NEXT(qp);
  2057ec:	9b05      	ldr	r3, [sp, #20]
  2057ee:	681b      	ldr	r3, [r3, #0]
  2057f0:	9305      	str	r3, [sp, #20]
    chDbgAssert((hp < qp) || (hp >= H_FREE_LIMIT(qp)), "within free block");
  2057f2:	e7b4      	b.n	20575e <chHeapFree+0x2e>
      break;
  2057f4:	bf00      	nop
  }

  /* Releasing heap mutex.*/
  H_UNLOCK(heapp);
  2057f6:	9b03      	ldr	r3, [sp, #12]
  2057f8:	3314      	adds	r3, #20
  2057fa:	4618      	mov	r0, r3
  2057fc:	f7fe fbf8 	bl	203ff0 <chMtxUnlock>

  return;
  205800:	bf00      	nop
}
  205802:	b007      	add	sp, #28
  205804:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205810 <chHeapStatus>:
 *                      free free block found space or @p NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
  205810:	b500      	push	{lr}
  205812:	b08b      	sub	sp, #44	@ 0x2c
  205814:	9003      	str	r0, [sp, #12]
  205816:	9102      	str	r1, [sp, #8]
  205818:	9201      	str	r2, [sp, #4]
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
  20581a:	9b03      	ldr	r3, [sp, #12]
  20581c:	2b00      	cmp	r3, #0
  20581e:	d101      	bne.n	205824 <chHeapStatus+0x14>
    heapp = &default_heap;
  205820:	4b20      	ldr	r3, [pc, #128]	@ (2058a4 <chHeapStatus+0x94>)
  205822:	9303      	str	r3, [sp, #12]
  }

  H_LOCK(heapp);
  205824:	9b03      	ldr	r3, [sp, #12]
  205826:	3314      	adds	r3, #20
  205828:	4618      	mov	r0, r3
  20582a:	f7fe fb31 	bl	203e90 <chMtxLock>
  tpages = 0U;
  20582e:	2300      	movs	r3, #0
  205830:	9307      	str	r3, [sp, #28]
  lpages = 0U;
  205832:	2300      	movs	r3, #0
  205834:	9306      	str	r3, [sp, #24]
  n = 0U;
  205836:	2300      	movs	r3, #0
  205838:	9308      	str	r3, [sp, #32]
  qp = &heapp->header;
  20583a:	9b03      	ldr	r3, [sp, #12]
  20583c:	330c      	adds	r3, #12
  20583e:	9309      	str	r3, [sp, #36]	@ 0x24
  while (H_FREE_NEXT(qp) != NULL) {
  205840:	e013      	b.n	20586a <chHeapStatus+0x5a>
    size_t pages = H_FREE_PAGES(H_FREE_NEXT(qp));
  205842:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  205844:	681b      	ldr	r3, [r3, #0]
  205846:	685b      	ldr	r3, [r3, #4]
  205848:	9305      	str	r3, [sp, #20]

    /* Updating counters.*/
    n++;
  20584a:	9b08      	ldr	r3, [sp, #32]
  20584c:	3301      	adds	r3, #1
  20584e:	9308      	str	r3, [sp, #32]
    tpages += pages;
  205850:	9a07      	ldr	r2, [sp, #28]
  205852:	9b05      	ldr	r3, [sp, #20]
  205854:	4413      	add	r3, r2
  205856:	9307      	str	r3, [sp, #28]
    if (pages > lpages) {
  205858:	9a05      	ldr	r2, [sp, #20]
  20585a:	9b06      	ldr	r3, [sp, #24]
  20585c:	429a      	cmp	r2, r3
  20585e:	d901      	bls.n	205864 <chHeapStatus+0x54>
      lpages = pages;
  205860:	9b05      	ldr	r3, [sp, #20]
  205862:	9306      	str	r3, [sp, #24]
    }

    qp = H_FREE_NEXT(qp);
  205864:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  205866:	681b      	ldr	r3, [r3, #0]
  205868:	9309      	str	r3, [sp, #36]	@ 0x24
  while (H_FREE_NEXT(qp) != NULL) {
  20586a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  20586c:	681b      	ldr	r3, [r3, #0]
  20586e:	2b00      	cmp	r3, #0
  205870:	d1e7      	bne.n	205842 <chHeapStatus+0x32>
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
  205872:	9b02      	ldr	r3, [sp, #8]
  205874:	2b00      	cmp	r3, #0
  205876:	d003      	beq.n	205880 <chHeapStatus+0x70>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
  205878:	9b07      	ldr	r3, [sp, #28]
  20587a:	00da      	lsls	r2, r3, #3
  20587c:	9b02      	ldr	r3, [sp, #8]
  20587e:	601a      	str	r2, [r3, #0]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
  205880:	9b01      	ldr	r3, [sp, #4]
  205882:	2b00      	cmp	r3, #0
  205884:	d003      	beq.n	20588e <chHeapStatus+0x7e>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
  205886:	9b06      	ldr	r3, [sp, #24]
  205888:	00da      	lsls	r2, r3, #3
  20588a:	9b01      	ldr	r3, [sp, #4]
  20588c:	601a      	str	r2, [r3, #0]
  }
  H_UNLOCK(heapp);
  20588e:	9b03      	ldr	r3, [sp, #12]
  205890:	3314      	adds	r3, #20
  205892:	4618      	mov	r0, r3
  205894:	f7fe fbac 	bl	203ff0 <chMtxUnlock>

  return n;
  205898:	9b08      	ldr	r3, [sp, #32]
}
  20589a:	4618      	mov	r0, r3
  20589c:	b00b      	add	sp, #44	@ 0x2c
  20589e:	f85d fb04 	ldr.w	pc, [sp], #4
  2058a2:	bf00      	nop
  2058a4:	20000b48 	.word	0x20000b48
	...

002058b0 <chHeapIntegrityCheck>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @api
 */
bool chHeapIntegrityCheck(memory_heap_t *heapp) {
  2058b0:	b500      	push	{lr}
  2058b2:	b087      	sub	sp, #28
  2058b4:	9001      	str	r0, [sp, #4]
  bool result = false;
  2058b6:	2300      	movs	r3, #0
  2058b8:	f88d 3017 	strb.w	r3, [sp, #23]
  heap_header_t *hp, *prevhp;

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
  2058bc:	9b01      	ldr	r3, [sp, #4]
  2058be:	2b00      	cmp	r3, #0
  2058c0:	d101      	bne.n	2058c6 <chHeapIntegrityCheck+0x16>
    heapp = &default_heap;
  2058c2:	4b2b      	ldr	r3, [pc, #172]	@ (205970 <chHeapIntegrityCheck+0xc0>)
  2058c4:	9301      	str	r3, [sp, #4]
  }

  /* Validating heap object.*/
  if (heapp->provider != NULL) {
  2058c6:	9b01      	ldr	r3, [sp, #4]
  2058c8:	681b      	ldr	r3, [r3, #0]
  2058ca:	2b00      	cmp	r3, #0
  2058cc:	d00c      	beq.n	2058e8 <chHeapIntegrityCheck+0x38>
    if (!chMemIsAddressExecutableX((const void *)heapp->provider)) {
  2058ce:	9b01      	ldr	r3, [sp, #4]
  2058d0:	681b      	ldr	r3, [r3, #0]
  2058d2:	4618      	mov	r0, r3
  2058d4:	f7ff facc 	bl	204e70 <chMemIsAddressExecutableX>
  2058d8:	4603      	mov	r3, r0
  2058da:	f083 0301 	eor.w	r3, r3, #1
  2058de:	b2db      	uxtb	r3, r3
  2058e0:	2b00      	cmp	r3, #0
  2058e2:	d001      	beq.n	2058e8 <chHeapIntegrityCheck+0x38>
      return true;
  2058e4:	2301      	movs	r3, #1
  2058e6:	e03e      	b.n	205966 <chHeapIntegrityCheck+0xb6>
    }
  }

  /* Taking heap mutex.*/
  H_LOCK(heapp);
  2058e8:	9b01      	ldr	r3, [sp, #4]
  2058ea:	3314      	adds	r3, #20
  2058ec:	4618      	mov	r0, r3
  2058ee:	f7fe facf 	bl	203e90 <chMtxLock>

  prevhp = NULL;
  2058f2:	2300      	movs	r3, #0
  2058f4:	9303      	str	r3, [sp, #12]
  hp = &heapp->header;
  2058f6:	9b01      	ldr	r3, [sp, #4]
  2058f8:	330c      	adds	r3, #12
  2058fa:	9304      	str	r3, [sp, #16]
  while ((hp = H_FREE_NEXT(hp)) != NULL) {
  2058fc:	e026      	b.n	20594c <chHeapIntegrityCheck+0x9c>

    /* Order violation or loop.*/
    if (hp <= prevhp) {
  2058fe:	9a04      	ldr	r2, [sp, #16]
  205900:	9b03      	ldr	r3, [sp, #12]
  205902:	429a      	cmp	r2, r3
  205904:	d803      	bhi.n	20590e <chHeapIntegrityCheck+0x5e>
      result = true;
  205906:	2301      	movs	r3, #1
  205908:	f88d 3017 	strb.w	r3, [sp, #23]
      break;
  20590c:	e024      	b.n	205958 <chHeapIntegrityCheck+0xa8>
    }

    /* Checking pointer alignment.*/
    if (!MEM_IS_ALIGNED(hp, CH_HEAP_ALIGNMENT)) {
  20590e:	9b04      	ldr	r3, [sp, #16]
  205910:	f003 0307 	and.w	r3, r3, #7
  205914:	2b00      	cmp	r3, #0
  205916:	d003      	beq.n	205920 <chHeapIntegrityCheck+0x70>
      result = true;
  205918:	2301      	movs	r3, #1
  20591a:	f88d 3017 	strb.w	r3, [sp, #23]
      break;
  20591e:	e01b      	b.n	205958 <chHeapIntegrityCheck+0xa8>
    }

    /* Validating the found free block.*/
    if (!chMemIsSpaceWithinX(&heapp->area,
  205920:	9b01      	ldr	r3, [sp, #4]
  205922:	1d18      	adds	r0, r3, #4
                             (void *)hp,
                             H_FREE_FULLSIZE(hp))) {
  205924:	9b04      	ldr	r3, [sp, #16]
  205926:	685b      	ldr	r3, [r3, #4]
  205928:	3301      	adds	r3, #1
  20592a:	00db      	lsls	r3, r3, #3
    if (!chMemIsSpaceWithinX(&heapp->area,
  20592c:	461a      	mov	r2, r3
  20592e:	9904      	ldr	r1, [sp, #16]
  205930:	f7ff fda6 	bl	205480 <chMemIsSpaceWithinX.lto_priv.1>
  205934:	4603      	mov	r3, r0
  205936:	f083 0301 	eor.w	r3, r3, #1
  20593a:	b2db      	uxtb	r3, r3
  20593c:	2b00      	cmp	r3, #0
  20593e:	d003      	beq.n	205948 <chHeapIntegrityCheck+0x98>
      result = true;
  205940:	2301      	movs	r3, #1
  205942:	f88d 3017 	strb.w	r3, [sp, #23]
      break;
  205946:	e007      	b.n	205958 <chHeapIntegrityCheck+0xa8>
    }

    prevhp = hp;
  205948:	9b04      	ldr	r3, [sp, #16]
  20594a:	9303      	str	r3, [sp, #12]
  while ((hp = H_FREE_NEXT(hp)) != NULL) {
  20594c:	9b04      	ldr	r3, [sp, #16]
  20594e:	681b      	ldr	r3, [r3, #0]
  205950:	9304      	str	r3, [sp, #16]
  205952:	9b04      	ldr	r3, [sp, #16]
  205954:	2b00      	cmp	r3, #0
  205956:	d1d2      	bne.n	2058fe <chHeapIntegrityCheck+0x4e>
  }

  /* Releasing the heap mutex.*/
  H_UNLOCK(heapp);
  205958:	9b01      	ldr	r3, [sp, #4]
  20595a:	3314      	adds	r3, #20
  20595c:	4618      	mov	r0, r3
  20595e:	f7fe fb47 	bl	203ff0 <chMtxUnlock>

  return result;
  205962:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
  205966:	4618      	mov	r0, r3
  205968:	b007      	add	sp, #28
  20596a:	f85d fb04 	ldr.w	pc, [sp], #4
  20596e:	bf00      	nop
  205970:	20000b48 	.word	0x20000b48
	...

00205980 <chSysLock.lto_priv.14>:
static inline void chSysLock(void) {
  205980:	b082      	sub	sp, #8
  205982:	2330      	movs	r3, #48	@ 0x30
  205984:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205986:	9b01      	ldr	r3, [sp, #4]
  205988:	f383 8811 	msr	BASEPRI, r3
}
  20598c:	bf00      	nop
}
  20598e:	bf00      	nop
}
  205990:	bf00      	nop
  205992:	b002      	add	sp, #8
  205994:	4770      	bx	lr
  205996:	bf00      	nop
	...

002059a0 <chSysUnlock.lto_priv.14>:
static inline void chSysUnlock(void) {
  2059a0:	b082      	sub	sp, #8
  2059a2:	2300      	movs	r3, #0
  2059a4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2059a6:	9b01      	ldr	r3, [sp, #4]
  2059a8:	f383 8811 	msr	BASEPRI, r3
}
  2059ac:	bf00      	nop
}
  2059ae:	bf00      	nop
}
  2059b0:	bf00      	nop
  2059b2:	b002      	add	sp, #8
  2059b4:	4770      	bx	lr
  2059b6:	bf00      	nop
	...

002059c0 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t object
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
  2059c0:	b500      	push	{lr}
  2059c2:	b083      	sub	sp, #12
  2059c4:	9001      	str	r0, [sp, #4]
  2059c6:	9100      	str	r1, [sp, #0]

  chPoolFree(mp, objp);
  2059c8:	9900      	ldr	r1, [sp, #0]
  2059ca:	9801      	ldr	r0, [sp, #4]
  2059cc:	f000 f8b0 	bl	205b30 <chPoolFree>
}
  2059d0:	bf00      	nop
  2059d2:	b003      	add	sp, #12
  2059d4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002059e0 <chGuardedPoolFreeI>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t object
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
static inline void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {
  2059e0:	b500      	push	{lr}
  2059e2:	b083      	sub	sp, #12
  2059e4:	9001      	str	r0, [sp, #4]
  2059e6:	9100      	str	r1, [sp, #0]

  chPoolFreeI(&gmp->pool, objp);
  2059e8:	9b01      	ldr	r3, [sp, #4]
  2059ea:	330c      	adds	r3, #12
  2059ec:	9900      	ldr	r1, [sp, #0]
  2059ee:	4618      	mov	r0, r3
  2059f0:	f000 f88e 	bl	205b10 <chPoolFreeI>
  chSemSignalI(&gmp->sem);
  2059f4:	9b01      	ldr	r3, [sp, #4]
  2059f6:	4618      	mov	r0, r3
  2059f8:	f7fe f902 	bl	203c00 <chSemSignalI>
}
  2059fc:	bf00      	nop
  2059fe:	b003      	add	sp, #12
  205a00:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205a10 <chGuardedPoolAdd>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t object
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chGuardedPoolAdd(guarded_memory_pool_t *gmp, void *objp) {
  205a10:	b500      	push	{lr}
  205a12:	b083      	sub	sp, #12
  205a14:	9001      	str	r0, [sp, #4]
  205a16:	9100      	str	r1, [sp, #0]

  chGuardedPoolFree(gmp, objp);
  205a18:	9900      	ldr	r1, [sp, #0]
  205a1a:	9801      	ldr	r0, [sp, #4]
  205a1c:	f000 f908 	bl	205c30 <chGuardedPoolFree>
}
  205a20:	bf00      	nop
  205a22:	b003      	add	sp, #12
  205a24:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205a30 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
  205a30:	b084      	sub	sp, #16
  205a32:	9003      	str	r0, [sp, #12]
  205a34:	9102      	str	r1, [sp, #8]
  205a36:	9201      	str	r2, [sp, #4]
  205a38:	9300      	str	r3, [sp, #0]
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  205a3a:	9b03      	ldr	r3, [sp, #12]
  205a3c:	2200      	movs	r2, #0
  205a3e:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
  205a40:	9b03      	ldr	r3, [sp, #12]
  205a42:	9a02      	ldr	r2, [sp, #8]
  205a44:	605a      	str	r2, [r3, #4]
  mp->align = align;
  205a46:	9b03      	ldr	r3, [sp, #12]
  205a48:	9a01      	ldr	r2, [sp, #4]
  205a4a:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
  205a4c:	9b03      	ldr	r3, [sp, #12]
  205a4e:	9a00      	ldr	r2, [sp, #0]
  205a50:	60da      	str	r2, [r3, #12]
}
  205a52:	bf00      	nop
  205a54:	b004      	add	sp, #16
  205a56:	4770      	bx	lr
	...

00205a60 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
  205a60:	b500      	push	{lr}
  205a62:	b085      	sub	sp, #20
  205a64:	9003      	str	r0, [sp, #12]
  205a66:	9102      	str	r1, [sp, #8]
  205a68:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
  205a6a:	e00b      	b.n	205a84 <chPoolLoadArray+0x24>
    chPoolAdd(mp, p);
  205a6c:	9902      	ldr	r1, [sp, #8]
  205a6e:	9803      	ldr	r0, [sp, #12]
  205a70:	f7ff ffa6 	bl	2059c0 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
  205a74:	9b03      	ldr	r3, [sp, #12]
  205a76:	685b      	ldr	r3, [r3, #4]
  205a78:	9a02      	ldr	r2, [sp, #8]
  205a7a:	4413      	add	r3, r2
  205a7c:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
  205a7e:	9b01      	ldr	r3, [sp, #4]
  205a80:	3b01      	subs	r3, #1
  205a82:	9301      	str	r3, [sp, #4]
  while (n != 0U) {
  205a84:	9b01      	ldr	r3, [sp, #4]
  205a86:	2b00      	cmp	r3, #0
  205a88:	d1f0      	bne.n	205a6c <chPoolLoadArray+0xc>
  }
}
  205a8a:	bf00      	nop
  205a8c:	bf00      	nop
  205a8e:	b005      	add	sp, #20
  205a90:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205aa0 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
  205aa0:	b500      	push	{lr}
  205aa2:	b085      	sub	sp, #20
  205aa4:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
  205aa6:	9b01      	ldr	r3, [sp, #4]
  205aa8:	681b      	ldr	r3, [r3, #0]
  205aaa:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
  205aac:	9b03      	ldr	r3, [sp, #12]
  205aae:	2b00      	cmp	r3, #0
  205ab0:	d005      	beq.n	205abe <chPoolAllocI+0x1e>
    mp->next = mp->next->next;
  205ab2:	9b01      	ldr	r3, [sp, #4]
  205ab4:	681b      	ldr	r3, [r3, #0]
  205ab6:	681a      	ldr	r2, [r3, #0]
  205ab8:	9b01      	ldr	r3, [sp, #4]
  205aba:	601a      	str	r2, [r3, #0]
  205abc:	e00c      	b.n	205ad8 <chPoolAllocI+0x38>
  }
  else if (mp->provider != NULL) {
  205abe:	9b01      	ldr	r3, [sp, #4]
  205ac0:	68db      	ldr	r3, [r3, #12]
  205ac2:	2b00      	cmp	r3, #0
  205ac4:	d008      	beq.n	205ad8 <chPoolAllocI+0x38>
    objp = mp->provider(mp->object_size, mp->align);
  205ac6:	9b01      	ldr	r3, [sp, #4]
  205ac8:	68db      	ldr	r3, [r3, #12]
  205aca:	9a01      	ldr	r2, [sp, #4]
  205acc:	6850      	ldr	r0, [r2, #4]
  205ace:	9a01      	ldr	r2, [sp, #4]
  205ad0:	6892      	ldr	r2, [r2, #8]
  205ad2:	4611      	mov	r1, r2
  205ad4:	4798      	blx	r3
  205ad6:	9003      	str	r0, [sp, #12]
    chDbgAssert(MEM_IS_ALIGNED(objp, mp->align),
                "returned object not aligned");
  }
  /*lint -restore*/

  return objp;
  205ad8:	9b03      	ldr	r3, [sp, #12]
}
  205ada:	4618      	mov	r0, r3
  205adc:	b005      	add	sp, #20
  205ade:	f85d fb04 	ldr.w	pc, [sp], #4
  205ae2:	bf00      	nop
	...

00205af0 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
  205af0:	b500      	push	{lr}
  205af2:	b085      	sub	sp, #20
  205af4:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
  205af6:	f7ff ff43 	bl	205980 <chSysLock.lto_priv.14>
  objp = chPoolAllocI(mp);
  205afa:	9801      	ldr	r0, [sp, #4]
  205afc:	f7ff ffd0 	bl	205aa0 <chPoolAllocI>
  205b00:	9003      	str	r0, [sp, #12]
  chSysUnlock();
  205b02:	f7ff ff4d 	bl	2059a0 <chSysUnlock.lto_priv.14>

  return objp;
  205b06:	9b03      	ldr	r3, [sp, #12]
}
  205b08:	4618      	mov	r0, r3
  205b0a:	b005      	add	sp, #20
  205b0c:	f85d fb04 	ldr.w	pc, [sp], #4

00205b10 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t object
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  205b10:	b084      	sub	sp, #16
  205b12:	9001      	str	r0, [sp, #4]
  205b14:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
  205b16:	9b00      	ldr	r3, [sp, #0]
  205b18:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
  205b1a:	9b01      	ldr	r3, [sp, #4]
  205b1c:	681a      	ldr	r2, [r3, #0]
  205b1e:	9b03      	ldr	r3, [sp, #12]
  205b20:	601a      	str	r2, [r3, #0]
  mp->next = php;
  205b22:	9b01      	ldr	r3, [sp, #4]
  205b24:	9a03      	ldr	r2, [sp, #12]
  205b26:	601a      	str	r2, [r3, #0]
}
  205b28:	bf00      	nop
  205b2a:	b004      	add	sp, #16
  205b2c:	4770      	bx	lr
  205b2e:	bf00      	nop

00205b30 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t object
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
  205b30:	b500      	push	{lr}
  205b32:	b083      	sub	sp, #12
  205b34:	9001      	str	r0, [sp, #4]
  205b36:	9100      	str	r1, [sp, #0]

  chSysLock();
  205b38:	f7ff ff22 	bl	205980 <chSysLock.lto_priv.14>
  chPoolFreeI(mp, objp);
  205b3c:	9900      	ldr	r1, [sp, #0]
  205b3e:	9801      	ldr	r0, [sp, #4]
  205b40:	f7ff ffe6 	bl	205b10 <chPoolFreeI>
  chSysUnlock();
  205b44:	f7ff ff2c 	bl	2059a0 <chSysUnlock.lto_priv.14>
}
  205b48:	bf00      	nop
  205b4a:	b003      	add	sp, #12
  205b4c:	f85d fb04 	ldr.w	pc, [sp], #4

00205b50 <chGuardedPoolObjectInitAligned>:
 *
 * @init
 */
void chGuardedPoolObjectInitAligned(guarded_memory_pool_t *gmp,
                                    size_t size,
                                    unsigned align) {
  205b50:	b500      	push	{lr}
  205b52:	b085      	sub	sp, #20
  205b54:	9003      	str	r0, [sp, #12]
  205b56:	9102      	str	r1, [sp, #8]
  205b58:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(&gmp->pool, size, align, NULL);
  205b5a:	9b03      	ldr	r3, [sp, #12]
  205b5c:	f103 000c 	add.w	r0, r3, #12
  205b60:	2300      	movs	r3, #0
  205b62:	9a01      	ldr	r2, [sp, #4]
  205b64:	9902      	ldr	r1, [sp, #8]
  205b66:	f7ff ff63 	bl	205a30 <chPoolObjectInitAligned>
  chSemObjectInit(&gmp->sem, (cnt_t)0);
  205b6a:	9b03      	ldr	r3, [sp, #12]
  205b6c:	2100      	movs	r1, #0
  205b6e:	4618      	mov	r0, r3
  205b70:	f7fd ff56 	bl	203a20 <chSemObjectInit>
}
  205b74:	bf00      	nop
  205b76:	b005      	add	sp, #20
  205b78:	f85d fb04 	ldr.w	pc, [sp], #4
  205b7c:	0000      	movs	r0, r0
	...

00205b80 <chGuardedPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
  205b80:	b500      	push	{lr}
  205b82:	b085      	sub	sp, #20
  205b84:	9003      	str	r0, [sp, #12]
  205b86:	9102      	str	r1, [sp, #8]
  205b88:	9201      	str	r2, [sp, #4]

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
  205b8a:	e00b      	b.n	205ba4 <chGuardedPoolLoadArray+0x24>
    chGuardedPoolAdd(gmp, p);
  205b8c:	9902      	ldr	r1, [sp, #8]
  205b8e:	9803      	ldr	r0, [sp, #12]
  205b90:	f7ff ff3e 	bl	205a10 <chGuardedPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
  205b94:	9b03      	ldr	r3, [sp, #12]
  205b96:	691b      	ldr	r3, [r3, #16]
  205b98:	9a02      	ldr	r2, [sp, #8]
  205b9a:	4413      	add	r3, r2
  205b9c:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
  205b9e:	9b01      	ldr	r3, [sp, #4]
  205ba0:	3b01      	subs	r3, #1
  205ba2:	9301      	str	r3, [sp, #4]
  while (n != 0U) {
  205ba4:	9b01      	ldr	r3, [sp, #4]
  205ba6:	2b00      	cmp	r3, #0
  205ba8:	d1f0      	bne.n	205b8c <chGuardedPoolLoadArray+0xc>
  }
}
  205baa:	bf00      	nop
  205bac:	bf00      	nop
  205bae:	b005      	add	sp, #20
  205bb0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205bc0 <chGuardedPoolAllocTimeoutS>:
 * @retval NULL         if the operation timed out.
 *
 * @sclass
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 sysinterval_t timeout) {
  205bc0:	b500      	push	{lr}
  205bc2:	b085      	sub	sp, #20
  205bc4:	9001      	str	r0, [sp, #4]
  205bc6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
  205bc8:	9b01      	ldr	r3, [sp, #4]
  205bca:	9900      	ldr	r1, [sp, #0]
  205bcc:	4618      	mov	r0, r3
  205bce:	f7fd ffbf 	bl	203b50 <chSemWaitTimeoutS>
  205bd2:	9003      	str	r0, [sp, #12]
  if (msg != MSG_OK) {
  205bd4:	9b03      	ldr	r3, [sp, #12]
  205bd6:	2b00      	cmp	r3, #0
  205bd8:	d001      	beq.n	205bde <chGuardedPoolAllocTimeoutS+0x1e>
    return NULL;
  205bda:	2300      	movs	r3, #0
  205bdc:	e005      	b.n	205bea <chGuardedPoolAllocTimeoutS+0x2a>
  }

  return chPoolAllocI(&gmp->pool);
  205bde:	9b01      	ldr	r3, [sp, #4]
  205be0:	330c      	adds	r3, #12
  205be2:	4618      	mov	r0, r3
  205be4:	f7ff ff5c 	bl	205aa0 <chPoolAllocI>
  205be8:	4603      	mov	r3, r0
}
  205bea:	4618      	mov	r0, r3
  205bec:	b005      	add	sp, #20
  205bee:	f85d fb04 	ldr.w	pc, [sp], #4
  205bf2:	bf00      	nop
	...

00205c00 <chGuardedPoolAllocTimeout>:
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
                                sysinterval_t timeout) {
  205c00:	b500      	push	{lr}
  205c02:	b085      	sub	sp, #20
  205c04:	9001      	str	r0, [sp, #4]
  205c06:	9100      	str	r1, [sp, #0]
  void *p;

  chSysLock();
  205c08:	f7ff feba 	bl	205980 <chSysLock.lto_priv.14>
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  205c0c:	9900      	ldr	r1, [sp, #0]
  205c0e:	9801      	ldr	r0, [sp, #4]
  205c10:	f7ff ffd6 	bl	205bc0 <chGuardedPoolAllocTimeoutS>
  205c14:	9003      	str	r0, [sp, #12]
  chSysUnlock();
  205c16:	f7ff fec3 	bl	2059a0 <chSysUnlock.lto_priv.14>

  return p;
  205c1a:	9b03      	ldr	r3, [sp, #12]
}
  205c1c:	4618      	mov	r0, r3
  205c1e:	b005      	add	sp, #20
  205c20:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205c30 <chGuardedPoolFree>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t object
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {
  205c30:	b500      	push	{lr}
  205c32:	b083      	sub	sp, #12
  205c34:	9001      	str	r0, [sp, #4]
  205c36:	9100      	str	r1, [sp, #0]

  chSysLock();
  205c38:	f7ff fea2 	bl	205980 <chSysLock.lto_priv.14>
  chGuardedPoolFreeI(gmp, objp);
  205c3c:	9900      	ldr	r1, [sp, #0]
  205c3e:	9801      	ldr	r0, [sp, #4]
  205c40:	f7ff fece 	bl	2059e0 <chGuardedPoolFreeI>
  chSchRescheduleS();
  205c44:	f7fd f814 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  205c48:	f7ff feaa 	bl	2059a0 <chSysUnlock.lto_priv.14>
}
  205c4c:	bf00      	nop
  205c4e:	b003      	add	sp, #12
  205c50:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205c60 <chSysLock.lto_priv.15>:
static inline void chSysLock(void) {
  205c60:	b082      	sub	sp, #8
  205c62:	2330      	movs	r3, #48	@ 0x30
  205c64:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205c66:	9b01      	ldr	r3, [sp, #4]
  205c68:	f383 8811 	msr	BASEPRI, r3
}
  205c6c:	bf00      	nop
}
  205c6e:	bf00      	nop
}
  205c70:	bf00      	nop
  205c72:	b002      	add	sp, #8
  205c74:	4770      	bx	lr
  205c76:	bf00      	nop
	...

00205c80 <chSysUnlock.lto_priv.15>:
static inline void chSysUnlock(void) {
  205c80:	b082      	sub	sp, #8
  205c82:	2300      	movs	r3, #0
  205c84:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205c86:	9b01      	ldr	r3, [sp, #4]
  205c88:	f383 8811 	msr	BASEPRI, r3
}
  205c8c:	bf00      	nop
}
  205c8e:	bf00      	nop
}
  205c90:	bf00      	nop
  205c92:	b002      	add	sp, #8
  205c94:	4770      	bx	lr
  205c96:	bf00      	nop
	...

00205ca0 <chPipeGetSize>:
 * @param[in] pp        the pointer to an initialized @p pipe_t object
 * @return              The size of the pipe.
 *
 * @api
 */
static inline size_t chPipeGetSize(const pipe_t *pp) {
  205ca0:	b082      	sub	sp, #8
  205ca2:	9001      	str	r0, [sp, #4]

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (size_t)(pp->top - pp->buffer);
  205ca4:	9b01      	ldr	r3, [sp, #4]
  205ca6:	685a      	ldr	r2, [r3, #4]
  205ca8:	9b01      	ldr	r3, [sp, #4]
  205caa:	681b      	ldr	r3, [r3, #0]
  205cac:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
  205cae:	4618      	mov	r0, r3
  205cb0:	b002      	add	sp, #8
  205cb2:	4770      	bx	lr
	...

00205cc0 <chPipeGetUsedCount>:
 * @param[in] pp        the pointer to an initialized @p pipe_t object
 * @return              The number of queued bytes.
 *
 * @api
 */
static inline size_t chPipeGetUsedCount(const pipe_t *pp) {
  205cc0:	b082      	sub	sp, #8
  205cc2:	9001      	str	r0, [sp, #4]

  return pp->cnt;
  205cc4:	9b01      	ldr	r3, [sp, #4]
  205cc6:	691b      	ldr	r3, [r3, #16]
}
  205cc8:	4618      	mov	r0, r3
  205cca:	b002      	add	sp, #8
  205ccc:	4770      	bx	lr
  205cce:	bf00      	nop

00205cd0 <chPipeGetFreeCount>:
 * @param[in] pp        the pointer to an initialized @p pipe_t object
 * @return              The number of empty byte slots.
 *
 * @api
 */
static inline size_t chPipeGetFreeCount(const pipe_t *pp) {
  205cd0:	b510      	push	{r4, lr}
  205cd2:	b082      	sub	sp, #8
  205cd4:	9001      	str	r0, [sp, #4]

  return chPipeGetSize(pp) - chPipeGetUsedCount(pp);
  205cd6:	9801      	ldr	r0, [sp, #4]
  205cd8:	f7ff ffe2 	bl	205ca0 <chPipeGetSize>
  205cdc:	4604      	mov	r4, r0
  205cde:	9801      	ldr	r0, [sp, #4]
  205ce0:	f7ff ffee 	bl	205cc0 <chPipeGetUsedCount>
  205ce4:	4603      	mov	r3, r0
  205ce6:	1ae3      	subs	r3, r4, r3
}
  205ce8:	4618      	mov	r0, r3
  205cea:	b002      	add	sp, #8
  205cec:	bd10      	pop	{r4, pc}
  205cee:	bf00      	nop

00205cf0 <pipe_write>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t pipe_write(pipe_t *pp, const uint8_t *bp, size_t n) {
  205cf0:	b500      	push	{lr}
  205cf2:	b087      	sub	sp, #28
  205cf4:	9003      	str	r0, [sp, #12]
  205cf6:	9102      	str	r1, [sp, #8]
  205cf8:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  PC_LOCK(pp);
  205cfa:	9b03      	ldr	r3, [sp, #12]
  205cfc:	3320      	adds	r3, #32
  205cfe:	4618      	mov	r0, r3
  205d00:	f7fe f8c6 	bl	203e90 <chMtxLock>

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > chPipeGetFreeCount(pp)) {
  205d04:	9803      	ldr	r0, [sp, #12]
  205d06:	f7ff ffe3 	bl	205cd0 <chPipeGetFreeCount>
  205d0a:	4602      	mov	r2, r0
  205d0c:	9b01      	ldr	r3, [sp, #4]
  205d0e:	4293      	cmp	r3, r2
  205d10:	d903      	bls.n	205d1a <pipe_write+0x2a>
    n = chPipeGetFreeCount(pp);
  205d12:	9803      	ldr	r0, [sp, #12]
  205d14:	f7ff ffdc 	bl	205cd0 <chPipeGetFreeCount>
  205d18:	9001      	str	r0, [sp, #4]
  }
  pp->cnt += n;
  205d1a:	9b03      	ldr	r3, [sp, #12]
  205d1c:	691a      	ldr	r2, [r3, #16]
  205d1e:	9b01      	ldr	r3, [sp, #4]
  205d20:	441a      	add	r2, r3
  205d22:	9b03      	ldr	r3, [sp, #12]
  205d24:	611a      	str	r2, [r3, #16]

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(pp->top - pp->wrptr);
  205d26:	9b03      	ldr	r3, [sp, #12]
  205d28:	685a      	ldr	r2, [r3, #4]
  205d2a:	9b03      	ldr	r3, [sp, #12]
  205d2c:	689b      	ldr	r3, [r3, #8]
  205d2e:	1ad3      	subs	r3, r2, r3
  205d30:	9305      	str	r3, [sp, #20]
  /*lint -restore*/

  if (n < s1) {
  205d32:	9a01      	ldr	r2, [sp, #4]
  205d34:	9b05      	ldr	r3, [sp, #20]
  205d36:	429a      	cmp	r2, r3
  205d38:	d20d      	bcs.n	205d56 <pipe_write+0x66>
    memcpy((void *)pp->wrptr, (const void *)bp, n);
  205d3a:	9b03      	ldr	r3, [sp, #12]
  205d3c:	689b      	ldr	r3, [r3, #8]
  205d3e:	9a01      	ldr	r2, [sp, #4]
  205d40:	9902      	ldr	r1, [sp, #8]
  205d42:	4618      	mov	r0, r3
  205d44:	f7fa fbce 	bl	2004e4 <memcpy>
    pp->wrptr += n;
  205d48:	9b03      	ldr	r3, [sp, #12]
  205d4a:	689a      	ldr	r2, [r3, #8]
  205d4c:	9b01      	ldr	r3, [sp, #4]
  205d4e:	441a      	add	r2, r3
  205d50:	9b03      	ldr	r3, [sp, #12]
  205d52:	609a      	str	r2, [r3, #8]
  205d54:	e02b      	b.n	205dae <pipe_write+0xbe>
  }
  else if (n > s1) {
  205d56:	9a01      	ldr	r2, [sp, #4]
  205d58:	9b05      	ldr	r3, [sp, #20]
  205d5a:	429a      	cmp	r2, r3
  205d5c:	d91c      	bls.n	205d98 <pipe_write+0xa8>
    memcpy((void *)pp->wrptr, (const void *)bp, s1);
  205d5e:	9b03      	ldr	r3, [sp, #12]
  205d60:	689b      	ldr	r3, [r3, #8]
  205d62:	9a05      	ldr	r2, [sp, #20]
  205d64:	9902      	ldr	r1, [sp, #8]
  205d66:	4618      	mov	r0, r3
  205d68:	f7fa fbbc 	bl	2004e4 <memcpy>
    bp += s1;
  205d6c:	9a02      	ldr	r2, [sp, #8]
  205d6e:	9b05      	ldr	r3, [sp, #20]
  205d70:	4413      	add	r3, r2
  205d72:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
  205d74:	9a01      	ldr	r2, [sp, #4]
  205d76:	9b05      	ldr	r3, [sp, #20]
  205d78:	1ad3      	subs	r3, r2, r3
  205d7a:	9304      	str	r3, [sp, #16]
    memcpy((void *)pp->buffer, (const void *)bp, s2);
  205d7c:	9b03      	ldr	r3, [sp, #12]
  205d7e:	681b      	ldr	r3, [r3, #0]
  205d80:	9a04      	ldr	r2, [sp, #16]
  205d82:	9902      	ldr	r1, [sp, #8]
  205d84:	4618      	mov	r0, r3
  205d86:	f7fa fbad 	bl	2004e4 <memcpy>
    pp->wrptr = pp->buffer + s2;
  205d8a:	9b03      	ldr	r3, [sp, #12]
  205d8c:	681a      	ldr	r2, [r3, #0]
  205d8e:	9b04      	ldr	r3, [sp, #16]
  205d90:	441a      	add	r2, r3
  205d92:	9b03      	ldr	r3, [sp, #12]
  205d94:	609a      	str	r2, [r3, #8]
  205d96:	e00a      	b.n	205dae <pipe_write+0xbe>
  }
  else {
    memcpy((void *)pp->wrptr, (const void *)bp, n);
  205d98:	9b03      	ldr	r3, [sp, #12]
  205d9a:	689b      	ldr	r3, [r3, #8]
  205d9c:	9a01      	ldr	r2, [sp, #4]
  205d9e:	9902      	ldr	r1, [sp, #8]
  205da0:	4618      	mov	r0, r3
  205da2:	f7fa fb9f 	bl	2004e4 <memcpy>
    pp->wrptr = pp->buffer;
  205da6:	9b03      	ldr	r3, [sp, #12]
  205da8:	681a      	ldr	r2, [r3, #0]
  205daa:	9b03      	ldr	r3, [sp, #12]
  205dac:	609a      	str	r2, [r3, #8]
  }

  PC_UNLOCK(pp);
  205dae:	9b03      	ldr	r3, [sp, #12]
  205db0:	3320      	adds	r3, #32
  205db2:	4618      	mov	r0, r3
  205db4:	f7fe f91c 	bl	203ff0 <chMtxUnlock>

  return n;
  205db8:	9b01      	ldr	r3, [sp, #4]
}
  205dba:	4618      	mov	r0, r3
  205dbc:	b007      	add	sp, #28
  205dbe:	f85d fb04 	ldr.w	pc, [sp], #4
  205dc2:	bf00      	nop
	...

00205dd0 <pipe_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t pipe_read(pipe_t *pp, uint8_t *bp, size_t n) {
  205dd0:	b500      	push	{lr}
  205dd2:	b087      	sub	sp, #28
  205dd4:	9003      	str	r0, [sp, #12]
  205dd6:	9102      	str	r1, [sp, #8]
  205dd8:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  PC_LOCK(pp);
  205dda:	9b03      	ldr	r3, [sp, #12]
  205ddc:	3320      	adds	r3, #32
  205dde:	4618      	mov	r0, r3
  205de0:	f7fe f856 	bl	203e90 <chMtxLock>

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > chPipeGetUsedCount(pp)) {
  205de4:	9803      	ldr	r0, [sp, #12]
  205de6:	f7ff ff6b 	bl	205cc0 <chPipeGetUsedCount>
  205dea:	4602      	mov	r2, r0
  205dec:	9b01      	ldr	r3, [sp, #4]
  205dee:	4293      	cmp	r3, r2
  205df0:	d903      	bls.n	205dfa <pipe_read+0x2a>
    n = chPipeGetUsedCount(pp);
  205df2:	9803      	ldr	r0, [sp, #12]
  205df4:	f7ff ff64 	bl	205cc0 <chPipeGetUsedCount>
  205df8:	9001      	str	r0, [sp, #4]
  }
  pp->cnt -= n;
  205dfa:	9b03      	ldr	r3, [sp, #12]
  205dfc:	691a      	ldr	r2, [r3, #16]
  205dfe:	9b01      	ldr	r3, [sp, #4]
  205e00:	1ad2      	subs	r2, r2, r3
  205e02:	9b03      	ldr	r3, [sp, #12]
  205e04:	611a      	str	r2, [r3, #16]

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(pp->top - pp->rdptr);
  205e06:	9b03      	ldr	r3, [sp, #12]
  205e08:	685a      	ldr	r2, [r3, #4]
  205e0a:	9b03      	ldr	r3, [sp, #12]
  205e0c:	68db      	ldr	r3, [r3, #12]
  205e0e:	1ad3      	subs	r3, r2, r3
  205e10:	9305      	str	r3, [sp, #20]
  /*lint -restore*/

  if (n < s1) {
  205e12:	9a01      	ldr	r2, [sp, #4]
  205e14:	9b05      	ldr	r3, [sp, #20]
  205e16:	429a      	cmp	r2, r3
  205e18:	d20d      	bcs.n	205e36 <pipe_read+0x66>
    memcpy((void *)bp, (void *)pp->rdptr, n);
  205e1a:	9b03      	ldr	r3, [sp, #12]
  205e1c:	68db      	ldr	r3, [r3, #12]
  205e1e:	9a01      	ldr	r2, [sp, #4]
  205e20:	4619      	mov	r1, r3
  205e22:	9802      	ldr	r0, [sp, #8]
  205e24:	f7fa fb5e 	bl	2004e4 <memcpy>
    pp->rdptr += n;
  205e28:	9b03      	ldr	r3, [sp, #12]
  205e2a:	68da      	ldr	r2, [r3, #12]
  205e2c:	9b01      	ldr	r3, [sp, #4]
  205e2e:	441a      	add	r2, r3
  205e30:	9b03      	ldr	r3, [sp, #12]
  205e32:	60da      	str	r2, [r3, #12]
  205e34:	e02b      	b.n	205e8e <pipe_read+0xbe>
  }
  else if (n > s1) {
  205e36:	9a01      	ldr	r2, [sp, #4]
  205e38:	9b05      	ldr	r3, [sp, #20]
  205e3a:	429a      	cmp	r2, r3
  205e3c:	d91c      	bls.n	205e78 <pipe_read+0xa8>
    memcpy((void *)bp, (void *)pp->rdptr, s1);
  205e3e:	9b03      	ldr	r3, [sp, #12]
  205e40:	68db      	ldr	r3, [r3, #12]
  205e42:	9a05      	ldr	r2, [sp, #20]
  205e44:	4619      	mov	r1, r3
  205e46:	9802      	ldr	r0, [sp, #8]
  205e48:	f7fa fb4c 	bl	2004e4 <memcpy>
    bp += s1;
  205e4c:	9a02      	ldr	r2, [sp, #8]
  205e4e:	9b05      	ldr	r3, [sp, #20]
  205e50:	4413      	add	r3, r2
  205e52:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
  205e54:	9a01      	ldr	r2, [sp, #4]
  205e56:	9b05      	ldr	r3, [sp, #20]
  205e58:	1ad3      	subs	r3, r2, r3
  205e5a:	9304      	str	r3, [sp, #16]
    memcpy((void *)bp, (void *)pp->buffer, s2);
  205e5c:	9b03      	ldr	r3, [sp, #12]
  205e5e:	681b      	ldr	r3, [r3, #0]
  205e60:	9a04      	ldr	r2, [sp, #16]
  205e62:	4619      	mov	r1, r3
  205e64:	9802      	ldr	r0, [sp, #8]
  205e66:	f7fa fb3d 	bl	2004e4 <memcpy>
    pp->rdptr = pp->buffer + s2;
  205e6a:	9b03      	ldr	r3, [sp, #12]
  205e6c:	681a      	ldr	r2, [r3, #0]
  205e6e:	9b04      	ldr	r3, [sp, #16]
  205e70:	441a      	add	r2, r3
  205e72:	9b03      	ldr	r3, [sp, #12]
  205e74:	60da      	str	r2, [r3, #12]
  205e76:	e00a      	b.n	205e8e <pipe_read+0xbe>
  }
  else {
    memcpy((void *)bp, (void *)pp->rdptr, n);
  205e78:	9b03      	ldr	r3, [sp, #12]
  205e7a:	68db      	ldr	r3, [r3, #12]
  205e7c:	9a01      	ldr	r2, [sp, #4]
  205e7e:	4619      	mov	r1, r3
  205e80:	9802      	ldr	r0, [sp, #8]
  205e82:	f7fa fb2f 	bl	2004e4 <memcpy>
    pp->rdptr = pp->buffer;
  205e86:	9b03      	ldr	r3, [sp, #12]
  205e88:	681a      	ldr	r2, [r3, #0]
  205e8a:	9b03      	ldr	r3, [sp, #12]
  205e8c:	60da      	str	r2, [r3, #12]
  }

  PC_UNLOCK(pp);
  205e8e:	9b03      	ldr	r3, [sp, #12]
  205e90:	3320      	adds	r3, #32
  205e92:	4618      	mov	r0, r3
  205e94:	f7fe f8ac 	bl	203ff0 <chMtxUnlock>

  return n;
  205e98:	9b01      	ldr	r3, [sp, #4]
}
  205e9a:	4618      	mov	r0, r3
  205e9c:	b007      	add	sp, #28
  205e9e:	f85d fb04 	ldr.w	pc, [sp], #4
  205ea2:	bf00      	nop
	...

00205eb0 <chPipeObjectInit>:
 * @param[in] buf       pointer to the pipe buffer as an array of @p uint8_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chPipeObjectInit(pipe_t *pp, uint8_t *buf, size_t n) {
  205eb0:	b500      	push	{lr}
  205eb2:	b085      	sub	sp, #20
  205eb4:	9003      	str	r0, [sp, #12]
  205eb6:	9102      	str	r1, [sp, #8]
  205eb8:	9201      	str	r2, [sp, #4]

  chDbgCheck((pp != NULL) && (buf != NULL) && (n > (size_t)0));

  pp->buffer = buf;
  205eba:	9b03      	ldr	r3, [sp, #12]
  205ebc:	9a02      	ldr	r2, [sp, #8]
  205ebe:	601a      	str	r2, [r3, #0]
  pp->rdptr  = buf;
  205ec0:	9b03      	ldr	r3, [sp, #12]
  205ec2:	9a02      	ldr	r2, [sp, #8]
  205ec4:	60da      	str	r2, [r3, #12]
  pp->wrptr  = buf;
  205ec6:	9b03      	ldr	r3, [sp, #12]
  205ec8:	9a02      	ldr	r2, [sp, #8]
  205eca:	609a      	str	r2, [r3, #8]
  pp->top    = &buf[n];
  205ecc:	9a02      	ldr	r2, [sp, #8]
  205ece:	9b01      	ldr	r3, [sp, #4]
  205ed0:	441a      	add	r2, r3
  205ed2:	9b03      	ldr	r3, [sp, #12]
  205ed4:	605a      	str	r2, [r3, #4]
  pp->cnt    = (size_t)0;
  205ed6:	9b03      	ldr	r3, [sp, #12]
  205ed8:	2200      	movs	r2, #0
  205eda:	611a      	str	r2, [r3, #16]
  pp->reset  = false;
  205edc:	9b03      	ldr	r3, [sp, #12]
  205ede:	2200      	movs	r2, #0
  205ee0:	751a      	strb	r2, [r3, #20]
  pp->wtr    = NULL;
  205ee2:	9b03      	ldr	r3, [sp, #12]
  205ee4:	2200      	movs	r2, #0
  205ee6:	619a      	str	r2, [r3, #24]
  pp->rtr    = NULL;
  205ee8:	9b03      	ldr	r3, [sp, #12]
  205eea:	2200      	movs	r2, #0
  205eec:	61da      	str	r2, [r3, #28]
  PC_INIT(pp);
  205eee:	9b03      	ldr	r3, [sp, #12]
  205ef0:	3320      	adds	r3, #32
  205ef2:	4618      	mov	r0, r3
  205ef4:	f7fd ffbc 	bl	203e70 <chMtxObjectInit>
  PW_INIT(pp);
  205ef8:	9b03      	ldr	r3, [sp, #12]
  205efa:	3330      	adds	r3, #48	@ 0x30
  205efc:	4618      	mov	r0, r3
  205efe:	f7fd ffb7 	bl	203e70 <chMtxObjectInit>
  PR_INIT(pp);
  205f02:	9b03      	ldr	r3, [sp, #12]
  205f04:	3340      	adds	r3, #64	@ 0x40
  205f06:	4618      	mov	r0, r3
  205f08:	f7fd ffb2 	bl	203e70 <chMtxObjectInit>
}
  205f0c:	bf00      	nop
  205f0e:	b005      	add	sp, #20
  205f10:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00205f20 <chPipeReset>:
 *
 * @param[in] pp        pointer to an initialized @p pipe_t object
 *
 * @api
 */
void chPipeReset(pipe_t *pp) {
  205f20:	b500      	push	{lr}
  205f22:	b083      	sub	sp, #12
  205f24:	9001      	str	r0, [sp, #4]

  chDbgCheck(pp != NULL);

  PC_LOCK(pp);
  205f26:	9b01      	ldr	r3, [sp, #4]
  205f28:	3320      	adds	r3, #32
  205f2a:	4618      	mov	r0, r3
  205f2c:	f7fd ffb0 	bl	203e90 <chMtxLock>

  pp->wrptr = pp->buffer;
  205f30:	9b01      	ldr	r3, [sp, #4]
  205f32:	681a      	ldr	r2, [r3, #0]
  205f34:	9b01      	ldr	r3, [sp, #4]
  205f36:	609a      	str	r2, [r3, #8]
  pp->rdptr = pp->buffer;
  205f38:	9b01      	ldr	r3, [sp, #4]
  205f3a:	681a      	ldr	r2, [r3, #0]
  205f3c:	9b01      	ldr	r3, [sp, #4]
  205f3e:	60da      	str	r2, [r3, #12]
  pp->cnt   = (size_t)0;
  205f40:	9b01      	ldr	r3, [sp, #4]
  205f42:	2200      	movs	r2, #0
  205f44:	611a      	str	r2, [r3, #16]
  pp->reset = true;
  205f46:	9b01      	ldr	r3, [sp, #4]
  205f48:	2201      	movs	r2, #1
  205f4a:	751a      	strb	r2, [r3, #20]

  chSysLock();
  205f4c:	f7ff fe88 	bl	205c60 <chSysLock.lto_priv.15>
  chThdResumeI(&pp->wtr, MSG_RESET);
  205f50:	9b01      	ldr	r3, [sp, #4]
  205f52:	3318      	adds	r3, #24
  205f54:	f06f 0101 	mvn.w	r1, #1
  205f58:	4618      	mov	r0, r3
  205f5a:	f7fd fbb1 	bl	2036c0 <chThdResumeI>
  chThdResumeI(&pp->rtr, MSG_RESET);
  205f5e:	9b01      	ldr	r3, [sp, #4]
  205f60:	331c      	adds	r3, #28
  205f62:	f06f 0101 	mvn.w	r1, #1
  205f66:	4618      	mov	r0, r3
  205f68:	f7fd fbaa 	bl	2036c0 <chThdResumeI>
  chSchRescheduleS();
  205f6c:	f7fc fe80 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  205f70:	f7ff fe86 	bl	205c80 <chSysUnlock.lto_priv.15>

  PC_UNLOCK(pp);
  205f74:	9b01      	ldr	r3, [sp, #4]
  205f76:	3320      	adds	r3, #32
  205f78:	4618      	mov	r0, r3
  205f7a:	f7fe f839 	bl	203ff0 <chMtxUnlock>
}
  205f7e:	bf00      	nop
  205f80:	b003      	add	sp, #12
  205f82:	f85d fb04 	ldr.w	pc, [sp], #4
  205f86:	bf00      	nop
	...

00205f90 <chPipeWriteTimeout>:
 *                      pipe went in reset state.
 *
 * @api
 */
size_t chPipeWriteTimeout(pipe_t *pp, const uint8_t *bp,
                          size_t n, sysinterval_t timeout) {
  205f90:	b500      	push	{lr}
  205f92:	b089      	sub	sp, #36	@ 0x24
  205f94:	9003      	str	r0, [sp, #12]
  205f96:	9102      	str	r1, [sp, #8]
  205f98:	9201      	str	r2, [sp, #4]
  205f9a:	9300      	str	r3, [sp, #0]
  size_t max = n;
  205f9c:	9b01      	ldr	r3, [sp, #4]
  205f9e:	9307      	str	r3, [sp, #28]

  chDbgCheck(n > 0U);

  /* If the pipe is in reset state then returns immediately.*/
  if (pp->reset) {
  205fa0:	9b03      	ldr	r3, [sp, #12]
  205fa2:	7d1b      	ldrb	r3, [r3, #20]
  205fa4:	2b00      	cmp	r3, #0
  205fa6:	d001      	beq.n	205fac <chPipeWriteTimeout+0x1c>
    return (size_t)0;
  205fa8:	2300      	movs	r3, #0
  205faa:	e036      	b.n	20601a <chPipeWriteTimeout+0x8a>
  }

  PW_LOCK(pp);
  205fac:	9b03      	ldr	r3, [sp, #12]
  205fae:	3330      	adds	r3, #48	@ 0x30
  205fb0:	4618      	mov	r0, r3
  205fb2:	f7fd ff6d 	bl	203e90 <chMtxLock>

  while (n > 0U) {
  205fb6:	e025      	b.n	206004 <chPipeWriteTimeout+0x74>
    size_t done;

    done = pipe_write(pp, bp, n);
  205fb8:	9a01      	ldr	r2, [sp, #4]
  205fba:	9902      	ldr	r1, [sp, #8]
  205fbc:	9803      	ldr	r0, [sp, #12]
  205fbe:	f7ff fe97 	bl	205cf0 <pipe_write>
  205fc2:	9006      	str	r0, [sp, #24]
    if (done == (size_t)0) {
  205fc4:	9b06      	ldr	r3, [sp, #24]
  205fc6:	2b00      	cmp	r3, #0
  205fc8:	d10e      	bne.n	205fe8 <chPipeWriteTimeout+0x58>
      msg_t msg;

      chSysLock();
  205fca:	f7ff fe49 	bl	205c60 <chSysLock.lto_priv.15>
      msg = chThdSuspendTimeoutS(&pp->wtr, timeout);
  205fce:	9b03      	ldr	r3, [sp, #12]
  205fd0:	3318      	adds	r3, #24
  205fd2:	9900      	ldr	r1, [sp, #0]
  205fd4:	4618      	mov	r0, r3
  205fd6:	f7fd fb4b 	bl	203670 <chThdSuspendTimeoutS>
  205fda:	9005      	str	r0, [sp, #20]
      chSysUnlock();
  205fdc:	f7ff fe50 	bl	205c80 <chSysUnlock.lto_priv.15>

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
  205fe0:	9b05      	ldr	r3, [sp, #20]
  205fe2:	2b00      	cmp	r3, #0
  205fe4:	d00e      	beq.n	206004 <chPipeWriteTimeout+0x74>
        break;
  205fe6:	e010      	b.n	20600a <chPipeWriteTimeout+0x7a>
      }
    }
    else {
      n  -= done;
  205fe8:	9a01      	ldr	r2, [sp, #4]
  205fea:	9b06      	ldr	r3, [sp, #24]
  205fec:	1ad3      	subs	r3, r2, r3
  205fee:	9301      	str	r3, [sp, #4]
      bp += done;
  205ff0:	9a02      	ldr	r2, [sp, #8]
  205ff2:	9b06      	ldr	r3, [sp, #24]
  205ff4:	4413      	add	r3, r2
  205ff6:	9302      	str	r3, [sp, #8]

      /* Resuming the reader, if present.*/
      chThdResume(&pp->rtr, MSG_OK);
  205ff8:	9b03      	ldr	r3, [sp, #12]
  205ffa:	331c      	adds	r3, #28
  205ffc:	2100      	movs	r1, #0
  205ffe:	4618      	mov	r0, r3
  206000:	f7fd fb8e 	bl	203720 <chThdResume>
  while (n > 0U) {
  206004:	9b01      	ldr	r3, [sp, #4]
  206006:	2b00      	cmp	r3, #0
  206008:	d1d6      	bne.n	205fb8 <chPipeWriteTimeout+0x28>
    }
  }

  PW_UNLOCK(pp);
  20600a:	9b03      	ldr	r3, [sp, #12]
  20600c:	3330      	adds	r3, #48	@ 0x30
  20600e:	4618      	mov	r0, r3
  206010:	f7fd ffee 	bl	203ff0 <chMtxUnlock>

  return max - n;
  206014:	9a07      	ldr	r2, [sp, #28]
  206016:	9b01      	ldr	r3, [sp, #4]
  206018:	1ad3      	subs	r3, r2, r3
}
  20601a:	4618      	mov	r0, r3
  20601c:	b009      	add	sp, #36	@ 0x24
  20601e:	f85d fb04 	ldr.w	pc, [sp], #4
  206022:	bf00      	nop
	...

00206030 <chPipeReadTimeout>:
 *                      pipe went in reset state.
 *
 * @api
 */
size_t chPipeReadTimeout(pipe_t *pp, uint8_t *bp,
                         size_t n, sysinterval_t timeout) {
  206030:	b500      	push	{lr}
  206032:	b089      	sub	sp, #36	@ 0x24
  206034:	9003      	str	r0, [sp, #12]
  206036:	9102      	str	r1, [sp, #8]
  206038:	9201      	str	r2, [sp, #4]
  20603a:	9300      	str	r3, [sp, #0]
  size_t max = n;
  20603c:	9b01      	ldr	r3, [sp, #4]
  20603e:	9307      	str	r3, [sp, #28]

  chDbgCheck(n > 0U);

  /* If the pipe is in reset state then returns immediately.*/
  if (pp->reset) {
  206040:	9b03      	ldr	r3, [sp, #12]
  206042:	7d1b      	ldrb	r3, [r3, #20]
  206044:	2b00      	cmp	r3, #0
  206046:	d001      	beq.n	20604c <chPipeReadTimeout+0x1c>
    return (size_t)0;
  206048:	2300      	movs	r3, #0
  20604a:	e036      	b.n	2060ba <chPipeReadTimeout+0x8a>
  }

  PR_LOCK(pp);
  20604c:	9b03      	ldr	r3, [sp, #12]
  20604e:	3340      	adds	r3, #64	@ 0x40
  206050:	4618      	mov	r0, r3
  206052:	f7fd ff1d 	bl	203e90 <chMtxLock>

  while (n > 0U) {
  206056:	e025      	b.n	2060a4 <chPipeReadTimeout+0x74>
    size_t done;

    done = pipe_read(pp, bp, n);
  206058:	9a01      	ldr	r2, [sp, #4]
  20605a:	9902      	ldr	r1, [sp, #8]
  20605c:	9803      	ldr	r0, [sp, #12]
  20605e:	f7ff feb7 	bl	205dd0 <pipe_read>
  206062:	9006      	str	r0, [sp, #24]
    if (done == (size_t)0) {
  206064:	9b06      	ldr	r3, [sp, #24]
  206066:	2b00      	cmp	r3, #0
  206068:	d10e      	bne.n	206088 <chPipeReadTimeout+0x58>
      msg_t msg;

      chSysLock();
  20606a:	f7ff fdf9 	bl	205c60 <chSysLock.lto_priv.15>
      msg = chThdSuspendTimeoutS(&pp->rtr, timeout);
  20606e:	9b03      	ldr	r3, [sp, #12]
  206070:	331c      	adds	r3, #28
  206072:	9900      	ldr	r1, [sp, #0]
  206074:	4618      	mov	r0, r3
  206076:	f7fd fafb 	bl	203670 <chThdSuspendTimeoutS>
  20607a:	9005      	str	r0, [sp, #20]
      chSysUnlock();
  20607c:	f7ff fe00 	bl	205c80 <chSysUnlock.lto_priv.15>

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
  206080:	9b05      	ldr	r3, [sp, #20]
  206082:	2b00      	cmp	r3, #0
  206084:	d00e      	beq.n	2060a4 <chPipeReadTimeout+0x74>
        break;
  206086:	e010      	b.n	2060aa <chPipeReadTimeout+0x7a>
      }
    }
    else {
      n  -= done;
  206088:	9a01      	ldr	r2, [sp, #4]
  20608a:	9b06      	ldr	r3, [sp, #24]
  20608c:	1ad3      	subs	r3, r2, r3
  20608e:	9301      	str	r3, [sp, #4]
      bp += done;
  206090:	9a02      	ldr	r2, [sp, #8]
  206092:	9b06      	ldr	r3, [sp, #24]
  206094:	4413      	add	r3, r2
  206096:	9302      	str	r3, [sp, #8]

      /* Resuming the writer, if present.*/
      chThdResume(&pp->wtr, MSG_OK);
  206098:	9b03      	ldr	r3, [sp, #12]
  20609a:	3318      	adds	r3, #24
  20609c:	2100      	movs	r1, #0
  20609e:	4618      	mov	r0, r3
  2060a0:	f7fd fb3e 	bl	203720 <chThdResume>
  while (n > 0U) {
  2060a4:	9b01      	ldr	r3, [sp, #4]
  2060a6:	2b00      	cmp	r3, #0
  2060a8:	d1d6      	bne.n	206058 <chPipeReadTimeout+0x28>
    }
  }

  PR_UNLOCK(pp);
  2060aa:	9b03      	ldr	r3, [sp, #12]
  2060ac:	3340      	adds	r3, #64	@ 0x40
  2060ae:	4618      	mov	r0, r3
  2060b0:	f7fd ff9e 	bl	203ff0 <chMtxUnlock>

  return max - n;
  2060b4:	9a07      	ldr	r2, [sp, #28]
  2060b6:	9b01      	ldr	r3, [sp, #4]
  2060b8:	1ad3      	subs	r3, r2, r3
}
  2060ba:	4618      	mov	r0, r3
  2060bc:	b009      	add	sp, #36	@ 0x24
  2060be:	f85d fb04 	ldr.w	pc, [sp], #4
  2060c2:	bf00      	nop
	...

002060d0 <chSysLock.lto_priv.16>:
static inline void chSysLock(void) {
  2060d0:	b082      	sub	sp, #8
  2060d2:	2330      	movs	r3, #48	@ 0x30
  2060d4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2060d6:	9b01      	ldr	r3, [sp, #4]
  2060d8:	f383 8811 	msr	BASEPRI, r3
}
  2060dc:	bf00      	nop
}
  2060de:	bf00      	nop
}
  2060e0:	bf00      	nop
  2060e2:	b002      	add	sp, #8
  2060e4:	4770      	bx	lr
  2060e6:	bf00      	nop
	...

002060f0 <chSysUnlock.lto_priv.16>:
static inline void chSysUnlock(void) {
  2060f0:	b082      	sub	sp, #8
  2060f2:	2300      	movs	r3, #0
  2060f4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2060f6:	9b01      	ldr	r3, [sp, #4]
  2060f8:	f383 8811 	msr	BASEPRI, r3
}
  2060fc:	bf00      	nop
}
  2060fe:	bf00      	nop
}
  206100:	bf00      	nop
  206102:	b002      	add	sp, #8
  206104:	4770      	bx	lr
  206106:	bf00      	nop
	...

00206110 <chSemFastWaitI>:
static inline void chSemFastWaitI(semaphore_t *sp) {
  206110:	b082      	sub	sp, #8
  206112:	9001      	str	r0, [sp, #4]
  sp->cnt--;
  206114:	9b01      	ldr	r3, [sp, #4]
  206116:	689b      	ldr	r3, [r3, #8]
  206118:	1e5a      	subs	r2, r3, #1
  20611a:	9b01      	ldr	r3, [sp, #4]
  20611c:	609a      	str	r2, [r3, #8]
}
  20611e:	bf00      	nop
  206120:	b002      	add	sp, #8
  206122:	4770      	bx	lr
	...

00206130 <chSemFastSignalI.lto_priv.1>:
static inline void chSemFastSignalI(semaphore_t *sp) {
  206130:	b082      	sub	sp, #8
  206132:	9001      	str	r0, [sp, #4]
  sp->cnt++;
  206134:	9b01      	ldr	r3, [sp, #4]
  206136:	689b      	ldr	r3, [r3, #8]
  206138:	1c5a      	adds	r2, r3, #1
  20613a:	9b01      	ldr	r3, [sp, #4]
  20613c:	609a      	str	r2, [r3, #8]
}
  20613e:	bf00      	nop
  206140:	b002      	add	sp, #8
  206142:	4770      	bx	lr
	...

00206150 <chSemGetCounterI.lto_priv.0>:
 * @param[in] sp        pointer to a @p semaphore_t object
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(const semaphore_t *sp) {
  206150:	b082      	sub	sp, #8
  206152:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->cnt;
  206154:	9b01      	ldr	r3, [sp, #4]
  206156:	689b      	ldr	r3, [r3, #8]
}
  206158:	4618      	mov	r0, r3
  20615a:	b002      	add	sp, #8
  20615c:	4770      	bx	lr
  20615e:	bf00      	nop

00206160 <hash_get_s>:
 *
 * @notapi
 */
static oc_object_t *hash_get_s(objects_cache_t *ocp,
                               void *owner,
                               uint32_t key) {
  206160:	b088      	sub	sp, #32
  206162:	9003      	str	r0, [sp, #12]
  206164:	9102      	str	r1, [sp, #8]
  206166:	9201      	str	r2, [sp, #4]
  oc_hash_element_t *hep, *p;

  /* Hash slot where to search for an hit.*/
  hep  = &ocp->hashp[OC_HASH_FUNCTION(ocp, owner, key)];
  206168:	9b03      	ldr	r3, [sp, #12]
  20616a:	685a      	ldr	r2, [r3, #4]
  20616c:	9902      	ldr	r1, [sp, #8]
  20616e:	9b01      	ldr	r3, [sp, #4]
  206170:	4419      	add	r1, r3
  206172:	9b03      	ldr	r3, [sp, #12]
  206174:	681b      	ldr	r3, [r3, #0]
  206176:	3b01      	subs	r3, #1
  206178:	400b      	ands	r3, r1
  20617a:	00db      	lsls	r3, r3, #3
  20617c:	4413      	add	r3, r2
  20617e:	9306      	str	r3, [sp, #24]

  /* Scanning the siblings collision list.*/
  p = hep->next;
  206180:	9b06      	ldr	r3, [sp, #24]
  206182:	681b      	ldr	r3, [r3, #0]
  206184:	9307      	str	r3, [sp, #28]
  while (p != hep) {
  206186:	e010      	b.n	2061aa <hash_get_s+0x4a>
    oc_object_t *objp = (oc_object_t *)(void *)p;
  206188:	9b07      	ldr	r3, [sp, #28]
  20618a:	9305      	str	r3, [sp, #20]
    if ((objp->obj_owner == owner) && (objp->obj_key == key)) {
  20618c:	9b05      	ldr	r3, [sp, #20]
  20618e:	691b      	ldr	r3, [r3, #16]
  206190:	9a02      	ldr	r2, [sp, #8]
  206192:	429a      	cmp	r2, r3
  206194:	d106      	bne.n	2061a4 <hash_get_s+0x44>
  206196:	9b05      	ldr	r3, [sp, #20]
  206198:	695b      	ldr	r3, [r3, #20]
  20619a:	9a01      	ldr	r2, [sp, #4]
  20619c:	429a      	cmp	r2, r3
  20619e:	d101      	bne.n	2061a4 <hash_get_s+0x44>

      /* Cache hit.*/
      return objp;
  2061a0:	9b05      	ldr	r3, [sp, #20]
  2061a2:	e007      	b.n	2061b4 <hash_get_s+0x54>
    }
    p = p->next;
  2061a4:	9b07      	ldr	r3, [sp, #28]
  2061a6:	681b      	ldr	r3, [r3, #0]
  2061a8:	9307      	str	r3, [sp, #28]
  while (p != hep) {
  2061aa:	9a07      	ldr	r2, [sp, #28]
  2061ac:	9b06      	ldr	r3, [sp, #24]
  2061ae:	429a      	cmp	r2, r3
  2061b0:	d1ea      	bne.n	206188 <hash_get_s+0x28>
  }

  return NULL;
  2061b2:	2300      	movs	r3, #0
}
  2061b4:	4618      	mov	r0, r3
  2061b6:	b008      	add	sp, #32
  2061b8:	4770      	bx	lr
  2061ba:	bf00      	nop
  2061bc:	0000      	movs	r0, r0
	...

002061c0 <lru_get_last_s>:
 * @param[out] ocp      pointer to the @p objects_cache_t object to be
 * @return              The pointer to the retrieved object.
 *
 * @notapi
 */
static oc_object_t *lru_get_last_s(objects_cache_t *ocp) {
  2061c0:	b500      	push	{lr}
  2061c2:	b085      	sub	sp, #20
  2061c4:	9001      	str	r0, [sp, #4]
  oc_object_t *objp;

  while (true) {
    /* Waiting for an object buffer to become available in the LRU.*/
    (void) chSemWaitS(&ocp->lru_sem);
  2061c6:	9b01      	ldr	r3, [sp, #4]
  2061c8:	3330      	adds	r3, #48	@ 0x30
  2061ca:	4618      	mov	r0, r3
  2061cc:	f7fd fc80 	bl	203ad0 <chSemWaitS>

    /* Now an object buffer is in the LRU for sure, taking it from the
       LRU tail.*/
    objp = (oc_object_t *)(void *)ocp->list.prev;
  2061d0:	9b01      	ldr	r3, [sp, #4]
  2061d2:	6a1b      	ldr	r3, [r3, #32]
  2061d4:	9303      	str	r3, [sp, #12]
    chDbgAssert((objp->obj_flags & OC_FLAG_INLRU) == OC_FLAG_INLRU,
                "not in LRU");
    chDbgAssert(chSemGetCounterI(&objp->obj_sem) == (cnt_t)1,
                "semaphore counter not 1");

    LRU_REMOVE(objp);
  2061d6:	9b03      	ldr	r3, [sp, #12]
  2061d8:	68db      	ldr	r3, [r3, #12]
  2061da:	9a03      	ldr	r2, [sp, #12]
  2061dc:	6892      	ldr	r2, [r2, #8]
  2061de:	609a      	str	r2, [r3, #8]
  2061e0:	9b03      	ldr	r3, [sp, #12]
  2061e2:	689b      	ldr	r3, [r3, #8]
  2061e4:	9a03      	ldr	r2, [sp, #12]
  2061e6:	68d2      	ldr	r2, [r2, #12]
  2061e8:	60da      	str	r2, [r3, #12]
    objp->obj_flags &= ~OC_FLAG_INLRU;
  2061ea:	9b03      	ldr	r3, [sp, #12]
  2061ec:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  2061ee:	f023 0201 	bic.w	r2, r3, #1
  2061f2:	9b03      	ldr	r3, [sp, #12]
  2061f4:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Getting the object semaphore, we know there is no wait so
       using the "fast" variant.*/
    chSemFastWaitI(&objp->obj_sem);
  2061f6:	9b03      	ldr	r3, [sp, #12]
  2061f8:	3318      	adds	r3, #24
  2061fa:	4618      	mov	r0, r3
  2061fc:	f7ff ff88 	bl	206110 <chSemFastWaitI>

    /* If it is a buffer not needing (lazy) write then it can be used
       right away.*/
    if ((objp->obj_flags & OC_FLAG_LAZYWRITE) == 0U) {
  206200:	9b03      	ldr	r3, [sp, #12]
  206202:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  206204:	f003 0310 	and.w	r3, r3, #16
  206208:	2b00      	cmp	r3, #0
  20620a:	d114      	bne.n	206236 <lru_get_last_s+0x76>

      /* Removing from hash table if required.*/
      if ((objp->obj_flags & OC_FLAG_INHASH) != 0U) {
  20620c:	9b03      	ldr	r3, [sp, #12]
  20620e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  206210:	f003 0302 	and.w	r3, r3, #2
  206214:	2b00      	cmp	r3, #0
  206216:	d009      	beq.n	20622c <lru_get_last_s+0x6c>
        HASH_REMOVE(objp);
  206218:	9b03      	ldr	r3, [sp, #12]
  20621a:	685b      	ldr	r3, [r3, #4]
  20621c:	9a03      	ldr	r2, [sp, #12]
  20621e:	6812      	ldr	r2, [r2, #0]
  206220:	601a      	str	r2, [r3, #0]
  206222:	9b03      	ldr	r3, [sp, #12]
  206224:	681b      	ldr	r3, [r3, #0]
  206226:	9a03      	ldr	r2, [sp, #12]
  206228:	6852      	ldr	r2, [r2, #4]
  20622a:	605a      	str	r2, [r3, #4]
      }

      /* Removing all flags, it is "new" now.*/
      objp->obj_flags = 0U;
  20622c:	9b03      	ldr	r3, [sp, #12]
  20622e:	2200      	movs	r2, #0
  206230:	625a      	str	r2, [r3, #36]	@ 0x24

      return objp;
  206232:	9b03      	ldr	r3, [sp, #12]
  206234:	e00d      	b.n	206252 <lru_get_last_s+0x92>
    }

    /* Out of critical section.*/
    chSysUnlock();
  206236:	f7ff ff5b 	bl	2060f0 <chSysUnlock.lto_priv.16>

   /* Invoking the writer asynchronously, it will release the buffer once it
      is written. It is responsibility of the write function to release
      the buffer.*/
    objp->obj_flags = OC_FLAG_INHASH | OC_FLAG_FORGET;
  20623a:	9b03      	ldr	r3, [sp, #12]
  20623c:	2222      	movs	r2, #34	@ 0x22
  20623e:	625a      	str	r2, [r3, #36]	@ 0x24
    (void) ocp->writef(ocp, objp, true);
  206240:	9b01      	ldr	r3, [sp, #4]
  206242:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
  206244:	2201      	movs	r2, #1
  206246:	9903      	ldr	r1, [sp, #12]
  206248:	9801      	ldr	r0, [sp, #4]
  20624a:	4798      	blx	r3

    /* Critical section enter again.*/
    chSysLock();
  20624c:	f7ff ff40 	bl	2060d0 <chSysLock.lto_priv.16>
    (void) chSemWaitS(&ocp->lru_sem);
  206250:	e7b9      	b.n	2061c6 <lru_get_last_s+0x6>
  }
}
  206252:	4618      	mov	r0, r3
  206254:	b005      	add	sp, #20
  206256:	f85d fb04 	ldr.w	pc, [sp], #4
  20625a:	bf00      	nop
  20625c:	0000      	movs	r0, r0
	...

00206260 <chCacheObjectInit>:
                       oc_hash_element_t *hashp,
                       ucnt_t objn,
                       size_t objsz,
                       void *objvp,
                       oc_readf_t readf,
                       oc_writef_t writef) {
  206260:	b500      	push	{lr}
  206262:	b087      	sub	sp, #28
  206264:	9003      	str	r0, [sp, #12]
  206266:	9102      	str	r1, [sp, #8]
  206268:	9201      	str	r2, [sp, #4]
  20626a:	9300      	str	r3, [sp, #0]
             ((hashn & (hashn - (ucnt_t)1)) == (ucnt_t)0) &&
             (objn > (ucnt_t)0) && (hashn >= objn) &&
             (objsz >= sizeof (oc_object_t)) &&
             ((objsz & (PORT_NATURAL_ALIGN - 1U)) == 0U));

  chSemObjectInit(&ocp->cache_sem, (cnt_t)1);
  20626c:	9b03      	ldr	r3, [sp, #12]
  20626e:	3324      	adds	r3, #36	@ 0x24
  206270:	2101      	movs	r1, #1
  206272:	4618      	mov	r0, r3
  206274:	f7fd fbd4 	bl	203a20 <chSemObjectInit>
  chSemObjectInit(&ocp->lru_sem, (cnt_t)objn);
  206278:	9b03      	ldr	r3, [sp, #12]
  20627a:	3330      	adds	r3, #48	@ 0x30
  20627c:	9a00      	ldr	r2, [sp, #0]
  20627e:	4611      	mov	r1, r2
  206280:	4618      	mov	r0, r3
  206282:	f7fd fbcd 	bl	203a20 <chSemObjectInit>
  ocp->hashn            = hashn;
  206286:	9b03      	ldr	r3, [sp, #12]
  206288:	9a02      	ldr	r2, [sp, #8]
  20628a:	601a      	str	r2, [r3, #0]
  ocp->hashp            = hashp;
  20628c:	9b03      	ldr	r3, [sp, #12]
  20628e:	9a01      	ldr	r2, [sp, #4]
  206290:	605a      	str	r2, [r3, #4]
  ocp->objn             = objn;
  206292:	9b03      	ldr	r3, [sp, #12]
  206294:	9a00      	ldr	r2, [sp, #0]
  206296:	609a      	str	r2, [r3, #8]
  ocp->objvp            = objvp;
  206298:	9b03      	ldr	r3, [sp, #12]
  20629a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  20629c:	611a      	str	r2, [r3, #16]
  ocp->readf            = readf;
  20629e:	9b03      	ldr	r3, [sp, #12]
  2062a0:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
  2062a2:	63da      	str	r2, [r3, #60]	@ 0x3c
  ocp->writef           = writef;
  2062a4:	9b03      	ldr	r3, [sp, #12]
  2062a6:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
  2062a8:	641a      	str	r2, [r3, #64]	@ 0x40
  ocp->list.h.next      = NULL;
  2062aa:	9b03      	ldr	r3, [sp, #12]
  2062ac:	2200      	movs	r2, #0
  2062ae:	615a      	str	r2, [r3, #20]
  ocp->list.h.prev      = NULL;
  2062b0:	9b03      	ldr	r3, [sp, #12]
  2062b2:	2200      	movs	r2, #0
  2062b4:	619a      	str	r2, [r3, #24]
  ocp->list.next        = &ocp->list;
  2062b6:	9b03      	ldr	r3, [sp, #12]
  2062b8:	f103 0214 	add.w	r2, r3, #20
  2062bc:	9b03      	ldr	r3, [sp, #12]
  2062be:	61da      	str	r2, [r3, #28]
  ocp->list.prev        = &ocp->list;
  2062c0:	9b03      	ldr	r3, [sp, #12]
  2062c2:	f103 0214 	add.w	r2, r3, #20
  2062c6:	9b03      	ldr	r3, [sp, #12]
  2062c8:	621a      	str	r2, [r3, #32]

  /* Hash headers initialization.*/
  do {
    hashp->next = hashp;
  2062ca:	9b01      	ldr	r3, [sp, #4]
  2062cc:	9a01      	ldr	r2, [sp, #4]
  2062ce:	601a      	str	r2, [r3, #0]
    hashp->prev = hashp;
  2062d0:	9b01      	ldr	r3, [sp, #4]
  2062d2:	9a01      	ldr	r2, [sp, #4]
  2062d4:	605a      	str	r2, [r3, #4]
    hashp++;
  2062d6:	9b01      	ldr	r3, [sp, #4]
  2062d8:	3308      	adds	r3, #8
  2062da:	9301      	str	r3, [sp, #4]
  } while (hashp < &ocp->hashp[ocp->hashn]);
  2062dc:	9b03      	ldr	r3, [sp, #12]
  2062de:	685a      	ldr	r2, [r3, #4]
  2062e0:	9b03      	ldr	r3, [sp, #12]
  2062e2:	681b      	ldr	r3, [r3, #0]
  2062e4:	00db      	lsls	r3, r3, #3
  2062e6:	4413      	add	r3, r2
  2062e8:	9a01      	ldr	r2, [sp, #4]
  2062ea:	429a      	cmp	r2, r3
  2062ec:	d3ed      	bcc.n	2062ca <chCacheObjectInit+0x6a>

  /* Object headers initialization.*/
  do {
    oc_object_t *objp = (oc_object_t *)objvp;
  2062ee:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  2062f0:	9305      	str	r3, [sp, #20]

    chSemObjectInit(&objp->obj_sem, (cnt_t)1);
  2062f2:	9b05      	ldr	r3, [sp, #20]
  2062f4:	3318      	adds	r3, #24
  2062f6:	2101      	movs	r1, #1
  2062f8:	4618      	mov	r0, r3
  2062fa:	f7fd fb91 	bl	203a20 <chSemObjectInit>
    LRU_INSERT_HEAD(ocp, objp);
  2062fe:	9b03      	ldr	r3, [sp, #12]
  206300:	69da      	ldr	r2, [r3, #28]
  206302:	9b05      	ldr	r3, [sp, #20]
  206304:	609a      	str	r2, [r3, #8]
  206306:	9b03      	ldr	r3, [sp, #12]
  206308:	f103 0214 	add.w	r2, r3, #20
  20630c:	9b05      	ldr	r3, [sp, #20]
  20630e:	60da      	str	r2, [r3, #12]
  206310:	9b03      	ldr	r3, [sp, #12]
  206312:	69db      	ldr	r3, [r3, #28]
  206314:	9a05      	ldr	r2, [sp, #20]
  206316:	60da      	str	r2, [r3, #12]
  206318:	9a05      	ldr	r2, [sp, #20]
  20631a:	9b03      	ldr	r3, [sp, #12]
  20631c:	61da      	str	r2, [r3, #28]
    objp->obj_owner = NULL;
  20631e:	9b05      	ldr	r3, [sp, #20]
  206320:	2200      	movs	r2, #0
  206322:	611a      	str	r2, [r3, #16]
    objp->obj_key   = 0U;
  206324:	9b05      	ldr	r3, [sp, #20]
  206326:	2200      	movs	r2, #0
  206328:	615a      	str	r2, [r3, #20]
    objp->obj_flags = OC_FLAG_INLRU;
  20632a:	9b05      	ldr	r3, [sp, #20]
  20632c:	2201      	movs	r2, #1
  20632e:	625a      	str	r2, [r3, #36]	@ 0x24
    objp->dptr      = NULL;
  206330:	9b05      	ldr	r3, [sp, #20]
  206332:	2200      	movs	r2, #0
  206334:	629a      	str	r2, [r3, #40]	@ 0x28
    objvp = (void *)((uint8_t *)objvp + objsz);
  206336:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  206338:	9b08      	ldr	r3, [sp, #32]
  20633a:	4413      	add	r3, r2
  20633c:	9309      	str	r3, [sp, #36]	@ 0x24
    objn--;
  20633e:	9b00      	ldr	r3, [sp, #0]
  206340:	3b01      	subs	r3, #1
  206342:	9300      	str	r3, [sp, #0]
  } while (objn > (ucnt_t)0);
  206344:	9b00      	ldr	r3, [sp, #0]
  206346:	2b00      	cmp	r3, #0
  206348:	d1d1      	bne.n	2062ee <chCacheObjectInit+0x8e>
}
  20634a:	bf00      	nop
  20634c:	bf00      	nop
  20634e:	b007      	add	sp, #28
  206350:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00206360 <chCacheGetObject>:
 *
 * @api
 */
oc_object_t *chCacheGetObject(objects_cache_t *ocp,
                              void *owner,
                              uint32_t key) {
  206360:	b500      	push	{lr}
  206362:	b087      	sub	sp, #28
  206364:	9003      	str	r0, [sp, #12]
  206366:	9102      	str	r1, [sp, #8]
  206368:	9201      	str	r2, [sp, #4]
  oc_object_t *objp;

  /* Critical section enter, the hash check operation is fast.*/
  chSysLock();
  20636a:	f7ff feb1 	bl	2060d0 <chSysLock.lto_priv.16>

  /* Checking the cache for a hit.*/
  objp = hash_get_s(ocp, owner, key);
  20636e:	9a01      	ldr	r2, [sp, #4]
  206370:	9902      	ldr	r1, [sp, #8]
  206372:	9803      	ldr	r0, [sp, #12]
  206374:	f7ff fef4 	bl	206160 <hash_get_s>
  206378:	9005      	str	r0, [sp, #20]
  if (objp != NULL) {
  20637a:	9b05      	ldr	r3, [sp, #20]
  20637c:	2b00      	cmp	r3, #0
  20637e:	d023      	beq.n	2063c8 <chCacheGetObject+0x68>
    chDbgAssert((objp->obj_flags & OC_FLAG_INHASH) == OC_FLAG_INHASH,
                "not in hash");

    /* Cache hit, checking if the buffer is owned by some
       other thread.*/
    if (chSemGetCounterI(&objp->obj_sem) > (cnt_t)0) {
  206380:	9b05      	ldr	r3, [sp, #20]
  206382:	3318      	adds	r3, #24
  206384:	4618      	mov	r0, r3
  206386:	f7ff fee3 	bl	206150 <chSemGetCounterI.lto_priv.0>
  20638a:	4603      	mov	r3, r0
  20638c:	2b00      	cmp	r3, #0
  20638e:	dd15      	ble.n	2063bc <chCacheGetObject+0x5c>

      chDbgAssert((objp->obj_flags & OC_FLAG_INLRU) == OC_FLAG_INLRU,
                  "not in LRU");

      /* Removing the object from LRU, now it is "owned".*/
      LRU_REMOVE(objp);
  206390:	9b05      	ldr	r3, [sp, #20]
  206392:	68db      	ldr	r3, [r3, #12]
  206394:	9a05      	ldr	r2, [sp, #20]
  206396:	6892      	ldr	r2, [r2, #8]
  206398:	609a      	str	r2, [r3, #8]
  20639a:	9b05      	ldr	r3, [sp, #20]
  20639c:	689b      	ldr	r3, [r3, #8]
  20639e:	9a05      	ldr	r2, [sp, #20]
  2063a0:	68d2      	ldr	r2, [r2, #12]
  2063a2:	60da      	str	r2, [r3, #12]
      objp->obj_flags &= ~OC_FLAG_INLRU;
  2063a4:	9b05      	ldr	r3, [sp, #20]
  2063a6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  2063a8:	f023 0201 	bic.w	r2, r3, #1
  2063ac:	9b05      	ldr	r3, [sp, #20]
  2063ae:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Getting the object semaphore, we know there is no wait so
         using the "fast" variant.*/
      chSemFastWaitI(&objp->obj_sem);
  2063b0:	9b05      	ldr	r3, [sp, #20]
  2063b2:	3318      	adds	r3, #24
  2063b4:	4618      	mov	r0, r3
  2063b6:	f7ff feab 	bl	206110 <chSemFastWaitI>
  2063ba:	e02c      	b.n	206416 <chCacheGetObject+0xb6>
         need to wait.*/

      chDbgAssert((objp->obj_flags & OC_FLAG_INLRU) == 0U, "in LRU");

      /* Waiting on the buffer semaphore.*/
      (void) chSemWaitS(&objp->obj_sem);
  2063bc:	9b05      	ldr	r3, [sp, #20]
  2063be:	3318      	adds	r3, #24
  2063c0:	4618      	mov	r0, r3
  2063c2:	f7fd fb85 	bl	203ad0 <chSemWaitS>
  2063c6:	e026      	b.n	206416 <chCacheGetObject+0xb6>
    }
  }
  else {
    /* Cache miss, getting an object buffer from the LRU list.*/
    objp = lru_get_last_s(ocp);
  2063c8:	9803      	ldr	r0, [sp, #12]
  2063ca:	f7ff fef9 	bl	2061c0 <lru_get_last_s>
  2063ce:	9005      	str	r0, [sp, #20]

    /* Naming this object and publishing it in the hash table.*/
    objp->obj_owner = owner;
  2063d0:	9b05      	ldr	r3, [sp, #20]
  2063d2:	9a02      	ldr	r2, [sp, #8]
  2063d4:	611a      	str	r2, [r3, #16]
    objp->obj_key   = key;
  2063d6:	9b05      	ldr	r3, [sp, #20]
  2063d8:	9a01      	ldr	r2, [sp, #4]
  2063da:	615a      	str	r2, [r3, #20]
    objp->obj_flags = OC_FLAG_INHASH | OC_FLAG_NOTSYNC;
  2063dc:	9b05      	ldr	r3, [sp, #20]
  2063de:	220a      	movs	r2, #10
  2063e0:	625a      	str	r2, [r3, #36]	@ 0x24
    HASH_INSERT(ocp, objp, owner, key);
  2063e2:	9b03      	ldr	r3, [sp, #12]
  2063e4:	685a      	ldr	r2, [r3, #4]
  2063e6:	9902      	ldr	r1, [sp, #8]
  2063e8:	9b01      	ldr	r3, [sp, #4]
  2063ea:	4419      	add	r1, r3
  2063ec:	9b03      	ldr	r3, [sp, #12]
  2063ee:	681b      	ldr	r3, [r3, #0]
  2063f0:	3b01      	subs	r3, #1
  2063f2:	400b      	ands	r3, r1
  2063f4:	00db      	lsls	r3, r3, #3
  2063f6:	4413      	add	r3, r2
  2063f8:	9304      	str	r3, [sp, #16]
  2063fa:	9b04      	ldr	r3, [sp, #16]
  2063fc:	681a      	ldr	r2, [r3, #0]
  2063fe:	9b05      	ldr	r3, [sp, #20]
  206400:	601a      	str	r2, [r3, #0]
  206402:	9b05      	ldr	r3, [sp, #20]
  206404:	9a04      	ldr	r2, [sp, #16]
  206406:	605a      	str	r2, [r3, #4]
  206408:	9b04      	ldr	r3, [sp, #16]
  20640a:	681b      	ldr	r3, [r3, #0]
  20640c:	9a05      	ldr	r2, [sp, #20]
  20640e:	605a      	str	r2, [r3, #4]
  206410:	9a05      	ldr	r2, [sp, #20]
  206412:	9b04      	ldr	r3, [sp, #16]
  206414:	601a      	str	r2, [r3, #0]
  }

  /* Out of critical section and returning the object.*/
  chSysUnlock();
  206416:	f7ff fe6b 	bl	2060f0 <chSysUnlock.lto_priv.16>

  return objp;
  20641a:	9b05      	ldr	r3, [sp, #20]
}
  20641c:	4618      	mov	r0, r3
  20641e:	b007      	add	sp, #28
  206420:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00206430 <chCacheReleaseObjectI>:
 * @param[in] objp      pointer to the @p oc_object_t object
 *
 * @iclass
 */
void chCacheReleaseObjectI(objects_cache_t *ocp,
                           oc_object_t *objp) {
  206430:	b500      	push	{lr}
  206432:	b083      	sub	sp, #12
  206434:	9001      	str	r0, [sp, #4]
  206436:	9100      	str	r1, [sp, #0]
  chDbgAssert(chSemGetCounterI(&objp->obj_sem) <= (cnt_t)0,
              "semaphore counter greater than 0");

  /* If some thread is waiting for this specific buffer then it is
     handed directly without going through the LRU.*/
  if (chSemGetCounterI(&objp->obj_sem) < (cnt_t)0) {
  206438:	9b00      	ldr	r3, [sp, #0]
  20643a:	3318      	adds	r3, #24
  20643c:	4618      	mov	r0, r3
  20643e:	f7ff fe87 	bl	206150 <chSemGetCounterI.lto_priv.0>
  206442:	4603      	mov	r3, r0
  206444:	2b00      	cmp	r3, #0
  206446:	da0b      	bge.n	206460 <chCacheReleaseObjectI+0x30>
    /* Clearing all flags except those that are still meaningful, note,
       OC_FLAG_NOTSYNC and OC_FLAG_LAZYWRITE are passed, the other thread
       will handle them.*/
    objp->obj_flags &= OC_FLAG_INHASH | OC_FLAG_NOTSYNC | OC_FLAG_LAZYWRITE;
  206448:	9b00      	ldr	r3, [sp, #0]
  20644a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20644c:	f003 021a 	and.w	r2, r3, #26
  206450:	9b00      	ldr	r3, [sp, #0]
  206452:	625a      	str	r2, [r3, #36]	@ 0x24
    chSemSignalI(&objp->obj_sem);
  206454:	9b00      	ldr	r3, [sp, #0]
  206456:	3318      	adds	r3, #24
  206458:	4618      	mov	r0, r3
  20645a:	f7fd fbd1 	bl	203c00 <chSemSignalI>
    return;
  20645e:	e066      	b.n	20652e <chCacheReleaseObjectI+0xfe>
  }

  /* If the object specifies OC_FLAG_NOTSYNC then it must be invalidated
     and removed from the hash table.*/
  if ((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U) {
  206460:	9b00      	ldr	r3, [sp, #0]
  206462:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  206464:	f003 0308 	and.w	r3, r3, #8
  206468:	2b00      	cmp	r3, #0
  20646a:	d023      	beq.n	2064b4 <chCacheReleaseObjectI+0x84>
    HASH_REMOVE(objp);
  20646c:	9b00      	ldr	r3, [sp, #0]
  20646e:	685b      	ldr	r3, [r3, #4]
  206470:	9a00      	ldr	r2, [sp, #0]
  206472:	6812      	ldr	r2, [r2, #0]
  206474:	601a      	str	r2, [r3, #0]
  206476:	9b00      	ldr	r3, [sp, #0]
  206478:	681b      	ldr	r3, [r3, #0]
  20647a:	9a00      	ldr	r2, [sp, #0]
  20647c:	6852      	ldr	r2, [r2, #4]
  20647e:	605a      	str	r2, [r3, #4]
    LRU_INSERT_TAIL(ocp, objp);
  206480:	9b01      	ldr	r3, [sp, #4]
  206482:	6a1a      	ldr	r2, [r3, #32]
  206484:	9b00      	ldr	r3, [sp, #0]
  206486:	60da      	str	r2, [r3, #12]
  206488:	9b01      	ldr	r3, [sp, #4]
  20648a:	f103 0214 	add.w	r2, r3, #20
  20648e:	9b00      	ldr	r3, [sp, #0]
  206490:	609a      	str	r2, [r3, #8]
  206492:	9b01      	ldr	r3, [sp, #4]
  206494:	6a1b      	ldr	r3, [r3, #32]
  206496:	9a00      	ldr	r2, [sp, #0]
  206498:	609a      	str	r2, [r3, #8]
  20649a:	9a00      	ldr	r2, [sp, #0]
  20649c:	9b01      	ldr	r3, [sp, #4]
  20649e:	621a      	str	r2, [r3, #32]
    objp->obj_owner = NULL;
  2064a0:	9b00      	ldr	r3, [sp, #0]
  2064a2:	2200      	movs	r2, #0
  2064a4:	611a      	str	r2, [r3, #16]
    objp->obj_key   = 0U;
  2064a6:	9b00      	ldr	r3, [sp, #0]
  2064a8:	2200      	movs	r2, #0
  2064aa:	615a      	str	r2, [r3, #20]
    objp->obj_flags = OC_FLAG_INLRU;
  2064ac:	9b00      	ldr	r3, [sp, #0]
  2064ae:	2201      	movs	r2, #1
  2064b0:	625a      	str	r2, [r3, #36]	@ 0x24
  2064b2:	e032      	b.n	20651a <chCacheReleaseObjectI+0xea>
  }
  else {
    /* LRU insertion point depends on the OC_FLAG_FORGET flag.*/
    if ((objp->obj_flags & OC_FLAG_FORGET) == 0U) {
  2064b4:	9b00      	ldr	r3, [sp, #0]
  2064b6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  2064b8:	f003 0320 	and.w	r3, r3, #32
  2064bc:	2b00      	cmp	r3, #0
  2064be:	d110      	bne.n	2064e2 <chCacheReleaseObjectI+0xb2>
      /* Placing it on head.*/
      LRU_INSERT_HEAD(ocp, objp);
  2064c0:	9b01      	ldr	r3, [sp, #4]
  2064c2:	69da      	ldr	r2, [r3, #28]
  2064c4:	9b00      	ldr	r3, [sp, #0]
  2064c6:	609a      	str	r2, [r3, #8]
  2064c8:	9b01      	ldr	r3, [sp, #4]
  2064ca:	f103 0214 	add.w	r2, r3, #20
  2064ce:	9b00      	ldr	r3, [sp, #0]
  2064d0:	60da      	str	r2, [r3, #12]
  2064d2:	9b01      	ldr	r3, [sp, #4]
  2064d4:	69db      	ldr	r3, [r3, #28]
  2064d6:	9a00      	ldr	r2, [sp, #0]
  2064d8:	60da      	str	r2, [r3, #12]
  2064da:	9a00      	ldr	r2, [sp, #0]
  2064dc:	9b01      	ldr	r3, [sp, #4]
  2064de:	61da      	str	r2, [r3, #28]
  2064e0:	e00f      	b.n	206502 <chCacheReleaseObjectI+0xd2>
    }
    else {
      /* Low priority data, placing it on tail.*/
      LRU_INSERT_TAIL(ocp, objp);
  2064e2:	9b01      	ldr	r3, [sp, #4]
  2064e4:	6a1a      	ldr	r2, [r3, #32]
  2064e6:	9b00      	ldr	r3, [sp, #0]
  2064e8:	60da      	str	r2, [r3, #12]
  2064ea:	9b01      	ldr	r3, [sp, #4]
  2064ec:	f103 0214 	add.w	r2, r3, #20
  2064f0:	9b00      	ldr	r3, [sp, #0]
  2064f2:	609a      	str	r2, [r3, #8]
  2064f4:	9b01      	ldr	r3, [sp, #4]
  2064f6:	6a1b      	ldr	r3, [r3, #32]
  2064f8:	9a00      	ldr	r2, [sp, #0]
  2064fa:	609a      	str	r2, [r3, #8]
  2064fc:	9a00      	ldr	r2, [sp, #0]
  2064fe:	9b01      	ldr	r3, [sp, #4]
  206500:	621a      	str	r2, [r3, #32]
    }
    objp->obj_flags &= OC_FLAG_INHASH | OC_FLAG_LAZYWRITE;
  206502:	9b00      	ldr	r3, [sp, #0]
  206504:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  206506:	f003 0212 	and.w	r2, r3, #18
  20650a:	9b00      	ldr	r3, [sp, #0]
  20650c:	625a      	str	r2, [r3, #36]	@ 0x24
    objp->obj_flags |= OC_FLAG_INLRU;
  20650e:	9b00      	ldr	r3, [sp, #0]
  206510:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  206512:	f043 0201 	orr.w	r2, r3, #1
  206516:	9b00      	ldr	r3, [sp, #0]
  206518:	625a      	str	r2, [r3, #36]	@ 0x24
  }

  /* Increasing the LRU counter semaphore.*/
  chSemSignalI(&ocp->lru_sem);
  20651a:	9b01      	ldr	r3, [sp, #4]
  20651c:	3330      	adds	r3, #48	@ 0x30
  20651e:	4618      	mov	r0, r3
  206520:	f7fd fb6e 	bl	203c00 <chSemSignalI>

  /* Releasing the object, we know there are no threads waiting so
     using the "fast" signal variant.*/
  chSemFastSignalI(&objp->obj_sem);
  206524:	9b00      	ldr	r3, [sp, #0]
  206526:	3318      	adds	r3, #24
  206528:	4618      	mov	r0, r3
  20652a:	f7ff fe01 	bl	206130 <chSemFastSignalI.lto_priv.1>
}
  20652e:	b003      	add	sp, #12
  206530:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00206540 <chCacheReadObject>:
 *
 * @api
 */
bool chCacheReadObject(objects_cache_t *ocp,
                       oc_object_t *objp,
                       bool async) {
  206540:	b500      	push	{lr}
  206542:	b085      	sub	sp, #20
  206544:	9003      	str	r0, [sp, #12]
  206546:	9102      	str	r1, [sp, #8]
  206548:	4613      	mov	r3, r2
  20654a:	f88d 3007 	strb.w	r3, [sp, #7]

  /* Marking it as OC_FLAG_NOTSYNC because the read operation is going
     to corrupt it in case of failure. It is responsibility of the read
     implementation to clear it if the operation succeeds.*/
  objp->obj_flags |= OC_FLAG_NOTSYNC;
  20654e:	9b02      	ldr	r3, [sp, #8]
  206550:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  206552:	f043 0208 	orr.w	r2, r3, #8
  206556:	9b02      	ldr	r3, [sp, #8]
  206558:	625a      	str	r2, [r3, #36]	@ 0x24

  return ocp->readf(ocp, objp, async);
  20655a:	9b03      	ldr	r3, [sp, #12]
  20655c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  20655e:	f89d 2007 	ldrb.w	r2, [sp, #7]
  206562:	9902      	ldr	r1, [sp, #8]
  206564:	9803      	ldr	r0, [sp, #12]
  206566:	4798      	blx	r3
  206568:	4603      	mov	r3, r0
}
  20656a:	4618      	mov	r0, r3
  20656c:	b005      	add	sp, #20
  20656e:	f85d fb04 	ldr.w	pc, [sp], #4
  206572:	bf00      	nop
	...

00206580 <chSysLock.lto_priv.17>:
static inline void chSysLock(void) {
  206580:	b082      	sub	sp, #8
  206582:	2330      	movs	r3, #48	@ 0x30
  206584:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  206586:	9b01      	ldr	r3, [sp, #4]
  206588:	f383 8811 	msr	BASEPRI, r3
}
  20658c:	bf00      	nop
}
  20658e:	bf00      	nop
}
  206590:	bf00      	nop
  206592:	b002      	add	sp, #8
  206594:	4770      	bx	lr
  206596:	bf00      	nop
	...

002065a0 <chSysUnlock.lto_priv.17>:
static inline void chSysUnlock(void) {
  2065a0:	b082      	sub	sp, #8
  2065a2:	2300      	movs	r3, #0
  2065a4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2065a6:	9b01      	ldr	r3, [sp, #4]
  2065a8:	f383 8811 	msr	BASEPRI, r3
}
  2065ac:	bf00      	nop
}
  2065ae:	bf00      	nop
}
  2065b0:	bf00      	nop
  2065b2:	b002      	add	sp, #8
  2065b4:	4770      	bx	lr
  2065b6:	bf00      	nop
	...

002065c0 <chMsgWait.lto_priv.0>:
static inline thread_t *chMsgWait(void) {
  2065c0:	b500      	push	{lr}
  2065c2:	b083      	sub	sp, #12
  chSysLock();
  2065c4:	f7ff ffdc 	bl	206580 <chSysLock.lto_priv.17>
  tp = chMsgWaitS();
  2065c8:	f7fe fb02 	bl	204bd0 <chMsgWaitS>
  2065cc:	9001      	str	r0, [sp, #4]
  chSysUnlock();
  2065ce:	f7ff ffe7 	bl	2065a0 <chSysUnlock.lto_priv.17>
  return tp;
  2065d2:	9b01      	ldr	r3, [sp, #4]
}
  2065d4:	4618      	mov	r0, r3
  2065d6:	b003      	add	sp, #12
  2065d8:	f85d fb04 	ldr.w	pc, [sp], #4
  2065dc:	0000      	movs	r0, r0
	...

002065e0 <chMsgGet.lto_priv.0>:
static inline msg_t chMsgGet(thread_t *tp) {
  2065e0:	b082      	sub	sp, #8
  2065e2:	9001      	str	r0, [sp, #4]
  return tp->u.sentmsg;
  2065e4:	9b01      	ldr	r3, [sp, #4]
  2065e6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
}
  2065e8:	4618      	mov	r0, r3
  2065ea:	b002      	add	sp, #8
  2065ec:	4770      	bx	lr
  2065ee:	bf00      	nop

002065f0 <__ch_delegate_fn0>:
 * @brief   Veneer for functions with no parameters.
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn0(va_list *argsp) {
  2065f0:	b500      	push	{lr}
  2065f2:	b085      	sub	sp, #20
  2065f4:	9001      	str	r0, [sp, #4]
  delegate_fn0_t fn0 = (delegate_fn0_t)va_arg(*argsp, delegate_fn0_t);
  2065f6:	9b01      	ldr	r3, [sp, #4]
  2065f8:	681b      	ldr	r3, [r3, #0]
  2065fa:	1d19      	adds	r1, r3, #4
  2065fc:	9a01      	ldr	r2, [sp, #4]
  2065fe:	6011      	str	r1, [r2, #0]
  206600:	681b      	ldr	r3, [r3, #0]
  206602:	9303      	str	r3, [sp, #12]
  return fn0();
  206604:	9b03      	ldr	r3, [sp, #12]
  206606:	4798      	blx	r3
  206608:	4603      	mov	r3, r0
}
  20660a:	4618      	mov	r0, r3
  20660c:	b005      	add	sp, #20
  20660e:	f85d fb04 	ldr.w	pc, [sp], #4
  206612:	bf00      	nop
	...

00206620 <__ch_delegate_fn1>:
 * @brief   Veneer for functions with one parameter.
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn1(va_list *argsp) {
  206620:	b500      	push	{lr}
  206622:	b085      	sub	sp, #20
  206624:	9001      	str	r0, [sp, #4]
  delegate_fn1_t fn1 = (delegate_fn1_t)va_arg(*argsp, delegate_fn1_t);
  206626:	9b01      	ldr	r3, [sp, #4]
  206628:	681b      	ldr	r3, [r3, #0]
  20662a:	1d19      	adds	r1, r3, #4
  20662c:	9a01      	ldr	r2, [sp, #4]
  20662e:	6011      	str	r1, [r2, #0]
  206630:	681b      	ldr	r3, [r3, #0]
  206632:	9303      	str	r3, [sp, #12]
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
  206634:	9b01      	ldr	r3, [sp, #4]
  206636:	681b      	ldr	r3, [r3, #0]
  206638:	1d19      	adds	r1, r3, #4
  20663a:	9a01      	ldr	r2, [sp, #4]
  20663c:	6011      	str	r1, [r2, #0]
  20663e:	681b      	ldr	r3, [r3, #0]
  206640:	9302      	str	r3, [sp, #8]
  return fn1(p1);
  206642:	9b03      	ldr	r3, [sp, #12]
  206644:	9802      	ldr	r0, [sp, #8]
  206646:	4798      	blx	r3
  206648:	4603      	mov	r3, r0
}
  20664a:	4618      	mov	r0, r3
  20664c:	b005      	add	sp, #20
  20664e:	f85d fb04 	ldr.w	pc, [sp], #4
  206652:	bf00      	nop
	...

00206660 <__ch_delegate_fn2>:
 * @brief   Veneer for functions with two parameters.
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn2(va_list *argsp) {
  206660:	b500      	push	{lr}
  206662:	b087      	sub	sp, #28
  206664:	9001      	str	r0, [sp, #4]
  delegate_fn2_t fn2 = (delegate_fn2_t)va_arg(*argsp, delegate_fn2_t);
  206666:	9b01      	ldr	r3, [sp, #4]
  206668:	681b      	ldr	r3, [r3, #0]
  20666a:	1d19      	adds	r1, r3, #4
  20666c:	9a01      	ldr	r2, [sp, #4]
  20666e:	6011      	str	r1, [r2, #0]
  206670:	681b      	ldr	r3, [r3, #0]
  206672:	9305      	str	r3, [sp, #20]
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
  206674:	9b01      	ldr	r3, [sp, #4]
  206676:	681b      	ldr	r3, [r3, #0]
  206678:	1d19      	adds	r1, r3, #4
  20667a:	9a01      	ldr	r2, [sp, #4]
  20667c:	6011      	str	r1, [r2, #0]
  20667e:	681b      	ldr	r3, [r3, #0]
  206680:	9304      	str	r3, [sp, #16]
  msg_t p2 = (msg_t)va_arg(*argsp, msg_t);
  206682:	9b01      	ldr	r3, [sp, #4]
  206684:	681b      	ldr	r3, [r3, #0]
  206686:	1d19      	adds	r1, r3, #4
  206688:	9a01      	ldr	r2, [sp, #4]
  20668a:	6011      	str	r1, [r2, #0]
  20668c:	681b      	ldr	r3, [r3, #0]
  20668e:	9303      	str	r3, [sp, #12]
  return fn2(p1, p2);
  206690:	9b05      	ldr	r3, [sp, #20]
  206692:	9903      	ldr	r1, [sp, #12]
  206694:	9804      	ldr	r0, [sp, #16]
  206696:	4798      	blx	r3
  206698:	4603      	mov	r3, r0
}
  20669a:	4618      	mov	r0, r3
  20669c:	b007      	add	sp, #28
  20669e:	f85d fb04 	ldr.w	pc, [sp], #4
  2066a2:	bf00      	nop
	...

002066b0 <__ch_delegate_fn3>:
 * @brief   Veneer for functions with three parameters.
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn3(va_list *argsp) {
  2066b0:	b500      	push	{lr}
  2066b2:	b087      	sub	sp, #28
  2066b4:	9001      	str	r0, [sp, #4]
  delegate_fn3_t fn3 = (delegate_fn3_t)va_arg(*argsp, delegate_fn3_t);
  2066b6:	9b01      	ldr	r3, [sp, #4]
  2066b8:	681b      	ldr	r3, [r3, #0]
  2066ba:	1d19      	adds	r1, r3, #4
  2066bc:	9a01      	ldr	r2, [sp, #4]
  2066be:	6011      	str	r1, [r2, #0]
  2066c0:	681b      	ldr	r3, [r3, #0]
  2066c2:	9305      	str	r3, [sp, #20]
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
  2066c4:	9b01      	ldr	r3, [sp, #4]
  2066c6:	681b      	ldr	r3, [r3, #0]
  2066c8:	1d19      	adds	r1, r3, #4
  2066ca:	9a01      	ldr	r2, [sp, #4]
  2066cc:	6011      	str	r1, [r2, #0]
  2066ce:	681b      	ldr	r3, [r3, #0]
  2066d0:	9304      	str	r3, [sp, #16]
  msg_t p2 = (msg_t)va_arg(*argsp, msg_t);
  2066d2:	9b01      	ldr	r3, [sp, #4]
  2066d4:	681b      	ldr	r3, [r3, #0]
  2066d6:	1d19      	adds	r1, r3, #4
  2066d8:	9a01      	ldr	r2, [sp, #4]
  2066da:	6011      	str	r1, [r2, #0]
  2066dc:	681b      	ldr	r3, [r3, #0]
  2066de:	9303      	str	r3, [sp, #12]
  msg_t p3 = (msg_t)va_arg(*argsp, msg_t);
  2066e0:	9b01      	ldr	r3, [sp, #4]
  2066e2:	681b      	ldr	r3, [r3, #0]
  2066e4:	1d19      	adds	r1, r3, #4
  2066e6:	9a01      	ldr	r2, [sp, #4]
  2066e8:	6011      	str	r1, [r2, #0]
  2066ea:	681b      	ldr	r3, [r3, #0]
  2066ec:	9302      	str	r3, [sp, #8]
  return fn3(p1, p2, p3);
  2066ee:	9b05      	ldr	r3, [sp, #20]
  2066f0:	9a02      	ldr	r2, [sp, #8]
  2066f2:	9903      	ldr	r1, [sp, #12]
  2066f4:	9804      	ldr	r0, [sp, #16]
  2066f6:	4798      	blx	r3
  2066f8:	4603      	mov	r3, r0
}
  2066fa:	4618      	mov	r0, r3
  2066fc:	b007      	add	sp, #28
  2066fe:	f85d fb04 	ldr.w	pc, [sp], #4
  206702:	bf00      	nop
	...

00206710 <__ch_delegate_fn4>:
 * @brief   Veneer for functions with four parameters.
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn4(va_list *argsp) {
  206710:	b510      	push	{r4, lr}
  206712:	b088      	sub	sp, #32
  206714:	9001      	str	r0, [sp, #4]
  delegate_fn4_t fn4 = (delegate_fn4_t)va_arg(*argsp, delegate_fn4_t);
  206716:	9b01      	ldr	r3, [sp, #4]
  206718:	681b      	ldr	r3, [r3, #0]
  20671a:	1d19      	adds	r1, r3, #4
  20671c:	9a01      	ldr	r2, [sp, #4]
  20671e:	6011      	str	r1, [r2, #0]
  206720:	681b      	ldr	r3, [r3, #0]
  206722:	9307      	str	r3, [sp, #28]
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
  206724:	9b01      	ldr	r3, [sp, #4]
  206726:	681b      	ldr	r3, [r3, #0]
  206728:	1d19      	adds	r1, r3, #4
  20672a:	9a01      	ldr	r2, [sp, #4]
  20672c:	6011      	str	r1, [r2, #0]
  20672e:	681b      	ldr	r3, [r3, #0]
  206730:	9306      	str	r3, [sp, #24]
  msg_t p2 = (msg_t)va_arg(*argsp, msg_t);
  206732:	9b01      	ldr	r3, [sp, #4]
  206734:	681b      	ldr	r3, [r3, #0]
  206736:	1d19      	adds	r1, r3, #4
  206738:	9a01      	ldr	r2, [sp, #4]
  20673a:	6011      	str	r1, [r2, #0]
  20673c:	681b      	ldr	r3, [r3, #0]
  20673e:	9305      	str	r3, [sp, #20]
  msg_t p3 = (msg_t)va_arg(*argsp, msg_t);
  206740:	9b01      	ldr	r3, [sp, #4]
  206742:	681b      	ldr	r3, [r3, #0]
  206744:	1d19      	adds	r1, r3, #4
  206746:	9a01      	ldr	r2, [sp, #4]
  206748:	6011      	str	r1, [r2, #0]
  20674a:	681b      	ldr	r3, [r3, #0]
  20674c:	9304      	str	r3, [sp, #16]
  msg_t p4 = (msg_t)va_arg(*argsp, msg_t);
  20674e:	9b01      	ldr	r3, [sp, #4]
  206750:	681b      	ldr	r3, [r3, #0]
  206752:	1d19      	adds	r1, r3, #4
  206754:	9a01      	ldr	r2, [sp, #4]
  206756:	6011      	str	r1, [r2, #0]
  206758:	681b      	ldr	r3, [r3, #0]
  20675a:	9303      	str	r3, [sp, #12]
  return fn4(p1, p2, p3, p4);
  20675c:	9c07      	ldr	r4, [sp, #28]
  20675e:	9b03      	ldr	r3, [sp, #12]
  206760:	9a04      	ldr	r2, [sp, #16]
  206762:	9905      	ldr	r1, [sp, #20]
  206764:	9806      	ldr	r0, [sp, #24]
  206766:	47a0      	blx	r4
  206768:	4603      	mov	r3, r0
}
  20676a:	4618      	mov	r0, r3
  20676c:	b008      	add	sp, #32
  20676e:	bd10      	pop	{r4, pc}

00206770 <chDelegateCallVeneer>:
 * @param[in] veneer    pointer to the veneer function to be called
 * @param[in] ...       variable number of parameters
 * @return              The function return value casted to msg_t. It is
 *                      garbage for functions returning @p void.
 */
msg_t chDelegateCallVeneer(thread_t *tp, delegate_veneer_t veneer, ...) {
  206770:	b40e      	push	{r1, r2, r3}
  206772:	b500      	push	{lr}
  206774:	b086      	sub	sp, #24
  206776:	9001      	str	r0, [sp, #4]
  va_list args;
  call_message_t cm;
  msg_t msg;

  va_start(args, veneer);
  206778:	ab08      	add	r3, sp, #32
  20677a:	9304      	str	r3, [sp, #16]

  /* Preparing the call message.*/
  cm.veneer = veneer;
  20677c:	9b07      	ldr	r3, [sp, #28]
  20677e:	9302      	str	r3, [sp, #8]
  cm.argsp  = &args;
  206780:	ab04      	add	r3, sp, #16
  206782:	9303      	str	r3, [sp, #12]
  (void)cm; /* Suppresses a lint warning.*/

  /* Sending the message to the dispatcher thread, the return value is
     contained in the returned message.*/
  msg = chMsgSend(tp, (msg_t)&cm);
  206784:	ab02      	add	r3, sp, #8
  206786:	4619      	mov	r1, r3
  206788:	9801      	ldr	r0, [sp, #4]
  20678a:	f7fe f9f9 	bl	204b80 <chMsgSend>
  20678e:	9005      	str	r0, [sp, #20]

  va_end(args);

  return msg;
  206790:	9b05      	ldr	r3, [sp, #20]
}
  206792:	4618      	mov	r0, r3
  206794:	b006      	add	sp, #24
  206796:	f85d eb04 	ldr.w	lr, [sp], #4
  20679a:	b003      	add	sp, #12
  20679c:	4770      	bx	lr
  20679e:	bf00      	nop

002067a0 <chDelegateDispatch>:
 *          are sending messages then the requests are served in priority
 *          order.
 *
 * @api
 */
void chDelegateDispatch(void) {
  2067a0:	b500      	push	{lr}
  2067a2:	b085      	sub	sp, #20
  thread_t *tp;
  const call_message_t *cmp;
  msg_t ret;

  tp = chMsgWait();
  2067a4:	f7ff ff0c 	bl	2065c0 <chMsgWait.lto_priv.0>
  2067a8:	9003      	str	r0, [sp, #12]
  cmp = (const call_message_t *)chMsgGet(tp);
  2067aa:	9803      	ldr	r0, [sp, #12]
  2067ac:	f7ff ff18 	bl	2065e0 <chMsgGet.lto_priv.0>
  2067b0:	4603      	mov	r3, r0
  2067b2:	9302      	str	r3, [sp, #8]
  ret = cmp->veneer(cmp->argsp);
  2067b4:	9b02      	ldr	r3, [sp, #8]
  2067b6:	681b      	ldr	r3, [r3, #0]
  2067b8:	9a02      	ldr	r2, [sp, #8]
  2067ba:	6852      	ldr	r2, [r2, #4]
  2067bc:	4610      	mov	r0, r2
  2067be:	4798      	blx	r3
  2067c0:	9001      	str	r0, [sp, #4]

  chMsgRelease(tp, ret);
  2067c2:	9901      	ldr	r1, [sp, #4]
  2067c4:	9803      	ldr	r0, [sp, #12]
  2067c6:	f7fe fa23 	bl	204c10 <chMsgRelease>
}
  2067ca:	bf00      	nop
  2067cc:	b005      	add	sp, #20
  2067ce:	f85d fb04 	ldr.w	pc, [sp], #4
  2067d2:	bf00      	nop
	...

002067e0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
  2067e0:	b500      	push	{lr}
  2067e2:	b083      	sub	sp, #12
  2067e4:	9001      	str	r0, [sp, #4]
  2067e6:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
  2067e8:	2200      	movs	r2, #0
  2067ea:	9900      	ldr	r1, [sp, #0]
  2067ec:	9801      	ldr	r0, [sp, #4]
  2067ee:	f7fe fdef 	bl	2053d0 <chCoreAllocFromTopI>
  2067f2:	4603      	mov	r3, r0
}
  2067f4:	4618      	mov	r0, r3
  2067f6:	b003      	add	sp, #12
  2067f8:	f85d fb04 	ldr.w	pc, [sp], #4
  2067fc:	0000      	movs	r0, r0
	...

00206800 <chPoolObjectInit.lto_priv.0>:
                                    memgetfunc_t provider) {
  206800:	b500      	push	{lr}
  206802:	b085      	sub	sp, #20
  206804:	9003      	str	r0, [sp, #12]
  206806:	9102      	str	r1, [sp, #8]
  206808:	9201      	str	r2, [sp, #4]
  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
  20680a:	9b01      	ldr	r3, [sp, #4]
  20680c:	2204      	movs	r2, #4
  20680e:	9902      	ldr	r1, [sp, #8]
  206810:	9803      	ldr	r0, [sp, #12]
  206812:	f7ff f90d 	bl	205a30 <chPoolObjectInitAligned>
}
  206816:	bf00      	nop
  206818:	b005      	add	sp, #20
  20681a:	f85d fb04 	ldr.w	pc, [sp], #4
  20681e:	bf00      	nop

00206820 <chFifoObjectInitAligned>:
 *
 * @init
 */
static inline void chFifoObjectInitAligned(objects_fifo_t *ofp, size_t objsize,
                                           size_t objn, unsigned objalign,
                                           void *objbuf, msg_t *msgbuf) {
  206820:	b500      	push	{lr}
  206822:	b085      	sub	sp, #20
  206824:	9003      	str	r0, [sp, #12]
  206826:	9102      	str	r1, [sp, #8]
  206828:	9201      	str	r2, [sp, #4]
  20682a:	9300      	str	r3, [sp, #0]

  chDbgCheck((objsize >= objalign) && ((objsize % objalign) == 0U));

  chGuardedPoolObjectInitAligned(&ofp->free, objsize, objalign);
  20682c:	9b03      	ldr	r3, [sp, #12]
  20682e:	9a00      	ldr	r2, [sp, #0]
  206830:	9902      	ldr	r1, [sp, #8]
  206832:	4618      	mov	r0, r3
  206834:	f7ff f98c 	bl	205b50 <chGuardedPoolObjectInitAligned>
  chGuardedPoolLoadArray(&ofp->free, objbuf, objn);
  206838:	9b03      	ldr	r3, [sp, #12]
  20683a:	9a01      	ldr	r2, [sp, #4]
  20683c:	9906      	ldr	r1, [sp, #24]
  20683e:	4618      	mov	r0, r3
  206840:	f7ff f99e 	bl	205b80 <chGuardedPoolLoadArray>
  chMBObjectInit(&ofp->mbx, msgbuf, objn);
  206844:	9b03      	ldr	r3, [sp, #12]
  206846:	331c      	adds	r3, #28
  206848:	9a01      	ldr	r2, [sp, #4]
  20684a:	9907      	ldr	r1, [sp, #28]
  20684c:	4618      	mov	r0, r3
  20684e:	f7fe fb67 	bl	204f20 <chMBObjectInit>
}
  206852:	bf00      	nop
  206854:	b005      	add	sp, #20
  206856:	f85d fb04 	ldr.w	pc, [sp], #4
  20685a:	bf00      	nop
  20685c:	0000      	movs	r0, r0
	...

00206860 <copy_name>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static void copy_name(const char *sp, char *dp) {
  206860:	b084      	sub	sp, #16
  206862:	9001      	str	r0, [sp, #4]
  206864:	9100      	str	r1, [sp, #0]
  unsigned i;
  char c;

  i = CH_CFG_FACTORY_MAX_NAMES_LENGTH;
  206866:	2308      	movs	r3, #8
  206868:	9303      	str	r3, [sp, #12]
  do {
    c = *sp++;
  20686a:	9b01      	ldr	r3, [sp, #4]
  20686c:	1c5a      	adds	r2, r3, #1
  20686e:	9201      	str	r2, [sp, #4]
  206870:	781b      	ldrb	r3, [r3, #0]
  206872:	f88d 300b 	strb.w	r3, [sp, #11]
    *dp++ = c;
  206876:	9b00      	ldr	r3, [sp, #0]
  206878:	1c5a      	adds	r2, r3, #1
  20687a:	9200      	str	r2, [sp, #0]
  20687c:	f89d 200b 	ldrb.w	r2, [sp, #11]
  206880:	701a      	strb	r2, [r3, #0]
    i--;
  206882:	9b03      	ldr	r3, [sp, #12]
  206884:	3b01      	subs	r3, #1
  206886:	9303      	str	r3, [sp, #12]
  } while ((c != (char)0) && (i > 0U));
  206888:	f89d 300b 	ldrb.w	r3, [sp, #11]
  20688c:	2b00      	cmp	r3, #0
  20688e:	d002      	beq.n	206896 <copy_name+0x36>
  206890:	9b03      	ldr	r3, [sp, #12]
  206892:	2b00      	cmp	r3, #0
  206894:	d1e9      	bne.n	20686a <copy_name+0xa>
}
  206896:	bf00      	nop
  206898:	b004      	add	sp, #16
  20689a:	4770      	bx	lr
  20689c:	0000      	movs	r0, r0
	...

002068a0 <dyn_list_init>:

static inline void dyn_list_init(dyn_list_t *dlp) {
  2068a0:	b082      	sub	sp, #8
  2068a2:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
  2068a4:	9b01      	ldr	r3, [sp, #4]
  2068a6:	9a01      	ldr	r2, [sp, #4]
  2068a8:	601a      	str	r2, [r3, #0]
}
  2068aa:	bf00      	nop
  2068ac:	b002      	add	sp, #8
  2068ae:	4770      	bx	lr

002068b0 <dyn_list_find>:

static dyn_element_t *dyn_list_find(const char *name, dyn_list_t *dlp) {
  2068b0:	b500      	push	{lr}
  2068b2:	b085      	sub	sp, #20
  2068b4:	9001      	str	r0, [sp, #4]
  2068b6:	9100      	str	r1, [sp, #0]
  dyn_element_t *p = dlp->next;
  2068b8:	9b00      	ldr	r3, [sp, #0]
  2068ba:	681b      	ldr	r3, [r3, #0]
  2068bc:	9303      	str	r3, [sp, #12]

  while (p != (dyn_element_t *)dlp) {
  2068be:	e00e      	b.n	2068de <dyn_list_find+0x2e>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
  2068c0:	9b03      	ldr	r3, [sp, #12]
  2068c2:	3308      	adds	r3, #8
  2068c4:	2208      	movs	r2, #8
  2068c6:	9901      	ldr	r1, [sp, #4]
  2068c8:	4618      	mov	r0, r3
  2068ca:	f7f9 fd97 	bl	2003fc <strncmp>
  2068ce:	4603      	mov	r3, r0
  2068d0:	2b00      	cmp	r3, #0
  2068d2:	d101      	bne.n	2068d8 <dyn_list_find+0x28>
      return p;
  2068d4:	9b03      	ldr	r3, [sp, #12]
  2068d6:	e007      	b.n	2068e8 <dyn_list_find+0x38>
    }
    p = p->next;
  2068d8:	9b03      	ldr	r3, [sp, #12]
  2068da:	681b      	ldr	r3, [r3, #0]
  2068dc:	9303      	str	r3, [sp, #12]
  while (p != (dyn_element_t *)dlp) {
  2068de:	9a03      	ldr	r2, [sp, #12]
  2068e0:	9b00      	ldr	r3, [sp, #0]
  2068e2:	429a      	cmp	r2, r3
  2068e4:	d1ec      	bne.n	2068c0 <dyn_list_find+0x10>
  }

  return NULL;
  2068e6:	2300      	movs	r3, #0
}
  2068e8:	4618      	mov	r0, r3
  2068ea:	b005      	add	sp, #20
  2068ec:	f85d fb04 	ldr.w	pc, [sp], #4

002068f0 <dyn_list_find_prev>:

static dyn_element_t *dyn_list_find_prev(dyn_element_t *element,
                                      dyn_list_t *dlp) {
  2068f0:	b084      	sub	sp, #16
  2068f2:	9001      	str	r0, [sp, #4]
  2068f4:	9100      	str	r1, [sp, #0]
  dyn_element_t *prev = (dyn_element_t *)dlp;
  2068f6:	9b00      	ldr	r3, [sp, #0]
  2068f8:	9303      	str	r3, [sp, #12]

  /* Scanning the list.*/
  while (prev->next != (dyn_element_t *)dlp) {
  2068fa:	e009      	b.n	206910 <dyn_list_find_prev+0x20>
    if (prev->next == element) {
  2068fc:	9b03      	ldr	r3, [sp, #12]
  2068fe:	681b      	ldr	r3, [r3, #0]
  206900:	9a01      	ldr	r2, [sp, #4]
  206902:	429a      	cmp	r2, r3
  206904:	d101      	bne.n	20690a <dyn_list_find_prev+0x1a>
      return prev;
  206906:	9b03      	ldr	r3, [sp, #12]
  206908:	e008      	b.n	20691c <dyn_list_find_prev+0x2c>
    }

    /* Next element in the list.*/
    prev = prev->next;
  20690a:	9b03      	ldr	r3, [sp, #12]
  20690c:	681b      	ldr	r3, [r3, #0]
  20690e:	9303      	str	r3, [sp, #12]
  while (prev->next != (dyn_element_t *)dlp) {
  206910:	9b03      	ldr	r3, [sp, #12]
  206912:	681b      	ldr	r3, [r3, #0]
  206914:	9a00      	ldr	r2, [sp, #0]
  206916:	429a      	cmp	r2, r3
  206918:	d1f0      	bne.n	2068fc <dyn_list_find_prev+0xc>
  }

  return NULL;
  20691a:	2300      	movs	r3, #0
}
  20691c:	4618      	mov	r0, r3
  20691e:	b004      	add	sp, #16
  206920:	4770      	bx	lr
  206922:	bf00      	nop
	...

00206930 <dyn_list_unlink>:

static dyn_element_t *dyn_list_unlink(dyn_element_t *prev) {
  206930:	b084      	sub	sp, #16
  206932:	9001      	str	r0, [sp, #4]
  dyn_element_t *element = prev->next;
  206934:	9b01      	ldr	r3, [sp, #4]
  206936:	681b      	ldr	r3, [r3, #0]
  206938:	9303      	str	r3, [sp, #12]

  prev->next = element->next;
  20693a:	9b03      	ldr	r3, [sp, #12]
  20693c:	681a      	ldr	r2, [r3, #0]
  20693e:	9b01      	ldr	r3, [sp, #4]
  206940:	601a      	str	r2, [r3, #0]

  return element;
  206942:	9b03      	ldr	r3, [sp, #12]
}
  206944:	4618      	mov	r0, r3
  206946:	b004      	add	sp, #16
  206948:	4770      	bx	lr
  20694a:	bf00      	nop
  20694c:	0000      	movs	r0, r0
	...

00206950 <dyn_create_object_heap>:

#if CH_FACTORY_REQUIRES_HEAP || defined(__DOXYGEN__)
static dyn_element_t *dyn_create_object_heap(const char *name,
                                             dyn_list_t *dlp,
                                             size_t size,
                                             unsigned align) {
  206950:	b500      	push	{lr}
  206952:	b087      	sub	sp, #28
  206954:	9003      	str	r0, [sp, #12]
  206956:	9102      	str	r1, [sp, #8]
  206958:	9201      	str	r2, [sp, #4]
  20695a:	9300      	str	r3, [sp, #0]
  dyn_element_t *dep;

  chDbgCheck(name != NULL);

  /* Checking if an object with this name has already been created.*/
  dep = dyn_list_find(name, dlp);
  20695c:	9902      	ldr	r1, [sp, #8]
  20695e:	9803      	ldr	r0, [sp, #12]
  206960:	f7ff ffa6 	bl	2068b0 <dyn_list_find>
  206964:	9005      	str	r0, [sp, #20]
  if (dep != NULL) {
  206966:	9b05      	ldr	r3, [sp, #20]
  206968:	2b00      	cmp	r3, #0
  20696a:	d001      	beq.n	206970 <dyn_create_object_heap+0x20>
    return NULL;
  20696c:	2300      	movs	r3, #0
  20696e:	e01b      	b.n	2069a8 <dyn_create_object_heap+0x58>
  }

  /* Allocating space for the new buffer object.*/
  dep = (dyn_element_t *)chHeapAllocAligned(NULL, size, align);
  206970:	9a00      	ldr	r2, [sp, #0]
  206972:	9901      	ldr	r1, [sp, #4]
  206974:	2000      	movs	r0, #0
  206976:	f7fe fe0b 	bl	205590 <chHeapAllocAligned>
  20697a:	9005      	str	r0, [sp, #20]
  if (dep == NULL) {
  20697c:	9b05      	ldr	r3, [sp, #20]
  20697e:	2b00      	cmp	r3, #0
  206980:	d101      	bne.n	206986 <dyn_create_object_heap+0x36>
    return NULL;
  206982:	2300      	movs	r3, #0
  206984:	e010      	b.n	2069a8 <dyn_create_object_heap+0x58>
  }

  /* Initializing object list element.*/
  copy_name(name, dep->name);
  206986:	9b05      	ldr	r3, [sp, #20]
  206988:	3308      	adds	r3, #8
  20698a:	4619      	mov	r1, r3
  20698c:	9803      	ldr	r0, [sp, #12]
  20698e:	f7ff ff67 	bl	206860 <copy_name>
  dep->refs = (ucnt_t)1;
  206992:	9b05      	ldr	r3, [sp, #20]
  206994:	2201      	movs	r2, #1
  206996:	605a      	str	r2, [r3, #4]
  dep->next = dlp->next;
  206998:	9b02      	ldr	r3, [sp, #8]
  20699a:	681a      	ldr	r2, [r3, #0]
  20699c:	9b05      	ldr	r3, [sp, #20]
  20699e:	601a      	str	r2, [r3, #0]

  /* Updating factory list.*/
  dlp->next = dep;
  2069a0:	9b02      	ldr	r3, [sp, #8]
  2069a2:	9a05      	ldr	r2, [sp, #20]
  2069a4:	601a      	str	r2, [r3, #0]

  return dep;
  2069a6:	9b05      	ldr	r3, [sp, #20]
}
  2069a8:	4618      	mov	r0, r3
  2069aa:	b007      	add	sp, #28
  2069ac:	f85d fb04 	ldr.w	pc, [sp], #4

002069b0 <dyn_release_object_heap>:

static ucnt_t dyn_release_object_heap(dyn_element_t *dep,
                                      dyn_list_t *dlp) {
  2069b0:	b500      	push	{lr}
  2069b2:	b085      	sub	sp, #20
  2069b4:	9001      	str	r0, [sp, #4]
  2069b6:	9100      	str	r1, [sp, #0]
  ucnt_t refs;

  chDbgCheck(dep != NULL);

  /* Checking 1st if the object is in the list.*/
  prev = dyn_list_find_prev(dep, dlp);
  2069b8:	9900      	ldr	r1, [sp, #0]
  2069ba:	9801      	ldr	r0, [sp, #4]
  2069bc:	f7ff ff98 	bl	2068f0 <dyn_list_find_prev>
  2069c0:	9003      	str	r0, [sp, #12]
  if (prev != NULL) {
  2069c2:	9b03      	ldr	r3, [sp, #12]
  2069c4:	2b00      	cmp	r3, #0
  2069c6:	d012      	beq.n	2069ee <dyn_release_object_heap+0x3e>

    chDbgAssert(dep->refs > (ucnt_t)0, "invalid references number");

    refs = --dep->refs;
  2069c8:	9b01      	ldr	r3, [sp, #4]
  2069ca:	685b      	ldr	r3, [r3, #4]
  2069cc:	1e5a      	subs	r2, r3, #1
  2069ce:	9b01      	ldr	r3, [sp, #4]
  2069d0:	605a      	str	r2, [r3, #4]
  2069d2:	9b01      	ldr	r3, [sp, #4]
  2069d4:	685b      	ldr	r3, [r3, #4]
  2069d6:	9302      	str	r3, [sp, #8]
    if (refs == (ucnt_t)0) {
  2069d8:	9b02      	ldr	r3, [sp, #8]
  2069da:	2b00      	cmp	r3, #0
  2069dc:	d109      	bne.n	2069f2 <dyn_release_object_heap+0x42>
      chHeapFree((void *)dyn_list_unlink(prev));
  2069de:	9803      	ldr	r0, [sp, #12]
  2069e0:	f7ff ffa6 	bl	206930 <dyn_list_unlink>
  2069e4:	4603      	mov	r3, r0
  2069e6:	4618      	mov	r0, r3
  2069e8:	f7fe fea2 	bl	205730 <chHeapFree>
  2069ec:	e001      	b.n	2069f2 <dyn_release_object_heap+0x42>
  }
  else {

    chDbgAssert(false, "unknown object");

    refs = 0U;
  2069ee:	2300      	movs	r3, #0
  2069f0:	9302      	str	r3, [sp, #8]
  }

  return refs;
  2069f2:	9b02      	ldr	r3, [sp, #8]
}
  2069f4:	4618      	mov	r0, r3
  2069f6:	b005      	add	sp, #20
  2069f8:	f85d fb04 	ldr.w	pc, [sp], #4
  2069fc:	0000      	movs	r0, r0
	...

00206a00 <dyn_create_object_pool>:
#endif /* CH_FACTORY_REQUIRES_HEAP */

#if CH_FACTORY_REQUIRES_POOLS || defined(__DOXYGEN__)
static dyn_element_t *dyn_create_object_pool(const char *name,
                                             dyn_list_t *dlp,
                                             memory_pool_t *mp) {
  206a00:	b500      	push	{lr}
  206a02:	b087      	sub	sp, #28
  206a04:	9003      	str	r0, [sp, #12]
  206a06:	9102      	str	r1, [sp, #8]
  206a08:	9201      	str	r2, [sp, #4]
  dyn_element_t *dep;

  chDbgCheck(name != NULL);

  /* Checking if an object object with this name has already been created.*/
  dep = dyn_list_find(name, dlp);
  206a0a:	9902      	ldr	r1, [sp, #8]
  206a0c:	9803      	ldr	r0, [sp, #12]
  206a0e:	f7ff ff4f 	bl	2068b0 <dyn_list_find>
  206a12:	9005      	str	r0, [sp, #20]
  if (dep != NULL) {
  206a14:	9b05      	ldr	r3, [sp, #20]
  206a16:	2b00      	cmp	r3, #0
  206a18:	d001      	beq.n	206a1e <dyn_create_object_pool+0x1e>
    return NULL;
  206a1a:	2300      	movs	r3, #0
  206a1c:	e019      	b.n	206a52 <dyn_create_object_pool+0x52>
  }

  /* Allocating space for the new object.*/
  dep = (dyn_element_t *)chPoolAlloc(mp);
  206a1e:	9801      	ldr	r0, [sp, #4]
  206a20:	f7ff f866 	bl	205af0 <chPoolAlloc>
  206a24:	9005      	str	r0, [sp, #20]
  if (dep == NULL) {
  206a26:	9b05      	ldr	r3, [sp, #20]
  206a28:	2b00      	cmp	r3, #0
  206a2a:	d101      	bne.n	206a30 <dyn_create_object_pool+0x30>
    return NULL;
  206a2c:	2300      	movs	r3, #0
  206a2e:	e010      	b.n	206a52 <dyn_create_object_pool+0x52>
  }

  /* Initializing object list element.*/
  copy_name(name, dep->name);
  206a30:	9b05      	ldr	r3, [sp, #20]
  206a32:	3308      	adds	r3, #8
  206a34:	4619      	mov	r1, r3
  206a36:	9803      	ldr	r0, [sp, #12]
  206a38:	f7ff ff12 	bl	206860 <copy_name>
  dep->refs = (ucnt_t)1;
  206a3c:	9b05      	ldr	r3, [sp, #20]
  206a3e:	2201      	movs	r2, #1
  206a40:	605a      	str	r2, [r3, #4]
  dep->next = dlp->next;
  206a42:	9b02      	ldr	r3, [sp, #8]
  206a44:	681a      	ldr	r2, [r3, #0]
  206a46:	9b05      	ldr	r3, [sp, #20]
  206a48:	601a      	str	r2, [r3, #0]

  /* Updating factory list.*/
  dlp->next = (dyn_element_t *)dep;
  206a4a:	9b02      	ldr	r3, [sp, #8]
  206a4c:	9a05      	ldr	r2, [sp, #20]
  206a4e:	601a      	str	r2, [r3, #0]

  return dep;
  206a50:	9b05      	ldr	r3, [sp, #20]
}
  206a52:	4618      	mov	r0, r3
  206a54:	b007      	add	sp, #28
  206a56:	f85d fb04 	ldr.w	pc, [sp], #4
  206a5a:	bf00      	nop
  206a5c:	0000      	movs	r0, r0
	...

00206a60 <dyn_release_object_pool>:

static ucnt_t dyn_release_object_pool(dyn_element_t *dep,
                                      dyn_list_t *dlp,
                                      memory_pool_t *mp) {
  206a60:	b500      	push	{lr}
  206a62:	b087      	sub	sp, #28
  206a64:	9003      	str	r0, [sp, #12]
  206a66:	9102      	str	r1, [sp, #8]
  206a68:	9201      	str	r2, [sp, #4]
  ucnt_t refs;

  chDbgCheck(dep != NULL);

  /* Checking 1st if the object is in the list.*/
  prev = dyn_list_find_prev(dep, dlp);
  206a6a:	9902      	ldr	r1, [sp, #8]
  206a6c:	9803      	ldr	r0, [sp, #12]
  206a6e:	f7ff ff3f 	bl	2068f0 <dyn_list_find_prev>
  206a72:	9005      	str	r0, [sp, #20]
  if (prev != NULL) {
  206a74:	9b05      	ldr	r3, [sp, #20]
  206a76:	2b00      	cmp	r3, #0
  206a78:	d013      	beq.n	206aa2 <dyn_release_object_pool+0x42>

    chDbgAssert(dep->refs > (ucnt_t)0, "invalid references number");

    refs = --dep->refs;
  206a7a:	9b03      	ldr	r3, [sp, #12]
  206a7c:	685b      	ldr	r3, [r3, #4]
  206a7e:	1e5a      	subs	r2, r3, #1
  206a80:	9b03      	ldr	r3, [sp, #12]
  206a82:	605a      	str	r2, [r3, #4]
  206a84:	9b03      	ldr	r3, [sp, #12]
  206a86:	685b      	ldr	r3, [r3, #4]
  206a88:	9304      	str	r3, [sp, #16]
    if (refs == (ucnt_t)0) {
  206a8a:	9b04      	ldr	r3, [sp, #16]
  206a8c:	2b00      	cmp	r3, #0
  206a8e:	d10a      	bne.n	206aa6 <dyn_release_object_pool+0x46>
      chPoolFree(mp, (void *)dyn_list_unlink(prev));
  206a90:	9805      	ldr	r0, [sp, #20]
  206a92:	f7ff ff4d 	bl	206930 <dyn_list_unlink>
  206a96:	4603      	mov	r3, r0
  206a98:	4619      	mov	r1, r3
  206a9a:	9801      	ldr	r0, [sp, #4]
  206a9c:	f7ff f848 	bl	205b30 <chPoolFree>
  206aa0:	e001      	b.n	206aa6 <dyn_release_object_pool+0x46>
  }
  else {

    chDbgAssert(false, "unknown object");

    refs = 0U;
  206aa2:	2300      	movs	r3, #0
  206aa4:	9304      	str	r3, [sp, #16]
  }

  return refs;
  206aa6:	9b04      	ldr	r3, [sp, #16]
}
  206aa8:	4618      	mov	r0, r3
  206aaa:	b007      	add	sp, #28
  206aac:	f85d fb04 	ldr.w	pc, [sp], #4

00206ab0 <dyn_find_object>:
#endif /* CH_FACTORY_REQUIRES_POOLS */

static dyn_element_t *dyn_find_object(const char *name, dyn_list_t *dlp) {
  206ab0:	b500      	push	{lr}
  206ab2:	b085      	sub	sp, #20
  206ab4:	9001      	str	r0, [sp, #4]
  206ab6:	9100      	str	r1, [sp, #0]
  dyn_element_t *dep;

  chDbgCheck(name != NULL);

  /* Checking if an object with this name has already been created.*/
  dep = dyn_list_find(name, dlp);
  206ab8:	9900      	ldr	r1, [sp, #0]
  206aba:	9801      	ldr	r0, [sp, #4]
  206abc:	f7ff fef8 	bl	2068b0 <dyn_list_find>
  206ac0:	9003      	str	r0, [sp, #12]
  if (dep != NULL) {
  206ac2:	9b03      	ldr	r3, [sp, #12]
  206ac4:	2b00      	cmp	r3, #0
  206ac6:	d004      	beq.n	206ad2 <dyn_find_object+0x22>
    /* Increasing references counter.*/
    dep->refs++;
  206ac8:	9b03      	ldr	r3, [sp, #12]
  206aca:	685b      	ldr	r3, [r3, #4]
  206acc:	1c5a      	adds	r2, r3, #1
  206ace:	9b03      	ldr	r3, [sp, #12]
  206ad0:	605a      	str	r2, [r3, #4]
  }

  return dep;
  206ad2:	9b03      	ldr	r3, [sp, #12]
}
  206ad4:	4618      	mov	r0, r3
  206ad6:	b005      	add	sp, #20
  206ad8:	f85d fb04 	ldr.w	pc, [sp], #4
  206adc:	0000      	movs	r0, r0
	...

00206ae0 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
  206ae0:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
  206ae2:	4810      	ldr	r0, [pc, #64]	@ (206b24 <__factory_init+0x44>)
  206ae4:	f7fd f9c4 	bl	203e70 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
  206ae8:	480f      	ldr	r0, [pc, #60]	@ (206b28 <__factory_init+0x48>)
  206aea:	f7ff fed9 	bl	2068a0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
  206aee:	4a0f      	ldr	r2, [pc, #60]	@ (206b2c <__factory_init+0x4c>)
  206af0:	2114      	movs	r1, #20
  206af2:	480f      	ldr	r0, [pc, #60]	@ (206b30 <__factory_init+0x50>)
  206af4:	f7ff fe84 	bl	206800 <chPoolObjectInit.lto_priv.0>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
  206af8:	480e      	ldr	r0, [pc, #56]	@ (206b34 <__factory_init+0x54>)
  206afa:	f7ff fed1 	bl	2068a0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
  206afe:	480e      	ldr	r0, [pc, #56]	@ (206b38 <__factory_init+0x58>)
  206b00:	f7ff fece 	bl	2068a0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
  206b04:	4a09      	ldr	r2, [pc, #36]	@ (206b2c <__factory_init+0x4c>)
  206b06:	211c      	movs	r1, #28
  206b08:	480c      	ldr	r0, [pc, #48]	@ (206b3c <__factory_init+0x5c>)
  206b0a:	f7ff fe79 	bl	206800 <chPoolObjectInit.lto_priv.0>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
  206b0e:	480c      	ldr	r0, [pc, #48]	@ (206b40 <__factory_init+0x60>)
  206b10:	f7ff fec6 	bl	2068a0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
  206b14:	480b      	ldr	r0, [pc, #44]	@ (206b44 <__factory_init+0x64>)
  206b16:	f7ff fec3 	bl	2068a0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
  206b1a:	480b      	ldr	r0, [pc, #44]	@ (206b48 <__factory_init+0x68>)
  206b1c:	f7ff fec0 	bl	2068a0 <dyn_list_init>
#endif
}
  206b20:	bf00      	nop
  206b22:	bd08      	pop	{r3, pc}
  206b24:	20000b6c 	.word	0x20000b6c
  206b28:	20000b7c 	.word	0x20000b7c
  206b2c:	002067e1 	.word	0x002067e1
  206b30:	20000b80 	.word	0x20000b80
  206b34:	20000b90 	.word	0x20000b90
  206b38:	20000b94 	.word	0x20000b94
  206b3c:	20000b98 	.word	0x20000b98
  206b40:	20000ba8 	.word	0x20000ba8
  206b44:	20000bac 	.word	0x20000bac
  206b48:	20000bb0 	.word	0x20000bb0
  206b4c:	00000000 	.word	0x00000000

00206b50 <chFactoryRegisterObject>:
 *                      a registered object with the same name exists.
 *
 * @api
 */
registered_object_t *chFactoryRegisterObject(const char *name,
                                             void *objp) {
  206b50:	b500      	push	{lr}
  206b52:	b085      	sub	sp, #20
  206b54:	9001      	str	r0, [sp, #4]
  206b56:	9100      	str	r1, [sp, #0]
  registered_object_t *rop;

  FACTORY_LOCK();
  206b58:	480b      	ldr	r0, [pc, #44]	@ (206b88 <chFactoryRegisterObject+0x38>)
  206b5a:	f7fd f999 	bl	203e90 <chMtxLock>

  rop = (registered_object_t *)dyn_create_object_pool(name,
  206b5e:	4a0b      	ldr	r2, [pc, #44]	@ (206b8c <chFactoryRegisterObject+0x3c>)
  206b60:	490b      	ldr	r1, [pc, #44]	@ (206b90 <chFactoryRegisterObject+0x40>)
  206b62:	9801      	ldr	r0, [sp, #4]
  206b64:	f7ff ff4c 	bl	206a00 <dyn_create_object_pool>
  206b68:	9003      	str	r0, [sp, #12]
                                                      &ch_factory.obj_list,
                                                      &ch_factory.obj_pool);
  if (rop != NULL) {
  206b6a:	9b03      	ldr	r3, [sp, #12]
  206b6c:	2b00      	cmp	r3, #0
  206b6e:	d002      	beq.n	206b76 <chFactoryRegisterObject+0x26>
    /* Initializing registered object data.*/
    rop->objp = objp;
  206b70:	9b03      	ldr	r3, [sp, #12]
  206b72:	9a00      	ldr	r2, [sp, #0]
  206b74:	611a      	str	r2, [r3, #16]
  }

  FACTORY_UNLOCK();
  206b76:	4804      	ldr	r0, [pc, #16]	@ (206b88 <chFactoryRegisterObject+0x38>)
  206b78:	f7fd fa3a 	bl	203ff0 <chMtxUnlock>

  return rop;
  206b7c:	9b03      	ldr	r3, [sp, #12]
}
  206b7e:	4618      	mov	r0, r3
  206b80:	b005      	add	sp, #20
  206b82:	f85d fb04 	ldr.w	pc, [sp], #4
  206b86:	bf00      	nop
  206b88:	20000b6c 	.word	0x20000b6c
  206b8c:	20000b80 	.word	0x20000b80
  206b90:	20000b7c 	.word	0x20000b7c
	...

00206ba0 <chFactoryFindObject>:
 * @retval NULL         if a registered object with the specified name
 *                      does not exist.
 *
 * @api
 */
registered_object_t *chFactoryFindObject(const char *name) {
  206ba0:	b500      	push	{lr}
  206ba2:	b085      	sub	sp, #20
  206ba4:	9001      	str	r0, [sp, #4]
  registered_object_t *rop;

  FACTORY_LOCK();
  206ba6:	4808      	ldr	r0, [pc, #32]	@ (206bc8 <chFactoryFindObject+0x28>)
  206ba8:	f7fd f972 	bl	203e90 <chMtxLock>

  rop = (registered_object_t *)dyn_find_object(name, &ch_factory.obj_list);
  206bac:	4907      	ldr	r1, [pc, #28]	@ (206bcc <chFactoryFindObject+0x2c>)
  206bae:	9801      	ldr	r0, [sp, #4]
  206bb0:	f7ff ff7e 	bl	206ab0 <dyn_find_object>
  206bb4:	9003      	str	r0, [sp, #12]

  FACTORY_UNLOCK();
  206bb6:	4804      	ldr	r0, [pc, #16]	@ (206bc8 <chFactoryFindObject+0x28>)
  206bb8:	f7fd fa1a 	bl	203ff0 <chMtxUnlock>

  return rop;
  206bbc:	9b03      	ldr	r3, [sp, #12]
}
  206bbe:	4618      	mov	r0, r3
  206bc0:	b005      	add	sp, #20
  206bc2:	f85d fb04 	ldr.w	pc, [sp], #4
  206bc6:	bf00      	nop
  206bc8:	20000b6c 	.word	0x20000b6c
  206bcc:	20000b7c 	.word	0x20000b7c

00206bd0 <chFactoryReleaseObject>:
 *                      release.
 * @retval 0		    if the object has been released.
 *
 * @api
 */
ucnt_t chFactoryReleaseObject(registered_object_t *rop) {
  206bd0:	b500      	push	{lr}
  206bd2:	b085      	sub	sp, #20
  206bd4:	9001      	str	r0, [sp, #4]
  ucnt_t refs;

  FACTORY_LOCK();
  206bd6:	4809      	ldr	r0, [pc, #36]	@ (206bfc <chFactoryReleaseObject+0x2c>)
  206bd8:	f7fd f95a 	bl	203e90 <chMtxLock>

  refs = dyn_release_object_pool(&rop->element,
  206bdc:	9b01      	ldr	r3, [sp, #4]
  206bde:	4a08      	ldr	r2, [pc, #32]	@ (206c00 <chFactoryReleaseObject+0x30>)
  206be0:	4908      	ldr	r1, [pc, #32]	@ (206c04 <chFactoryReleaseObject+0x34>)
  206be2:	4618      	mov	r0, r3
  206be4:	f7ff ff3c 	bl	206a60 <dyn_release_object_pool>
  206be8:	9003      	str	r0, [sp, #12]
                                 &ch_factory.obj_list,
                                 &ch_factory.obj_pool);

  FACTORY_UNLOCK();
  206bea:	4804      	ldr	r0, [pc, #16]	@ (206bfc <chFactoryReleaseObject+0x2c>)
  206bec:	f7fd fa00 	bl	203ff0 <chMtxUnlock>

  return refs;
  206bf0:	9b03      	ldr	r3, [sp, #12]
}
  206bf2:	4618      	mov	r0, r3
  206bf4:	b005      	add	sp, #20
  206bf6:	f85d fb04 	ldr.w	pc, [sp], #4
  206bfa:	bf00      	nop
  206bfc:	20000b6c 	.word	0x20000b6c
  206c00:	20000b80 	.word	0x20000b80
  206c04:	20000b7c 	.word	0x20000b7c
	...

00206c10 <chFactoryCreateBuffer>:
 * @retval NULL         if the dynamic buffer object cannot be allocated or
 *                      a dynamic buffer object with the same name exists.
 *
 * @api
 */
dyn_buffer_t *chFactoryCreateBuffer(const char *name, size_t size) {
  206c10:	b500      	push	{lr}
  206c12:	b085      	sub	sp, #20
  206c14:	9001      	str	r0, [sp, #4]
  206c16:	9100      	str	r1, [sp, #0]
  dyn_buffer_t *dbp;

  FACTORY_LOCK();
  206c18:	480e      	ldr	r0, [pc, #56]	@ (206c54 <chFactoryCreateBuffer+0x44>)
  206c1a:	f7fd f939 	bl	203e90 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_create_object_heap(name,
  206c1e:	9b00      	ldr	r3, [sp, #0]
  206c20:	f103 0210 	add.w	r2, r3, #16
  206c24:	2308      	movs	r3, #8
  206c26:	490c      	ldr	r1, [pc, #48]	@ (206c58 <chFactoryCreateBuffer+0x48>)
  206c28:	9801      	ldr	r0, [sp, #4]
  206c2a:	f7ff fe91 	bl	206950 <dyn_create_object_heap>
  206c2e:	9003      	str	r0, [sp, #12]
                                               &ch_factory.buf_list,
                                               sizeof (dyn_buffer_t) + size,
                                               CH_HEAP_ALIGNMENT);
  if (dbp != NULL) {
  206c30:	9b03      	ldr	r3, [sp, #12]
  206c32:	2b00      	cmp	r3, #0
  206c34:	d006      	beq.n	206c44 <chFactoryCreateBuffer+0x34>
    /* Initializing buffer object data.*/
    memset((void *)(dbp + 1), 0, size);
  206c36:	9b03      	ldr	r3, [sp, #12]
  206c38:	3310      	adds	r3, #16
  206c3a:	9a00      	ldr	r2, [sp, #0]
  206c3c:	2100      	movs	r1, #0
  206c3e:	4618      	mov	r0, r3
  206c40:	f7f9 fb8a 	bl	200358 <memset>
  }

  FACTORY_UNLOCK();
  206c44:	4803      	ldr	r0, [pc, #12]	@ (206c54 <chFactoryCreateBuffer+0x44>)
  206c46:	f7fd f9d3 	bl	203ff0 <chMtxUnlock>

  return dbp;
  206c4a:	9b03      	ldr	r3, [sp, #12]
}
  206c4c:	4618      	mov	r0, r3
  206c4e:	b005      	add	sp, #20
  206c50:	f85d fb04 	ldr.w	pc, [sp], #4
  206c54:	20000b6c 	.word	0x20000b6c
  206c58:	20000b90 	.word	0x20000b90
  206c5c:	00000000 	.word	0x00000000

00206c60 <chFactoryFindBuffer>:
 * @retval NULL         if a dynamic buffer object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_buffer_t *chFactoryFindBuffer(const char *name) {
  206c60:	b500      	push	{lr}
  206c62:	b085      	sub	sp, #20
  206c64:	9001      	str	r0, [sp, #4]
  dyn_buffer_t *dbp;

  FACTORY_LOCK();
  206c66:	4808      	ldr	r0, [pc, #32]	@ (206c88 <chFactoryFindBuffer+0x28>)
  206c68:	f7fd f912 	bl	203e90 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_find_object(name, &ch_factory.buf_list);
  206c6c:	4907      	ldr	r1, [pc, #28]	@ (206c8c <chFactoryFindBuffer+0x2c>)
  206c6e:	9801      	ldr	r0, [sp, #4]
  206c70:	f7ff ff1e 	bl	206ab0 <dyn_find_object>
  206c74:	9003      	str	r0, [sp, #12]

  FACTORY_UNLOCK();
  206c76:	4804      	ldr	r0, [pc, #16]	@ (206c88 <chFactoryFindBuffer+0x28>)
  206c78:	f7fd f9ba 	bl	203ff0 <chMtxUnlock>

  return dbp;
  206c7c:	9b03      	ldr	r3, [sp, #12]
}
  206c7e:	4618      	mov	r0, r3
  206c80:	b005      	add	sp, #20
  206c82:	f85d fb04 	ldr.w	pc, [sp], #4
  206c86:	bf00      	nop
  206c88:	20000b6c 	.word	0x20000b6c
  206c8c:	20000b90 	.word	0x20000b90

00206c90 <chFactoryReleaseBuffer>:
 *                      release.
 * @retval 0            if the object has been released.
 *
 * @api
 */
ucnt_t chFactoryReleaseBuffer(dyn_buffer_t *dbp) {
  206c90:	b500      	push	{lr}
  206c92:	b085      	sub	sp, #20
  206c94:	9001      	str	r0, [sp, #4]
  ucnt_t refs;

  FACTORY_LOCK();
  206c96:	4808      	ldr	r0, [pc, #32]	@ (206cb8 <chFactoryReleaseBuffer+0x28>)
  206c98:	f7fd f8fa 	bl	203e90 <chMtxLock>

  refs = dyn_release_object_heap(&dbp->element, &ch_factory.buf_list);
  206c9c:	9b01      	ldr	r3, [sp, #4]
  206c9e:	4907      	ldr	r1, [pc, #28]	@ (206cbc <chFactoryReleaseBuffer+0x2c>)
  206ca0:	4618      	mov	r0, r3
  206ca2:	f7ff fe85 	bl	2069b0 <dyn_release_object_heap>
  206ca6:	9003      	str	r0, [sp, #12]

  FACTORY_UNLOCK();
  206ca8:	4803      	ldr	r0, [pc, #12]	@ (206cb8 <chFactoryReleaseBuffer+0x28>)
  206caa:	f7fd f9a1 	bl	203ff0 <chMtxUnlock>

  return refs;
  206cae:	9b03      	ldr	r3, [sp, #12]
}
  206cb0:	4618      	mov	r0, r3
  206cb2:	b005      	add	sp, #20
  206cb4:	f85d fb04 	ldr.w	pc, [sp], #4
  206cb8:	20000b6c 	.word	0x20000b6c
  206cbc:	20000b90 	.word	0x20000b90

00206cc0 <chFactoryCreateSemaphore>:
 * @retval NULL         if the dynamic semaphore object cannot be allocated or
 *                      a dynamic semaphore with the same name exists.
 *
 * @api
 */
dyn_semaphore_t *chFactoryCreateSemaphore(const char *name, cnt_t n) {
  206cc0:	b500      	push	{lr}
  206cc2:	b085      	sub	sp, #20
  206cc4:	9001      	str	r0, [sp, #4]
  206cc6:	9100      	str	r1, [sp, #0]
  dyn_semaphore_t *dsp;

  FACTORY_LOCK();
  206cc8:	480c      	ldr	r0, [pc, #48]	@ (206cfc <chFactoryCreateSemaphore+0x3c>)
  206cca:	f7fd f8e1 	bl	203e90 <chMtxLock>

  dsp = (dyn_semaphore_t *)dyn_create_object_pool(name,
  206cce:	4a0c      	ldr	r2, [pc, #48]	@ (206d00 <chFactoryCreateSemaphore+0x40>)
  206cd0:	490c      	ldr	r1, [pc, #48]	@ (206d04 <chFactoryCreateSemaphore+0x44>)
  206cd2:	9801      	ldr	r0, [sp, #4]
  206cd4:	f7ff fe94 	bl	206a00 <dyn_create_object_pool>
  206cd8:	9003      	str	r0, [sp, #12]
                                                  &ch_factory.sem_list,
                                                  &ch_factory.sem_pool);
  if (dsp != NULL) {
  206cda:	9b03      	ldr	r3, [sp, #12]
  206cdc:	2b00      	cmp	r3, #0
  206cde:	d005      	beq.n	206cec <chFactoryCreateSemaphore+0x2c>
    /* Initializing semaphore object dataa.*/
    chSemObjectInit(&dsp->sem, n);
  206ce0:	9b03      	ldr	r3, [sp, #12]
  206ce2:	3310      	adds	r3, #16
  206ce4:	9900      	ldr	r1, [sp, #0]
  206ce6:	4618      	mov	r0, r3
  206ce8:	f7fc fe9a 	bl	203a20 <chSemObjectInit>
  }

  FACTORY_UNLOCK();
  206cec:	4803      	ldr	r0, [pc, #12]	@ (206cfc <chFactoryCreateSemaphore+0x3c>)
  206cee:	f7fd f97f 	bl	203ff0 <chMtxUnlock>

  return dsp;
  206cf2:	9b03      	ldr	r3, [sp, #12]
}
  206cf4:	4618      	mov	r0, r3
  206cf6:	b005      	add	sp, #20
  206cf8:	f85d fb04 	ldr.w	pc, [sp], #4
  206cfc:	20000b6c 	.word	0x20000b6c
  206d00:	20000b98 	.word	0x20000b98
  206d04:	20000b94 	.word	0x20000b94
	...

00206d10 <chFactoryFindSemaphore>:
 * @retval NULL         if a dynamic semaphore object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_semaphore_t *chFactoryFindSemaphore(const char *name) {
  206d10:	b500      	push	{lr}
  206d12:	b085      	sub	sp, #20
  206d14:	9001      	str	r0, [sp, #4]
  dyn_semaphore_t *dsp;

  FACTORY_LOCK();
  206d16:	4808      	ldr	r0, [pc, #32]	@ (206d38 <chFactoryFindSemaphore+0x28>)
  206d18:	f7fd f8ba 	bl	203e90 <chMtxLock>

  dsp = (dyn_semaphore_t *)dyn_find_object(name, &ch_factory.sem_list);
  206d1c:	4907      	ldr	r1, [pc, #28]	@ (206d3c <chFactoryFindSemaphore+0x2c>)
  206d1e:	9801      	ldr	r0, [sp, #4]
  206d20:	f7ff fec6 	bl	206ab0 <dyn_find_object>
  206d24:	9003      	str	r0, [sp, #12]

  FACTORY_UNLOCK();
  206d26:	4804      	ldr	r0, [pc, #16]	@ (206d38 <chFactoryFindSemaphore+0x28>)
  206d28:	f7fd f962 	bl	203ff0 <chMtxUnlock>

  return dsp;
  206d2c:	9b03      	ldr	r3, [sp, #12]
}
  206d2e:	4618      	mov	r0, r3
  206d30:	b005      	add	sp, #20
  206d32:	f85d fb04 	ldr.w	pc, [sp], #4
  206d36:	bf00      	nop
  206d38:	20000b6c 	.word	0x20000b6c
  206d3c:	20000b94 	.word	0x20000b94

00206d40 <chFactoryReleaseSemaphore>:
 *                      release.
 * @retval 0            if the object has been released.
 *
 * @api
 */
ucnt_t chFactoryReleaseSemaphore(dyn_semaphore_t *dsp) {
  206d40:	b500      	push	{lr}
  206d42:	b085      	sub	sp, #20
  206d44:	9001      	str	r0, [sp, #4]
  ucnt_t refs;

  FACTORY_LOCK();
  206d46:	4809      	ldr	r0, [pc, #36]	@ (206d6c <chFactoryReleaseSemaphore+0x2c>)
  206d48:	f7fd f8a2 	bl	203e90 <chMtxLock>

  refs = dyn_release_object_pool(&dsp->element,
  206d4c:	9b01      	ldr	r3, [sp, #4]
  206d4e:	4a08      	ldr	r2, [pc, #32]	@ (206d70 <chFactoryReleaseSemaphore+0x30>)
  206d50:	4908      	ldr	r1, [pc, #32]	@ (206d74 <chFactoryReleaseSemaphore+0x34>)
  206d52:	4618      	mov	r0, r3
  206d54:	f7ff fe84 	bl	206a60 <dyn_release_object_pool>
  206d58:	9003      	str	r0, [sp, #12]
                                 &ch_factory.sem_list,
                                 &ch_factory.sem_pool);

  FACTORY_UNLOCK();
  206d5a:	4804      	ldr	r0, [pc, #16]	@ (206d6c <chFactoryReleaseSemaphore+0x2c>)
  206d5c:	f7fd f948 	bl	203ff0 <chMtxUnlock>

  return refs;
  206d60:	9b03      	ldr	r3, [sp, #12]
}
  206d62:	4618      	mov	r0, r3
  206d64:	b005      	add	sp, #20
  206d66:	f85d fb04 	ldr.w	pc, [sp], #4
  206d6a:	bf00      	nop
  206d6c:	20000b6c 	.word	0x20000b6c
  206d70:	20000b98 	.word	0x20000b98
  206d74:	20000b94 	.word	0x20000b94
	...

00206d80 <chFactoryCreateMailbox>:
 * @retval NULL         if the dynamic mailbox object cannot be allocated or
 *                      a dynamic mailbox object with the same name exists.
 *
 * @api
 */
dyn_mailbox_t *chFactoryCreateMailbox(const char *name, size_t n) {
  206d80:	b500      	push	{lr}
  206d82:	b085      	sub	sp, #20
  206d84:	9001      	str	r0, [sp, #4]
  206d86:	9100      	str	r1, [sp, #0]
  dyn_mailbox_t *dmp;

  FACTORY_LOCK();
  206d88:	480f      	ldr	r0, [pc, #60]	@ (206dc8 <chFactoryCreateMailbox+0x48>)
  206d8a:	f7fd f881 	bl	203e90 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_create_object_heap(name,
                                                &ch_factory.mbx_list,
                                                sizeof (dyn_mailbox_t) +
  206d8e:	9b00      	ldr	r3, [sp, #0]
  206d90:	330e      	adds	r3, #14
  dmp = (dyn_mailbox_t *)dyn_create_object_heap(name,
  206d92:	009a      	lsls	r2, r3, #2
  206d94:	2308      	movs	r3, #8
  206d96:	490d      	ldr	r1, [pc, #52]	@ (206dcc <chFactoryCreateMailbox+0x4c>)
  206d98:	9801      	ldr	r0, [sp, #4]
  206d9a:	f7ff fdd9 	bl	206950 <dyn_create_object_heap>
  206d9e:	9003      	str	r0, [sp, #12]
                                                (n * sizeof (msg_t)),
                                                CH_HEAP_ALIGNMENT);
  if (dmp != NULL) {
  206da0:	9b03      	ldr	r3, [sp, #12]
  206da2:	2b00      	cmp	r3, #0
  206da4:	d008      	beq.n	206db8 <chFactoryCreateMailbox+0x38>
    /* Initializing mailbox object data.*/
    chMBObjectInit(&dmp->mbx, (msg_t *)(dmp + 1), n);
  206da6:	9b03      	ldr	r3, [sp, #12]
  206da8:	f103 0010 	add.w	r0, r3, #16
  206dac:	9b03      	ldr	r3, [sp, #12]
  206dae:	3338      	adds	r3, #56	@ 0x38
  206db0:	9a00      	ldr	r2, [sp, #0]
  206db2:	4619      	mov	r1, r3
  206db4:	f7fe f8b4 	bl	204f20 <chMBObjectInit>
  }

  FACTORY_UNLOCK();
  206db8:	4803      	ldr	r0, [pc, #12]	@ (206dc8 <chFactoryCreateMailbox+0x48>)
  206dba:	f7fd f919 	bl	203ff0 <chMtxUnlock>

  return dmp;
  206dbe:	9b03      	ldr	r3, [sp, #12]
}
  206dc0:	4618      	mov	r0, r3
  206dc2:	b005      	add	sp, #20
  206dc4:	f85d fb04 	ldr.w	pc, [sp], #4
  206dc8:	20000b6c 	.word	0x20000b6c
  206dcc:	20000ba8 	.word	0x20000ba8

00206dd0 <chFactoryFindMailbox>:
 * @retval NULL         if a dynamic mailbox object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_mailbox_t *chFactoryFindMailbox(const char *name) {
  206dd0:	b500      	push	{lr}
  206dd2:	b085      	sub	sp, #20
  206dd4:	9001      	str	r0, [sp, #4]
  dyn_mailbox_t *dmp;

  FACTORY_LOCK();
  206dd6:	4808      	ldr	r0, [pc, #32]	@ (206df8 <chFactoryFindMailbox+0x28>)
  206dd8:	f7fd f85a 	bl	203e90 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_find_object(name, &ch_factory.mbx_list);
  206ddc:	4907      	ldr	r1, [pc, #28]	@ (206dfc <chFactoryFindMailbox+0x2c>)
  206dde:	9801      	ldr	r0, [sp, #4]
  206de0:	f7ff fe66 	bl	206ab0 <dyn_find_object>
  206de4:	9003      	str	r0, [sp, #12]

  FACTORY_UNLOCK();
  206de6:	4804      	ldr	r0, [pc, #16]	@ (206df8 <chFactoryFindMailbox+0x28>)
  206de8:	f7fd f902 	bl	203ff0 <chMtxUnlock>

  return dmp;
  206dec:	9b03      	ldr	r3, [sp, #12]
}
  206dee:	4618      	mov	r0, r3
  206df0:	b005      	add	sp, #20
  206df2:	f85d fb04 	ldr.w	pc, [sp], #4
  206df6:	bf00      	nop
  206df8:	20000b6c 	.word	0x20000b6c
  206dfc:	20000ba8 	.word	0x20000ba8

00206e00 <chFactoryReleaseMailbox>:
 *                      release.
 * @retval 0            if the object has been released.
 *
 * @api
 */
ucnt_t chFactoryReleaseMailbox(dyn_mailbox_t *dmp) {
  206e00:	b500      	push	{lr}
  206e02:	b085      	sub	sp, #20
  206e04:	9001      	str	r0, [sp, #4]
  ucnt_t refs;

  FACTORY_LOCK();
  206e06:	4808      	ldr	r0, [pc, #32]	@ (206e28 <chFactoryReleaseMailbox+0x28>)
  206e08:	f7fd f842 	bl	203e90 <chMtxLock>

  refs = dyn_release_object_heap(&dmp->element, &ch_factory.mbx_list);
  206e0c:	9b01      	ldr	r3, [sp, #4]
  206e0e:	4907      	ldr	r1, [pc, #28]	@ (206e2c <chFactoryReleaseMailbox+0x2c>)
  206e10:	4618      	mov	r0, r3
  206e12:	f7ff fdcd 	bl	2069b0 <dyn_release_object_heap>
  206e16:	9003      	str	r0, [sp, #12]

  FACTORY_UNLOCK();
  206e18:	4803      	ldr	r0, [pc, #12]	@ (206e28 <chFactoryReleaseMailbox+0x28>)
  206e1a:	f7fd f8e9 	bl	203ff0 <chMtxUnlock>

  return refs;
  206e1e:	9b03      	ldr	r3, [sp, #12]
}
  206e20:	4618      	mov	r0, r3
  206e22:	b005      	add	sp, #20
  206e24:	f85d fb04 	ldr.w	pc, [sp], #4
  206e28:	20000b6c 	.word	0x20000b6c
  206e2c:	20000ba8 	.word	0x20000ba8

00206e30 <chFactoryCreateObjectsFIFO>:
 * @api
 */
dyn_objects_fifo_t *chFactoryCreateObjectsFIFO(const char *name,
                                               size_t objsize,
                                               size_t objn,
                                               unsigned objalign) {
  206e30:	b500      	push	{lr}
  206e32:	b08d      	sub	sp, #52	@ 0x34
  206e34:	9005      	str	r0, [sp, #20]
  206e36:	9104      	str	r1, [sp, #16]
  206e38:	9203      	str	r2, [sp, #12]
  206e3a:	9302      	str	r3, [sp, #8]
  size_t size1, size2;
  dyn_objects_fifo_t *dofp;

  FACTORY_LOCK();
  206e3c:	4820      	ldr	r0, [pc, #128]	@ (206ec0 <chFactoryCreateObjectsFIFO+0x90>)
  206e3e:	f7fd f827 	bl	203e90 <chMtxLock>

  /* Enforcing alignment for the objects array.*/
  objsize = MEM_ALIGN_NEXT(objsize, objalign);
  206e42:	9a02      	ldr	r2, [sp, #8]
  206e44:	9b04      	ldr	r3, [sp, #16]
  206e46:	4413      	add	r3, r2
  206e48:	1e5a      	subs	r2, r3, #1
  206e4a:	9b02      	ldr	r3, [sp, #8]
  206e4c:	425b      	negs	r3, r3
  206e4e:	4013      	ands	r3, r2
  206e50:	9304      	str	r3, [sp, #16]
  size1   = MEM_ALIGN_NEXT(sizeof (dyn_objects_fifo_t) + (objn * sizeof (msg_t)),
  206e52:	9b03      	ldr	r3, [sp, #12]
  206e54:	3315      	adds	r3, #21
  206e56:	009a      	lsls	r2, r3, #2
  206e58:	9b02      	ldr	r3, [sp, #8]
  206e5a:	4413      	add	r3, r2
  206e5c:	1e5a      	subs	r2, r3, #1
  206e5e:	9b02      	ldr	r3, [sp, #8]
  206e60:	425b      	negs	r3, r3
  206e62:	4013      	ands	r3, r2
  206e64:	930b      	str	r3, [sp, #44]	@ 0x2c
                           objalign);
  size2   = objn * objsize;
  206e66:	9b03      	ldr	r3, [sp, #12]
  206e68:	9a04      	ldr	r2, [sp, #16]
  206e6a:	fb02 f303 	mul.w	r3, r2, r3
  206e6e:	930a      	str	r3, [sp, #40]	@ 0x28

  /* Allocating the FIFO object with messages buffer and objects buffer.*/
  dofp = (dyn_objects_fifo_t *)dyn_create_object_heap(name,
  206e70:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
  206e72:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  206e74:	441a      	add	r2, r3
  206e76:	9b02      	ldr	r3, [sp, #8]
  206e78:	4912      	ldr	r1, [pc, #72]	@ (206ec4 <chFactoryCreateObjectsFIFO+0x94>)
  206e7a:	9805      	ldr	r0, [sp, #20]
  206e7c:	f7ff fd68 	bl	206950 <dyn_create_object_heap>
  206e80:	9009      	str	r0, [sp, #36]	@ 0x24
                                                      &ch_factory.fifo_list,
                                                      size1 + size2,
                                                      objalign);
  if (dofp != NULL) {
  206e82:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  206e84:	2b00      	cmp	r3, #0
  206e86:	d012      	beq.n	206eae <chFactoryCreateObjectsFIFO+0x7e>
    msg_t *msgbuf = (msg_t *)(dofp + 1);
  206e88:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  206e8a:	3354      	adds	r3, #84	@ 0x54
  206e8c:	9308      	str	r3, [sp, #32]
    uint8_t *objbuf = (uint8_t *)dofp + size1;
  206e8e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  206e90:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  206e92:	4413      	add	r3, r2
  206e94:	9307      	str	r3, [sp, #28]

    /* Initializing mailbox object data.*/
    chFifoObjectInitAligned(&dofp->fifo, objsize, objn, objalign,
  206e96:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  206e98:	f103 0010 	add.w	r0, r3, #16
  206e9c:	9b08      	ldr	r3, [sp, #32]
  206e9e:	9301      	str	r3, [sp, #4]
  206ea0:	9b07      	ldr	r3, [sp, #28]
  206ea2:	9300      	str	r3, [sp, #0]
  206ea4:	9b02      	ldr	r3, [sp, #8]
  206ea6:	9a03      	ldr	r2, [sp, #12]
  206ea8:	9904      	ldr	r1, [sp, #16]
  206eaa:	f7ff fcb9 	bl	206820 <chFifoObjectInitAligned>
                            (void *)objbuf, msgbuf);
  }

  FACTORY_UNLOCK();
  206eae:	4804      	ldr	r0, [pc, #16]	@ (206ec0 <chFactoryCreateObjectsFIFO+0x90>)
  206eb0:	f7fd f89e 	bl	203ff0 <chMtxUnlock>

  return dofp;
  206eb4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
}
  206eb6:	4618      	mov	r0, r3
  206eb8:	b00d      	add	sp, #52	@ 0x34
  206eba:	f85d fb04 	ldr.w	pc, [sp], #4
  206ebe:	bf00      	nop
  206ec0:	20000b6c 	.word	0x20000b6c
  206ec4:	20000bac 	.word	0x20000bac
	...

00206ed0 <chFactoryFindObjectsFIFO>:
 * @retval NULL         if a dynamic "objects FIFO" object with the specified
 *                      name does not exist.
 *
 * @api
 */
dyn_objects_fifo_t *chFactoryFindObjectsFIFO(const char *name) {
  206ed0:	b500      	push	{lr}
  206ed2:	b085      	sub	sp, #20
  206ed4:	9001      	str	r0, [sp, #4]
  dyn_objects_fifo_t *dofp;

  FACTORY_LOCK();
  206ed6:	4808      	ldr	r0, [pc, #32]	@ (206ef8 <chFactoryFindObjectsFIFO+0x28>)
  206ed8:	f7fc ffda 	bl	203e90 <chMtxLock>

  dofp = (dyn_objects_fifo_t *)dyn_find_object(name, &ch_factory.fifo_list);
  206edc:	4907      	ldr	r1, [pc, #28]	@ (206efc <chFactoryFindObjectsFIFO+0x2c>)
  206ede:	9801      	ldr	r0, [sp, #4]
  206ee0:	f7ff fde6 	bl	206ab0 <dyn_find_object>
  206ee4:	9003      	str	r0, [sp, #12]

  FACTORY_UNLOCK();
  206ee6:	4804      	ldr	r0, [pc, #16]	@ (206ef8 <chFactoryFindObjectsFIFO+0x28>)
  206ee8:	f7fd f882 	bl	203ff0 <chMtxUnlock>

  return dofp;
  206eec:	9b03      	ldr	r3, [sp, #12]
}
  206eee:	4618      	mov	r0, r3
  206ef0:	b005      	add	sp, #20
  206ef2:	f85d fb04 	ldr.w	pc, [sp], #4
  206ef6:	bf00      	nop
  206ef8:	20000b6c 	.word	0x20000b6c
  206efc:	20000bac 	.word	0x20000bac

00206f00 <chFactoryReleaseObjectsFIFO>:
 *                      release.
 * @retval 0            if the object has been released.
 *
 * @api
 */
ucnt_t chFactoryReleaseObjectsFIFO(dyn_objects_fifo_t *dofp) {
  206f00:	b500      	push	{lr}
  206f02:	b085      	sub	sp, #20
  206f04:	9001      	str	r0, [sp, #4]
  ucnt_t refs;

  FACTORY_LOCK();
  206f06:	4808      	ldr	r0, [pc, #32]	@ (206f28 <chFactoryReleaseObjectsFIFO+0x28>)
  206f08:	f7fc ffc2 	bl	203e90 <chMtxLock>

  refs = dyn_release_object_heap(&dofp->element, &ch_factory.fifo_list);
  206f0c:	9b01      	ldr	r3, [sp, #4]
  206f0e:	4907      	ldr	r1, [pc, #28]	@ (206f2c <chFactoryReleaseObjectsFIFO+0x2c>)
  206f10:	4618      	mov	r0, r3
  206f12:	f7ff fd4d 	bl	2069b0 <dyn_release_object_heap>
  206f16:	9003      	str	r0, [sp, #12]

  FACTORY_UNLOCK();
  206f18:	4803      	ldr	r0, [pc, #12]	@ (206f28 <chFactoryReleaseObjectsFIFO+0x28>)
  206f1a:	f7fd f869 	bl	203ff0 <chMtxUnlock>

  return refs;
  206f1e:	9b03      	ldr	r3, [sp, #12]
}
  206f20:	4618      	mov	r0, r3
  206f22:	b005      	add	sp, #20
  206f24:	f85d fb04 	ldr.w	pc, [sp], #4
  206f28:	20000b6c 	.word	0x20000b6c
  206f2c:	20000bac 	.word	0x20000bac

00206f30 <chFactoryCreatePipe>:
 *                      allocated or a dynamic pipe object with
 *                      the same name exists.
 *
 * @api
 */
dyn_pipe_t *chFactoryCreatePipe(const char *name, size_t size) {
  206f30:	b500      	push	{lr}
  206f32:	b085      	sub	sp, #20
  206f34:	9001      	str	r0, [sp, #4]
  206f36:	9100      	str	r1, [sp, #0]
  dyn_pipe_t *dpp;

  FACTORY_LOCK();
  206f38:	480f      	ldr	r0, [pc, #60]	@ (206f78 <chFactoryCreatePipe+0x48>)
  206f3a:	f7fc ffa9 	bl	203e90 <chMtxLock>

  dpp = (dyn_pipe_t *)dyn_create_object_heap(name,
  206f3e:	9b00      	ldr	r3, [sp, #0]
  206f40:	f103 0260 	add.w	r2, r3, #96	@ 0x60
  206f44:	2308      	movs	r3, #8
  206f46:	490d      	ldr	r1, [pc, #52]	@ (206f7c <chFactoryCreatePipe+0x4c>)
  206f48:	9801      	ldr	r0, [sp, #4]
  206f4a:	f7ff fd01 	bl	206950 <dyn_create_object_heap>
  206f4e:	9003      	str	r0, [sp, #12]
                                             &ch_factory.pipe_list,
                                             sizeof (dyn_pipe_t) + size,
                                             CH_HEAP_ALIGNMENT);
  if (dpp != NULL) {
  206f50:	9b03      	ldr	r3, [sp, #12]
  206f52:	2b00      	cmp	r3, #0
  206f54:	d008      	beq.n	206f68 <chFactoryCreatePipe+0x38>
    /* Initializing mailbox object data.*/
    chPipeObjectInit(&dpp->pipe, (uint8_t *)(dpp + 1), size);
  206f56:	9b03      	ldr	r3, [sp, #12]
  206f58:	f103 0010 	add.w	r0, r3, #16
  206f5c:	9b03      	ldr	r3, [sp, #12]
  206f5e:	3360      	adds	r3, #96	@ 0x60
  206f60:	9a00      	ldr	r2, [sp, #0]
  206f62:	4619      	mov	r1, r3
  206f64:	f7fe ffa4 	bl	205eb0 <chPipeObjectInit>
  }

  FACTORY_UNLOCK();
  206f68:	4803      	ldr	r0, [pc, #12]	@ (206f78 <chFactoryCreatePipe+0x48>)
  206f6a:	f7fd f841 	bl	203ff0 <chMtxUnlock>

  return dpp;
  206f6e:	9b03      	ldr	r3, [sp, #12]
}
  206f70:	4618      	mov	r0, r3
  206f72:	b005      	add	sp, #20
  206f74:	f85d fb04 	ldr.w	pc, [sp], #4
  206f78:	20000b6c 	.word	0x20000b6c
  206f7c:	20000bb0 	.word	0x20000bb0

00206f80 <chFactoryFindPipe>:
 * @retval NULL         if a dynamic pipe object with the specified
 *                      name does not exist.
 *
 * @api
 */
dyn_pipe_t *chFactoryFindPipe(const char *name) {
  206f80:	b500      	push	{lr}
  206f82:	b085      	sub	sp, #20
  206f84:	9001      	str	r0, [sp, #4]
  dyn_pipe_t *dpp;

  FACTORY_LOCK();
  206f86:	4808      	ldr	r0, [pc, #32]	@ (206fa8 <chFactoryFindPipe+0x28>)
  206f88:	f7fc ff82 	bl	203e90 <chMtxLock>

  dpp = (dyn_pipe_t *)dyn_find_object(name, &ch_factory.pipe_list);
  206f8c:	4907      	ldr	r1, [pc, #28]	@ (206fac <chFactoryFindPipe+0x2c>)
  206f8e:	9801      	ldr	r0, [sp, #4]
  206f90:	f7ff fd8e 	bl	206ab0 <dyn_find_object>
  206f94:	9003      	str	r0, [sp, #12]

  FACTORY_UNLOCK();
  206f96:	4804      	ldr	r0, [pc, #16]	@ (206fa8 <chFactoryFindPipe+0x28>)
  206f98:	f7fd f82a 	bl	203ff0 <chMtxUnlock>

  return dpp;
  206f9c:	9b03      	ldr	r3, [sp, #12]
}
  206f9e:	4618      	mov	r0, r3
  206fa0:	b005      	add	sp, #20
  206fa2:	f85d fb04 	ldr.w	pc, [sp], #4
  206fa6:	bf00      	nop
  206fa8:	20000b6c 	.word	0x20000b6c
  206fac:	20000bb0 	.word	0x20000bb0

00206fb0 <chFactoryReleasePipe>:
 *                      release.
 * @retval 0            if the object has been released.
 *
 * @api
 */
ucnt_t chFactoryReleasePipe(dyn_pipe_t *dpp) {
  206fb0:	b500      	push	{lr}
  206fb2:	b085      	sub	sp, #20
  206fb4:	9001      	str	r0, [sp, #4]
  ucnt_t refs;

  FACTORY_LOCK();
  206fb6:	4808      	ldr	r0, [pc, #32]	@ (206fd8 <chFactoryReleasePipe+0x28>)
  206fb8:	f7fc ff6a 	bl	203e90 <chMtxLock>

  refs = dyn_release_object_heap(&dpp->element, &ch_factory.pipe_list);
  206fbc:	9b01      	ldr	r3, [sp, #4]
  206fbe:	4907      	ldr	r1, [pc, #28]	@ (206fdc <chFactoryReleasePipe+0x2c>)
  206fc0:	4618      	mov	r0, r3
  206fc2:	f7ff fcf5 	bl	2069b0 <dyn_release_object_heap>
  206fc6:	9003      	str	r0, [sp, #12]

  FACTORY_UNLOCK();
  206fc8:	4803      	ldr	r0, [pc, #12]	@ (206fd8 <chFactoryReleasePipe+0x28>)
  206fca:	f7fd f811 	bl	203ff0 <chMtxUnlock>

  return refs;
  206fce:	9b03      	ldr	r3, [sp, #12]
}
  206fd0:	4618      	mov	r0, r3
  206fd2:	b005      	add	sp, #20
  206fd4:	f85d fb04 	ldr.w	pc, [sp], #4
  206fd8:	20000b6c 	.word	0x20000b6c
  206fdc:	20000bb0 	.word	0x20000bb0

00206fe0 <__NVIC_SetPriorityGrouping>:
{
  206fe0:	b084      	sub	sp, #16
  206fe2:	9001      	str	r0, [sp, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
  206fe4:	9b01      	ldr	r3, [sp, #4]
  206fe6:	f003 0307 	and.w	r3, r3, #7
  206fea:	9303      	str	r3, [sp, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  206fec:	4b0a      	ldr	r3, [pc, #40]	@ (207018 <__NVIC_SetPriorityGrouping+0x38>)
  206fee:	68db      	ldr	r3, [r3, #12]
  206ff0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  206ff2:	9a02      	ldr	r2, [sp, #8]
  206ff4:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
  206ff8:	4013      	ands	r3, r2
  206ffa:	9302      	str	r3, [sp, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  206ffc:	9b03      	ldr	r3, [sp, #12]
  206ffe:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
  207000:	9b02      	ldr	r3, [sp, #8]
  207002:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
  207004:	4b05      	ldr	r3, [pc, #20]	@ (20701c <__NVIC_SetPriorityGrouping+0x3c>)
  207006:	4313      	orrs	r3, r2
  207008:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
  20700a:	4a03      	ldr	r2, [pc, #12]	@ (207018 <__NVIC_SetPriorityGrouping+0x38>)
  20700c:	9b02      	ldr	r3, [sp, #8]
  20700e:	60d3      	str	r3, [r2, #12]
}
  207010:	bf00      	nop
  207012:	b004      	add	sp, #16
  207014:	4770      	bx	lr
  207016:	bf00      	nop
  207018:	e000ed00 	.word	0xe000ed00
  20701c:	05fa0000 	.word	0x05fa0000

00207020 <__NVIC_SetPriority>:
{
  207020:	b082      	sub	sp, #8
  207022:	4603      	mov	r3, r0
  207024:	9100      	str	r1, [sp, #0]
  207026:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
  20702a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
  20702e:	2b00      	cmp	r3, #0
  207030:	db0a      	blt.n	207048 <__NVIC_SetPriority+0x28>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  207032:	9b00      	ldr	r3, [sp, #0]
  207034:	b2da      	uxtb	r2, r3
  207036:	490c      	ldr	r1, [pc, #48]	@ (207068 <__NVIC_SetPriority+0x48>)
  207038:	f99d 3007 	ldrsb.w	r3, [sp, #7]
  20703c:	0112      	lsls	r2, r2, #4
  20703e:	b2d2      	uxtb	r2, r2
  207040:	440b      	add	r3, r1
  207042:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
  207046:	e00b      	b.n	207060 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  207048:	9b00      	ldr	r3, [sp, #0]
  20704a:	b2da      	uxtb	r2, r3
  20704c:	4907      	ldr	r1, [pc, #28]	@ (20706c <__NVIC_SetPriority+0x4c>)
  20704e:	f89d 3007 	ldrb.w	r3, [sp, #7]
  207052:	f003 030f 	and.w	r3, r3, #15
  207056:	3b04      	subs	r3, #4
  207058:	0112      	lsls	r2, r2, #4
  20705a:	b2d2      	uxtb	r2, r2
  20705c:	440b      	add	r3, r1
  20705e:	761a      	strb	r2, [r3, #24]
}
  207060:	bf00      	nop
  207062:	b002      	add	sp, #8
  207064:	4770      	bx	lr
  207066:	bf00      	nop
  207068:	e000e100 	.word	0xe000e100
  20706c:	e000ed00 	.word	0xe000ed00

00207070 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch and, optionally, for system calls.
 * @note    The SVC vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
  207070:	b084      	sub	sp, #16
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  207072:	f3ef 8309 	mrs	r3, PSP
  207076:	9300      	str	r3, [sp, #0]
  return(result);
  207078:	9b00      	ldr	r3, [sp, #0]
/*lint -restore*/
  uint32_t psp = __get_PSP();
  20707a:	9303      	str	r3, [sp, #12]

  /* Unstacking procedure, discarding the current exception context and
     positioning the stack to point to the real one.*/
  psp += sizeof (struct port_extctx);
  20707c:	9b03      	ldr	r3, [sp, #12]
  20707e:	3368      	adds	r3, #104	@ 0x68
  207080:	9303      	str	r3, [sp, #12]

#if CORTEX_USE_FPU == TRUE
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
  207082:	4b0b      	ldr	r3, [pc, #44]	@ (2070b0 <SVC_Handler+0x40>)
  207084:	685b      	ldr	r3, [r3, #4]
  207086:	4a0a      	ldr	r2, [pc, #40]	@ (2070b0 <SVC_Handler+0x40>)
  207088:	f023 0301 	bic.w	r3, r3, #1
  20708c:	6053      	str	r3, [r2, #4]
  20708e:	9b03      	ldr	r3, [sp, #12]
  207090:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  207092:	9b01      	ldr	r3, [sp, #4]
  207094:	f383 8809 	msr	PSP, r3
}
  207098:	bf00      	nop
  20709a:	2300      	movs	r3, #0
  20709c:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20709e:	9b02      	ldr	r3, [sp, #8]
  2070a0:	f383 8811 	msr	BASEPRI, r3
}
  2070a4:	bf00      	nop
  2070a6:	bf00      	nop
}
  2070a8:	bf00      	nop
  /* Restoring real position of the original stack frame.*/
  __set_PSP(psp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
  2070aa:	bf00      	nop
  2070ac:	b004      	add	sp, #16
  2070ae:	4770      	bx	lr
  2070b0:	e000ef30 	.word	0xe000ef30
	...

002070c0 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
  2070c0:	b500      	push	{lr}
  2070c2:	b087      	sub	sp, #28
  2070c4:	9001      	str	r0, [sp, #4]
  2070c6:	2330      	movs	r3, #48	@ 0x30
  2070c8:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2070ca:	9b03      	ldr	r3, [sp, #12]
  2070cc:	f383 8811 	msr	BASEPRI, r3
}
  2070d0:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
  2070d2:	b662      	cpsie	i
}
  2070d4:	bf00      	nop
}
  2070d6:	bf00      	nop
  port_suspend();

#if CORTEX_USE_FPU == TRUE
  /* Making sure to use the correct settings for FPU-related exception
     handling, better do not rely on startup settings.*/
  FPU->FPCCR  = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
  2070d8:	4b1b      	ldr	r3, [pc, #108]	@ (207148 <port_init+0x88>)
  2070da:	f04f 4240 	mov.w	r2, #3221225472	@ 0xc0000000
  2070de:	605a      	str	r2, [r3, #4]
  FPU->FPDSCR = 0U;
  2070e0:	4b19      	ldr	r3, [pc, #100]	@ (207148 <port_init+0x88>)
  2070e2:	2200      	movs	r2, #0
  2070e4:	60da      	str	r2, [r3, #12]
  2070e6:	2300      	movs	r3, #0
  2070e8:	9304      	str	r3, [sp, #16]
  __builtin_arm_set_fpscr(fpscr);
  2070ea:	9b04      	ldr	r3, [sp, #16]
  2070ec:	eee1 3a10 	vmsr	fpscr, r3
}
  2070f0:	bf00      	nop
  2070f2:	2306      	movs	r3, #6
  2070f4:	9305      	str	r3, [sp, #20]
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  2070f6:	9b05      	ldr	r3, [sp, #20]
  2070f8:	f383 8814 	msr	CONTROL, r3
}
  2070fc:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
  2070fe:	f3bf 8f6f 	isb	sy
}
  207102:	bf00      	nop
  __set_CONTROL(CONTROL_FPCA_Msk | CONTROL_SPSEL_Msk);
  __ISB();
#endif

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
  207104:	2003      	movs	r0, #3
  207106:	f7ff ff6b 	bl	206fe0 <__NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  20710a:	4b10      	ldr	r3, [pc, #64]	@ (20714c <port_init+0x8c>)
  20710c:	68db      	ldr	r3, [r3, #12]
  20710e:	4a0f      	ldr	r2, [pc, #60]	@ (20714c <port_init+0x8c>)
  207110:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
  207114:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
  207116:	4b0e      	ldr	r3, [pc, #56]	@ (207150 <port_init+0x90>)
  207118:	4a0e      	ldr	r2, [pc, #56]	@ (207154 <port_init+0x94>)
  20711a:	f8c3 2fb0 	str.w	r2, [r3, #4016]	@ 0xfb0
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
  20711e:	4b0c      	ldr	r3, [pc, #48]	@ (207150 <port_init+0x90>)
  207120:	681b      	ldr	r3, [r3, #0]
  207122:	4a0b      	ldr	r2, [pc, #44]	@ (207150 <port_init+0x90>)
  207124:	f043 0301 	orr.w	r3, r3, #1
  207128:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
  20712a:	2102      	movs	r1, #2
  20712c:	f06f 0004 	mvn.w	r0, #4
  207130:	f7ff ff76 	bl	207020 <__NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
  207134:	2103      	movs	r1, #3
  207136:	f06f 0001 	mvn.w	r0, #1
  20713a:	f7ff ff71 	bl	207020 <__NVIC_SetPriority>

#if (PORT_MPU_INITIALIZE == TRUE) || (PORT_ENABLE_GUARD_PAGES == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
  20713e:	bf00      	nop
  207140:	b007      	add	sp, #28
  207142:	f85d fb04 	ldr.w	pc, [sp], #4
  207146:	bf00      	nop
  207148:	e000ef30 	.word	0xe000ef30
  20714c:	e000edf0 	.word	0xe000edf0
  207150:	e0001000 	.word	0xe0001000
  207154:	c5acce55 	.word	0xc5acce55
	...

00207160 <__port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {
  207160:	b500      	push	{lr}
  207162:	b087      	sub	sp, #28
  207164:	2330      	movs	r3, #48	@ 0x30
  207166:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207168:	9b03      	ldr	r3, [sp, #12]
  20716a:	f383 8811 	msr	BASEPRI, r3
}
  20716e:	bf00      	nop
}
  207170:	bf00      	nop
}
  207172:	bf00      	nop

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  207174:	4b1b      	ldr	r3, [pc, #108]	@ (2071e4 <__port_irq_epilogue+0x84>)
  207176:	685b      	ldr	r3, [r3, #4]
  207178:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
  20717c:	2b00      	cmp	r3, #0
  20717e:	d026      	beq.n	2071ce <__port_irq_epilogue+0x6e>
  return __builtin_arm_get_fpscr();
  207180:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  207184:	f3ef 8309 	mrs	r3, PSP
  207188:	9301      	str	r3, [sp, #4]
  return(result);
  20718a:	9b01      	ldr	r3, [sp, #4]
#endif


    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    psp = __get_PSP();
  20718c:	9305      	str	r3, [sp, #20]
    psp -= sizeof (struct port_extctx);
  20718e:	9b05      	ldr	r3, [sp, #20]
  207190:	3b68      	subs	r3, #104	@ 0x68
  207192:	9305      	str	r3, [sp, #20]

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)psp;
  207194:	9b05      	ldr	r3, [sp, #20]
  207196:	9304      	str	r3, [sp, #16]

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
  207198:	9b04      	ldr	r3, [sp, #16]
  20719a:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
  20719e:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ectxp->fpscr = FPU->FPDSCR;
  2071a0:	4b11      	ldr	r3, [pc, #68]	@ (2071e8 <__port_irq_epilogue+0x88>)
  2071a2:	68da      	ldr	r2, [r3, #12]
  2071a4:	9b04      	ldr	r3, [sp, #16]
  2071a6:	661a      	str	r2, [r3, #96]	@ 0x60
  2071a8:	9b05      	ldr	r3, [sp, #20]
  2071aa:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2071ac:	9b02      	ldr	r3, [sp, #8]
  2071ae:	f383 8809 	msr	PSP, r3
}
  2071b2:	bf00      	nop
    /* Writing back the modified S-PSP value.*/
    __set_PSP(psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
  2071b4:	f7fb fd7c 	bl	202cb0 <chSchIsPreemptionRequired>
  2071b8:	4603      	mov	r3, r0
  2071ba:	2b00      	cmp	r3, #0
  2071bc:	d003      	beq.n	2071c6 <__port_irq_epilogue+0x66>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
  2071be:	4a0b      	ldr	r2, [pc, #44]	@ (2071ec <__port_irq_epilogue+0x8c>)
  2071c0:	9b04      	ldr	r3, [sp, #16]
  2071c2:	619a      	str	r2, [r3, #24]
      ectxp->pc = (uint32_t)__port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  2071c4:	e00b      	b.n	2071de <__port_irq_epilogue+0x7e>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
  2071c6:	4a0a      	ldr	r2, [pc, #40]	@ (2071f0 <__port_irq_epilogue+0x90>)
  2071c8:	9b04      	ldr	r3, [sp, #16]
  2071ca:	619a      	str	r2, [r3, #24]
    return;
  2071cc:	e007      	b.n	2071de <__port_irq_epilogue+0x7e>
  2071ce:	2300      	movs	r3, #0
  2071d0:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2071d2:	9b00      	ldr	r3, [sp, #0]
  2071d4:	f383 8811 	msr	BASEPRI, r3
}
  2071d8:	bf00      	nop
}
  2071da:	bf00      	nop
}
  2071dc:	bf00      	nop
  }
  port_unlock_from_isr();
}
  2071de:	b007      	add	sp, #28
  2071e0:	f85d fb04 	ldr.w	pc, [sp], #4
  2071e4:	e000ed00 	.word	0xe000ed00
  2071e8:	e000ef30 	.word	0xe000ef30
  2071ec:	0020034f 	.word	0x0020034f
  2071f0:	00200352 	.word	0x00200352
	...

00207200 <chTimeIsInRangeX.lto_priv.1>:
 *
 * @xclass
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {
  207200:	b084      	sub	sp, #16
  207202:	9003      	str	r0, [sp, #12]
  207204:	9102      	str	r1, [sp, #8]
  207206:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
  207208:	9a03      	ldr	r2, [sp, #12]
  20720a:	9b02      	ldr	r3, [sp, #8]
  20720c:	1ad2      	subs	r2, r2, r3
                (systime_t)((systime_t)end - (systime_t)start));
  20720e:	9901      	ldr	r1, [sp, #4]
  207210:	9b02      	ldr	r3, [sp, #8]
  207212:	1acb      	subs	r3, r1, r3
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
  207214:	429a      	cmp	r2, r3
  207216:	bf34      	ite	cc
  207218:	2301      	movcc	r3, #1
  20721a:	2300      	movcs	r3, #0
  20721c:	b2db      	uxtb	r3, r3
}
  20721e:	4618      	mov	r0, r3
  207220:	b004      	add	sp, #16
  207222:	4770      	bx	lr
	...

00207230 <port_timer_get_time.lto_priv.3>:
static inline systime_t port_timer_get_time(void) {
  207230:	b508      	push	{r3, lr}
  return stGetCounter();
  207232:	f7f9 fb55 	bl	2008e0 <stGetCounter>
  207236:	4603      	mov	r3, r0
}
  207238:	4618      	mov	r0, r3
  20723a:	bd08      	pop	{r3, pc}
  20723c:	0000      	movs	r0, r0
	...

00207240 <chVTGetSystemTimeX.lto_priv.3>:
static inline systime_t chVTGetSystemTimeX(void) {
  207240:	b508      	push	{r3, lr}
  return port_timer_get_time();
  207242:	f7ff fff5 	bl	207230 <port_timer_get_time.lto_priv.3>
  207246:	4603      	mov	r3, r0
}
  207248:	4618      	mov	r0, r3
  20724a:	bd08      	pop	{r3, pc}
  20724c:	0000      	movs	r0, r0
	...

00207250 <osalOsGetSystemTimeX>:
static inline systime_t osalOsGetSystemTimeX(void) {
  207250:	b508      	push	{r3, lr}
  return chVTGetSystemTimeX();
  207252:	f7ff fff5 	bl	207240 <chVTGetSystemTimeX.lto_priv.3>
  207256:	4603      	mov	r3, r0
}
  207258:	4618      	mov	r0, r3
  20725a:	bd08      	pop	{r3, pc}
  20725c:	0000      	movs	r0, r0
	...

00207260 <osalTimeIsInRangeX>:
                                      systime_t end) {
  207260:	b500      	push	{lr}
  207262:	b085      	sub	sp, #20
  207264:	9003      	str	r0, [sp, #12]
  207266:	9102      	str	r1, [sp, #8]
  207268:	9201      	str	r2, [sp, #4]
  return chTimeIsInRangeX(time, start, end);
  20726a:	9a01      	ldr	r2, [sp, #4]
  20726c:	9902      	ldr	r1, [sp, #8]
  20726e:	9803      	ldr	r0, [sp, #12]
  207270:	f7ff ffc6 	bl	207200 <chTimeIsInRangeX.lto_priv.1>
  207274:	4603      	mov	r3, r0
}
  207276:	4618      	mov	r0, r3
  207278:	b005      	add	sp, #20
  20727a:	f85d fb04 	ldr.w	pc, [sp], #4
  20727e:	bf00      	nop

00207280 <osalThreadSleep.lto_priv.1>:
static inline void osalThreadSleep(sysinterval_t delay) {
  207280:	b500      	push	{lr}
  207282:	b083      	sub	sp, #12
  207284:	9001      	str	r0, [sp, #4]
  chThdSleep(delay);
  207286:	9801      	ldr	r0, [sp, #4]
  207288:	f7fc f9b2 	bl	2035f0 <chThdSleep>
}
  20728c:	bf00      	nop
  20728e:	b003      	add	sp, #12
  207290:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002072a0 <test_stream_putchar>:
/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

#if (TEST_CFG_CHIBIOS_SUPPORT == TRUE) || defined(__DOXYGEN__)
static int test_stream_putchar(int c) {
  2072a0:	b500      	push	{lr}
  2072a2:	b083      	sub	sp, #12
  2072a4:	9001      	str	r0, [sp, #4]

  streamPut(chtest.stream, (uint8_t)c);
  2072a6:	4b07      	ldr	r3, [pc, #28]	@ (2072c4 <test_stream_putchar+0x24>)
  2072a8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  2072aa:	681b      	ldr	r3, [r3, #0]
  2072ac:	68db      	ldr	r3, [r3, #12]
  2072ae:	4a05      	ldr	r2, [pc, #20]	@ (2072c4 <test_stream_putchar+0x24>)
  2072b0:	6a52      	ldr	r2, [r2, #36]	@ 0x24
  2072b2:	9901      	ldr	r1, [sp, #4]
  2072b4:	b2c9      	uxtb	r1, r1
  2072b6:	4610      	mov	r0, r2
  2072b8:	4798      	blx	r3

  return c;
  2072ba:	9b01      	ldr	r3, [sp, #4]
}
  2072bc:	4618      	mov	r0, r3
  2072be:	b003      	add	sp, #12
  2072c0:	f85d fb04 	ldr.w	pc, [sp], #4
  2072c4:	20000bb4 	.word	0x20000bb4
	...

002072d0 <test_clear_tokens>:
#endif

static void test_clear_tokens(void) {

  chtest.tokp = chtest.tokens_buffer;
  2072d0:	4b02      	ldr	r3, [pc, #8]	@ (2072dc <test_clear_tokens+0xc>)
  2072d2:	4a03      	ldr	r2, [pc, #12]	@ (2072e0 <test_clear_tokens+0x10>)
  2072d4:	60da      	str	r2, [r3, #12]
}
  2072d6:	bf00      	nop
  2072d8:	4770      	bx	lr
  2072da:	bf00      	nop
  2072dc:	20000bb4 	.word	0x20000bb4
  2072e0:	20000bc4 	.word	0x20000bc4
	...

002072f0 <test_print_tokens>:

static void test_print_tokens(void) {
  2072f0:	b500      	push	{lr}
  2072f2:	b083      	sub	sp, #12
  char *cp = chtest.tokens_buffer;
  2072f4:	4b09      	ldr	r3, [pc, #36]	@ (20731c <test_print_tokens+0x2c>)
  2072f6:	9301      	str	r3, [sp, #4]

  while (cp < chtest.tokp) {
  2072f8:	e006      	b.n	207308 <test_print_tokens+0x18>
    test_putchar(*cp++);
  2072fa:	9b01      	ldr	r3, [sp, #4]
  2072fc:	1c5a      	adds	r2, r3, #1
  2072fe:	9201      	str	r2, [sp, #4]
  207300:	781b      	ldrb	r3, [r3, #0]
  207302:	4618      	mov	r0, r3
  207304:	f000 fa9c 	bl	207840 <test_putchar>
  while (cp < chtest.tokp) {
  207308:	4b05      	ldr	r3, [pc, #20]	@ (207320 <test_print_tokens+0x30>)
  20730a:	68db      	ldr	r3, [r3, #12]
  20730c:	9a01      	ldr	r2, [sp, #4]
  20730e:	429a      	cmp	r2, r3
  207310:	d3f3      	bcc.n	2072fa <test_print_tokens+0xa>
  }
}
  207312:	bf00      	nop
  207314:	bf00      	nop
  207316:	b003      	add	sp, #12
  207318:	f85d fb04 	ldr.w	pc, [sp], #4
  20731c:	20000bc4 	.word	0x20000bc4
  207320:	20000bb4 	.word	0x20000bb4
	...

00207330 <test_execute_case>:

static void test_execute_case(const testcase_t *tcp) {
  207330:	b500      	push	{lr}
  207332:	b083      	sub	sp, #12
  207334:	9001      	str	r0, [sp, #4]

  /* Initialization */
  test_clear_tokens();
  207336:	f7ff ffcb 	bl	2072d0 <test_clear_tokens>
  chtest.local_fail = false;
  20733a:	4b0c      	ldr	r3, [pc, #48]	@ (20736c <test_execute_case+0x3c>)
  20733c:	2200      	movs	r2, #0
  20733e:	715a      	strb	r2, [r3, #5]

  if (tcp->setup != NULL) {
  207340:	9b01      	ldr	r3, [sp, #4]
  207342:	685b      	ldr	r3, [r3, #4]
  207344:	2b00      	cmp	r3, #0
  207346:	d002      	beq.n	20734e <test_execute_case+0x1e>
    tcp->setup();
  207348:	9b01      	ldr	r3, [sp, #4]
  20734a:	685b      	ldr	r3, [r3, #4]
  20734c:	4798      	blx	r3
  }
  tcp->execute();
  20734e:	9b01      	ldr	r3, [sp, #4]
  207350:	68db      	ldr	r3, [r3, #12]
  207352:	4798      	blx	r3
  if (tcp->teardown != NULL) {
  207354:	9b01      	ldr	r3, [sp, #4]
  207356:	689b      	ldr	r3, [r3, #8]
  207358:	2b00      	cmp	r3, #0
  20735a:	d002      	beq.n	207362 <test_execute_case+0x32>
    tcp->teardown();
  20735c:	9b01      	ldr	r3, [sp, #4]
  20735e:	689b      	ldr	r3, [r3, #8]
  207360:	4798      	blx	r3
  }
}
  207362:	bf00      	nop
  207364:	b003      	add	sp, #12
  207366:	f85d fb04 	ldr.w	pc, [sp], #4
  20736a:	bf00      	nop
  20736c:	20000bb4 	.word	0x20000bb4

00207370 <test_print_string>:

static void test_print_string(const char *s) {
  207370:	b500      	push	{lr}
  207372:	b085      	sub	sp, #20
  207374:	9001      	str	r0, [sp, #4]
  char c;

  while ((c = *s) != '\0') {
  207376:	e007      	b.n	207388 <test_print_string+0x18>
    test_putchar(c);
  207378:	f89d 300f 	ldrb.w	r3, [sp, #15]
  20737c:	4618      	mov	r0, r3
  20737e:	f000 fa5f 	bl	207840 <test_putchar>
    s++;
  207382:	9b01      	ldr	r3, [sp, #4]
  207384:	3301      	adds	r3, #1
  207386:	9301      	str	r3, [sp, #4]
  while ((c = *s) != '\0') {
  207388:	9b01      	ldr	r3, [sp, #4]
  20738a:	781b      	ldrb	r3, [r3, #0]
  20738c:	f88d 300f 	strb.w	r3, [sp, #15]
  207390:	f89d 300f 	ldrb.w	r3, [sp, #15]
  207394:	2b00      	cmp	r3, #0
  207396:	d1ef      	bne.n	207378 <test_print_string+0x8>
  }
}
  207398:	bf00      	nop
  20739a:	bf00      	nop
  20739c:	b005      	add	sp, #20
  20739e:	f85d fb04 	ldr.w	pc, [sp], #4
  2073a2:	bf00      	nop
	...

002073b0 <test_print_line>:

static void test_print_line(void) {
  2073b0:	b500      	push	{lr}
  2073b2:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < 76; i++) {
  2073b4:	2300      	movs	r3, #0
  2073b6:	9301      	str	r3, [sp, #4]
  2073b8:	e005      	b.n	2073c6 <test_print_line+0x16>
    test_putchar('-');
  2073ba:	202d      	movs	r0, #45	@ 0x2d
  2073bc:	f000 fa40 	bl	207840 <test_putchar>
  for (i = 0; i < 76; i++) {
  2073c0:	9b01      	ldr	r3, [sp, #4]
  2073c2:	3301      	adds	r3, #1
  2073c4:	9301      	str	r3, [sp, #4]
  2073c6:	9b01      	ldr	r3, [sp, #4]
  2073c8:	2b4b      	cmp	r3, #75	@ 0x4b
  2073ca:	d9f6      	bls.n	2073ba <test_print_line+0xa>
  }
  test_print_string(TEST_CFG_EOL_STRING);
  2073cc:	4803      	ldr	r0, [pc, #12]	@ (2073dc <test_print_line+0x2c>)
  2073ce:	f7ff ffcf 	bl	207370 <test_print_string>
}
  2073d2:	bf00      	nop
  2073d4:	b003      	add	sp, #12
  2073d6:	f85d fb04 	ldr.w	pc, [sp], #4
  2073da:	bf00      	nop
  2073dc:	08010d4c 	.word	0x08010d4c

002073e0 <test_print_fat_line>:

static void test_print_fat_line(void) {
  2073e0:	b500      	push	{lr}
  2073e2:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < 76; i++) {
  2073e4:	2300      	movs	r3, #0
  2073e6:	9301      	str	r3, [sp, #4]
  2073e8:	e005      	b.n	2073f6 <test_print_fat_line+0x16>
    test_putchar('=');
  2073ea:	203d      	movs	r0, #61	@ 0x3d
  2073ec:	f000 fa28 	bl	207840 <test_putchar>
  for (i = 0; i < 76; i++) {
  2073f0:	9b01      	ldr	r3, [sp, #4]
  2073f2:	3301      	adds	r3, #1
  2073f4:	9301      	str	r3, [sp, #4]
  2073f6:	9b01      	ldr	r3, [sp, #4]
  2073f8:	2b4b      	cmp	r3, #75	@ 0x4b
  2073fa:	d9f6      	bls.n	2073ea <test_print_fat_line+0xa>
  }
  test_print_string(TEST_CFG_EOL_STRING);
  2073fc:	4803      	ldr	r0, [pc, #12]	@ (20740c <test_print_fat_line+0x2c>)
  2073fe:	f7ff ffb7 	bl	207370 <test_print_string>
}
  207402:	bf00      	nop
  207404:	b003      	add	sp, #12
  207406:	f85d fb04 	ldr.w	pc, [sp], #4
  20740a:	bf00      	nop
  20740c:	08010d4c 	.word	0x08010d4c

00207410 <test_execute_inner>:
 * @param[in] tsp       test suite to execute
 * @return              A failure boolean.
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 */
static bool test_execute_inner(const testsuite_t *tsp) {
  207410:	b500      	push	{lr}
  207412:	b085      	sub	sp, #20
  207414:	9001      	str	r0, [sp, #4]
  unsigned tseq, tcase;

  /* Test execution.*/
  test_printf(TEST_CFG_EOL_STRING);
  207416:	4865      	ldr	r0, [pc, #404]	@ (2075ac <test_execute_inner+0x19c>)
  207418:	f000 fc7a 	bl	207d10 <test_printf>
  if (tsp->name != NULL) {
  20741c:	9b01      	ldr	r3, [sp, #4]
  20741e:	681b      	ldr	r3, [r3, #0]
  207420:	2b00      	cmp	r3, #0
  207422:	d006      	beq.n	207432 <test_execute_inner+0x22>
    test_printf("*** %s"TEST_CFG_EOL_STRING, tsp->name);
  207424:	9b01      	ldr	r3, [sp, #4]
  207426:	681b      	ldr	r3, [r3, #0]
  207428:	4619      	mov	r1, r3
  20742a:	4861      	ldr	r0, [pc, #388]	@ (2075b0 <test_execute_inner+0x1a0>)
  20742c:	f000 fc70 	bl	207d10 <test_printf>
  207430:	e002      	b.n	207438 <test_execute_inner+0x28>
  }
  else {
    test_printf("*** Test Suite"TEST_CFG_EOL_STRING);
  207432:	4860      	ldr	r0, [pc, #384]	@ (2075b4 <test_execute_inner+0x1a4>)
  207434:	f000 fc6c 	bl	207d10 <test_printf>
  }
  test_printf("***"TEST_CFG_EOL_STRING);
  207438:	485f      	ldr	r0, [pc, #380]	@ (2075b8 <test_execute_inner+0x1a8>)
  20743a:	f000 fc69 	bl	207d10 <test_printf>
  test_printf("*** Compiled:     %s"TEST_CFG_EOL_STRING, __DATE__ " - " __TIME__);
  20743e:	495f      	ldr	r1, [pc, #380]	@ (2075bc <test_execute_inner+0x1ac>)
  207440:	485f      	ldr	r0, [pc, #380]	@ (2075c0 <test_execute_inner+0x1b0>)
  207442:	f000 fc65 	bl	207d10 <test_printf>
#if defined(PLATFORM_NAME)
  test_printf("*** Platform:     %s"TEST_CFG_EOL_STRING, PLATFORM_NAME);
  207446:	495f      	ldr	r1, [pc, #380]	@ (2075c4 <test_execute_inner+0x1b4>)
  207448:	485f      	ldr	r0, [pc, #380]	@ (2075c8 <test_execute_inner+0x1b8>)
  20744a:	f000 fc61 	bl	207d10 <test_printf>
#endif
#if defined(BOARD_NAME)
  test_printf("*** Test Board:   %s"TEST_CFG_EOL_STRING, BOARD_NAME);
  20744e:	495f      	ldr	r1, [pc, #380]	@ (2075cc <test_execute_inner+0x1bc>)
  207450:	485f      	ldr	r0, [pc, #380]	@ (2075d0 <test_execute_inner+0x1c0>)
  207452:	f000 fc5d 	bl	207d10 <test_printf>
  {
    extern uint8_t __text_base__,   __text_end__,
                   __rodata_base__, __rodata_end__,
                   __data_base__,   __data_end__,
                   __bss_base__,    __bss_end__;
    test_printf("***"TEST_CFG_EOL_STRING);
  207456:	4858      	ldr	r0, [pc, #352]	@ (2075b8 <test_execute_inner+0x1a8>)
  207458:	f000 fc5a 	bl	207d10 <test_printf>
    test_printf("*** Text size:    %u bytes"TEST_CFG_EOL_STRING, &__text_end__   - &__text_base__);
  20745c:	4a5d      	ldr	r2, [pc, #372]	@ (2075d4 <test_execute_inner+0x1c4>)
  20745e:	4b5e      	ldr	r3, [pc, #376]	@ (2075d8 <test_execute_inner+0x1c8>)
  207460:	1ad3      	subs	r3, r2, r3
  207462:	4619      	mov	r1, r3
  207464:	485d      	ldr	r0, [pc, #372]	@ (2075dc <test_execute_inner+0x1cc>)
  207466:	f000 fc53 	bl	207d10 <test_printf>
    test_printf("*** RO data size: %u bytes"TEST_CFG_EOL_STRING, &__rodata_end__ - &__rodata_base__);
  20746a:	4a5d      	ldr	r2, [pc, #372]	@ (2075e0 <test_execute_inner+0x1d0>)
  20746c:	4b5d      	ldr	r3, [pc, #372]	@ (2075e4 <test_execute_inner+0x1d4>)
  20746e:	1ad3      	subs	r3, r2, r3
  207470:	4619      	mov	r1, r3
  207472:	485d      	ldr	r0, [pc, #372]	@ (2075e8 <test_execute_inner+0x1d8>)
  207474:	f000 fc4c 	bl	207d10 <test_printf>
    test_printf("*** Data size:    %u bytes"TEST_CFG_EOL_STRING, &__data_end__   - &__data_base__);
  207478:	4a5c      	ldr	r2, [pc, #368]	@ (2075ec <test_execute_inner+0x1dc>)
  20747a:	4b5d      	ldr	r3, [pc, #372]	@ (2075f0 <test_execute_inner+0x1e0>)
  20747c:	1ad3      	subs	r3, r2, r3
  20747e:	4619      	mov	r1, r3
  207480:	485c      	ldr	r0, [pc, #368]	@ (2075f4 <test_execute_inner+0x1e4>)
  207482:	f000 fc45 	bl	207d10 <test_printf>
    test_printf("*** BSS size:     %u bytes"TEST_CFG_EOL_STRING, &__bss_end__    - &__bss_base__);
  207486:	4a5c      	ldr	r2, [pc, #368]	@ (2075f8 <test_execute_inner+0x1e8>)
  207488:	4b5c      	ldr	r3, [pc, #368]	@ (2075fc <test_execute_inner+0x1ec>)
  20748a:	1ad3      	subs	r3, r2, r3
  20748c:	4619      	mov	r1, r3
  20748e:	485c      	ldr	r0, [pc, #368]	@ (207600 <test_execute_inner+0x1f0>)
  207490:	f000 fc3e 	bl	207d10 <test_printf>
  }
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER();
#endif
  test_printf(TEST_CFG_EOL_STRING);
  207494:	4845      	ldr	r0, [pc, #276]	@ (2075ac <test_execute_inner+0x19c>)
  207496:	f000 fc3b 	bl	207d10 <test_printf>

  chtest.global_fail = false;
  20749a:	4b5a      	ldr	r3, [pc, #360]	@ (207604 <test_execute_inner+0x1f4>)
  20749c:	2200      	movs	r2, #0
  20749e:	711a      	strb	r2, [r3, #4]
  tseq = 0U;
  2074a0:	2300      	movs	r3, #0
  2074a2:	9303      	str	r3, [sp, #12]
  while (tsp->sequences[tseq] != NULL) {
  2074a4:	e064      	b.n	207570 <test_execute_inner+0x160>
#if defined(TEST_REPORT_HOOK_TESTSEQUENCE)
    TEST_REPORT_HOOK_TESTSEQUENCE(tsp->sequences[tseq]);
#endif
#if TEST_CFG_SHOW_SEQUENCES == TRUE
    test_print_fat_line();
  2074a6:	f7ff ff9b 	bl	2073e0 <test_print_fat_line>
    test_printf("=== Test Sequence %u (%s)"TEST_CFG_EOL_STRING, tseq + 1U, tsp->sequences[tseq]->name);
  2074aa:	9b03      	ldr	r3, [sp, #12]
  2074ac:	1c59      	adds	r1, r3, #1
  2074ae:	9b01      	ldr	r3, [sp, #4]
  2074b0:	685a      	ldr	r2, [r3, #4]
  2074b2:	9b03      	ldr	r3, [sp, #12]
  2074b4:	009b      	lsls	r3, r3, #2
  2074b6:	4413      	add	r3, r2
  2074b8:	681b      	ldr	r3, [r3, #0]
  2074ba:	681b      	ldr	r3, [r3, #0]
  2074bc:	461a      	mov	r2, r3
  2074be:	4852      	ldr	r0, [pc, #328]	@ (207608 <test_execute_inner+0x1f8>)
  2074c0:	f000 fc26 	bl	207d10 <test_printf>
#endif
    tcase = 0U;
  2074c4:	2300      	movs	r3, #0
  2074c6:	9302      	str	r3, [sp, #8]
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
  2074c8:	e042      	b.n	207550 <test_execute_inner+0x140>
      test_print_line();
  2074ca:	f7ff ff71 	bl	2073b0 <test_print_line>
      test_printf("--- Test Case %u.%u (%s)"TEST_CFG_EOL_STRING, tseq + 1U, tcase + 1U, tsp->sequences[tseq]->cases[tcase]->name);
  2074ce:	9b03      	ldr	r3, [sp, #12]
  2074d0:	1c59      	adds	r1, r3, #1
  2074d2:	9b02      	ldr	r3, [sp, #8]
  2074d4:	1c58      	adds	r0, r3, #1
  2074d6:	9b01      	ldr	r3, [sp, #4]
  2074d8:	685a      	ldr	r2, [r3, #4]
  2074da:	9b03      	ldr	r3, [sp, #12]
  2074dc:	009b      	lsls	r3, r3, #2
  2074de:	4413      	add	r3, r2
  2074e0:	681b      	ldr	r3, [r3, #0]
  2074e2:	685a      	ldr	r2, [r3, #4]
  2074e4:	9b02      	ldr	r3, [sp, #8]
  2074e6:	009b      	lsls	r3, r3, #2
  2074e8:	4413      	add	r3, r2
  2074ea:	681b      	ldr	r3, [r3, #0]
  2074ec:	681b      	ldr	r3, [r3, #0]
  2074ee:	4602      	mov	r2, r0
  2074f0:	4846      	ldr	r0, [pc, #280]	@ (20760c <test_execute_inner+0x1fc>)
  2074f2:	f000 fc0d 	bl	207d10 <test_printf>
#if TEST_CFG_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_CFG_DELAY_BETWEEN_TESTS);
  2074f6:	f44f 60fa 	mov.w	r0, #2000	@ 0x7d0
  2074fa:	f7ff fec1 	bl	207280 <osalThreadSleep.lto_priv.1>
#endif
#if defined(TEST_REPORT_HOOK_TESTCASE)
      TEST_REPORT_HOOK_TESTCASE(tsp->sequences[tseq]->cases[tcase]);
#endif
      test_execute_case(tsp->sequences[tseq]->cases[tcase]);
  2074fe:	9b01      	ldr	r3, [sp, #4]
  207500:	685a      	ldr	r2, [r3, #4]
  207502:	9b03      	ldr	r3, [sp, #12]
  207504:	009b      	lsls	r3, r3, #2
  207506:	4413      	add	r3, r2
  207508:	681b      	ldr	r3, [r3, #0]
  20750a:	685a      	ldr	r2, [r3, #4]
  20750c:	9b02      	ldr	r3, [sp, #8]
  20750e:	009b      	lsls	r3, r3, #2
  207510:	4413      	add	r3, r2
  207512:	681b      	ldr	r3, [r3, #0]
  207514:	4618      	mov	r0, r3
  207516:	f7ff ff0b 	bl	207330 <test_execute_case>
      if (chtest.local_fail) {
  20751a:	4b3a      	ldr	r3, [pc, #232]	@ (207604 <test_execute_inner+0x1f4>)
  20751c:	795b      	ldrb	r3, [r3, #5]
  20751e:	2b00      	cmp	r3, #0
  207520:	d010      	beq.n	207544 <test_execute_inner+0x134>
        test_printf("--- Result: FAILURE (#%u [", chtest.current_step, "", chtest.failure_message);
  207522:	4b38      	ldr	r3, [pc, #224]	@ (207604 <test_execute_inner+0x1f4>)
  207524:	6819      	ldr	r1, [r3, #0]
  207526:	4b37      	ldr	r3, [pc, #220]	@ (207604 <test_execute_inner+0x1f4>)
  207528:	689b      	ldr	r3, [r3, #8]
  20752a:	4a39      	ldr	r2, [pc, #228]	@ (207610 <test_execute_inner+0x200>)
  20752c:	4839      	ldr	r0, [pc, #228]	@ (207614 <test_execute_inner+0x204>)
  20752e:	f000 fbef 	bl	207d10 <test_printf>
        test_print_tokens();
  207532:	f7ff fedd 	bl	2072f0 <test_print_tokens>
        test_printf("] \"%s\")"TEST_CFG_EOL_STRING, chtest.failure_message);
  207536:	4b33      	ldr	r3, [pc, #204]	@ (207604 <test_execute_inner+0x1f4>)
  207538:	689b      	ldr	r3, [r3, #8]
  20753a:	4619      	mov	r1, r3
  20753c:	4836      	ldr	r0, [pc, #216]	@ (207618 <test_execute_inner+0x208>)
  20753e:	f000 fbe7 	bl	207d10 <test_printf>
  207542:	e002      	b.n	20754a <test_execute_inner+0x13a>
      }
      else {
        test_printf("--- Result: SUCCESS"TEST_CFG_EOL_STRING);
  207544:	4835      	ldr	r0, [pc, #212]	@ (20761c <test_execute_inner+0x20c>)
  207546:	f000 fbe3 	bl	207d10 <test_printf>
      }
      tcase++;
  20754a:	9b02      	ldr	r3, [sp, #8]
  20754c:	3301      	adds	r3, #1
  20754e:	9302      	str	r3, [sp, #8]
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
  207550:	9b01      	ldr	r3, [sp, #4]
  207552:	685a      	ldr	r2, [r3, #4]
  207554:	9b03      	ldr	r3, [sp, #12]
  207556:	009b      	lsls	r3, r3, #2
  207558:	4413      	add	r3, r2
  20755a:	681b      	ldr	r3, [r3, #0]
  20755c:	685a      	ldr	r2, [r3, #4]
  20755e:	9b02      	ldr	r3, [sp, #8]
  207560:	009b      	lsls	r3, r3, #2
  207562:	4413      	add	r3, r2
  207564:	681b      	ldr	r3, [r3, #0]
  207566:	2b00      	cmp	r3, #0
  207568:	d1af      	bne.n	2074ca <test_execute_inner+0xba>
    }
    tseq++;
  20756a:	9b03      	ldr	r3, [sp, #12]
  20756c:	3301      	adds	r3, #1
  20756e:	9303      	str	r3, [sp, #12]
  while (tsp->sequences[tseq] != NULL) {
  207570:	9b01      	ldr	r3, [sp, #4]
  207572:	685a      	ldr	r2, [r3, #4]
  207574:	9b03      	ldr	r3, [sp, #12]
  207576:	009b      	lsls	r3, r3, #2
  207578:	4413      	add	r3, r2
  20757a:	681b      	ldr	r3, [r3, #0]
  20757c:	2b00      	cmp	r3, #0
  20757e:	d192      	bne.n	2074a6 <test_execute_inner+0x96>
  }
  test_print_line();
  207580:	f7ff ff16 	bl	2073b0 <test_print_line>
  test_printf(TEST_CFG_EOL_STRING);
  207584:	4809      	ldr	r0, [pc, #36]	@ (2075ac <test_execute_inner+0x19c>)
  207586:	f000 fbc3 	bl	207d10 <test_printf>
  test_printf("Final result: %s"TEST_CFG_EOL_STRING,
              chtest.global_fail ? "FAILURE" : "SUCCESS");
  20758a:	4b1e      	ldr	r3, [pc, #120]	@ (207604 <test_execute_inner+0x1f4>)
  20758c:	791b      	ldrb	r3, [r3, #4]
  test_printf("Final result: %s"TEST_CFG_EOL_STRING,
  20758e:	2b00      	cmp	r3, #0
  207590:	d001      	beq.n	207596 <test_execute_inner+0x186>
  207592:	4b23      	ldr	r3, [pc, #140]	@ (207620 <test_execute_inner+0x210>)
  207594:	e000      	b.n	207598 <test_execute_inner+0x188>
  207596:	4b23      	ldr	r3, [pc, #140]	@ (207624 <test_execute_inner+0x214>)
  207598:	4619      	mov	r1, r3
  20759a:	4823      	ldr	r0, [pc, #140]	@ (207628 <test_execute_inner+0x218>)
  20759c:	f000 fbb8 	bl	207d10 <test_printf>

#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END();
#endif

  return chtest.global_fail;
  2075a0:	4b18      	ldr	r3, [pc, #96]	@ (207604 <test_execute_inner+0x1f4>)
  2075a2:	791b      	ldrb	r3, [r3, #4]
}
  2075a4:	4618      	mov	r0, r3
  2075a6:	b005      	add	sp, #20
  2075a8:	f85d fb04 	ldr.w	pc, [sp], #4
  2075ac:	08010d4c 	.word	0x08010d4c
  2075b0:	08010bb0 	.word	0x08010bb0
  2075b4:	08010bbc 	.word	0x08010bbc
  2075b8:	08010bd0 	.word	0x08010bd0
  2075bc:	08010bd8 	.word	0x08010bd8
  2075c0:	08010bf0 	.word	0x08010bf0
  2075c4:	08010c08 	.word	0x08010c08
  2075c8:	08010c3c 	.word	0x08010c3c
  2075cc:	08010c54 	.word	0x08010c54
  2075d0:	08010c80 	.word	0x08010c80
  2075d4:	0020ffa0 	.word	0x0020ffa0
  2075d8:	00200200 	.word	0x00200200
  2075dc:	08010c98 	.word	0x08010c98
  2075e0:	080128f8 	.word	0x080128f8
  2075e4:	0800ffa0 	.word	0x0800ffa0
  2075e8:	08010cb8 	.word	0x08010cb8
  2075ec:	200200dc 	.word	0x200200dc
  2075f0:	20020000 	.word	0x20020000
  2075f4:	08010cd8 	.word	0x08010cd8
  2075f8:	20002a20 	.word	0x20002a20
  2075fc:	20000800 	.word	0x20000800
  207600:	08010cf8 	.word	0x08010cf8
  207604:	20000bb4 	.word	0x20000bb4
  207608:	08010d18 	.word	0x08010d18
  20760c:	08010d34 	.word	0x08010d34
  207610:	08010bcc 	.word	0x08010bcc
  207614:	08010d50 	.word	0x08010d50
  207618:	08010d6c 	.word	0x08010d6c
  20761c:	08010d78 	.word	0x08010d78
  207620:	08010d90 	.word	0x08010d90
  207624:	08010d98 	.word	0x08010d98
  207628:	08010da0 	.word	0x08010da0
  20762c:	00000000 	.word	0x00000000

00207630 <__test_fail>:

/*===========================================================================*/
/* Module exported functions.                                                */
/*===========================================================================*/

bool __test_fail(const char *msg) {
  207630:	b082      	sub	sp, #8
  207632:	9001      	str	r0, [sp, #4]

  chtest.local_fail      = true;
  207634:	4b06      	ldr	r3, [pc, #24]	@ (207650 <__test_fail+0x20>)
  207636:	2201      	movs	r2, #1
  207638:	715a      	strb	r2, [r3, #5]
  chtest.global_fail     = true;
  20763a:	4b05      	ldr	r3, [pc, #20]	@ (207650 <__test_fail+0x20>)
  20763c:	2201      	movs	r2, #1
  20763e:	711a      	strb	r2, [r3, #4]
  chtest.failure_message = msg;
  207640:	4a03      	ldr	r2, [pc, #12]	@ (207650 <__test_fail+0x20>)
  207642:	9b01      	ldr	r3, [sp, #4]
  207644:	6093      	str	r3, [r2, #8]
  return true;
  207646:	2301      	movs	r3, #1
}
  207648:	4618      	mov	r0, r3
  20764a:	b002      	add	sp, #8
  20764c:	4770      	bx	lr
  20764e:	bf00      	nop
  207650:	20000bb4 	.word	0x20000bb4
	...

00207660 <__test_assert>:

bool __test_assert(bool condition, const char *msg) {
  207660:	b500      	push	{lr}
  207662:	b083      	sub	sp, #12
  207664:	4603      	mov	r3, r0
  207666:	9100      	str	r1, [sp, #0]
  207668:	f88d 3007 	strb.w	r3, [sp, #7]

  if (!condition) {
  20766c:	f89d 3007 	ldrb.w	r3, [sp, #7]
  207670:	f083 0301 	eor.w	r3, r3, #1
  207674:	b2db      	uxtb	r3, r3
  207676:	2b00      	cmp	r3, #0
  207678:	d004      	beq.n	207684 <__test_assert+0x24>
    return __test_fail(msg);
  20767a:	9800      	ldr	r0, [sp, #0]
  20767c:	f7ff ffd8 	bl	207630 <__test_fail>
  207680:	4603      	mov	r3, r0
  207682:	e000      	b.n	207686 <__test_assert+0x26>
  }
  return false;
  207684:	2300      	movs	r3, #0
}
  207686:	4618      	mov	r0, r3
  207688:	b003      	add	sp, #12
  20768a:	f85d fb04 	ldr.w	pc, [sp], #4
  20768e:	bf00      	nop

00207690 <__test_assert_sequence>:

bool __test_assert_sequence(char *expected, const char *msg) {
  207690:	b500      	push	{lr}
  207692:	b085      	sub	sp, #20
  207694:	9001      	str	r0, [sp, #4]
  207696:	9100      	str	r1, [sp, #0]
  char *cp = chtest.tokens_buffer;
  207698:	4b13      	ldr	r3, [pc, #76]	@ (2076e8 <__test_assert_sequence+0x58>)
  20769a:	9303      	str	r3, [sp, #12]

  while (cp < chtest.tokp) {
  20769c:	e00e      	b.n	2076bc <__test_assert_sequence+0x2c>
    if (*cp++ != *expected++)
  20769e:	9b03      	ldr	r3, [sp, #12]
  2076a0:	1c5a      	adds	r2, r3, #1
  2076a2:	9203      	str	r2, [sp, #12]
  2076a4:	781a      	ldrb	r2, [r3, #0]
  2076a6:	9b01      	ldr	r3, [sp, #4]
  2076a8:	1c59      	adds	r1, r3, #1
  2076aa:	9101      	str	r1, [sp, #4]
  2076ac:	781b      	ldrb	r3, [r3, #0]
  2076ae:	429a      	cmp	r2, r3
  2076b0:	d004      	beq.n	2076bc <__test_assert_sequence+0x2c>
     return __test_fail(msg);
  2076b2:	9800      	ldr	r0, [sp, #0]
  2076b4:	f7ff ffbc 	bl	207630 <__test_fail>
  2076b8:	4603      	mov	r3, r0
  2076ba:	e010      	b.n	2076de <__test_assert_sequence+0x4e>
  while (cp < chtest.tokp) {
  2076bc:	4b0b      	ldr	r3, [pc, #44]	@ (2076ec <__test_assert_sequence+0x5c>)
  2076be:	68db      	ldr	r3, [r3, #12]
  2076c0:	9a03      	ldr	r2, [sp, #12]
  2076c2:	429a      	cmp	r2, r3
  2076c4:	d3eb      	bcc.n	20769e <__test_assert_sequence+0xe>
  }

  if (*expected) {
  2076c6:	9b01      	ldr	r3, [sp, #4]
  2076c8:	781b      	ldrb	r3, [r3, #0]
  2076ca:	2b00      	cmp	r3, #0
  2076cc:	d004      	beq.n	2076d8 <__test_assert_sequence+0x48>
    return __test_fail(msg);
  2076ce:	9800      	ldr	r0, [sp, #0]
  2076d0:	f7ff ffae 	bl	207630 <__test_fail>
  2076d4:	4603      	mov	r3, r0
  2076d6:	e002      	b.n	2076de <__test_assert_sequence+0x4e>
  }

  test_clear_tokens();
  2076d8:	f7ff fdfa 	bl	2072d0 <test_clear_tokens>

  return false;
  2076dc:	2300      	movs	r3, #0
}
  2076de:	4618      	mov	r0, r3
  2076e0:	b005      	add	sp, #20
  2076e2:	f85d fb04 	ldr.w	pc, [sp], #4
  2076e6:	bf00      	nop
  2076e8:	20000bc4 	.word	0x20000bc4
  2076ec:	20000bb4 	.word	0x20000bb4

002076f0 <__test_assert_time_window>:

#if (TEST_CFG_CHIBIOS_SUPPORT == TRUE) || defined(__DOXYGEN__)
bool __test_assert_time_window(systime_t start,
                               systime_t end,
                               const char *msg) {
  2076f0:	b500      	push	{lr}
  2076f2:	b085      	sub	sp, #20
  2076f4:	9003      	str	r0, [sp, #12]
  2076f6:	9102      	str	r1, [sp, #8]
  2076f8:	9201      	str	r2, [sp, #4]

  return __test_assert(osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end),
  2076fa:	f7ff fda9 	bl	207250 <osalOsGetSystemTimeX>
  2076fe:	4603      	mov	r3, r0
  207700:	9a02      	ldr	r2, [sp, #8]
  207702:	9903      	ldr	r1, [sp, #12]
  207704:	4618      	mov	r0, r3
  207706:	f7ff fdab 	bl	207260 <osalTimeIsInRangeX>
  20770a:	4603      	mov	r3, r0
  20770c:	9901      	ldr	r1, [sp, #4]
  20770e:	4618      	mov	r0, r3
  207710:	f7ff ffa6 	bl	207660 <__test_assert>
  207714:	4603      	mov	r3, r0
                       msg);
}
  207716:	4618      	mov	r0, r3
  207718:	b005      	add	sp, #20
  20771a:	f85d fb04 	ldr.w	pc, [sp], #4
  20771e:	bf00      	nop

00207720 <test_emit_token>:
 *
 * @param[in] token     the token as a char
 *
 * @api
 */
void test_emit_token(char token) {
  207720:	b082      	sub	sp, #8
  207722:	4603      	mov	r3, r0
  207724:	f88d 3007 	strb.w	r3, [sp, #7]

  if (chtest.tokp < &chtest.tokens_buffer[TEST_CFG_MAX_TOKENS]) {
  207728:	4b07      	ldr	r3, [pc, #28]	@ (207748 <test_emit_token+0x28>)
  20772a:	68db      	ldr	r3, [r3, #12]
  20772c:	4a07      	ldr	r2, [pc, #28]	@ (20774c <test_emit_token+0x2c>)
  20772e:	4293      	cmp	r3, r2
  207730:	d207      	bcs.n	207742 <test_emit_token+0x22>
    *chtest.tokp++ = token;
  207732:	4b05      	ldr	r3, [pc, #20]	@ (207748 <test_emit_token+0x28>)
  207734:	68db      	ldr	r3, [r3, #12]
  207736:	1c5a      	adds	r2, r3, #1
  207738:	4903      	ldr	r1, [pc, #12]	@ (207748 <test_emit_token+0x28>)
  20773a:	60ca      	str	r2, [r1, #12]
  20773c:	f89d 2007 	ldrb.w	r2, [sp, #7]
  207740:	701a      	strb	r2, [r3, #0]
  }
}
  207742:	bf00      	nop
  207744:	b002      	add	sp, #8
  207746:	4770      	bx	lr
  207748:	20000bb4 	.word	0x20000bb4
  20774c:	20000bd4 	.word	0x20000bd4

00207750 <test_execute_stream>:
 * @retval true         if one or more tests failed.
 *
 * @api
 */
bool test_execute_stream(BaseSequentialStream *stream,
                         const testsuite_t *tsp) {
  207750:	b500      	push	{lr}
  207752:	b083      	sub	sp, #12
  207754:	9001      	str	r0, [sp, #4]
  207756:	9100      	str	r1, [sp, #0]

  /* Output initialization using streams.*/
  chtest.stream  = stream;
  207758:	4a06      	ldr	r2, [pc, #24]	@ (207774 <test_execute_stream+0x24>)
  20775a:	9b01      	ldr	r3, [sp, #4]
  20775c:	6253      	str	r3, [r2, #36]	@ 0x24
  chtest.putchar = test_stream_putchar;
  20775e:	4b05      	ldr	r3, [pc, #20]	@ (207774 <test_execute_stream+0x24>)
  207760:	4a05      	ldr	r2, [pc, #20]	@ (207778 <test_execute_stream+0x28>)
  207762:	621a      	str	r2, [r3, #32]

  /* Test execution.*/
  return test_execute_inner(tsp);
  207764:	9800      	ldr	r0, [sp, #0]
  207766:	f7ff fe53 	bl	207410 <test_execute_inner>
  20776a:	4603      	mov	r3, r0
}
  20776c:	4618      	mov	r0, r3
  20776e:	b003      	add	sp, #12
  207770:	f85d fb04 	ldr.w	pc, [sp], #4
  207774:	20000bb4 	.word	0x20000bb4
  207778:	002072a1 	.word	0x002072a1
  20777c:	00000000 	.word	0x00000000

00207780 <test_ltoswd>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *test_ltoswd(char *p, long num, int radix, long divisor) {
  207780:	b08a      	sub	sp, #40	@ 0x28
  207782:	9003      	str	r0, [sp, #12]
  207784:	9102      	str	r1, [sp, #8]
  207786:	9201      	str	r2, [sp, #4]
  207788:	9300      	str	r3, [sp, #0]
  int i, c;
  char *q;
  long l, ll;

  l = num;
  20778a:	9b02      	ldr	r3, [sp, #8]
  20778c:	9306      	str	r3, [sp, #24]
  if (divisor == 0) {
  20778e:	9b00      	ldr	r3, [sp, #0]
  207790:	2b00      	cmp	r3, #0
  207792:	d102      	bne.n	20779a <test_ltoswd+0x1a>
    ll = num;
  207794:	9b02      	ldr	r3, [sp, #8]
  207796:	9305      	str	r3, [sp, #20]
  207798:	e001      	b.n	20779e <test_ltoswd+0x1e>
  } else {
    ll = divisor;
  20779a:	9b00      	ldr	r3, [sp, #0]
  20779c:	9305      	str	r3, [sp, #20]
  }

  q = p + MAX_FILLER;
  20779e:	9b03      	ldr	r3, [sp, #12]
  2077a0:	330b      	adds	r3, #11
  2077a2:	9307      	str	r3, [sp, #28]
  do {
    c = (int)(l % (long)radix);
  2077a4:	9b06      	ldr	r3, [sp, #24]
  2077a6:	9a01      	ldr	r2, [sp, #4]
  2077a8:	fb93 f2f2 	sdiv	r2, r3, r2
  2077ac:	9901      	ldr	r1, [sp, #4]
  2077ae:	fb01 f202 	mul.w	r2, r1, r2
  2077b2:	1a9b      	subs	r3, r3, r2
  2077b4:	9308      	str	r3, [sp, #32]
    c += '0';
  2077b6:	9b08      	ldr	r3, [sp, #32]
  2077b8:	3330      	adds	r3, #48	@ 0x30
  2077ba:	9308      	str	r3, [sp, #32]
    if (c > '9') {
  2077bc:	9b08      	ldr	r3, [sp, #32]
  2077be:	2b39      	cmp	r3, #57	@ 0x39
  2077c0:	dd02      	ble.n	2077c8 <test_ltoswd+0x48>
      c += ('A' - '0') - 10;
  2077c2:	9b08      	ldr	r3, [sp, #32]
  2077c4:	3307      	adds	r3, #7
  2077c6:	9308      	str	r3, [sp, #32]
    }
    *--q = (char)c;
  2077c8:	9b07      	ldr	r3, [sp, #28]
  2077ca:	3b01      	subs	r3, #1
  2077cc:	9307      	str	r3, [sp, #28]
  2077ce:	9b08      	ldr	r3, [sp, #32]
  2077d0:	b2da      	uxtb	r2, r3
  2077d2:	9b07      	ldr	r3, [sp, #28]
  2077d4:	701a      	strb	r2, [r3, #0]
    l /= radix;
  2077d6:	9a06      	ldr	r2, [sp, #24]
  2077d8:	9b01      	ldr	r3, [sp, #4]
  2077da:	fb92 f3f3 	sdiv	r3, r2, r3
  2077de:	9306      	str	r3, [sp, #24]
    ll /= radix;
  2077e0:	9a05      	ldr	r2, [sp, #20]
  2077e2:	9b01      	ldr	r3, [sp, #4]
  2077e4:	fb92 f3f3 	sdiv	r3, r2, r3
  2077e8:	9305      	str	r3, [sp, #20]
  } while (ll != 0);
  2077ea:	9b05      	ldr	r3, [sp, #20]
  2077ec:	2b00      	cmp	r3, #0
  2077ee:	d1d9      	bne.n	2077a4 <test_ltoswd+0x24>

  i = (int)(p + MAX_FILLER - q);
  2077f0:	9b03      	ldr	r3, [sp, #12]
  2077f2:	f103 020b 	add.w	r2, r3, #11
  2077f6:	9b07      	ldr	r3, [sp, #28]
  2077f8:	1ad3      	subs	r3, r2, r3
  2077fa:	9309      	str	r3, [sp, #36]	@ 0x24
  do {
    *p++ = *q++;
  2077fc:	9a07      	ldr	r2, [sp, #28]
  2077fe:	1c53      	adds	r3, r2, #1
  207800:	9307      	str	r3, [sp, #28]
  207802:	9b03      	ldr	r3, [sp, #12]
  207804:	1c59      	adds	r1, r3, #1
  207806:	9103      	str	r1, [sp, #12]
  207808:	7812      	ldrb	r2, [r2, #0]
  20780a:	701a      	strb	r2, [r3, #0]
  } while (--i);
  20780c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  20780e:	3b01      	subs	r3, #1
  207810:	9309      	str	r3, [sp, #36]	@ 0x24
  207812:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  207814:	2b00      	cmp	r3, #0
  207816:	d1f1      	bne.n	2077fc <test_ltoswd+0x7c>

  return p;
  207818:	9b03      	ldr	r3, [sp, #12]
}
  20781a:	4618      	mov	r0, r3
  20781c:	b00a      	add	sp, #40	@ 0x28
  20781e:	4770      	bx	lr

00207820 <test_ltoa>:

static char *test_ltoa(char *p, long num, int radix) {
  207820:	b500      	push	{lr}
  207822:	b085      	sub	sp, #20
  207824:	9003      	str	r0, [sp, #12]
  207826:	9102      	str	r1, [sp, #8]
  207828:	9201      	str	r2, [sp, #4]

  return test_ltoswd(p, num, radix, 0);
  20782a:	2300      	movs	r3, #0
  20782c:	9a01      	ldr	r2, [sp, #4]
  20782e:	9902      	ldr	r1, [sp, #8]
  207830:	9803      	ldr	r0, [sp, #12]
  207832:	f7ff ffa5 	bl	207780 <test_ltoswd>
  207836:	4603      	mov	r3, r0
}
  207838:	4618      	mov	r0, r3
  20783a:	b005      	add	sp, #20
  20783c:	f85d fb04 	ldr.w	pc, [sp], #4

00207840 <test_putchar>:
/**
 * @brief   Base character output function.
 *
 * @param[in] c         character to be printed
 */
void test_putchar(char c) {
  207840:	b500      	push	{lr}
  207842:	b083      	sub	sp, #12
  207844:	4603      	mov	r3, r0
  207846:	f88d 3007 	strb.w	r3, [sp, #7]

  if (chtest.putchar != NULL) {
  20784a:	4b07      	ldr	r3, [pc, #28]	@ (207868 <test_putchar+0x28>)
  20784c:	6a1b      	ldr	r3, [r3, #32]
  20784e:	2b00      	cmp	r3, #0
  207850:	d005      	beq.n	20785e <test_putchar+0x1e>
    chtest.putchar(c);
  207852:	4b05      	ldr	r3, [pc, #20]	@ (207868 <test_putchar+0x28>)
  207854:	6a1b      	ldr	r3, [r3, #32]
  207856:	f89d 2007 	ldrb.w	r2, [sp, #7]
  20785a:	4610      	mov	r0, r2
  20785c:	4798      	blx	r3
  }
}
  20785e:	bf00      	nop
  207860:	b003      	add	sp, #12
  207862:	f85d fb04 	ldr.w	pc, [sp], #4
  207866:	bf00      	nop
  207868:	20000bb4 	.word	0x20000bb4
  20786c:	00000000 	.word	0x00000000

00207870 <test_vprintf>:
 * @param[in] ap        list of parameters
 * @return              The number of bytes written.
 *
 * @api
 */
int test_vprintf(const char *fmt, va_list ap) {
  207870:	b500      	push	{lr}
  207872:	b091      	sub	sp, #68	@ 0x44
  207874:	9001      	str	r0, [sp, #4]
  207876:	9100      	str	r1, [sp, #0]
  int n;
  char tmpbuf[MAX_FILLER + 1];

  n = 0;
  207878:	2300      	movs	r3, #0
  20787a:	930f      	str	r3, [sp, #60]	@ 0x3c
  while (true) {
    char *p, *s, c, filler;
    int i, precision, width;
    bool is_long, left_align, do_sign;

    c = *fmt++;
  20787c:	9b01      	ldr	r3, [sp, #4]
  20787e:	1c5a      	adds	r2, r3, #1
  207880:	9201      	str	r2, [sp, #4]
  207882:	781b      	ldrb	r3, [r3, #0]
  207884:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
    if (c == '\0') {
  207888:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  20788c:	2b00      	cmp	r3, #0
  20788e:	d101      	bne.n	207894 <test_vprintf+0x24>
      return n;
  207890:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  207892:	e237      	b.n	207d04 <test_vprintf+0x494>
    }

    if (c != '%') {
  207894:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  207898:	2b25      	cmp	r3, #37	@ 0x25
  20789a:	d008      	beq.n	2078ae <test_vprintf+0x3e>
      test_putchar(c);
  20789c:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  2078a0:	4618      	mov	r0, r3
  2078a2:	f7ff ffcd 	bl	207840 <test_putchar>
      n++;
  2078a6:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  2078a8:	3301      	adds	r3, #1
  2078aa:	930f      	str	r3, [sp, #60]	@ 0x3c
      continue;
  2078ac:	e229      	b.n	207d02 <test_vprintf+0x492>
    }

    /* Pointers to the temporary buffer.*/
    p = tmpbuf;
  2078ae:	ab03      	add	r3, sp, #12
  2078b0:	930e      	str	r3, [sp, #56]	@ 0x38
    s = tmpbuf;
  2078b2:	ab03      	add	r3, sp, #12
  2078b4:	930d      	str	r3, [sp, #52]	@ 0x34

    /* Alignment mode.*/
    left_align = false;
  2078b6:	2300      	movs	r3, #0
  2078b8:	f88d 3022 	strb.w	r3, [sp, #34]	@ 0x22
    if (*fmt == '-') {
  2078bc:	9b01      	ldr	r3, [sp, #4]
  2078be:	781b      	ldrb	r3, [r3, #0]
  2078c0:	2b2d      	cmp	r3, #45	@ 0x2d
  2078c2:	d105      	bne.n	2078d0 <test_vprintf+0x60>
      fmt++;
  2078c4:	9b01      	ldr	r3, [sp, #4]
  2078c6:	3301      	adds	r3, #1
  2078c8:	9301      	str	r3, [sp, #4]
      left_align = true;
  2078ca:	2301      	movs	r3, #1
  2078cc:	f88d 3022 	strb.w	r3, [sp, #34]	@ 0x22
    }

    /* Sign mode.*/
    do_sign = false;
  2078d0:	2300      	movs	r3, #0
  2078d2:	f88d 3021 	strb.w	r3, [sp, #33]	@ 0x21
    if (*fmt == '+') {
  2078d6:	9b01      	ldr	r3, [sp, #4]
  2078d8:	781b      	ldrb	r3, [r3, #0]
  2078da:	2b2b      	cmp	r3, #43	@ 0x2b
  2078dc:	d105      	bne.n	2078ea <test_vprintf+0x7a>
      fmt++;
  2078de:	9b01      	ldr	r3, [sp, #4]
  2078e0:	3301      	adds	r3, #1
  2078e2:	9301      	str	r3, [sp, #4]
      do_sign = true;
  2078e4:	2301      	movs	r3, #1
  2078e6:	f88d 3021 	strb.w	r3, [sp, #33]	@ 0x21
    }

    /* Filler mode.*/
    filler = ' ';
  2078ea:	2320      	movs	r3, #32
  2078ec:	f88d 3032 	strb.w	r3, [sp, #50]	@ 0x32
    if (*fmt == '0') {
  2078f0:	9b01      	ldr	r3, [sp, #4]
  2078f2:	781b      	ldrb	r3, [r3, #0]
  2078f4:	2b30      	cmp	r3, #48	@ 0x30
  2078f6:	d105      	bne.n	207904 <test_vprintf+0x94>
      fmt++;
  2078f8:	9b01      	ldr	r3, [sp, #4]
  2078fa:	3301      	adds	r3, #1
  2078fc:	9301      	str	r3, [sp, #4]
      filler = '0';
  2078fe:	2330      	movs	r3, #48	@ 0x30
  207900:	f88d 3032 	strb.w	r3, [sp, #50]	@ 0x32
    }

    /* Width modifier.*/
    if ( *fmt == '*') {
  207904:	9b01      	ldr	r3, [sp, #4]
  207906:	781b      	ldrb	r3, [r3, #0]
  207908:	2b2a      	cmp	r3, #42	@ 0x2a
  20790a:	d10e      	bne.n	20792a <test_vprintf+0xba>
      width = va_arg(ap, int);
  20790c:	9b00      	ldr	r3, [sp, #0]
  20790e:	1d1a      	adds	r2, r3, #4
  207910:	9200      	str	r2, [sp, #0]
  207912:	681b      	ldr	r3, [r3, #0]
  207914:	9309      	str	r3, [sp, #36]	@ 0x24
      ++fmt;
  207916:	9b01      	ldr	r3, [sp, #4]
  207918:	3301      	adds	r3, #1
  20791a:	9301      	str	r3, [sp, #4]
      c = *fmt++;
  20791c:	9b01      	ldr	r3, [sp, #4]
  20791e:	1c5a      	adds	r2, r3, #1
  207920:	9201      	str	r2, [sp, #4]
  207922:	781b      	ldrb	r3, [r3, #0]
  207924:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
  207928:	e025      	b.n	207976 <test_vprintf+0x106>
    }
    else {
      width = 0;
  20792a:	2300      	movs	r3, #0
  20792c:	9309      	str	r3, [sp, #36]	@ 0x24
      while (true) {
        c = *fmt++;
  20792e:	9b01      	ldr	r3, [sp, #4]
  207930:	1c5a      	adds	r2, r3, #1
  207932:	9201      	str	r2, [sp, #4]
  207934:	781b      	ldrb	r3, [r3, #0]
  207936:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
        if (c == '\0') {
  20793a:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  20793e:	2b00      	cmp	r3, #0
  207940:	d101      	bne.n	207946 <test_vprintf+0xd6>
          return n;
  207942:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  207944:	e1de      	b.n	207d04 <test_vprintf+0x494>
        }
        if ((c >= '0') && (c <= '9')) {
  207946:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  20794a:	2b2f      	cmp	r3, #47	@ 0x2f
  20794c:	d913      	bls.n	207976 <test_vprintf+0x106>
  20794e:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  207952:	2b39      	cmp	r3, #57	@ 0x39
  207954:	d80f      	bhi.n	207976 <test_vprintf+0x106>
          c -= '0';
  207956:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  20795a:	3b30      	subs	r3, #48	@ 0x30
  20795c:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
          width = width * 10 + c;
  207960:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  207962:	4613      	mov	r3, r2
  207964:	009b      	lsls	r3, r3, #2
  207966:	4413      	add	r3, r2
  207968:	005b      	lsls	r3, r3, #1
  20796a:	461a      	mov	r2, r3
  20796c:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  207970:	4413      	add	r3, r2
  207972:	9309      	str	r3, [sp, #36]	@ 0x24
        c = *fmt++;
  207974:	e7db      	b.n	20792e <test_vprintf+0xbe>
        }
      }
    }

    /* Precision modifier.*/
    precision = 0;
  207976:	2300      	movs	r3, #0
  207978:	930a      	str	r3, [sp, #40]	@ 0x28
    if (c == '.') {
  20797a:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  20797e:	2b2e      	cmp	r3, #46	@ 0x2e
  207980:	d13e      	bne.n	207a00 <test_vprintf+0x190>
      c = *fmt++;
  207982:	9b01      	ldr	r3, [sp, #4]
  207984:	1c5a      	adds	r2, r3, #1
  207986:	9201      	str	r2, [sp, #4]
  207988:	781b      	ldrb	r3, [r3, #0]
  20798a:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
      if (c == '\0') {
  20798e:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  207992:	2b00      	cmp	r3, #0
  207994:	d101      	bne.n	20799a <test_vprintf+0x12a>
        return n;
  207996:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  207998:	e1b4      	b.n	207d04 <test_vprintf+0x494>
      }
      if (c == '*') {
  20799a:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  20799e:	2b2a      	cmp	r3, #42	@ 0x2a
  2079a0:	d126      	bne.n	2079f0 <test_vprintf+0x180>
        precision = va_arg(ap, int);
  2079a2:	9b00      	ldr	r3, [sp, #0]
  2079a4:	1d1a      	adds	r2, r3, #4
  2079a6:	9200      	str	r2, [sp, #0]
  2079a8:	681b      	ldr	r3, [r3, #0]
  2079aa:	930a      	str	r3, [sp, #40]	@ 0x28
        c = *fmt++;
  2079ac:	9b01      	ldr	r3, [sp, #4]
  2079ae:	1c5a      	adds	r2, r3, #1
  2079b0:	9201      	str	r2, [sp, #4]
  2079b2:	781b      	ldrb	r3, [r3, #0]
  2079b4:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
  2079b8:	e022      	b.n	207a00 <test_vprintf+0x190>
      }
      else {
        while ((c >= '0') && (c <= '9')) {
          c -= '0';
  2079ba:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  2079be:	3b30      	subs	r3, #48	@ 0x30
  2079c0:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
          precision = precision * 10 + c;
  2079c4:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
  2079c6:	4613      	mov	r3, r2
  2079c8:	009b      	lsls	r3, r3, #2
  2079ca:	4413      	add	r3, r2
  2079cc:	005b      	lsls	r3, r3, #1
  2079ce:	461a      	mov	r2, r3
  2079d0:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  2079d4:	4413      	add	r3, r2
  2079d6:	930a      	str	r3, [sp, #40]	@ 0x28
          c = *fmt++;
  2079d8:	9b01      	ldr	r3, [sp, #4]
  2079da:	1c5a      	adds	r2, r3, #1
  2079dc:	9201      	str	r2, [sp, #4]
  2079de:	781b      	ldrb	r3, [r3, #0]
  2079e0:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
          if (c == '\0') {
  2079e4:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  2079e8:	2b00      	cmp	r3, #0
  2079ea:	d101      	bne.n	2079f0 <test_vprintf+0x180>
            return n;
  2079ec:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  2079ee:	e189      	b.n	207d04 <test_vprintf+0x494>
        while ((c >= '0') && (c <= '9')) {
  2079f0:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  2079f4:	2b2f      	cmp	r3, #47	@ 0x2f
  2079f6:	d903      	bls.n	207a00 <test_vprintf+0x190>
  2079f8:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  2079fc:	2b39      	cmp	r3, #57	@ 0x39
  2079fe:	d9dc      	bls.n	2079ba <test_vprintf+0x14a>
        }
      }
    }

    /* Long modifier.*/
    if ((c == 'l') || (c == 'L')) {
  207a00:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  207a04:	2b6c      	cmp	r3, #108	@ 0x6c
  207a06:	d003      	beq.n	207a10 <test_vprintf+0x1a0>
  207a08:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  207a0c:	2b4c      	cmp	r3, #76	@ 0x4c
  207a0e:	d10e      	bne.n	207a2e <test_vprintf+0x1be>
      is_long = true;
  207a10:	2301      	movs	r3, #1
  207a12:	f88d 3023 	strb.w	r3, [sp, #35]	@ 0x23
      c = *fmt++;
  207a16:	9b01      	ldr	r3, [sp, #4]
  207a18:	1c5a      	adds	r2, r3, #1
  207a1a:	9201      	str	r2, [sp, #4]
  207a1c:	781b      	ldrb	r3, [r3, #0]
  207a1e:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
      if (c == '\0') {
  207a22:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  207a26:	2b00      	cmp	r3, #0
  207a28:	d114      	bne.n	207a54 <test_vprintf+0x1e4>
        return n;
  207a2a:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  207a2c:	e16a      	b.n	207d04 <test_vprintf+0x494>
      }
    }
    else {
      is_long = (c >= 'A') && (c <= 'Z');
  207a2e:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  207a32:	2b40      	cmp	r3, #64	@ 0x40
  207a34:	d905      	bls.n	207a42 <test_vprintf+0x1d2>
  207a36:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  207a3a:	2b5a      	cmp	r3, #90	@ 0x5a
  207a3c:	d801      	bhi.n	207a42 <test_vprintf+0x1d2>
  207a3e:	2301      	movs	r3, #1
  207a40:	e000      	b.n	207a44 <test_vprintf+0x1d4>
  207a42:	2300      	movs	r3, #0
  207a44:	f88d 3023 	strb.w	r3, [sp, #35]	@ 0x23
  207a48:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
  207a4c:	f003 0301 	and.w	r3, r3, #1
  207a50:	f88d 3023 	strb.w	r3, [sp, #35]	@ 0x23
    }

    /* Command decoding.*/
    switch (c) {
  207a54:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
  207a58:	3b44      	subs	r3, #68	@ 0x44
  207a5a:	2b34      	cmp	r3, #52	@ 0x34
  207a5c:	f200 80e8 	bhi.w	207c30 <test_vprintf+0x3c0>
  207a60:	a201      	add	r2, pc, #4	@ (adr r2, 207a68 <test_vprintf+0x1f8>)
  207a62:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  207a66:	bf00      	nop
  207a68:	00207b9f 	.word	0x00207b9f
  207a6c:	00207c31 	.word	0x00207c31
  207a70:	00207c31 	.word	0x00207c31
  207a74:	00207c31 	.word	0x00207c31
  207a78:	00207c31 	.word	0x00207c31
  207a7c:	00207b9f 	.word	0x00207b9f
  207a80:	00207c31 	.word	0x00207c31
  207a84:	00207c31 	.word	0x00207c31
  207a88:	00207c31 	.word	0x00207c31
  207a8c:	00207c31 	.word	0x00207c31
  207a90:	00207c31 	.word	0x00207c31
  207a94:	00207c01 	.word	0x00207c01
  207a98:	00207bf5 	.word	0x00207bf5
  207a9c:	00207c31 	.word	0x00207c31
  207aa0:	00207c31 	.word	0x00207c31
  207aa4:	00207c31 	.word	0x00207c31
  207aa8:	00207c31 	.word	0x00207c31
  207aac:	00207bfb 	.word	0x00207bfb
  207ab0:	00207c31 	.word	0x00207c31
  207ab4:	00207c31 	.word	0x00207c31
  207ab8:	00207bf5 	.word	0x00207bf5
  207abc:	00207c31 	.word	0x00207c31
  207ac0:	00207c31 	.word	0x00207c31
  207ac4:	00207c31 	.word	0x00207c31
  207ac8:	00207c31 	.word	0x00207c31
  207acc:	00207c31 	.word	0x00207c31
  207ad0:	00207c31 	.word	0x00207c31
  207ad4:	00207c31 	.word	0x00207c31
  207ad8:	00207c31 	.word	0x00207c31
  207adc:	00207c31 	.word	0x00207c31
  207ae0:	00207c31 	.word	0x00207c31
  207ae4:	00207b3d 	.word	0x00207b3d
  207ae8:	00207b9f 	.word	0x00207b9f
  207aec:	00207c31 	.word	0x00207c31
  207af0:	00207c31 	.word	0x00207c31
  207af4:	00207c31 	.word	0x00207c31
  207af8:	00207c31 	.word	0x00207c31
  207afc:	00207b9f 	.word	0x00207b9f
  207b00:	00207c31 	.word	0x00207c31
  207b04:	00207c31 	.word	0x00207c31
  207b08:	00207c31 	.word	0x00207c31
  207b0c:	00207c31 	.word	0x00207c31
  207b10:	00207c31 	.word	0x00207c31
  207b14:	00207c01 	.word	0x00207c01
  207b18:	00207bf5 	.word	0x00207bf5
  207b1c:	00207c31 	.word	0x00207c31
  207b20:	00207c31 	.word	0x00207c31
  207b24:	00207b57 	.word	0x00207b57
  207b28:	00207c31 	.word	0x00207c31
  207b2c:	00207bfb 	.word	0x00207bfb
  207b30:	00207c31 	.word	0x00207c31
  207b34:	00207c31 	.word	0x00207c31
  207b38:	00207bf5 	.word	0x00207bf5
      int radix;
      long arg;

    case 'c':
      filler = ' ';
  207b3c:	2320      	movs	r3, #32
  207b3e:	f88d 3032 	strb.w	r3, [sp, #50]	@ 0x32
      *p++ = va_arg(ap, int);
  207b42:	9b00      	ldr	r3, [sp, #0]
  207b44:	1d1a      	adds	r2, r3, #4
  207b46:	9200      	str	r2, [sp, #0]
  207b48:	6819      	ldr	r1, [r3, #0]
  207b4a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  207b4c:	1c5a      	adds	r2, r3, #1
  207b4e:	920e      	str	r2, [sp, #56]	@ 0x38
  207b50:	b2ca      	uxtb	r2, r1
  207b52:	701a      	strb	r2, [r3, #0]
      break;
  207b54:	e074      	b.n	207c40 <test_vprintf+0x3d0>
    case 's':
      filler = ' ';
  207b56:	2320      	movs	r3, #32
  207b58:	f88d 3032 	strb.w	r3, [sp, #50]	@ 0x32
      if ((s = va_arg(ap, char *)) == NULL) {
  207b5c:	9b00      	ldr	r3, [sp, #0]
  207b5e:	1d1a      	adds	r2, r3, #4
  207b60:	9200      	str	r2, [sp, #0]
  207b62:	681b      	ldr	r3, [r3, #0]
  207b64:	930d      	str	r3, [sp, #52]	@ 0x34
  207b66:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  207b68:	2b00      	cmp	r3, #0
  207b6a:	d101      	bne.n	207b70 <test_vprintf+0x300>
        s = "(null)";
  207b6c:	4b67      	ldr	r3, [pc, #412]	@ (207d0c <test_vprintf+0x49c>)
  207b6e:	930d      	str	r3, [sp, #52]	@ 0x34
      }
      if (precision == 0) {
  207b70:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  207b72:	2b00      	cmp	r3, #0
  207b74:	d102      	bne.n	207b7c <test_vprintf+0x30c>
        precision = 32767;
  207b76:	f647 73ff 	movw	r3, #32767	@ 0x7fff
  207b7a:	930a      	str	r3, [sp, #40]	@ 0x28
      }
      for (p = s; (*p != '\0') && (--precision >= 0); p++) {
  207b7c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  207b7e:	930e      	str	r3, [sp, #56]	@ 0x38
  207b80:	e002      	b.n	207b88 <test_vprintf+0x318>
  207b82:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  207b84:	3301      	adds	r3, #1
  207b86:	930e      	str	r3, [sp, #56]	@ 0x38
  207b88:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  207b8a:	781b      	ldrb	r3, [r3, #0]
  207b8c:	2b00      	cmp	r3, #0
  207b8e:	d056      	beq.n	207c3e <test_vprintf+0x3ce>
  207b90:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  207b92:	3b01      	subs	r3, #1
  207b94:	930a      	str	r3, [sp, #40]	@ 0x28
  207b96:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  207b98:	2b00      	cmp	r3, #0
  207b9a:	daf2      	bge.n	207b82 <test_vprintf+0x312>
        /* Scanning string.*/
      }
      break;
  207b9c:	e04f      	b.n	207c3e <test_vprintf+0x3ce>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long) {
  207b9e:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
  207ba2:	2b00      	cmp	r3, #0
  207ba4:	d005      	beq.n	207bb2 <test_vprintf+0x342>
        arg = va_arg(ap, long);
  207ba6:	9b00      	ldr	r3, [sp, #0]
  207ba8:	1d1a      	adds	r2, r3, #4
  207baa:	9200      	str	r2, [sp, #0]
  207bac:	681b      	ldr	r3, [r3, #0]
  207bae:	9306      	str	r3, [sp, #24]
  207bb0:	e004      	b.n	207bbc <test_vprintf+0x34c>
      }
      else {
        arg = va_arg(ap, int);
  207bb2:	9b00      	ldr	r3, [sp, #0]
  207bb4:	1d1a      	adds	r2, r3, #4
  207bb6:	9200      	str	r2, [sp, #0]
  207bb8:	681b      	ldr	r3, [r3, #0]
  207bba:	9306      	str	r3, [sp, #24]
      }
      if (arg < 0) {
  207bbc:	9b06      	ldr	r3, [sp, #24]
  207bbe:	2b00      	cmp	r3, #0
  207bc0:	da08      	bge.n	207bd4 <test_vprintf+0x364>
        *p++ = '-';
  207bc2:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  207bc4:	1c5a      	adds	r2, r3, #1
  207bc6:	920e      	str	r2, [sp, #56]	@ 0x38
  207bc8:	222d      	movs	r2, #45	@ 0x2d
  207bca:	701a      	strb	r2, [r3, #0]
        arg = -arg;
  207bcc:	9b06      	ldr	r3, [sp, #24]
  207bce:	425b      	negs	r3, r3
  207bd0:	9306      	str	r3, [sp, #24]
  207bd2:	e008      	b.n	207be6 <test_vprintf+0x376>
      }
      else
        if (do_sign) {
  207bd4:	f89d 3021 	ldrb.w	r3, [sp, #33]	@ 0x21
  207bd8:	2b00      	cmp	r3, #0
  207bda:	d004      	beq.n	207be6 <test_vprintf+0x376>
          *p++ = '+';
  207bdc:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  207bde:	1c5a      	adds	r2, r3, #1
  207be0:	920e      	str	r2, [sp, #56]	@ 0x38
  207be2:	222b      	movs	r2, #43	@ 0x2b
  207be4:	701a      	strb	r2, [r3, #0]
        }
      p = test_ltoa(p, arg, 10);
  207be6:	220a      	movs	r2, #10
  207be8:	9906      	ldr	r1, [sp, #24]
  207bea:	980e      	ldr	r0, [sp, #56]	@ 0x38
  207bec:	f7ff fe18 	bl	207820 <test_ltoa>
  207bf0:	900e      	str	r0, [sp, #56]	@ 0x38
      break;
  207bf2:	e025      	b.n	207c40 <test_vprintf+0x3d0>
    case 'X':
    case 'x':
    case 'P':
    case 'p':
      radix = 16;
  207bf4:	2310      	movs	r3, #16
  207bf6:	9307      	str	r3, [sp, #28]
      goto unsigned_common;
  207bf8:	e004      	b.n	207c04 <test_vprintf+0x394>
    case 'U':
    case 'u':
      radix = 10;
  207bfa:	230a      	movs	r3, #10
  207bfc:	9307      	str	r3, [sp, #28]
      goto unsigned_common;
  207bfe:	e001      	b.n	207c04 <test_vprintf+0x394>
    case 'O':
    case 'o':
      radix = 8;
  207c00:	2308      	movs	r3, #8
  207c02:	9307      	str	r3, [sp, #28]
unsigned_common:
      if (is_long) {
  207c04:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
  207c08:	2b00      	cmp	r3, #0
  207c0a:	d005      	beq.n	207c18 <test_vprintf+0x3a8>
        arg = va_arg(ap, unsigned long);
  207c0c:	9b00      	ldr	r3, [sp, #0]
  207c0e:	1d1a      	adds	r2, r3, #4
  207c10:	9200      	str	r2, [sp, #0]
  207c12:	681b      	ldr	r3, [r3, #0]
  207c14:	9306      	str	r3, [sp, #24]
  207c16:	e004      	b.n	207c22 <test_vprintf+0x3b2>
      }
      else {
        arg = va_arg(ap, unsigned int);
  207c18:	9b00      	ldr	r3, [sp, #0]
  207c1a:	1d1a      	adds	r2, r3, #4
  207c1c:	9200      	str	r2, [sp, #0]
  207c1e:	681b      	ldr	r3, [r3, #0]
  207c20:	9306      	str	r3, [sp, #24]
      }
      p = test_ltoa(p, arg, radix);
  207c22:	9a07      	ldr	r2, [sp, #28]
  207c24:	9906      	ldr	r1, [sp, #24]
  207c26:	980e      	ldr	r0, [sp, #56]	@ 0x38
  207c28:	f7ff fdfa 	bl	207820 <test_ltoa>
  207c2c:	900e      	str	r0, [sp, #56]	@ 0x38
      break;
  207c2e:	e007      	b.n	207c40 <test_vprintf+0x3d0>
    default:
      *p++ = c;
  207c30:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  207c32:	1c5a      	adds	r2, r3, #1
  207c34:	920e      	str	r2, [sp, #56]	@ 0x38
  207c36:	f89d 2033 	ldrb.w	r2, [sp, #51]	@ 0x33
  207c3a:	701a      	strb	r2, [r3, #0]
      break;
  207c3c:	e000      	b.n	207c40 <test_vprintf+0x3d0>
      break;
  207c3e:	bf00      	nop
    }
    i = (int)(p - s);
  207c40:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
  207c42:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  207c44:	1ad3      	subs	r3, r2, r3
  207c46:	930b      	str	r3, [sp, #44]	@ 0x2c
    width -= i;
  207c48:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  207c4a:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  207c4c:	1ad3      	subs	r3, r2, r3
  207c4e:	9309      	str	r3, [sp, #36]	@ 0x24
    if (width < 0) {
  207c50:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  207c52:	2b00      	cmp	r3, #0
  207c54:	da01      	bge.n	207c5a <test_vprintf+0x3ea>
      width = 0;
  207c56:	2300      	movs	r3, #0
  207c58:	9309      	str	r3, [sp, #36]	@ 0x24
    }
    if (left_align == false) {
  207c5a:	f89d 3022 	ldrb.w	r3, [sp, #34]	@ 0x22
  207c5e:	f083 0301 	eor.w	r3, r3, #1
  207c62:	b2db      	uxtb	r3, r3
  207c64:	2b00      	cmp	r3, #0
  207c66:	d002      	beq.n	207c6e <test_vprintf+0x3fe>
      width = -width;
  207c68:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  207c6a:	425b      	negs	r3, r3
  207c6c:	9309      	str	r3, [sp, #36]	@ 0x24
    }
    if (width < 0) {
  207c6e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  207c70:	2b00      	cmp	r3, #0
  207c72:	da31      	bge.n	207cd8 <test_vprintf+0x468>
      if (((*s == '-') || (*s == '+')) && (filler == '0')) {
  207c74:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  207c76:	781b      	ldrb	r3, [r3, #0]
  207c78:	2b2d      	cmp	r3, #45	@ 0x2d
  207c7a:	d003      	beq.n	207c84 <test_vprintf+0x414>
  207c7c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  207c7e:	781b      	ldrb	r3, [r3, #0]
  207c80:	2b2b      	cmp	r3, #43	@ 0x2b
  207c82:	d110      	bne.n	207ca6 <test_vprintf+0x436>
  207c84:	f89d 3032 	ldrb.w	r3, [sp, #50]	@ 0x32
  207c88:	2b30      	cmp	r3, #48	@ 0x30
  207c8a:	d10c      	bne.n	207ca6 <test_vprintf+0x436>
        test_putchar(*s++);
  207c8c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  207c8e:	1c5a      	adds	r2, r3, #1
  207c90:	920d      	str	r2, [sp, #52]	@ 0x34
  207c92:	781b      	ldrb	r3, [r3, #0]
  207c94:	4618      	mov	r0, r3
  207c96:	f7ff fdd3 	bl	207840 <test_putchar>
        n++;
  207c9a:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  207c9c:	3301      	adds	r3, #1
  207c9e:	930f      	str	r3, [sp, #60]	@ 0x3c
        i--;
  207ca0:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  207ca2:	3b01      	subs	r3, #1
  207ca4:	930b      	str	r3, [sp, #44]	@ 0x2c
      }
      do {
        test_putchar(filler);
  207ca6:	f89d 3032 	ldrb.w	r3, [sp, #50]	@ 0x32
  207caa:	4618      	mov	r0, r3
  207cac:	f7ff fdc8 	bl	207840 <test_putchar>
        n++;
  207cb0:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  207cb2:	3301      	adds	r3, #1
  207cb4:	930f      	str	r3, [sp, #60]	@ 0x3c
      } while (++width != 0);
  207cb6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  207cb8:	3301      	adds	r3, #1
  207cba:	9309      	str	r3, [sp, #36]	@ 0x24
  207cbc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  207cbe:	2b00      	cmp	r3, #0
  207cc0:	d1f1      	bne.n	207ca6 <test_vprintf+0x436>
    }
    while (--i >= 0) {
  207cc2:	e009      	b.n	207cd8 <test_vprintf+0x468>
      test_putchar(*s++);
  207cc4:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  207cc6:	1c5a      	adds	r2, r3, #1
  207cc8:	920d      	str	r2, [sp, #52]	@ 0x34
  207cca:	781b      	ldrb	r3, [r3, #0]
  207ccc:	4618      	mov	r0, r3
  207cce:	f7ff fdb7 	bl	207840 <test_putchar>
      n++;
  207cd2:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  207cd4:	3301      	adds	r3, #1
  207cd6:	930f      	str	r3, [sp, #60]	@ 0x3c
    while (--i >= 0) {
  207cd8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  207cda:	3b01      	subs	r3, #1
  207cdc:	930b      	str	r3, [sp, #44]	@ 0x2c
  207cde:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  207ce0:	2b00      	cmp	r3, #0
  207ce2:	daef      	bge.n	207cc4 <test_vprintf+0x454>
    }

    while (width) {
  207ce4:	e00a      	b.n	207cfc <test_vprintf+0x48c>
      test_putchar(filler);
  207ce6:	f89d 3032 	ldrb.w	r3, [sp, #50]	@ 0x32
  207cea:	4618      	mov	r0, r3
  207cec:	f7ff fda8 	bl	207840 <test_putchar>
      n++;
  207cf0:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  207cf2:	3301      	adds	r3, #1
  207cf4:	930f      	str	r3, [sp, #60]	@ 0x3c
      width--;
  207cf6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  207cf8:	3b01      	subs	r3, #1
  207cfa:	9309      	str	r3, [sp, #36]	@ 0x24
    while (width) {
  207cfc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  207cfe:	2b00      	cmp	r3, #0
  207d00:	d1f1      	bne.n	207ce6 <test_vprintf+0x476>
  while (true) {
  207d02:	e5bb      	b.n	20787c <test_vprintf+0xc>
    }
  }
}
  207d04:	4618      	mov	r0, r3
  207d06:	b011      	add	sp, #68	@ 0x44
  207d08:	f85d fb04 	ldr.w	pc, [sp], #4
  207d0c:	08010db4 	.word	0x08010db4

00207d10 <test_printf>:
 * @param[in] fmt       formatting string
 * @return              The number of bytes written.
 *
 * @api
 */
int test_printf(const char *fmt, ...) {
  207d10:	b40f      	push	{r0, r1, r2, r3}
  207d12:	b500      	push	{lr}
  207d14:	b083      	sub	sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  207d16:	ab05      	add	r3, sp, #20
  207d18:	9300      	str	r3, [sp, #0]
  formatted_bytes = test_vprintf(fmt, ap);
  207d1a:	9900      	ldr	r1, [sp, #0]
  207d1c:	9804      	ldr	r0, [sp, #16]
  207d1e:	f7ff fda7 	bl	207870 <test_vprintf>
  207d22:	9001      	str	r0, [sp, #4]
  va_end(ap);

  return formatted_bytes;
  207d24:	9b01      	ldr	r3, [sp, #4]
}
  207d26:	4618      	mov	r0, r3
  207d28:	b003      	add	sp, #12
  207d2a:	f85d eb04 	ldr.w	lr, [sp], #4
  207d2e:	b004      	add	sp, #16
  207d30:	4770      	bx	lr
  207d32:	bf00      	nop
	...

00207d40 <port_timer_get_time.lto_priv.4>:
static inline systime_t port_timer_get_time(void) {
  207d40:	b508      	push	{r3, lr}
  return stGetCounter();
  207d42:	f7f8 fdcd 	bl	2008e0 <stGetCounter>
  207d46:	4603      	mov	r3, r0
}
  207d48:	4618      	mov	r0, r3
  207d4a:	bd08      	pop	{r3, pc}
  207d4c:	0000      	movs	r0, r0
	...

00207d50 <chSysLock.lto_priv.18>:
static inline void chSysLock(void) {
  207d50:	b082      	sub	sp, #8
  207d52:	2330      	movs	r3, #48	@ 0x30
  207d54:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207d56:	9b01      	ldr	r3, [sp, #4]
  207d58:	f383 8811 	msr	BASEPRI, r3
}
  207d5c:	bf00      	nop
}
  207d5e:	bf00      	nop
}
  207d60:	bf00      	nop
  207d62:	b002      	add	sp, #8
  207d64:	4770      	bx	lr
  207d66:	bf00      	nop
	...

00207d70 <chSysUnlock.lto_priv.18>:
static inline void chSysUnlock(void) {
  207d70:	b082      	sub	sp, #8
  207d72:	2300      	movs	r3, #0
  207d74:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207d76:	9b01      	ldr	r3, [sp, #4]
  207d78:	f383 8811 	msr	BASEPRI, r3
}
  207d7c:	bf00      	nop
}
  207d7e:	bf00      	nop
}
  207d80:	bf00      	nop
  207d82:	b002      	add	sp, #8
  207d84:	4770      	bx	lr
  207d86:	bf00      	nop
	...

00207d90 <chVTGetSystemTimeX.lto_priv.4>:
static inline systime_t chVTGetSystemTimeX(void) {
  207d90:	b508      	push	{r3, lr}
  return port_timer_get_time();
  207d92:	f7ff ffd5 	bl	207d40 <port_timer_get_time.lto_priv.4>
  207d96:	4603      	mov	r3, r0
}
  207d98:	4618      	mov	r0, r3
  207d9a:	bd08      	pop	{r3, pc}
  207d9c:	0000      	movs	r0, r0
	...

00207da0 <chVTGetSystemTime>:
static inline systime_t chVTGetSystemTime(void) {
  207da0:	b500      	push	{lr}
  207da2:	b083      	sub	sp, #12
  chSysLock();
  207da4:	f7ff ffd4 	bl	207d50 <chSysLock.lto_priv.18>
  systime = chVTGetSystemTimeX();
  207da8:	f7ff fff2 	bl	207d90 <chVTGetSystemTimeX.lto_priv.4>
  207dac:	9001      	str	r0, [sp, #4]
  chSysUnlock();
  207dae:	f7ff ffdf 	bl	207d70 <chSysUnlock.lto_priv.18>
  return systime;
  207db2:	9b01      	ldr	r3, [sp, #4]
}
  207db4:	4618      	mov	r0, r3
  207db6:	b003      	add	sp, #12
  207db8:	f85d fb04 	ldr.w	pc, [sp], #4
  207dbc:	0000      	movs	r0, r0
	...

00207dc0 <test_terminate_threads>:
                         test_buffer + (TEST_BUFFER_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  207dc0:	b500      	push	{lr}
  207dc2:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
  207dc4:	2300      	movs	r3, #0
  207dc6:	9301      	str	r3, [sp, #4]
  207dc8:	e00f      	b.n	207dea <test_terminate_threads+0x2a>
    if (threads[i])
  207dca:	4a0c      	ldr	r2, [pc, #48]	@ (207dfc <test_terminate_threads+0x3c>)
  207dcc:	9b01      	ldr	r3, [sp, #4]
  207dce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  207dd2:	2b00      	cmp	r3, #0
  207dd4:	d006      	beq.n	207de4 <test_terminate_threads+0x24>
      chThdTerminate(threads[i]);
  207dd6:	4a09      	ldr	r2, [pc, #36]	@ (207dfc <test_terminate_threads+0x3c>)
  207dd8:	9b01      	ldr	r3, [sp, #4]
  207dda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  207dde:	4618      	mov	r0, r3
  207de0:	f7fb fbee 	bl	2035c0 <chThdTerminate>
  for (i = 0; i < MAX_THREADS; i++)
  207de4:	9b01      	ldr	r3, [sp, #4]
  207de6:	3301      	adds	r3, #1
  207de8:	9301      	str	r3, [sp, #4]
  207dea:	9b01      	ldr	r3, [sp, #4]
  207dec:	2b04      	cmp	r3, #4
  207dee:	d9ec      	bls.n	207dca <test_terminate_threads+0xa>
}
  207df0:	bf00      	nop
  207df2:	bf00      	nop
  207df4:	b003      	add	sp, #12
  207df6:	f85d fb04 	ldr.w	pc, [sp], #4
  207dfa:	bf00      	nop
  207dfc:	20001900 	.word	0x20001900

00207e00 <test_wait_threads>:

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  207e00:	b500      	push	{lr}
  207e02:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
  207e04:	2300      	movs	r3, #0
  207e06:	9301      	str	r3, [sp, #4]
  207e08:	e014      	b.n	207e34 <test_wait_threads+0x34>
    if (threads[i] != NULL) {
  207e0a:	4a0e      	ldr	r2, [pc, #56]	@ (207e44 <test_wait_threads+0x44>)
  207e0c:	9b01      	ldr	r3, [sp, #4]
  207e0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  207e12:	2b00      	cmp	r3, #0
  207e14:	d00b      	beq.n	207e2e <test_wait_threads+0x2e>
      chThdWait(threads[i]);
  207e16:	4a0b      	ldr	r2, [pc, #44]	@ (207e44 <test_wait_threads+0x44>)
  207e18:	9b01      	ldr	r3, [sp, #4]
  207e1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  207e1e:	4618      	mov	r0, r3
  207e20:	f7fb fb7e 	bl	203520 <chThdWait>
      threads[i] = NULL;
  207e24:	4a07      	ldr	r2, [pc, #28]	@ (207e44 <test_wait_threads+0x44>)
  207e26:	9b01      	ldr	r3, [sp, #4]
  207e28:	2100      	movs	r1, #0
  207e2a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  for (i = 0; i < MAX_THREADS; i++)
  207e2e:	9b01      	ldr	r3, [sp, #4]
  207e30:	3301      	adds	r3, #1
  207e32:	9301      	str	r3, [sp, #4]
  207e34:	9b01      	ldr	r3, [sp, #4]
  207e36:	2b04      	cmp	r3, #4
  207e38:	d9e7      	bls.n	207e0a <test_wait_threads+0xa>
    }
}
  207e3a:	bf00      	nop
  207e3c:	bf00      	nop
  207e3e:	b003      	add	sp, #12
  207e40:	f85d fb04 	ldr.w	pc, [sp], #4
  207e44:	20001900 	.word	0x20001900
	...

00207e50 <test_wait_tick>:

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
  207e50:	b508      	push	{r3, lr}

  chThdSleep(1);
  207e52:	2001      	movs	r0, #1
  207e54:	f7fb fbcc 	bl	2035f0 <chThdSleep>
  return chVTGetSystemTime();
  207e58:	f7ff ffa2 	bl	207da0 <chVTGetSystemTime>
  207e5c:	4603      	mov	r3, r0
}
  207e5e:	4618      	mov	r0, r3
  207e60:	bd08      	pop	{r3, pc}
  207e62:	bf00      	nop
	...

00207e70 <test_printn.lto_priv.0>:
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
static inline void test_printn(uint32_t n) {
  207e70:	b500      	push	{lr}
  207e72:	b083      	sub	sp, #12
  207e74:	9001      	str	r0, [sp, #4]

  test_printf("%u", n);
  207e76:	9901      	ldr	r1, [sp, #4]
  207e78:	4803      	ldr	r0, [pc, #12]	@ (207e88 <test_printn.lto_priv.0+0x18>)
  207e7a:	f7ff ff49 	bl	207d10 <test_printf>
}
  207e7e:	bf00      	nop
  207e80:	b003      	add	sp, #12
  207e82:	f85d fb04 	ldr.w	pc, [sp], #4
  207e86:	bf00      	nop
  207e88:	08010dbc 	.word	0x08010dbc
  207e8c:	00000000 	.word	0x00000000

00207e90 <test_print.lto_priv.0>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
static inline void test_print(const char *msgp) {
  207e90:	b500      	push	{lr}
  207e92:	b083      	sub	sp, #12
  207e94:	9001      	str	r0, [sp, #4]

  test_printf("%s", msgp);
  207e96:	9901      	ldr	r1, [sp, #4]
  207e98:	4803      	ldr	r0, [pc, #12]	@ (207ea8 <test_print.lto_priv.0+0x18>)
  207e9a:	f7ff ff39 	bl	207d10 <test_printf>
}
  207e9e:	bf00      	nop
  207ea0:	b003      	add	sp, #12
  207ea2:	f85d fb04 	ldr.w	pc, [sp], #4
  207ea6:	bf00      	nop
  207ea8:	08010dc0 	.word	0x08010dc0
  207eac:	00000000 	.word	0x00000000

00207eb0 <test_println.lto_priv.0>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
static inline void test_println(const char *msgp) {
  207eb0:	b500      	push	{lr}
  207eb2:	b083      	sub	sp, #12
  207eb4:	9001      	str	r0, [sp, #4]

  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
  207eb6:	9901      	ldr	r1, [sp, #4]
  207eb8:	4803      	ldr	r0, [pc, #12]	@ (207ec8 <test_println.lto_priv.0+0x18>)
  207eba:	f7ff ff29 	bl	207d10 <test_printf>
}
  207ebe:	bf00      	nop
  207ec0:	b003      	add	sp, #12
  207ec2:	f85d fb04 	ldr.w	pc, [sp], #4
  207ec6:	bf00      	nop
  207ec8:	08010bb4 	.word	0x08010bb4
  207ecc:	00000000 	.word	0x00000000

00207ed0 <rt_test_001_001_execute>:
 * <h2>Test Steps</h2>
 * - [1.1.1] Prints the version string.
 * .
 */

static void rt_test_001_001_execute(void) {
  207ed0:	b508      	push	{r3, lr}

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
  207ed2:	4b1c      	ldr	r3, [pc, #112]	@ (207f44 <rt_test_001_001_execute+0x74>)
  207ed4:	2201      	movs	r2, #1
  207ed6:	601a      	str	r2, [r3, #0]
  {
#if defined(PORT_ARCHITECTURE_NAME)
    test_print("--- Architecture:                       ");
  207ed8:	481b      	ldr	r0, [pc, #108]	@ (207f48 <rt_test_001_001_execute+0x78>)
  207eda:	f7ff ffd9 	bl	207e90 <test_print.lto_priv.0>
    test_println(PORT_ARCHITECTURE_NAME);
  207ede:	481b      	ldr	r0, [pc, #108]	@ (207f4c <rt_test_001_001_execute+0x7c>)
  207ee0:	f7ff ffe6 	bl	207eb0 <test_println.lto_priv.0>
#endif
#if defined(PORT_CORE_VARIANT_NAME)
    test_print("--- Core Variant:                       ");
  207ee4:	481a      	ldr	r0, [pc, #104]	@ (207f50 <rt_test_001_001_execute+0x80>)
  207ee6:	f7ff ffd3 	bl	207e90 <test_print.lto_priv.0>
    test_println(PORT_CORE_VARIANT_NAME);
  207eea:	481a      	ldr	r0, [pc, #104]	@ (207f54 <rt_test_001_001_execute+0x84>)
  207eec:	f7ff ffe0 	bl	207eb0 <test_println.lto_priv.0>
#endif
#if defined(PORT_COMPILER_NAME)
    test_print("--- Compiler:                           ");
  207ef0:	4819      	ldr	r0, [pc, #100]	@ (207f58 <rt_test_001_001_execute+0x88>)
  207ef2:	f7ff ffcd 	bl	207e90 <test_print.lto_priv.0>
    test_println(PORT_COMPILER_NAME);
  207ef6:	4819      	ldr	r0, [pc, #100]	@ (207f5c <rt_test_001_001_execute+0x8c>)
  207ef8:	f7ff ffda 	bl	207eb0 <test_println.lto_priv.0>
#endif
#if defined(PORT_INFO)
    test_print("--- Port Info:                          ");
  207efc:	4818      	ldr	r0, [pc, #96]	@ (207f60 <rt_test_001_001_execute+0x90>)
  207efe:	f7ff ffc7 	bl	207e90 <test_print.lto_priv.0>
    test_println(PORT_INFO);
  207f02:	4818      	ldr	r0, [pc, #96]	@ (207f64 <rt_test_001_001_execute+0x94>)
  207f04:	f7ff ffd4 	bl	207eb0 <test_println.lto_priv.0>
#endif
#if defined(PORT_NATURAL_ALIGN)
    test_print("--- Natural alignment:                  ");
  207f08:	4817      	ldr	r0, [pc, #92]	@ (207f68 <rt_test_001_001_execute+0x98>)
  207f0a:	f7ff ffc1 	bl	207e90 <test_print.lto_priv.0>
    test_printn(PORT_NATURAL_ALIGN);
  207f0e:	2004      	movs	r0, #4
  207f10:	f7ff ffae 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  207f14:	4815      	ldr	r0, [pc, #84]	@ (207f6c <rt_test_001_001_execute+0x9c>)
  207f16:	f7ff ffcb 	bl	207eb0 <test_println.lto_priv.0>
#endif
#if defined(PORT_STACK_ALIGN)
    test_print("--- Stack alignment:                    ");
  207f1a:	4815      	ldr	r0, [pc, #84]	@ (207f70 <rt_test_001_001_execute+0xa0>)
  207f1c:	f7ff ffb8 	bl	207e90 <test_print.lto_priv.0>
    test_printn(PORT_STACK_ALIGN);
  207f20:	2020      	movs	r0, #32
  207f22:	f7ff ffa5 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  207f26:	4811      	ldr	r0, [pc, #68]	@ (207f6c <rt_test_001_001_execute+0x9c>)
  207f28:	f7ff ffc2 	bl	207eb0 <test_println.lto_priv.0>
#endif
#if defined(PORT_WORKING_AREA_ALIGN)
    test_print("--- Working area alignment:             ");
  207f2c:	4811      	ldr	r0, [pc, #68]	@ (207f74 <rt_test_001_001_execute+0xa4>)
  207f2e:	f7ff ffaf 	bl	207e90 <test_print.lto_priv.0>
    test_printn(PORT_WORKING_AREA_ALIGN);
  207f32:	2020      	movs	r0, #32
  207f34:	f7ff ff9c 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  207f38:	480c      	ldr	r0, [pc, #48]	@ (207f6c <rt_test_001_001_execute+0x9c>)
  207f3a:	f7ff ffb9 	bl	207eb0 <test_println.lto_priv.0>
#endif
  }
  test_end_step(1);
}
  207f3e:	bf00      	nop
  207f40:	bd08      	pop	{r3, pc}
  207f42:	bf00      	nop
  207f44:	20000bb4 	.word	0x20000bb4
  207f48:	08010dc4 	.word	0x08010dc4
  207f4c:	08010df0 	.word	0x08010df0
  207f50:	08010dfc 	.word	0x08010dfc
  207f54:	08010e28 	.word	0x08010e28
  207f58:	08010e34 	.word	0x08010e34
  207f5c:	08010e60 	.word	0x08010e60
  207f60:	08010e74 	.word	0x08010e74
  207f64:	08010ea0 	.word	0x08010ea0
  207f68:	08010eb8 	.word	0x08010eb8
  207f6c:	08010bcc 	.word	0x08010bcc
  207f70:	08010ee4 	.word	0x08010ee4
  207f74:	08010f10 	.word	0x08010f10
	...

00207f80 <rt_test_001_002_execute>:
 * <h2>Test Steps</h2>
 * - [1.2.1] Prints the version string.
 * .
 */

static void rt_test_001_002_execute(void) {
  207f80:	b508      	push	{r3, lr}

  /* [1.2.1] Prints the version string.*/
  test_set_step(1);
  207f82:	4b19      	ldr	r3, [pc, #100]	@ (207fe8 <rt_test_001_002_execute+0x68>)
  207f84:	2201      	movs	r2, #1
  207f86:	601a      	str	r2, [r3, #0]
  {
    test_println("--- Product:                            ChibiOS/RT");
  207f88:	4818      	ldr	r0, [pc, #96]	@ (207fec <rt_test_001_002_execute+0x6c>)
  207f8a:	f7ff ff91 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- Stable Flag:                        ");
  207f8e:	4818      	ldr	r0, [pc, #96]	@ (207ff0 <rt_test_001_002_execute+0x70>)
  207f90:	f7ff ff7e 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_KERNEL_STABLE);
  207f94:	2000      	movs	r0, #0
  207f96:	f7ff ff6b 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  207f9a:	4816      	ldr	r0, [pc, #88]	@ (207ff4 <rt_test_001_002_execute+0x74>)
  207f9c:	f7ff ff88 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- Version String:                     ");
  207fa0:	4815      	ldr	r0, [pc, #84]	@ (207ff8 <rt_test_001_002_execute+0x78>)
  207fa2:	f7ff ff75 	bl	207e90 <test_print.lto_priv.0>
    test_println(CH_KERNEL_VERSION);
  207fa6:	4815      	ldr	r0, [pc, #84]	@ (207ffc <rt_test_001_002_execute+0x7c>)
  207fa8:	f7ff ff82 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- Major Number:                       ");
  207fac:	4814      	ldr	r0, [pc, #80]	@ (208000 <rt_test_001_002_execute+0x80>)
  207fae:	f7ff ff6f 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_KERNEL_MAJOR);
  207fb2:	2008      	movs	r0, #8
  207fb4:	f7ff ff5c 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  207fb8:	480e      	ldr	r0, [pc, #56]	@ (207ff4 <rt_test_001_002_execute+0x74>)
  207fba:	f7ff ff79 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- Minor Number:                       ");
  207fbe:	4811      	ldr	r0, [pc, #68]	@ (208004 <rt_test_001_002_execute+0x84>)
  207fc0:	f7ff ff66 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_KERNEL_MINOR);
  207fc4:	2000      	movs	r0, #0
  207fc6:	f7ff ff53 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  207fca:	480a      	ldr	r0, [pc, #40]	@ (207ff4 <rt_test_001_002_execute+0x74>)
  207fcc:	f7ff ff70 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- Patch Number:                       ");
  207fd0:	480d      	ldr	r0, [pc, #52]	@ (208008 <rt_test_001_002_execute+0x88>)
  207fd2:	f7ff ff5d 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_KERNEL_PATCH);
  207fd6:	2000      	movs	r0, #0
  207fd8:	f7ff ff4a 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  207fdc:	4805      	ldr	r0, [pc, #20]	@ (207ff4 <rt_test_001_002_execute+0x74>)
  207fde:	f7ff ff67 	bl	207eb0 <test_println.lto_priv.0>
  }
  test_end_step(1);
}
  207fe2:	bf00      	nop
  207fe4:	bd08      	pop	{r3, pc}
  207fe6:	bf00      	nop
  207fe8:	20000bb4 	.word	0x20000bb4
  207fec:	08010f3c 	.word	0x08010f3c
  207ff0:	08010f70 	.word	0x08010f70
  207ff4:	08010bcc 	.word	0x08010bcc
  207ff8:	08010f9c 	.word	0x08010f9c
  207ffc:	08010fc8 	.word	0x08010fc8
  208000:	08010fd0 	.word	0x08010fd0
  208004:	08010ffc 	.word	0x08010ffc
  208008:	08011028 	.word	0x08011028
  20800c:	00000000 	.word	0x00000000

00208010 <rt_test_001_003_execute>:
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void rt_test_001_003_execute(void) {
  208010:	b508      	push	{r3, lr}

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
  208012:	4b9c      	ldr	r3, [pc, #624]	@ (208284 <rt_test_001_003_execute+0x274>)
  208014:	2201      	movs	r2, #1
  208016:	601a      	str	r2, [r3, #0]
  {
    test_print("--- CH_CFG_SMP_MODE:                    ");
  208018:	489b      	ldr	r0, [pc, #620]	@ (208288 <rt_test_001_003_execute+0x278>)
  20801a:	f7ff ff39 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_SMP_MODE);
  20801e:	2000      	movs	r0, #0
  208020:	f7ff ff26 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208024:	4899      	ldr	r0, [pc, #612]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208026:	f7ff ff43 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_HARDENING_LEVEL:             ");
  20802a:	4899      	ldr	r0, [pc, #612]	@ (208290 <rt_test_001_003_execute+0x280>)
  20802c:	f7ff ff30 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_HARDENING_LEVEL);
  208030:	2000      	movs	r0, #0
  208032:	f7ff ff1d 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208036:	4895      	ldr	r0, [pc, #596]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208038:	f7ff ff3a 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
  20803c:	4895      	ldr	r0, [pc, #596]	@ (208294 <rt_test_001_003_execute+0x284>)
  20803e:	f7ff ff27 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_ST_RESOLUTION);
  208042:	2020      	movs	r0, #32
  208044:	f7ff ff14 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208048:	4890      	ldr	r0, [pc, #576]	@ (20828c <rt_test_001_003_execute+0x27c>)
  20804a:	f7ff ff31 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_ST_FREQUENCY:                ");
  20804e:	4892      	ldr	r0, [pc, #584]	@ (208298 <rt_test_001_003_execute+0x288>)
  208050:	f7ff ff1e 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_ST_FREQUENCY);
  208054:	f242 7010 	movw	r0, #10000	@ 0x2710
  208058:	f7ff ff0a 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  20805c:	488b      	ldr	r0, [pc, #556]	@ (20828c <rt_test_001_003_execute+0x27c>)
  20805e:	f7ff ff27 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_INTERVALS_SIZE:              ");
  208062:	488e      	ldr	r0, [pc, #568]	@ (20829c <rt_test_001_003_execute+0x28c>)
  208064:	f7ff ff14 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_INTERVALS_SIZE);
  208068:	2020      	movs	r0, #32
  20806a:	f7ff ff01 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  20806e:	4887      	ldr	r0, [pc, #540]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208070:	f7ff ff1e 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_TIME_TYPES_SIZE:             ");
  208074:	488a      	ldr	r0, [pc, #552]	@ (2082a0 <rt_test_001_003_execute+0x290>)
  208076:	f7ff ff0b 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_TIME_TYPES_SIZE);
  20807a:	2020      	movs	r0, #32
  20807c:	f7ff fef8 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208080:	4882      	ldr	r0, [pc, #520]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208082:	f7ff ff15 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_ST_TIMEDELTA:                ");
  208086:	4887      	ldr	r0, [pc, #540]	@ (2082a4 <rt_test_001_003_execute+0x294>)
  208088:	f7ff ff02 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_ST_TIMEDELTA);
  20808c:	2002      	movs	r0, #2
  20808e:	f7ff feef 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208092:	487e      	ldr	r0, [pc, #504]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208094:	f7ff ff0c 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_TIME_QUANTUM:                ");
  208098:	4883      	ldr	r0, [pc, #524]	@ (2082a8 <rt_test_001_003_execute+0x298>)
  20809a:	f7ff fef9 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_TIME_QUANTUM);
  20809e:	2000      	movs	r0, #0
  2080a0:	f7ff fee6 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2080a4:	4879      	ldr	r0, [pc, #484]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2080a6:	f7ff ff03 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_NO_IDLE_THREAD:              ");
  2080aa:	4880      	ldr	r0, [pc, #512]	@ (2082ac <rt_test_001_003_execute+0x29c>)
  2080ac:	f7ff fef0 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_NO_IDLE_THREAD);
  2080b0:	2000      	movs	r0, #0
  2080b2:	f7ff fedd 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2080b6:	4875      	ldr	r0, [pc, #468]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2080b8:	f7ff fefa 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_OPTIMIZE_SPEED:              ");
  2080bc:	487c      	ldr	r0, [pc, #496]	@ (2082b0 <rt_test_001_003_execute+0x2a0>)
  2080be:	f7ff fee7 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_OPTIMIZE_SPEED);
  2080c2:	2001      	movs	r0, #1
  2080c4:	f7ff fed4 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2080c8:	4870      	ldr	r0, [pc, #448]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2080ca:	f7ff fef1 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_TM:                      ");
  2080ce:	4879      	ldr	r0, [pc, #484]	@ (2082b4 <rt_test_001_003_execute+0x2a4>)
  2080d0:	f7ff fede 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_TM);
  2080d4:	2001      	movs	r0, #1
  2080d6:	f7ff fecb 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2080da:	486c      	ldr	r0, [pc, #432]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2080dc:	f7ff fee8 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_TIMESTAMP:               ");
  2080e0:	4875      	ldr	r0, [pc, #468]	@ (2082b8 <rt_test_001_003_execute+0x2a8>)
  2080e2:	f7ff fed5 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_TIMESTAMP);
  2080e6:	2001      	movs	r0, #1
  2080e8:	f7ff fec2 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2080ec:	4867      	ldr	r0, [pc, #412]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2080ee:	f7ff fedf 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_REGISTRY:                ");
  2080f2:	4872      	ldr	r0, [pc, #456]	@ (2082bc <rt_test_001_003_execute+0x2ac>)
  2080f4:	f7ff fecc 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_REGISTRY);
  2080f8:	2001      	movs	r0, #1
  2080fa:	f7ff feb9 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2080fe:	4863      	ldr	r0, [pc, #396]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208100:	f7ff fed6 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_WAITEXIT:                ");
  208104:	486e      	ldr	r0, [pc, #440]	@ (2082c0 <rt_test_001_003_execute+0x2b0>)
  208106:	f7ff fec3 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_WAITEXIT);
  20810a:	2001      	movs	r0, #1
  20810c:	f7ff feb0 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208110:	485e      	ldr	r0, [pc, #376]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208112:	f7ff fecd 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_SEMAPHORES:              ");
  208116:	486b      	ldr	r0, [pc, #428]	@ (2082c4 <rt_test_001_003_execute+0x2b4>)
  208118:	f7ff feba 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_SEMAPHORES);
  20811c:	2001      	movs	r0, #1
  20811e:	f7ff fea7 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208122:	485a      	ldr	r0, [pc, #360]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208124:	f7ff fec4 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_SEMAPHORES_PRIORITY:     ");
  208128:	4867      	ldr	r0, [pc, #412]	@ (2082c8 <rt_test_001_003_execute+0x2b8>)
  20812a:	f7ff feb1 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_SEMAPHORES_PRIORITY);
  20812e:	2000      	movs	r0, #0
  208130:	f7ff fe9e 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208134:	4855      	ldr	r0, [pc, #340]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208136:	f7ff febb 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_MUTEXES:                 ");
  20813a:	4864      	ldr	r0, [pc, #400]	@ (2082cc <rt_test_001_003_execute+0x2bc>)
  20813c:	f7ff fea8 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_MUTEXES);
  208140:	2001      	movs	r0, #1
  208142:	f7ff fe95 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208146:	4851      	ldr	r0, [pc, #324]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208148:	f7ff feb2 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_MUTEXES_RECURSIVE:       ");
  20814c:	4860      	ldr	r0, [pc, #384]	@ (2082d0 <rt_test_001_003_execute+0x2c0>)
  20814e:	f7ff fe9f 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_MUTEXES_RECURSIVE);
  208152:	2000      	movs	r0, #0
  208154:	f7ff fe8c 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");   
  208158:	484c      	ldr	r0, [pc, #304]	@ (20828c <rt_test_001_003_execute+0x27c>)
  20815a:	f7ff fea9 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_CONDVARS:                ");
  20815e:	485d      	ldr	r0, [pc, #372]	@ (2082d4 <rt_test_001_003_execute+0x2c4>)
  208160:	f7ff fe96 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_CONDVARS);
  208164:	2001      	movs	r0, #1
  208166:	f7ff fe83 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  20816a:	4848      	ldr	r0, [pc, #288]	@ (20828c <rt_test_001_003_execute+0x27c>)
  20816c:	f7ff fea0 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_CONDVARS_TIMEOUT:        ");
  208170:	4859      	ldr	r0, [pc, #356]	@ (2082d8 <rt_test_001_003_execute+0x2c8>)
  208172:	f7ff fe8d 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_CONDVARS_TIMEOUT);
  208176:	2001      	movs	r0, #1
  208178:	f7ff fe7a 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  20817c:	4843      	ldr	r0, [pc, #268]	@ (20828c <rt_test_001_003_execute+0x27c>)
  20817e:	f7ff fe97 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_EVENTS:                  ");
  208182:	4856      	ldr	r0, [pc, #344]	@ (2082dc <rt_test_001_003_execute+0x2cc>)
  208184:	f7ff fe84 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_EVENTS);
  208188:	2001      	movs	r0, #1
  20818a:	f7ff fe71 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  20818e:	483f      	ldr	r0, [pc, #252]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208190:	f7ff fe8e 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_EVENTS_TIMEOUT:          ");
  208194:	4852      	ldr	r0, [pc, #328]	@ (2082e0 <rt_test_001_003_execute+0x2d0>)
  208196:	f7ff fe7b 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_EVENTS_TIMEOUT);
  20819a:	2001      	movs	r0, #1
  20819c:	f7ff fe68 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2081a0:	483a      	ldr	r0, [pc, #232]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2081a2:	f7ff fe85 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_MESSAGES:                ");
  2081a6:	484f      	ldr	r0, [pc, #316]	@ (2082e4 <rt_test_001_003_execute+0x2d4>)
  2081a8:	f7ff fe72 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_MESSAGES);
  2081ac:	2001      	movs	r0, #1
  2081ae:	f7ff fe5f 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2081b2:	4836      	ldr	r0, [pc, #216]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2081b4:	f7ff fe7c 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_MESSAGES_PRIORITY:       ");
  2081b8:	484b      	ldr	r0, [pc, #300]	@ (2082e8 <rt_test_001_003_execute+0x2d8>)
  2081ba:	f7ff fe69 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_MESSAGES_PRIORITY);
  2081be:	2000      	movs	r0, #0
  2081c0:	f7ff fe56 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2081c4:	4831      	ldr	r0, [pc, #196]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2081c6:	f7ff fe73 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_CFG_USE_DYNAMIC:                 ");
  2081ca:	4848      	ldr	r0, [pc, #288]	@ (2082ec <rt_test_001_003_execute+0x2dc>)
  2081cc:	f7ff fe60 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_CFG_USE_DYNAMIC);
  2081d0:	2001      	movs	r0, #1
  2081d2:	f7ff fe4d 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2081d6:	482d      	ldr	r0, [pc, #180]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2081d8:	f7ff fe6a 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_DBG_STATISTICS:                  ");
  2081dc:	4844      	ldr	r0, [pc, #272]	@ (2082f0 <rt_test_001_003_execute+0x2e0>)
  2081de:	f7ff fe57 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_DBG_STATISTICS);
  2081e2:	2000      	movs	r0, #0
  2081e4:	f7ff fe44 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2081e8:	4828      	ldr	r0, [pc, #160]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2081ea:	f7ff fe61 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_DBG_SYSTEM_STATE_CHECK:          ");
  2081ee:	4841      	ldr	r0, [pc, #260]	@ (2082f4 <rt_test_001_003_execute+0x2e4>)
  2081f0:	f7ff fe4e 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_DBG_SYSTEM_STATE_CHECK);
  2081f4:	2000      	movs	r0, #0
  2081f6:	f7ff fe3b 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  2081fa:	4824      	ldr	r0, [pc, #144]	@ (20828c <rt_test_001_003_execute+0x27c>)
  2081fc:	f7ff fe58 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_DBG_ENABLE_CHECKS:               ");
  208200:	483d      	ldr	r0, [pc, #244]	@ (2082f8 <rt_test_001_003_execute+0x2e8>)
  208202:	f7ff fe45 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_DBG_ENABLE_CHECKS);
  208206:	2000      	movs	r0, #0
  208208:	f7ff fe32 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  20820c:	481f      	ldr	r0, [pc, #124]	@ (20828c <rt_test_001_003_execute+0x27c>)
  20820e:	f7ff fe4f 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_DBG_ENABLE_ASSERTS:              ");
  208212:	483a      	ldr	r0, [pc, #232]	@ (2082fc <rt_test_001_003_execute+0x2ec>)
  208214:	f7ff fe3c 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_DBG_ENABLE_ASSERTS);
  208218:	2000      	movs	r0, #0
  20821a:	f7ff fe29 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  20821e:	481b      	ldr	r0, [pc, #108]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208220:	f7ff fe46 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_DBG_TRACE_MASK:                  ");
  208224:	4836      	ldr	r0, [pc, #216]	@ (208300 <rt_test_001_003_execute+0x2f0>)
  208226:	f7ff fe33 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_DBG_TRACE_MASK);
  20822a:	20ff      	movs	r0, #255	@ 0xff
  20822c:	f7ff fe20 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208230:	4816      	ldr	r0, [pc, #88]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208232:	f7ff fe3d 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_DBG_TRACE_BUFFER_SIZE:           ");
  208236:	4833      	ldr	r0, [pc, #204]	@ (208304 <rt_test_001_003_execute+0x2f4>)
  208238:	f7ff fe2a 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_DBG_TRACE_BUFFER_SIZE);
  20823c:	2080      	movs	r0, #128	@ 0x80
  20823e:	f7ff fe17 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208242:	4812      	ldr	r0, [pc, #72]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208244:	f7ff fe34 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_DBG_ENABLE_STACK_CHECK:          ");
  208248:	482f      	ldr	r0, [pc, #188]	@ (208308 <rt_test_001_003_execute+0x2f8>)
  20824a:	f7ff fe21 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_DBG_ENABLE_STACK_CHECK);
  20824e:	2000      	movs	r0, #0
  208250:	f7ff fe0e 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208254:	480d      	ldr	r0, [pc, #52]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208256:	f7ff fe2b 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_DBG_FILL_THREADS:                ");
  20825a:	482c      	ldr	r0, [pc, #176]	@ (20830c <rt_test_001_003_execute+0x2fc>)
  20825c:	f7ff fe18 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_DBG_FILL_THREADS);
  208260:	2000      	movs	r0, #0
  208262:	f7ff fe05 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208266:	4809      	ldr	r0, [pc, #36]	@ (20828c <rt_test_001_003_execute+0x27c>)
  208268:	f7ff fe22 	bl	207eb0 <test_println.lto_priv.0>
    test_print("--- CH_DBG_THREADS_PROFILING:           ");
  20826c:	4828      	ldr	r0, [pc, #160]	@ (208310 <rt_test_001_003_execute+0x300>)
  20826e:	f7ff fe0f 	bl	207e90 <test_print.lto_priv.0>
    test_printn(CH_DBG_THREADS_PROFILING);
  208272:	2000      	movs	r0, #0
  208274:	f7ff fdfc 	bl	207e70 <test_printn.lto_priv.0>
    test_println("");
  208278:	4804      	ldr	r0, [pc, #16]	@ (20828c <rt_test_001_003_execute+0x27c>)
  20827a:	f7ff fe19 	bl	207eb0 <test_println.lto_priv.0>
  }
  test_end_step(1);
}
  20827e:	bf00      	nop
  208280:	bd08      	pop	{r3, pc}
  208282:	bf00      	nop
  208284:	20000bb4 	.word	0x20000bb4
  208288:	08011054 	.word	0x08011054
  20828c:	08010bcc 	.word	0x08010bcc
  208290:	08011080 	.word	0x08011080
  208294:	080110ac 	.word	0x080110ac
  208298:	080110d8 	.word	0x080110d8
  20829c:	08011104 	.word	0x08011104
  2082a0:	08011130 	.word	0x08011130
  2082a4:	0801115c 	.word	0x0801115c
  2082a8:	08011188 	.word	0x08011188
  2082ac:	080111b4 	.word	0x080111b4
  2082b0:	080111e0 	.word	0x080111e0
  2082b4:	0801120c 	.word	0x0801120c
  2082b8:	08011238 	.word	0x08011238
  2082bc:	08011264 	.word	0x08011264
  2082c0:	08011290 	.word	0x08011290
  2082c4:	080112bc 	.word	0x080112bc
  2082c8:	080112e8 	.word	0x080112e8
  2082cc:	08011314 	.word	0x08011314
  2082d0:	08011340 	.word	0x08011340
  2082d4:	0801136c 	.word	0x0801136c
  2082d8:	08011398 	.word	0x08011398
  2082dc:	080113c4 	.word	0x080113c4
  2082e0:	080113f0 	.word	0x080113f0
  2082e4:	0801141c 	.word	0x0801141c
  2082e8:	08011448 	.word	0x08011448
  2082ec:	08011474 	.word	0x08011474
  2082f0:	080114a0 	.word	0x080114a0
  2082f4:	080114cc 	.word	0x080114cc
  2082f8:	080114f8 	.word	0x080114f8
  2082fc:	08011524 	.word	0x08011524
  208300:	08011550 	.word	0x08011550
  208304:	0801157c 	.word	0x0801157c
  208308:	080115a8 	.word	0x080115a8
  20830c:	080115d4 	.word	0x080115d4
  208310:	08011600 	.word	0x08011600
	...

00208320 <chSysDisable>:
  __ASM volatile ("cpsid i" : : : "memory");
  208320:	b672      	cpsid	i
}
  208322:	bf00      	nop
}
  208324:	bf00      	nop
}
  208326:	bf00      	nop
  208328:	4770      	bx	lr
  20832a:	bf00      	nop
  20832c:	0000      	movs	r0, r0
	...

00208330 <chSysSuspend>:
static inline void chSysSuspend(void) {
  208330:	b082      	sub	sp, #8
  208332:	2330      	movs	r3, #48	@ 0x30
  208334:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208336:	9b01      	ldr	r3, [sp, #4]
  208338:	f383 8811 	msr	BASEPRI, r3
}
  20833c:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
  20833e:	b662      	cpsie	i
}
  208340:	bf00      	nop
}
  208342:	bf00      	nop
}
  208344:	bf00      	nop
  208346:	b002      	add	sp, #8
  208348:	4770      	bx	lr
  20834a:	bf00      	nop
  20834c:	0000      	movs	r0, r0
	...

00208350 <chSysEnable>:
static inline void chSysEnable(void) {
  208350:	b082      	sub	sp, #8
  208352:	2300      	movs	r3, #0
  208354:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208356:	9b01      	ldr	r3, [sp, #4]
  208358:	f383 8811 	msr	BASEPRI, r3
}
  20835c:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
  20835e:	b662      	cpsie	i
}
  208360:	bf00      	nop
}
  208362:	bf00      	nop
}
  208364:	bf00      	nop
  208366:	b002      	add	sp, #8
  208368:	4770      	bx	lr
  20836a:	bf00      	nop
  20836c:	0000      	movs	r0, r0
	...

00208370 <chSysLock.lto_priv.19>:
static inline void chSysLock(void) {
  208370:	b082      	sub	sp, #8
  208372:	2330      	movs	r3, #48	@ 0x30
  208374:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208376:	9b01      	ldr	r3, [sp, #4]
  208378:	f383 8811 	msr	BASEPRI, r3
}
  20837c:	bf00      	nop
}
  20837e:	bf00      	nop
}
  208380:	bf00      	nop
  208382:	b002      	add	sp, #8
  208384:	4770      	bx	lr
  208386:	bf00      	nop
	...

00208390 <chSysUnlock.lto_priv.19>:
static inline void chSysUnlock(void) {
  208390:	b082      	sub	sp, #8
  208392:	2300      	movs	r3, #0
  208394:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208396:	9b01      	ldr	r3, [sp, #4]
  208398:	f383 8811 	msr	BASEPRI, r3
}
  20839c:	bf00      	nop
}
  20839e:	bf00      	nop
}
  2083a0:	bf00      	nop
  2083a2:	b002      	add	sp, #8
  2083a4:	4770      	bx	lr
  2083a6:	bf00      	nop
	...

002083b0 <chSysLockFromISR.lto_priv.5>:
static inline void chSysLockFromISR(void) {
  2083b0:	b082      	sub	sp, #8
  2083b2:	2330      	movs	r3, #48	@ 0x30
  2083b4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2083b6:	9b01      	ldr	r3, [sp, #4]
  2083b8:	f383 8811 	msr	BASEPRI, r3
}
  2083bc:	bf00      	nop
}
  2083be:	bf00      	nop
}
  2083c0:	bf00      	nop
}
  2083c2:	bf00      	nop
  2083c4:	b002      	add	sp, #8
  2083c6:	4770      	bx	lr
	...

002083d0 <chSysUnlockFromISR.lto_priv.5>:
static inline void chSysUnlockFromISR(void) {
  2083d0:	b082      	sub	sp, #8
  2083d2:	2300      	movs	r3, #0
  2083d4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2083d6:	9b01      	ldr	r3, [sp, #4]
  2083d8:	f383 8811 	msr	BASEPRI, r3
}
  2083dc:	bf00      	nop
}
  2083de:	bf00      	nop
}
  2083e0:	bf00      	nop
}
  2083e2:	bf00      	nop
  2083e4:	b002      	add	sp, #8
  2083e6:	4770      	bx	lr
	...

002083f0 <chSysUnconditionalLock>:
 * @note    This function is only available if the underlying port supports
 *          @p port_get_lock_status() and @p port_is_locked().
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {
  2083f0:	b500      	push	{lr}
  2083f2:	b085      	sub	sp, #20
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
  2083f4:	f3ef 8311 	mrs	r3, BASEPRI
  2083f8:	9302      	str	r3, [sp, #8]
  return(result);
  2083fa:	9b02      	ldr	r3, [sp, #8]
  sts = (syssts_t)__get_BASEPRI();
  2083fc:	9301      	str	r3, [sp, #4]
  return sts;
  2083fe:	9b01      	ldr	r3, [sp, #4]
  208400:	9303      	str	r3, [sp, #12]
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
  208402:	9b03      	ldr	r3, [sp, #12]
  208404:	2b00      	cmp	r3, #0
  208406:	bf0c      	ite	eq
  208408:	2301      	moveq	r3, #1
  20840a:	2300      	movne	r3, #0
  20840c:	b2db      	uxtb	r3, r3

  if (!port_is_locked(port_get_lock_status())) {
  20840e:	2b00      	cmp	r3, #0
  208410:	d001      	beq.n	208416 <chSysUnconditionalLock+0x26>
    chSysLock();
  208412:	f7ff ffad 	bl	208370 <chSysLock.lto_priv.19>
  }
}
  208416:	bf00      	nop
  208418:	b005      	add	sp, #20
  20841a:	f85d fb04 	ldr.w	pc, [sp], #4
  20841e:	bf00      	nop

00208420 <chSysUnconditionalUnlock>:
 * @note    This function is only available if the underlying port supports
 *          @p port_get_lock_status() and @p port_is_locked().
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {
  208420:	b500      	push	{lr}
  208422:	b085      	sub	sp, #20
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
  208424:	f3ef 8311 	mrs	r3, BASEPRI
  208428:	9302      	str	r3, [sp, #8]
  return(result);
  20842a:	9b02      	ldr	r3, [sp, #8]
  sts = (syssts_t)__get_BASEPRI();
  20842c:	9301      	str	r3, [sp, #4]
  return sts;
  20842e:	9b01      	ldr	r3, [sp, #4]
  208430:	9303      	str	r3, [sp, #12]
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
  208432:	9b03      	ldr	r3, [sp, #12]
  208434:	2b00      	cmp	r3, #0
  208436:	bf0c      	ite	eq
  208438:	2301      	moveq	r3, #1
  20843a:	2300      	movne	r3, #0
  20843c:	b2db      	uxtb	r3, r3

  if (port_is_locked(port_get_lock_status())) {
  20843e:	f083 0301 	eor.w	r3, r3, #1
  208442:	b2db      	uxtb	r3, r3
  208444:	2b00      	cmp	r3, #0
  208446:	d001      	beq.n	20844c <chSysUnconditionalUnlock+0x2c>
    chSysUnlock();
  208448:	f7ff ffa2 	bl	208390 <chSysUnlock.lto_priv.19>
  }
}
  20844c:	bf00      	nop
  20844e:	b005      	add	sp, #20
  208450:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00208460 <chVTIsArmedI.lto_priv.1>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
  208460:	b082      	sub	sp, #8
  208462:	9001      	str	r0, [sp, #4]
  return (bool)(vtp->dlist.next != NULL);
  208464:	9b01      	ldr	r3, [sp, #4]
  208466:	681b      	ldr	r3, [r3, #0]
  208468:	2b00      	cmp	r3, #0
  20846a:	bf14      	ite	ne
  20846c:	2301      	movne	r3, #1
  20846e:	2300      	moveq	r3, #0
  208470:	b2db      	uxtb	r3, r3
}
  208472:	4618      	mov	r0, r3
  208474:	b002      	add	sp, #8
  208476:	4770      	bx	lr
	...

00208480 <chVTIsArmed>:
static inline bool chVTIsArmed(const virtual_timer_t *vtp) {
  208480:	b500      	push	{lr}
  208482:	b085      	sub	sp, #20
  208484:	9001      	str	r0, [sp, #4]
  chSysLock();
  208486:	f7ff ff73 	bl	208370 <chSysLock.lto_priv.19>
  b = chVTIsArmedI(vtp);
  20848a:	9801      	ldr	r0, [sp, #4]
  20848c:	f7ff ffe8 	bl	208460 <chVTIsArmedI.lto_priv.1>
  208490:	4603      	mov	r3, r0
  208492:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
  208496:	f7ff ff7b 	bl	208390 <chSysUnlock.lto_priv.19>
  return b;
  20849a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
  20849e:	4618      	mov	r0, r3
  2084a0:	b005      	add	sp, #20
  2084a2:	f85d fb04 	ldr.w	pc, [sp], #4
  2084a6:	bf00      	nop
	...

002084b0 <chVTResetI>:
static inline void chVTResetI(virtual_timer_t *vtp) {
  2084b0:	b500      	push	{lr}
  2084b2:	b083      	sub	sp, #12
  2084b4:	9001      	str	r0, [sp, #4]
  if (chVTIsArmedI(vtp)) {
  2084b6:	9801      	ldr	r0, [sp, #4]
  2084b8:	f7ff ffd2 	bl	208460 <chVTIsArmedI.lto_priv.1>
  2084bc:	4603      	mov	r3, r0
  2084be:	2b00      	cmp	r3, #0
  2084c0:	d002      	beq.n	2084c8 <chVTResetI+0x18>
    chVTDoResetI(vtp);
  2084c2:	9801      	ldr	r0, [sp, #4]
  2084c4:	f7fa f884 	bl	2025d0 <chVTDoResetI>
}
  2084c8:	bf00      	nop
  2084ca:	b003      	add	sp, #12
  2084cc:	f85d fb04 	ldr.w	pc, [sp], #4

002084d0 <chVTSetI>:
                            vtfunc_t vtfunc, void *par) {
  2084d0:	b500      	push	{lr}
  2084d2:	b085      	sub	sp, #20
  2084d4:	9003      	str	r0, [sp, #12]
  2084d6:	9102      	str	r1, [sp, #8]
  2084d8:	9201      	str	r2, [sp, #4]
  2084da:	9300      	str	r3, [sp, #0]
  chVTResetI(vtp);
  2084dc:	9803      	ldr	r0, [sp, #12]
  2084de:	f7ff ffe7 	bl	2084b0 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
  2084e2:	9b00      	ldr	r3, [sp, #0]
  2084e4:	9a01      	ldr	r2, [sp, #4]
  2084e6:	9902      	ldr	r1, [sp, #8]
  2084e8:	9803      	ldr	r0, [sp, #12]
  2084ea:	f7fa f851 	bl	202590 <chVTDoSetI>
}
  2084ee:	bf00      	nop
  2084f0:	b005      	add	sp, #20
  2084f2:	f85d fb04 	ldr.w	pc, [sp], #4
  2084f6:	bf00      	nop
	...

00208500 <chVTSet>:
                           vtfunc_t vtfunc, void *par) {
  208500:	b500      	push	{lr}
  208502:	b085      	sub	sp, #20
  208504:	9003      	str	r0, [sp, #12]
  208506:	9102      	str	r1, [sp, #8]
  208508:	9201      	str	r2, [sp, #4]
  20850a:	9300      	str	r3, [sp, #0]
  chSysLock();
  20850c:	f7ff ff30 	bl	208370 <chSysLock.lto_priv.19>
  chVTSetI(vtp, delay, vtfunc, par);
  208510:	9b00      	ldr	r3, [sp, #0]
  208512:	9a01      	ldr	r2, [sp, #4]
  208514:	9902      	ldr	r1, [sp, #8]
  208516:	9803      	ldr	r0, [sp, #12]
  208518:	f7ff ffda 	bl	2084d0 <chVTSetI>
  chSysUnlock();
  20851c:	f7ff ff38 	bl	208390 <chSysUnlock.lto_priv.19>
}
  208520:	bf00      	nop
  208522:	b005      	add	sp, #20
  208524:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00208530 <vtcb>:
 * Shared code.
 ****************************************************************************/

#if CH_PORT_SUPPORTS_RECURSIVE_LOCKS == TRUE
/* Timer callback for testing system functions in ISR context.*/
static void vtcb(virtual_timer_t *vtp, void *p) {
  208530:	b500      	push	{lr}
  208532:	b085      	sub	sp, #20
  208534:	9001      	str	r0, [sp, #4]
  208536:	9100      	str	r1, [sp, #0]

  (void)vtp;
  (void)p;

  /* Testing normal case.*/
  chSysLockFromISR();
  208538:	f7ff ff3a 	bl	2083b0 <chSysLockFromISR.lto_priv.5>
  chSysUnlockFromISR();
  20853c:	f7ff ff48 	bl	2083d0 <chSysUnlockFromISR.lto_priv.5>

  /* Reentrant case.*/
  chSysLockFromISR();
  208540:	f7ff ff36 	bl	2083b0 <chSysLockFromISR.lto_priv.5>
  sts = chSysGetStatusAndLockX();
  208544:	f7f9 fdac 	bl	2020a0 <chSysGetStatusAndLockX>
  208548:	9003      	str	r0, [sp, #12]
  chSysRestoreStatusX(sts);
  20854a:	9803      	ldr	r0, [sp, #12]
  20854c:	f7f9 fdd8 	bl	202100 <chSysRestoreStatusX>
  chSysUnlockFromISR();
  208550:	f7ff ff3e 	bl	2083d0 <chSysUnlockFromISR.lto_priv.5>
}
  208554:	bf00      	nop
  208556:	b005      	add	sp, #20
  208558:	f85d fb04 	ldr.w	pc, [sp], #4
  20855c:	0000      	movs	r0, r0
	...

00208560 <rt_test_002_001_execute>:
 * - [2.1.3] Testing Registry List integrity.
 * - [2.1.4] Testing Port-defined integrity.
 * .
 */

static void rt_test_002_001_execute(void) {
  208560:	b500      	push	{lr}
  208562:	b083      	sub	sp, #12
  bool result;

  /* [2.1.1] Testing Ready List integrity.*/
  test_set_step(1);
  208564:	4b42      	ldr	r3, [pc, #264]	@ (208670 <rt_test_002_001_execute+0x110>)
  208566:	2201      	movs	r2, #1
  208568:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  20856a:	f7ff ff01 	bl	208370 <chSysLock.lto_priv.19>
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
  20856e:	2001      	movs	r0, #1
  208570:	f7f9 fd06 	bl	201f80 <chSysIntegrityCheckI>
  208574:	4603      	mov	r3, r0
  208576:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
  20857a:	f7ff ff09 	bl	208390 <chSysUnlock.lto_priv.19>
    test_assert(result == false, "ready list check failed");
  20857e:	f89d 3007 	ldrb.w	r3, [sp, #7]
  208582:	2b00      	cmp	r3, #0
  208584:	bf14      	ite	ne
  208586:	2301      	movne	r3, #1
  208588:	2300      	moveq	r3, #0
  20858a:	b2db      	uxtb	r3, r3
  20858c:	f083 0301 	eor.w	r3, r3, #1
  208590:	b2db      	uxtb	r3, r3
  208592:	f003 0301 	and.w	r3, r3, #1
  208596:	b2db      	uxtb	r3, r3
  208598:	4936      	ldr	r1, [pc, #216]	@ (208674 <rt_test_002_001_execute+0x114>)
  20859a:	4618      	mov	r0, r3
  20859c:	f7ff f860 	bl	207660 <__test_assert>
  2085a0:	4603      	mov	r3, r0
  2085a2:	2b00      	cmp	r3, #0
  2085a4:	d161      	bne.n	20866a <rt_test_002_001_execute+0x10a>
  }
  test_end_step(1);

  /* [2.1.2] Testing Virtual Timers List integrity.*/
  test_set_step(2);
  2085a6:	4b32      	ldr	r3, [pc, #200]	@ (208670 <rt_test_002_001_execute+0x110>)
  2085a8:	2202      	movs	r2, #2
  2085aa:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  2085ac:	f7ff fee0 	bl	208370 <chSysLock.lto_priv.19>
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
  2085b0:	2002      	movs	r0, #2
  2085b2:	f7f9 fce5 	bl	201f80 <chSysIntegrityCheckI>
  2085b6:	4603      	mov	r3, r0
  2085b8:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
  2085bc:	f7ff fee8 	bl	208390 <chSysUnlock.lto_priv.19>
    test_assert(result == false, "virtual timers list check failed");
  2085c0:	f89d 3007 	ldrb.w	r3, [sp, #7]
  2085c4:	2b00      	cmp	r3, #0
  2085c6:	bf14      	ite	ne
  2085c8:	2301      	movne	r3, #1
  2085ca:	2300      	moveq	r3, #0
  2085cc:	b2db      	uxtb	r3, r3
  2085ce:	f083 0301 	eor.w	r3, r3, #1
  2085d2:	b2db      	uxtb	r3, r3
  2085d4:	f003 0301 	and.w	r3, r3, #1
  2085d8:	b2db      	uxtb	r3, r3
  2085da:	4927      	ldr	r1, [pc, #156]	@ (208678 <rt_test_002_001_execute+0x118>)
  2085dc:	4618      	mov	r0, r3
  2085de:	f7ff f83f 	bl	207660 <__test_assert>
  2085e2:	4603      	mov	r3, r0
  2085e4:	2b00      	cmp	r3, #0
  2085e6:	d140      	bne.n	20866a <rt_test_002_001_execute+0x10a>
  }
  test_end_step(2);

  /* [2.1.3] Testing Registry List integrity.*/
  test_set_step(3);
  2085e8:	4b21      	ldr	r3, [pc, #132]	@ (208670 <rt_test_002_001_execute+0x110>)
  2085ea:	2203      	movs	r2, #3
  2085ec:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  2085ee:	f7ff febf 	bl	208370 <chSysLock.lto_priv.19>
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
  2085f2:	2004      	movs	r0, #4
  2085f4:	f7f9 fcc4 	bl	201f80 <chSysIntegrityCheckI>
  2085f8:	4603      	mov	r3, r0
  2085fa:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
  2085fe:	f7ff fec7 	bl	208390 <chSysUnlock.lto_priv.19>
    test_assert(result == false, "registry list check failed");
  208602:	f89d 3007 	ldrb.w	r3, [sp, #7]
  208606:	2b00      	cmp	r3, #0
  208608:	bf14      	ite	ne
  20860a:	2301      	movne	r3, #1
  20860c:	2300      	moveq	r3, #0
  20860e:	b2db      	uxtb	r3, r3
  208610:	f083 0301 	eor.w	r3, r3, #1
  208614:	b2db      	uxtb	r3, r3
  208616:	f003 0301 	and.w	r3, r3, #1
  20861a:	b2db      	uxtb	r3, r3
  20861c:	4917      	ldr	r1, [pc, #92]	@ (20867c <rt_test_002_001_execute+0x11c>)
  20861e:	4618      	mov	r0, r3
  208620:	f7ff f81e 	bl	207660 <__test_assert>
  208624:	4603      	mov	r3, r0
  208626:	2b00      	cmp	r3, #0
  208628:	d11f      	bne.n	20866a <rt_test_002_001_execute+0x10a>
  }
  test_end_step(3);

  /* [2.1.4] Testing Port-defined integrity.*/
  test_set_step(4);
  20862a:	4b11      	ldr	r3, [pc, #68]	@ (208670 <rt_test_002_001_execute+0x110>)
  20862c:	2204      	movs	r2, #4
  20862e:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  208630:	f7ff fe9e 	bl	208370 <chSysLock.lto_priv.19>
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
  208634:	2008      	movs	r0, #8
  208636:	f7f9 fca3 	bl	201f80 <chSysIntegrityCheckI>
  20863a:	4603      	mov	r3, r0
  20863c:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
  208640:	f7ff fea6 	bl	208390 <chSysUnlock.lto_priv.19>
    test_assert(result == false, "port layer check failed");
  208644:	f89d 3007 	ldrb.w	r3, [sp, #7]
  208648:	2b00      	cmp	r3, #0
  20864a:	bf14      	ite	ne
  20864c:	2301      	movne	r3, #1
  20864e:	2300      	moveq	r3, #0
  208650:	b2db      	uxtb	r3, r3
  208652:	f083 0301 	eor.w	r3, r3, #1
  208656:	b2db      	uxtb	r3, r3
  208658:	f003 0301 	and.w	r3, r3, #1
  20865c:	b2db      	uxtb	r3, r3
  20865e:	4908      	ldr	r1, [pc, #32]	@ (208680 <rt_test_002_001_execute+0x120>)
  208660:	4618      	mov	r0, r3
  208662:	f7fe fffd 	bl	207660 <__test_assert>
  208666:	4603      	mov	r3, r0
  208668:	2b00      	cmp	r3, #0
  }
  test_end_step(4);
}
  20866a:	b003      	add	sp, #12
  20866c:	f85d fb04 	ldr.w	pc, [sp], #4
  208670:	20000bb4 	.word	0x20000bb4
  208674:	0801162c 	.word	0x0801162c
  208678:	08011644 	.word	0x08011644
  20867c:	08011668 	.word	0x08011668
  208680:	08011684 	.word	0x08011684
	...

00208690 <rt_test_002_002_execute>:
 * - [2.2.4] Testing chSysUnconditionalUnlock().
 * - [2.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void rt_test_002_002_execute(void) {
  208690:	b500      	push	{lr}
  208692:	b089      	sub	sp, #36	@ 0x24
  syssts_t sts;
  virtual_timer_t vt;

  /* [2.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
  208694:	4b28      	ldr	r3, [pc, #160]	@ (208738 <rt_test_002_002_execute+0xa8>)
  208696:	2201      	movs	r2, #1
  208698:	601a      	str	r2, [r3, #0]
  {
    sts = chSysGetStatusAndLockX();
  20869a:	f7f9 fd01 	bl	2020a0 <chSysGetStatusAndLockX>
  20869e:	9007      	str	r0, [sp, #28]
    chSysRestoreStatusX(sts);
  2086a0:	9807      	ldr	r0, [sp, #28]
  2086a2:	f7f9 fd2d 	bl	202100 <chSysRestoreStatusX>
  }
  test_end_step(1);

  /* [2.2.2] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), reentrant case.*/
  test_set_step(2);
  2086a6:	4b24      	ldr	r3, [pc, #144]	@ (208738 <rt_test_002_002_execute+0xa8>)
  2086a8:	2202      	movs	r2, #2
  2086aa:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  2086ac:	f7ff fe60 	bl	208370 <chSysLock.lto_priv.19>
    sts = chSysGetStatusAndLockX();
  2086b0:	f7f9 fcf6 	bl	2020a0 <chSysGetStatusAndLockX>
  2086b4:	9007      	str	r0, [sp, #28]
    chSysRestoreStatusX(sts);
  2086b6:	9807      	ldr	r0, [sp, #28]
  2086b8:	f7f9 fd22 	bl	202100 <chSysRestoreStatusX>
    chSysUnlock();
  2086bc:	f7ff fe68 	bl	208390 <chSysUnlock.lto_priv.19>
  }
  test_end_step(2);

  /* [2.2.3] Testing chSysUnconditionalLock().*/
  test_set_step(3);
  2086c0:	4b1d      	ldr	r3, [pc, #116]	@ (208738 <rt_test_002_002_execute+0xa8>)
  2086c2:	2203      	movs	r2, #3
  2086c4:	601a      	str	r2, [r3, #0]
  {
    chSysUnconditionalLock();
  2086c6:	f7ff fe93 	bl	2083f0 <chSysUnconditionalLock>
    chSysUnconditionalLock();
  2086ca:	f7ff fe91 	bl	2083f0 <chSysUnconditionalLock>
    chSysUnlock();
  2086ce:	f7ff fe5f 	bl	208390 <chSysUnlock.lto_priv.19>
  }
  test_end_step(3);

  /* [2.2.4] Testing chSysUnconditionalUnlock().*/
  test_set_step(4);
  2086d2:	4b19      	ldr	r3, [pc, #100]	@ (208738 <rt_test_002_002_execute+0xa8>)
  2086d4:	2204      	movs	r2, #4
  2086d6:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  2086d8:	f7ff fe4a 	bl	208370 <chSysLock.lto_priv.19>
    chSysUnconditionalUnlock();
  2086dc:	f7ff fea0 	bl	208420 <chSysUnconditionalUnlock>
    chSysUnconditionalUnlock();
  2086e0:	f7ff fe9e 	bl	208420 <chSysUnconditionalUnlock>
  }
  test_end_step(4);

  /* [2.2.5] Testing from ISR context using a virtual timer.*/
  test_set_step(5);
  2086e4:	4b14      	ldr	r3, [pc, #80]	@ (208738 <rt_test_002_002_execute+0xa8>)
  2086e6:	2205      	movs	r2, #5
  2086e8:	601a      	str	r2, [r3, #0]
  {
    chVTObjectInit(&vt);
  2086ea:	ab01      	add	r3, sp, #4
  2086ec:	4618      	mov	r0, r3
  2086ee:	f7f9 ff47 	bl	202580 <chVTObjectInit>
    chVTSet(&vt, 1, vtcb, NULL);
  2086f2:	a801      	add	r0, sp, #4
  2086f4:	2300      	movs	r3, #0
  2086f6:	4a11      	ldr	r2, [pc, #68]	@ (20873c <rt_test_002_002_execute+0xac>)
  2086f8:	2101      	movs	r1, #1
  2086fa:	f7ff ff01 	bl	208500 <chVTSet>
    chThdSleep(10);
  2086fe:	200a      	movs	r0, #10
  208700:	f7fa ff76 	bl	2035f0 <chThdSleep>

    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
  208704:	ab01      	add	r3, sp, #4
  208706:	4618      	mov	r0, r3
  208708:	f7ff feba 	bl	208480 <chVTIsArmed>
  20870c:	4603      	mov	r3, r0
  20870e:	2b00      	cmp	r3, #0
  208710:	bf14      	ite	ne
  208712:	2301      	movne	r3, #1
  208714:	2300      	moveq	r3, #0
  208716:	b2db      	uxtb	r3, r3
  208718:	f083 0301 	eor.w	r3, r3, #1
  20871c:	b2db      	uxtb	r3, r3
  20871e:	f003 0301 	and.w	r3, r3, #1
  208722:	b2db      	uxtb	r3, r3
  208724:	4906      	ldr	r1, [pc, #24]	@ (208740 <rt_test_002_002_execute+0xb0>)
  208726:	4618      	mov	r0, r3
  208728:	f7fe ff9a 	bl	207660 <__test_assert>
  20872c:	4603      	mov	r3, r0
  20872e:	2b00      	cmp	r3, #0
  }
  test_end_step(5);
}
  208730:	b009      	add	sp, #36	@ 0x24
  208732:	f85d fb04 	ldr.w	pc, [sp], #4
  208736:	bf00      	nop
  208738:	20000bb4 	.word	0x20000bb4
  20873c:	00208531 	.word	0x00208531
  208740:	0801169c 	.word	0x0801169c
	...

00208750 <rt_test_002_003_execute>:
 * <h2>Test Steps</h2>
 * - [2.3.1] Testing chSysSuspend(), chSysDisable() and chSysEnable().
 * .
 */

static void rt_test_002_003_execute(void) {
  208750:	b508      	push	{r3, lr}

  /* [2.3.1] Testing chSysSuspend(), chSysDisable() and
     chSysEnable().*/
  test_set_step(1);
  208752:	4b06      	ldr	r3, [pc, #24]	@ (20876c <rt_test_002_003_execute+0x1c>)
  208754:	2201      	movs	r2, #1
  208756:	601a      	str	r2, [r3, #0]
  {
    chSysSuspend();
  208758:	f7ff fdea 	bl	208330 <chSysSuspend>
    chSysDisable();
  20875c:	f7ff fde0 	bl	208320 <chSysDisable>
    chSysSuspend();
  208760:	f7ff fde6 	bl	208330 <chSysSuspend>
    chSysEnable();
  208764:	f7ff fdf4 	bl	208350 <chSysEnable>
  }
  test_end_step(1);
}
  208768:	bf00      	nop
  20876a:	bd08      	pop	{r3, pc}
  20876c:	20000bb4 	.word	0x20000bb4

00208770 <chTimeIsInRangeX.lto_priv.2>:
                                    systime_t end) {
  208770:	b084      	sub	sp, #16
  208772:	9003      	str	r0, [sp, #12]
  208774:	9102      	str	r1, [sp, #8]
  208776:	9201      	str	r2, [sp, #4]
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
  208778:	9a03      	ldr	r2, [sp, #12]
  20877a:	9b02      	ldr	r3, [sp, #8]
  20877c:	1ad2      	subs	r2, r2, r3
                (systime_t)((systime_t)end - (systime_t)start));
  20877e:	9901      	ldr	r1, [sp, #4]
  208780:	9b02      	ldr	r3, [sp, #8]
  208782:	1acb      	subs	r3, r1, r3
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
  208784:	429a      	cmp	r2, r3
  208786:	bf34      	ite	cc
  208788:	2301      	movcc	r3, #1
  20878a:	2300      	movcs	r3, #0
  20878c:	b2db      	uxtb	r3, r3
}
  20878e:	4618      	mov	r0, r3
  208790:	b004      	add	sp, #16
  208792:	4770      	bx	lr
	...

002087a0 <port_timer_get_time.lto_priv.5>:
static inline systime_t port_timer_get_time(void) {
  2087a0:	b508      	push	{r3, lr}
  return stGetCounter();
  2087a2:	f7f8 f89d 	bl	2008e0 <stGetCounter>
  2087a6:	4603      	mov	r3, r0
}
  2087a8:	4618      	mov	r0, r3
  2087aa:	bd08      	pop	{r3, pc}
  2087ac:	0000      	movs	r0, r0
	...

002087b0 <chVTGetSystemTimeX.lto_priv.5>:
static inline systime_t chVTGetSystemTimeX(void) {
  2087b0:	b508      	push	{r3, lr}
  return port_timer_get_time();
  2087b2:	f7ff fff5 	bl	2087a0 <port_timer_get_time.lto_priv.5>
  2087b6:	4603      	mov	r3, r0
}
  2087b8:	4618      	mov	r0, r3
  2087ba:	bd08      	pop	{r3, pc}
  2087bc:	0000      	movs	r0, r0
	...

002087c0 <rt_test_003_001_execute>:
 * - [3.1.1] A System Tick Counter increment is expected, the test
 *   simply hangs if it does not happen.
 * .
 */

static void rt_test_003_001_execute(void) {
  2087c0:	b500      	push	{lr}
  2087c2:	b083      	sub	sp, #12

  /* [3.1.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
  2087c4:	4b08      	ldr	r3, [pc, #32]	@ (2087e8 <rt_test_003_001_execute+0x28>)
  2087c6:	2201      	movs	r2, #1
  2087c8:	601a      	str	r2, [r3, #0]
  {
    systime_t time = chVTGetSystemTimeX();
  2087ca:	f7ff fff1 	bl	2087b0 <chVTGetSystemTimeX.lto_priv.5>
  2087ce:	9001      	str	r0, [sp, #4]
    while (time == chVTGetSystemTimeX()) {
  2087d0:	bf00      	nop
  2087d2:	f7ff ffed 	bl	2087b0 <chVTGetSystemTimeX.lto_priv.5>
  2087d6:	4602      	mov	r2, r0
  2087d8:	9b01      	ldr	r3, [sp, #4]
  2087da:	4293      	cmp	r3, r2
  2087dc:	d0f9      	beq.n	2087d2 <rt_test_003_001_execute+0x12>
        _sim_check_for_interrupts();
#endif
    }
  }
  test_end_step(1);
}
  2087de:	bf00      	nop
  2087e0:	bf00      	nop
  2087e2:	b003      	add	sp, #12
  2087e4:	f85d fb04 	ldr.w	pc, [sp], #4
  2087e8:	20000bb4 	.word	0x20000bb4
  2087ec:	00000000 	.word	0x00000000

002087f0 <rt_test_003_002_execute>:
 * - [3.2.2] Checking boundaries for start < end.
 * - [3.2.3] Checking boundaries for start > end.
 * .
 */

static void rt_test_003_002_execute(void) {
  2087f0:	b500      	push	{lr}
  2087f2:	b083      	sub	sp, #12

  /* [3.2.1] Checking case where start == end, it must always evaluate
     as not in range.*/
  test_set_step(1);
  2087f4:	4b9d      	ldr	r3, [pc, #628]	@ (208a6c <rt_test_003_002_execute+0x27c>)
  2087f6:	2201      	movs	r2, #1
  2087f8:	601a      	str	r2, [r3, #0]
  {
    bool b;

    b = chTimeIsInRangeX((systime_t)0, (systime_t)0, (systime_t)0);
  2087fa:	2200      	movs	r2, #0
  2087fc:	2100      	movs	r1, #0
  2087fe:	2000      	movs	r0, #0
  208800:	f7ff ffb6 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  208804:	4603      	mov	r3, r0
  208806:	f88d 3007 	strb.w	r3, [sp, #7]
    test_assert(b == false, "in range");
  20880a:	f89d 3007 	ldrb.w	r3, [sp, #7]
  20880e:	2b00      	cmp	r3, #0
  208810:	bf14      	ite	ne
  208812:	2301      	movne	r3, #1
  208814:	2300      	moveq	r3, #0
  208816:	b2db      	uxtb	r3, r3
  208818:	f083 0301 	eor.w	r3, r3, #1
  20881c:	b2db      	uxtb	r3, r3
  20881e:	f003 0301 	and.w	r3, r3, #1
  208822:	b2db      	uxtb	r3, r3
  208824:	4992      	ldr	r1, [pc, #584]	@ (208a70 <rt_test_003_002_execute+0x280>)
  208826:	4618      	mov	r0, r3
  208828:	f7fe ff1a 	bl	207660 <__test_assert>
  20882c:	4603      	mov	r3, r0
  20882e:	2b00      	cmp	r3, #0
  208830:	f040 8118 	bne.w	208a64 <rt_test_003_002_execute+0x274>
    b = chTimeIsInRangeX((systime_t)-1, (systime_t)0, (systime_t)0);
  208834:	2200      	movs	r2, #0
  208836:	2100      	movs	r1, #0
  208838:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20883c:	f7ff ff98 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  208840:	4603      	mov	r3, r0
  208842:	f88d 3007 	strb.w	r3, [sp, #7]
    test_assert(b == false, "in range");
  208846:	f89d 3007 	ldrb.w	r3, [sp, #7]
  20884a:	2b00      	cmp	r3, #0
  20884c:	bf14      	ite	ne
  20884e:	2301      	movne	r3, #1
  208850:	2300      	moveq	r3, #0
  208852:	b2db      	uxtb	r3, r3
  208854:	f083 0301 	eor.w	r3, r3, #1
  208858:	b2db      	uxtb	r3, r3
  20885a:	f003 0301 	and.w	r3, r3, #1
  20885e:	b2db      	uxtb	r3, r3
  208860:	4983      	ldr	r1, [pc, #524]	@ (208a70 <rt_test_003_002_execute+0x280>)
  208862:	4618      	mov	r0, r3
  208864:	f7fe fefc 	bl	207660 <__test_assert>
  208868:	4603      	mov	r3, r0
  20886a:	2b00      	cmp	r3, #0
  20886c:	f040 80fa 	bne.w	208a64 <rt_test_003_002_execute+0x274>
    b = chTimeIsInRangeX((systime_t)0, (systime_t)-1, (systime_t)-1);
  208870:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  208874:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
  208878:	2000      	movs	r0, #0
  20887a:	f7ff ff79 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  20887e:	4603      	mov	r3, r0
  208880:	f88d 3007 	strb.w	r3, [sp, #7]
    test_assert(b == false, "in range");
  208884:	f89d 3007 	ldrb.w	r3, [sp, #7]
  208888:	2b00      	cmp	r3, #0
  20888a:	bf14      	ite	ne
  20888c:	2301      	movne	r3, #1
  20888e:	2300      	moveq	r3, #0
  208890:	b2db      	uxtb	r3, r3
  208892:	f083 0301 	eor.w	r3, r3, #1
  208896:	b2db      	uxtb	r3, r3
  208898:	f003 0301 	and.w	r3, r3, #1
  20889c:	b2db      	uxtb	r3, r3
  20889e:	4974      	ldr	r1, [pc, #464]	@ (208a70 <rt_test_003_002_execute+0x280>)
  2088a0:	4618      	mov	r0, r3
  2088a2:	f7fe fedd 	bl	207660 <__test_assert>
  2088a6:	4603      	mov	r3, r0
  2088a8:	2b00      	cmp	r3, #0
  2088aa:	f040 80db 	bne.w	208a64 <rt_test_003_002_execute+0x274>
    b = chTimeIsInRangeX((systime_t)-1, (systime_t)-1, (systime_t)-1);
  2088ae:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  2088b2:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
  2088b6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  2088ba:	f7ff ff59 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  2088be:	4603      	mov	r3, r0
  2088c0:	f88d 3007 	strb.w	r3, [sp, #7]
    test_assert(b == false, "in range");
  2088c4:	f89d 3007 	ldrb.w	r3, [sp, #7]
  2088c8:	2b00      	cmp	r3, #0
  2088ca:	bf14      	ite	ne
  2088cc:	2301      	movne	r3, #1
  2088ce:	2300      	moveq	r3, #0
  2088d0:	b2db      	uxtb	r3, r3
  2088d2:	f083 0301 	eor.w	r3, r3, #1
  2088d6:	b2db      	uxtb	r3, r3
  2088d8:	f003 0301 	and.w	r3, r3, #1
  2088dc:	b2db      	uxtb	r3, r3
  2088de:	4964      	ldr	r1, [pc, #400]	@ (208a70 <rt_test_003_002_execute+0x280>)
  2088e0:	4618      	mov	r0, r3
  2088e2:	f7fe febd 	bl	207660 <__test_assert>
  2088e6:	4603      	mov	r3, r0
  2088e8:	2b00      	cmp	r3, #0
  2088ea:	f040 80bb 	bne.w	208a64 <rt_test_003_002_execute+0x274>
  }
  test_end_step(1);

  /* [3.2.2] Checking boundaries for start < end.*/
  test_set_step(2);
  2088ee:	4b5f      	ldr	r3, [pc, #380]	@ (208a6c <rt_test_003_002_execute+0x27c>)
  2088f0:	2202      	movs	r2, #2
  2088f2:	601a      	str	r2, [r3, #0]
  {
    bool b;

    b = chTimeIsInRangeX((systime_t)10, (systime_t)10, (systime_t)100);
  2088f4:	2264      	movs	r2, #100	@ 0x64
  2088f6:	210a      	movs	r1, #10
  2088f8:	200a      	movs	r0, #10
  2088fa:	f7ff ff39 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  2088fe:	4603      	mov	r3, r0
  208900:	f88d 3006 	strb.w	r3, [sp, #6]
    test_assert(b == true, "not in range");
  208904:	f89d 3006 	ldrb.w	r3, [sp, #6]
  208908:	495a      	ldr	r1, [pc, #360]	@ (208a74 <rt_test_003_002_execute+0x284>)
  20890a:	4618      	mov	r0, r3
  20890c:	f7fe fea8 	bl	207660 <__test_assert>
  208910:	4603      	mov	r3, r0
  208912:	2b00      	cmp	r3, #0
  208914:	f040 80a6 	bne.w	208a64 <rt_test_003_002_execute+0x274>
    b = chTimeIsInRangeX((systime_t)9, (systime_t)10, (systime_t)100);
  208918:	2264      	movs	r2, #100	@ 0x64
  20891a:	210a      	movs	r1, #10
  20891c:	2009      	movs	r0, #9
  20891e:	f7ff ff27 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  208922:	4603      	mov	r3, r0
  208924:	f88d 3006 	strb.w	r3, [sp, #6]
    test_assert(b == false, "in range");
  208928:	f89d 3006 	ldrb.w	r3, [sp, #6]
  20892c:	2b00      	cmp	r3, #0
  20892e:	bf14      	ite	ne
  208930:	2301      	movne	r3, #1
  208932:	2300      	moveq	r3, #0
  208934:	b2db      	uxtb	r3, r3
  208936:	f083 0301 	eor.w	r3, r3, #1
  20893a:	b2db      	uxtb	r3, r3
  20893c:	f003 0301 	and.w	r3, r3, #1
  208940:	b2db      	uxtb	r3, r3
  208942:	494b      	ldr	r1, [pc, #300]	@ (208a70 <rt_test_003_002_execute+0x280>)
  208944:	4618      	mov	r0, r3
  208946:	f7fe fe8b 	bl	207660 <__test_assert>
  20894a:	4603      	mov	r3, r0
  20894c:	2b00      	cmp	r3, #0
  20894e:	f040 8089 	bne.w	208a64 <rt_test_003_002_execute+0x274>
    b = chTimeIsInRangeX((systime_t)99, (systime_t)10, (systime_t)100);
  208952:	2264      	movs	r2, #100	@ 0x64
  208954:	210a      	movs	r1, #10
  208956:	2063      	movs	r0, #99	@ 0x63
  208958:	f7ff ff0a 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  20895c:	4603      	mov	r3, r0
  20895e:	f88d 3006 	strb.w	r3, [sp, #6]
    test_assert(b == true, "not in range");
  208962:	f89d 3006 	ldrb.w	r3, [sp, #6]
  208966:	4943      	ldr	r1, [pc, #268]	@ (208a74 <rt_test_003_002_execute+0x284>)
  208968:	4618      	mov	r0, r3
  20896a:	f7fe fe79 	bl	207660 <__test_assert>
  20896e:	4603      	mov	r3, r0
  208970:	2b00      	cmp	r3, #0
  208972:	d177      	bne.n	208a64 <rt_test_003_002_execute+0x274>
    b = chTimeIsInRangeX((systime_t)100, (systime_t)10, (systime_t)100);
  208974:	2264      	movs	r2, #100	@ 0x64
  208976:	210a      	movs	r1, #10
  208978:	2064      	movs	r0, #100	@ 0x64
  20897a:	f7ff fef9 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  20897e:	4603      	mov	r3, r0
  208980:	f88d 3006 	strb.w	r3, [sp, #6]
    test_assert(b == false, "in range");
  208984:	f89d 3006 	ldrb.w	r3, [sp, #6]
  208988:	2b00      	cmp	r3, #0
  20898a:	bf14      	ite	ne
  20898c:	2301      	movne	r3, #1
  20898e:	2300      	moveq	r3, #0
  208990:	b2db      	uxtb	r3, r3
  208992:	f083 0301 	eor.w	r3, r3, #1
  208996:	b2db      	uxtb	r3, r3
  208998:	f003 0301 	and.w	r3, r3, #1
  20899c:	b2db      	uxtb	r3, r3
  20899e:	4934      	ldr	r1, [pc, #208]	@ (208a70 <rt_test_003_002_execute+0x280>)
  2089a0:	4618      	mov	r0, r3
  2089a2:	f7fe fe5d 	bl	207660 <__test_assert>
  2089a6:	4603      	mov	r3, r0
  2089a8:	2b00      	cmp	r3, #0
  2089aa:	d15b      	bne.n	208a64 <rt_test_003_002_execute+0x274>
  }
  test_end_step(2);

  /* [3.2.3] Checking boundaries for start > end.*/
  test_set_step(3);
  2089ac:	4b2f      	ldr	r3, [pc, #188]	@ (208a6c <rt_test_003_002_execute+0x27c>)
  2089ae:	2203      	movs	r2, #3
  2089b0:	601a      	str	r2, [r3, #0]
  {
    bool b;

    b = chTimeIsInRangeX((systime_t)100, (systime_t)100, (systime_t)10);
  2089b2:	220a      	movs	r2, #10
  2089b4:	2164      	movs	r1, #100	@ 0x64
  2089b6:	2064      	movs	r0, #100	@ 0x64
  2089b8:	f7ff feda 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  2089bc:	4603      	mov	r3, r0
  2089be:	f88d 3005 	strb.w	r3, [sp, #5]
    test_assert(b == true, "not in range");
  2089c2:	f89d 3005 	ldrb.w	r3, [sp, #5]
  2089c6:	492b      	ldr	r1, [pc, #172]	@ (208a74 <rt_test_003_002_execute+0x284>)
  2089c8:	4618      	mov	r0, r3
  2089ca:	f7fe fe49 	bl	207660 <__test_assert>
  2089ce:	4603      	mov	r3, r0
  2089d0:	2b00      	cmp	r3, #0
  2089d2:	d147      	bne.n	208a64 <rt_test_003_002_execute+0x274>
    b = chTimeIsInRangeX((systime_t)99, (systime_t)100, (systime_t)10);
  2089d4:	220a      	movs	r2, #10
  2089d6:	2164      	movs	r1, #100	@ 0x64
  2089d8:	2063      	movs	r0, #99	@ 0x63
  2089da:	f7ff fec9 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  2089de:	4603      	mov	r3, r0
  2089e0:	f88d 3005 	strb.w	r3, [sp, #5]
    test_assert(b == false, "in range");
  2089e4:	f89d 3005 	ldrb.w	r3, [sp, #5]
  2089e8:	2b00      	cmp	r3, #0
  2089ea:	bf14      	ite	ne
  2089ec:	2301      	movne	r3, #1
  2089ee:	2300      	moveq	r3, #0
  2089f0:	b2db      	uxtb	r3, r3
  2089f2:	f083 0301 	eor.w	r3, r3, #1
  2089f6:	b2db      	uxtb	r3, r3
  2089f8:	f003 0301 	and.w	r3, r3, #1
  2089fc:	b2db      	uxtb	r3, r3
  2089fe:	491c      	ldr	r1, [pc, #112]	@ (208a70 <rt_test_003_002_execute+0x280>)
  208a00:	4618      	mov	r0, r3
  208a02:	f7fe fe2d 	bl	207660 <__test_assert>
  208a06:	4603      	mov	r3, r0
  208a08:	2b00      	cmp	r3, #0
  208a0a:	d12b      	bne.n	208a64 <rt_test_003_002_execute+0x274>
    b = chTimeIsInRangeX((systime_t)9, (systime_t)100, (systime_t)10);
  208a0c:	220a      	movs	r2, #10
  208a0e:	2164      	movs	r1, #100	@ 0x64
  208a10:	2009      	movs	r0, #9
  208a12:	f7ff fead 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  208a16:	4603      	mov	r3, r0
  208a18:	f88d 3005 	strb.w	r3, [sp, #5]
    test_assert(b == true, "not in range");
  208a1c:	f89d 3005 	ldrb.w	r3, [sp, #5]
  208a20:	4914      	ldr	r1, [pc, #80]	@ (208a74 <rt_test_003_002_execute+0x284>)
  208a22:	4618      	mov	r0, r3
  208a24:	f7fe fe1c 	bl	207660 <__test_assert>
  208a28:	4603      	mov	r3, r0
  208a2a:	2b00      	cmp	r3, #0
  208a2c:	d11a      	bne.n	208a64 <rt_test_003_002_execute+0x274>
    b = chTimeIsInRangeX((systime_t)10, (systime_t)100, (systime_t)10);
  208a2e:	220a      	movs	r2, #10
  208a30:	2164      	movs	r1, #100	@ 0x64
  208a32:	200a      	movs	r0, #10
  208a34:	f7ff fe9c 	bl	208770 <chTimeIsInRangeX.lto_priv.2>
  208a38:	4603      	mov	r3, r0
  208a3a:	f88d 3005 	strb.w	r3, [sp, #5]
    test_assert(b == false, "in range");
  208a3e:	f89d 3005 	ldrb.w	r3, [sp, #5]
  208a42:	2b00      	cmp	r3, #0
  208a44:	bf14      	ite	ne
  208a46:	2301      	movne	r3, #1
  208a48:	2300      	moveq	r3, #0
  208a4a:	b2db      	uxtb	r3, r3
  208a4c:	f083 0301 	eor.w	r3, r3, #1
  208a50:	b2db      	uxtb	r3, r3
  208a52:	f003 0301 	and.w	r3, r3, #1
  208a56:	b2db      	uxtb	r3, r3
  208a58:	4905      	ldr	r1, [pc, #20]	@ (208a70 <rt_test_003_002_execute+0x280>)
  208a5a:	4618      	mov	r0, r3
  208a5c:	f7fe fe00 	bl	207660 <__test_assert>
  208a60:	4603      	mov	r3, r0
  208a62:	2b00      	cmp	r3, #0
  }
  test_end_step(3);
}
  208a64:	b003      	add	sp, #12
  208a66:	f85d fb04 	ldr.w	pc, [sp], #4
  208a6a:	bf00      	nop
  208a6c:	20000bb4 	.word	0x20000bb4
  208a70:	080116b4 	.word	0x080116b4
  208a74:	080116b0 	.word	0x080116b0
	...

00208a80 <chTimeAddX.lto_priv.1>:
                                   sysinterval_t interval) {
  208a80:	b082      	sub	sp, #8
  208a82:	9001      	str	r0, [sp, #4]
  208a84:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
  208a86:	9a01      	ldr	r2, [sp, #4]
  208a88:	9b00      	ldr	r3, [sp, #0]
  208a8a:	4413      	add	r3, r2
}
  208a8c:	4618      	mov	r0, r3
  208a8e:	b002      	add	sp, #8
  208a90:	4770      	bx	lr
  208a92:	bf00      	nop
	...

00208aa0 <chTimeIsInRangeX.lto_priv.3>:
                                    systime_t end) {
  208aa0:	b084      	sub	sp, #16
  208aa2:	9003      	str	r0, [sp, #12]
  208aa4:	9102      	str	r1, [sp, #8]
  208aa6:	9201      	str	r2, [sp, #4]
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
  208aa8:	9a03      	ldr	r2, [sp, #12]
  208aaa:	9b02      	ldr	r3, [sp, #8]
  208aac:	1ad2      	subs	r2, r2, r3
                (systime_t)((systime_t)end - (systime_t)start));
  208aae:	9901      	ldr	r1, [sp, #4]
  208ab0:	9b02      	ldr	r3, [sp, #8]
  208ab2:	1acb      	subs	r3, r1, r3
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
  208ab4:	429a      	cmp	r2, r3
  208ab6:	bf34      	ite	cc
  208ab8:	2301      	movcc	r3, #1
  208aba:	2300      	movcs	r3, #0
  208abc:	b2db      	uxtb	r3, r3
}
  208abe:	4618      	mov	r0, r3
  208ac0:	b004      	add	sp, #16
  208ac2:	4770      	bx	lr
	...

00208ad0 <port_timer_get_time.lto_priv.6>:
static inline systime_t port_timer_get_time(void) {
  208ad0:	b508      	push	{r3, lr}
  return stGetCounter();
  208ad2:	f7f7 ff05 	bl	2008e0 <stGetCounter>
  208ad6:	4603      	mov	r3, r0
}
  208ad8:	4618      	mov	r0, r3
  208ada:	bd08      	pop	{r3, pc}
  208adc:	0000      	movs	r0, r0
	...

00208ae0 <chSysLock.lto_priv.20>:
static inline void chSysLock(void) {
  208ae0:	b082      	sub	sp, #8
  208ae2:	2330      	movs	r3, #48	@ 0x30
  208ae4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208ae6:	9b01      	ldr	r3, [sp, #4]
  208ae8:	f383 8811 	msr	BASEPRI, r3
}
  208aec:	bf00      	nop
}
  208aee:	bf00      	nop
}
  208af0:	bf00      	nop
  208af2:	b002      	add	sp, #8
  208af4:	4770      	bx	lr
  208af6:	bf00      	nop
	...

00208b00 <chSysUnlock.lto_priv.20>:
static inline void chSysUnlock(void) {
  208b00:	b082      	sub	sp, #8
  208b02:	2300      	movs	r3, #0
  208b04:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208b06:	9b01      	ldr	r3, [sp, #4]
  208b08:	f383 8811 	msr	BASEPRI, r3
}
  208b0c:	bf00      	nop
}
  208b0e:	bf00      	nop
}
  208b10:	bf00      	nop
  208b12:	b002      	add	sp, #8
  208b14:	4770      	bx	lr
  208b16:	bf00      	nop
	...

00208b20 <chVTGetSystemTimeX.lto_priv.6>:
static inline systime_t chVTGetSystemTimeX(void) {
  208b20:	b508      	push	{r3, lr}
  return port_timer_get_time();
  208b22:	f7ff ffd5 	bl	208ad0 <port_timer_get_time.lto_priv.6>
  208b26:	4603      	mov	r3, r0
}
  208b28:	4618      	mov	r0, r3
  208b2a:	bd08      	pop	{r3, pc}
  208b2c:	0000      	movs	r0, r0
	...

00208b30 <chVTIsSystemTimeWithinX.lto_priv.0>:
static inline bool chVTIsSystemTimeWithinX(systime_t start, systime_t end) {
  208b30:	b500      	push	{lr}
  208b32:	b083      	sub	sp, #12
  208b34:	9001      	str	r0, [sp, #4]
  208b36:	9100      	str	r1, [sp, #0]
  return chTimeIsInRangeX(chVTGetSystemTimeX(), start, end);
  208b38:	f7ff fff2 	bl	208b20 <chVTGetSystemTimeX.lto_priv.6>
  208b3c:	4603      	mov	r3, r0
  208b3e:	9a00      	ldr	r2, [sp, #0]
  208b40:	9901      	ldr	r1, [sp, #4]
  208b42:	4618      	mov	r0, r3
  208b44:	f7ff ffac 	bl	208aa0 <chTimeIsInRangeX.lto_priv.3>
  208b48:	4603      	mov	r3, r0
}
  208b4a:	4618      	mov	r0, r3
  208b4c:	b003      	add	sp, #12
  208b4e:	f85d fb04 	ldr.w	pc, [sp], #4
  208b52:	bf00      	nop
	...

00208b60 <chVTGetTimeStamp>:
static inline systimestamp_t chVTGetTimeStamp(void) {
  208b60:	b500      	push	{lr}
  208b62:	b083      	sub	sp, #12
  chSysLock();
  208b64:	f7ff ffbc 	bl	208ae0 <chSysLock.lto_priv.20>
  stamp = chVTGetTimeStampI();
  208b68:	f7f9 fe3a 	bl	2027e0 <chVTGetTimeStampI>
  208b6c:	e9cd 0100 	strd	r0, r1, [sp]
  chSysUnlock();
  208b70:	f7ff ffc6 	bl	208b00 <chSysUnlock.lto_priv.20>
  return stamp;
  208b74:	e9dd 2300 	ldrd	r2, r3, [sp]
}
  208b78:	4610      	mov	r0, r2
  208b7a:	4619      	mov	r1, r3
  208b7c:	b003      	add	sp, #12
  208b7e:	f85d fb04 	ldr.w	pc, [sp], #4
  208b82:	bf00      	nop
	...

00208b90 <rt_test_004_001_execute>:
 * <h2>Test Steps</h2>
 * - [4.1.1] Time stamps are generated and checked for monotonicity.
 * .
 */

static void rt_test_004_001_execute(void) {
  208b90:	b500      	push	{lr}
  208b92:	b089      	sub	sp, #36	@ 0x24

  /* [4.1.1] Time stamps are generated and checked for monotonicity.*/
  test_set_step(1);
  208b94:	4b1e      	ldr	r3, [pc, #120]	@ (208c10 <rt_test_004_001_execute+0x80>)
  208b96:	2201      	movs	r2, #1
  208b98:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;
    systimestamp_t last, now;
    sysinterval_t duration;

    last = chVTGetTimeStamp();
  208b9a:	f7ff ffe1 	bl	208b60 <chVTGetTimeStamp>
  208b9e:	e9cd 0106 	strd	r0, r1, [sp, #24]
    start = test_wait_tick();
  208ba2:	f7ff f955 	bl	207e50 <test_wait_tick>
  208ba6:	9004      	str	r0, [sp, #16]
    duration = (sysinterval_t)(TIME_MAX_SYSTIME / 2U);
  208ba8:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
  208bac:	9305      	str	r3, [sp, #20]
    if (duration > TIME_MS2I(1000)) {
  208bae:	9b05      	ldr	r3, [sp, #20]
  208bb0:	f242 7210 	movw	r2, #10000	@ 0x2710
  208bb4:	4293      	cmp	r3, r2
  208bb6:	d902      	bls.n	208bbe <rt_test_004_001_execute+0x2e>
      duration = TIME_MS2I(1000);
  208bb8:	f242 7310 	movw	r3, #10000	@ 0x2710
  208bbc:	9305      	str	r3, [sp, #20]
    }
    end = chTimeAddX(start, duration);
  208bbe:	9905      	ldr	r1, [sp, #20]
  208bc0:	9804      	ldr	r0, [sp, #16]
  208bc2:	f7ff ff5d 	bl	208a80 <chTimeAddX.lto_priv.1>
  208bc6:	9003      	str	r0, [sp, #12]
    do {
      now = chVTGetTimeStamp();
  208bc8:	f7ff ffca 	bl	208b60 <chVTGetTimeStamp>
  208bcc:	e9cd 0100 	strd	r0, r1, [sp]
      test_assert(last <= now, "not monotonic");
  208bd0:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  208bd4:	e9dd 0100 	ldrd	r0, r1, [sp]
  208bd8:	4290      	cmp	r0, r2
  208bda:	eb71 0303 	sbcs.w	r3, r1, r3
  208bde:	bf2c      	ite	cs
  208be0:	2301      	movcs	r3, #1
  208be2:	2300      	movcc	r3, #0
  208be4:	b2db      	uxtb	r3, r3
  208be6:	490b      	ldr	r1, [pc, #44]	@ (208c14 <rt_test_004_001_execute+0x84>)
  208be8:	4618      	mov	r0, r3
  208bea:	f7fe fd39 	bl	207660 <__test_assert>
  208bee:	4603      	mov	r3, r0
  208bf0:	2b00      	cmp	r3, #0
  208bf2:	d10a      	bne.n	208c0a <rt_test_004_001_execute+0x7a>
      last = now;
  208bf4:	e9dd 2300 	ldrd	r2, r3, [sp]
  208bf8:	e9cd 2306 	strd	r2, r3, [sp, #24]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  208bfc:	9903      	ldr	r1, [sp, #12]
  208bfe:	9804      	ldr	r0, [sp, #16]
  208c00:	f7ff ff96 	bl	208b30 <chVTIsSystemTimeWithinX.lto_priv.0>
  208c04:	4603      	mov	r3, r0
  208c06:	2b00      	cmp	r3, #0
  208c08:	d1de      	bne.n	208bc8 <rt_test_004_001_execute+0x38>
  }
  test_end_step(1);
}
  208c0a:	b009      	add	sp, #36	@ 0x24
  208c0c:	f85d fb04 	ldr.w	pc, [sp], #4
  208c10:	20000bb4 	.word	0x20000bb4
  208c14:	080116c0 	.word	0x080116c0
	...

00208c20 <chTimeAddX.lto_priv.2>:
                                   sysinterval_t interval) {
  208c20:	b082      	sub	sp, #8
  208c22:	9001      	str	r0, [sp, #4]
  208c24:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
  208c26:	9a01      	ldr	r2, [sp, #4]
  208c28:	9b00      	ldr	r3, [sp, #0]
  208c2a:	4413      	add	r3, r2
}
  208c2c:	4618      	mov	r0, r3
  208c2e:	b002      	add	sp, #8
  208c30:	4770      	bx	lr
  208c32:	bf00      	nop
	...

00208c40 <port_timer_get_time.lto_priv.7>:
static inline systime_t port_timer_get_time(void) {
  208c40:	b508      	push	{r3, lr}
  return stGetCounter();
  208c42:	f7f7 fe4d 	bl	2008e0 <stGetCounter>
  208c46:	4603      	mov	r3, r0
}
  208c48:	4618      	mov	r0, r3
  208c4a:	bd08      	pop	{r3, pc}
  208c4c:	0000      	movs	r0, r0
	...

00208c50 <chSysLock.lto_priv.21>:
static inline void chSysLock(void) {
  208c50:	b082      	sub	sp, #8
  208c52:	2330      	movs	r3, #48	@ 0x30
  208c54:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208c56:	9b01      	ldr	r3, [sp, #4]
  208c58:	f383 8811 	msr	BASEPRI, r3
}
  208c5c:	bf00      	nop
}
  208c5e:	bf00      	nop
}
  208c60:	bf00      	nop
  208c62:	b002      	add	sp, #8
  208c64:	4770      	bx	lr
  208c66:	bf00      	nop
	...

00208c70 <chSysUnlock.lto_priv.21>:
static inline void chSysUnlock(void) {
  208c70:	b082      	sub	sp, #8
  208c72:	2300      	movs	r3, #0
  208c74:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208c76:	9b01      	ldr	r3, [sp, #4]
  208c78:	f383 8811 	msr	BASEPRI, r3
}
  208c7c:	bf00      	nop
}
  208c7e:	bf00      	nop
}
  208c80:	bf00      	nop
  208c82:	b002      	add	sp, #8
  208c84:	4770      	bx	lr
  208c86:	bf00      	nop
	...

00208c90 <chVTGetSystemTimeX.lto_priv.7>:
static inline systime_t chVTGetSystemTimeX(void) {
  208c90:	b508      	push	{r3, lr}
  return port_timer_get_time();
  208c92:	f7ff ffd5 	bl	208c40 <port_timer_get_time.lto_priv.7>
  208c96:	4603      	mov	r3, r0
}
  208c98:	4618      	mov	r0, r3
  208c9a:	bd08      	pop	{r3, pc}
  208c9c:	0000      	movs	r0, r0
	...

00208ca0 <chThdGetSelfX.lto_priv.6>:
  return __sch_get_currthread();
  208ca0:	4b01      	ldr	r3, [pc, #4]	@ (208ca8 <chThdGetSelfX.lto_priv.6+0x8>)
  208ca2:	68db      	ldr	r3, [r3, #12]
}
  208ca4:	4618      	mov	r0, r3
  208ca6:	4770      	bx	lr
  208ca8:	20000890 	.word	0x20000890
  208cac:	00000000 	.word	0x00000000

00208cb0 <chThdGetPriorityX.lto_priv.0>:
static inline tprio_t chThdGetPriorityX(void) {
  208cb0:	b508      	push	{r3, lr}
  return chThdGetSelfX()->hdr.pqueue.prio;
  208cb2:	f7ff fff5 	bl	208ca0 <chThdGetSelfX.lto_priv.6>
  208cb6:	4603      	mov	r3, r0
  208cb8:	689b      	ldr	r3, [r3, #8]
}
  208cba:	4618      	mov	r0, r3
  208cbc:	bd08      	pop	{r3, pc}
  208cbe:	bf00      	nop

00208cc0 <thread>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {
  208cc0:	b500      	push	{lr}
  208cc2:	b083      	sub	sp, #12
  208cc4:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
  208cc6:	9b01      	ldr	r3, [sp, #4]
  208cc8:	781b      	ldrb	r3, [r3, #0]
  208cca:	4618      	mov	r0, r3
  208ccc:	f7fe fd28 	bl	207720 <test_emit_token>
}
  208cd0:	bf00      	nop
  208cd2:	b003      	add	sp, #12
  208cd4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00208ce0 <rt_test_005_001_execute>:
 * - [5.1.5] Function chThdSleepUntil() is tested with a timeline of
 *   "now" + 100 ticks.
 * .
 */

static void rt_test_005_001_execute(void) {
  208ce0:	b510      	push	{r4, lr}
  208ce2:	b082      	sub	sp, #8
  systime_t time;

  /* [5.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
  208ce4:	4b4a      	ldr	r3, [pc, #296]	@ (208e10 <rt_test_005_001_execute+0x130>)
  208ce6:	2201      	movs	r2, #1
  208ce8:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
  208cea:	f7ff ffd1 	bl	208c90 <chVTGetSystemTimeX.lto_priv.7>
  208cee:	9001      	str	r0, [sp, #4]
    chThdSleep(100);
  208cf0:	2064      	movs	r0, #100	@ 0x64
  208cf2:	f7fa fc7d 	bl	2035f0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, 100),
  208cf6:	2164      	movs	r1, #100	@ 0x64
  208cf8:	9801      	ldr	r0, [sp, #4]
  208cfa:	f7ff ff91 	bl	208c20 <chTimeAddX.lto_priv.2>
  208cfe:	4604      	mov	r4, r0
  208d00:	2167      	movs	r1, #103	@ 0x67
  208d02:	9801      	ldr	r0, [sp, #4]
  208d04:	f7ff ff8c 	bl	208c20 <chTimeAddX.lto_priv.2>
  208d08:	4603      	mov	r3, r0
  208d0a:	4a42      	ldr	r2, [pc, #264]	@ (208e14 <rt_test_005_001_execute+0x134>)
  208d0c:	4619      	mov	r1, r3
  208d0e:	4620      	mov	r0, r4
  208d10:	f7fe fcee 	bl	2076f0 <__test_assert_time_window>
  208d14:	4603      	mov	r3, r0
  208d16:	2b00      	cmp	r3, #0
  208d18:	d178      	bne.n	208e0c <rt_test_005_001_execute+0x12c>
  test_end_step(1);

  /* [5.1.2] The current system time is read then a sleep is performed
     for 100000 microseconds and on exit the system time is verified
     again.*/
  test_set_step(2);
  208d1a:	4b3d      	ldr	r3, [pc, #244]	@ (208e10 <rt_test_005_001_execute+0x130>)
  208d1c:	2202      	movs	r2, #2
  208d1e:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
  208d20:	f7ff ffb6 	bl	208c90 <chVTGetSystemTimeX.lto_priv.7>
  208d24:	9001      	str	r0, [sp, #4]
    chThdSleepMicroseconds(100000);
  208d26:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  208d2a:	f7fa fc61 	bl	2035f0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_US2I(100000)),
  208d2e:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
  208d32:	9801      	ldr	r0, [sp, #4]
  208d34:	f7ff ff74 	bl	208c20 <chTimeAddX.lto_priv.2>
  208d38:	4604      	mov	r4, r0
  208d3a:	f240 31eb 	movw	r1, #1003	@ 0x3eb
  208d3e:	9801      	ldr	r0, [sp, #4]
  208d40:	f7ff ff6e 	bl	208c20 <chTimeAddX.lto_priv.2>
  208d44:	4603      	mov	r3, r0
  208d46:	4a33      	ldr	r2, [pc, #204]	@ (208e14 <rt_test_005_001_execute+0x134>)
  208d48:	4619      	mov	r1, r3
  208d4a:	4620      	mov	r0, r4
  208d4c:	f7fe fcd0 	bl	2076f0 <__test_assert_time_window>
  208d50:	4603      	mov	r3, r0
  208d52:	2b00      	cmp	r3, #0
  208d54:	d15a      	bne.n	208e0c <rt_test_005_001_execute+0x12c>
  test_end_step(2);

  /* [5.1.3] The current system time is read then a sleep is performed
     for 100 milliseconds and on exit the system time is verified
     again.*/
  test_set_step(3);
  208d56:	4b2e      	ldr	r3, [pc, #184]	@ (208e10 <rt_test_005_001_execute+0x130>)
  208d58:	2203      	movs	r2, #3
  208d5a:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
  208d5c:	f7ff ff98 	bl	208c90 <chVTGetSystemTimeX.lto_priv.7>
  208d60:	9001      	str	r0, [sp, #4]
    chThdSleepMilliseconds(100);
  208d62:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  208d66:	f7fa fc43 	bl	2035f0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(100)),
  208d6a:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
  208d6e:	9801      	ldr	r0, [sp, #4]
  208d70:	f7ff ff56 	bl	208c20 <chTimeAddX.lto_priv.2>
  208d74:	4604      	mov	r4, r0
  208d76:	f240 31eb 	movw	r1, #1003	@ 0x3eb
  208d7a:	9801      	ldr	r0, [sp, #4]
  208d7c:	f7ff ff50 	bl	208c20 <chTimeAddX.lto_priv.2>
  208d80:	4603      	mov	r3, r0
  208d82:	4a24      	ldr	r2, [pc, #144]	@ (208e14 <rt_test_005_001_execute+0x134>)
  208d84:	4619      	mov	r1, r3
  208d86:	4620      	mov	r0, r4
  208d88:	f7fe fcb2 	bl	2076f0 <__test_assert_time_window>
  208d8c:	4603      	mov	r3, r0
  208d8e:	2b00      	cmp	r3, #0
  208d90:	d13c      	bne.n	208e0c <rt_test_005_001_execute+0x12c>
  }
  test_end_step(3);

  /* [5.1.4] The current system time is read then a sleep is performed
     for 1 second and on exit the system time is verified again.*/
  test_set_step(4);
  208d92:	4b1f      	ldr	r3, [pc, #124]	@ (208e10 <rt_test_005_001_execute+0x130>)
  208d94:	2204      	movs	r2, #4
  208d96:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
  208d98:	f7ff ff7a 	bl	208c90 <chVTGetSystemTimeX.lto_priv.7>
  208d9c:	9001      	str	r0, [sp, #4]
    chThdSleepSeconds(1);
  208d9e:	f242 7010 	movw	r0, #10000	@ 0x2710
  208da2:	f7fa fc25 	bl	2035f0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_S2I(1)),
  208da6:	f242 7110 	movw	r1, #10000	@ 0x2710
  208daa:	9801      	ldr	r0, [sp, #4]
  208dac:	f7ff ff38 	bl	208c20 <chTimeAddX.lto_priv.2>
  208db0:	4604      	mov	r4, r0
  208db2:	f242 7113 	movw	r1, #10003	@ 0x2713
  208db6:	9801      	ldr	r0, [sp, #4]
  208db8:	f7ff ff32 	bl	208c20 <chTimeAddX.lto_priv.2>
  208dbc:	4603      	mov	r3, r0
  208dbe:	4a15      	ldr	r2, [pc, #84]	@ (208e14 <rt_test_005_001_execute+0x134>)
  208dc0:	4619      	mov	r1, r3
  208dc2:	4620      	mov	r0, r4
  208dc4:	f7fe fc94 	bl	2076f0 <__test_assert_time_window>
  208dc8:	4603      	mov	r3, r0
  208dca:	2b00      	cmp	r3, #0
  208dcc:	d11e      	bne.n	208e0c <rt_test_005_001_execute+0x12c>
  }
  test_end_step(4);

  /* [5.1.5] Function chThdSleepUntil() is tested with a timeline of
     "now" + 100 ticks.*/
  test_set_step(5);
  208dce:	4b10      	ldr	r3, [pc, #64]	@ (208e10 <rt_test_005_001_execute+0x130>)
  208dd0:	2205      	movs	r2, #5
  208dd2:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
  208dd4:	f7ff ff5c 	bl	208c90 <chVTGetSystemTimeX.lto_priv.7>
  208dd8:	9001      	str	r0, [sp, #4]
    chThdSleepUntil(chTimeAddX(time, 100));
  208dda:	2164      	movs	r1, #100	@ 0x64
  208ddc:	9801      	ldr	r0, [sp, #4]
  208dde:	f7ff ff1f 	bl	208c20 <chTimeAddX.lto_priv.2>
  208de2:	4603      	mov	r3, r0
  208de4:	4618      	mov	r0, r3
  208de6:	f7fa fc13 	bl	203610 <chThdSleepUntil>
    test_assert_time_window(chTimeAddX(time, 100),
  208dea:	2164      	movs	r1, #100	@ 0x64
  208dec:	9801      	ldr	r0, [sp, #4]
  208dee:	f7ff ff17 	bl	208c20 <chTimeAddX.lto_priv.2>
  208df2:	4604      	mov	r4, r0
  208df4:	2167      	movs	r1, #103	@ 0x67
  208df6:	9801      	ldr	r0, [sp, #4]
  208df8:	f7ff ff12 	bl	208c20 <chTimeAddX.lto_priv.2>
  208dfc:	4603      	mov	r3, r0
  208dfe:	4a05      	ldr	r2, [pc, #20]	@ (208e14 <rt_test_005_001_execute+0x134>)
  208e00:	4619      	mov	r1, r3
  208e02:	4620      	mov	r0, r4
  208e04:	f7fe fc74 	bl	2076f0 <__test_assert_time_window>
  208e08:	4603      	mov	r3, r0
  208e0a:	2b00      	cmp	r3, #0
                            chTimeAddX(time, 100 + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
  }
  test_end_step(5);
}
  208e0c:	b002      	add	sp, #8
  208e0e:	bd10      	pop	{r4, pc}
  208e10:	20000bb4 	.word	0x20000bb4
  208e14:	080116d0 	.word	0x080116d0
	...

00208e20 <rt_test_005_002_execute>:
 * - [5.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void rt_test_005_002_execute(void) {
  208e20:	b510      	push	{r4, lr}
  208e22:	b082      	sub	sp, #8

  /* [5.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
  208e24:	4b92      	ldr	r3, [pc, #584]	@ (209070 <rt_test_005_002_execute+0x250>)
  208e26:	2201      	movs	r2, #1
  208e28:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  208e2a:	4b92      	ldr	r3, [pc, #584]	@ (209074 <rt_test_005_002_execute+0x254>)
  208e2c:	681c      	ldr	r4, [r3, #0]
  208e2e:	f7ff ff3f 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208e32:	4603      	mov	r3, r0
  208e34:	1f5a      	subs	r2, r3, #5
  208e36:	4b90      	ldr	r3, [pc, #576]	@ (209078 <rt_test_005_002_execute+0x258>)
  208e38:	9300      	str	r3, [sp, #0]
  208e3a:	4b90      	ldr	r3, [pc, #576]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208e3c:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208e40:	4620      	mov	r0, r4
  208e42:	f7fa fa9d 	bl	203380 <chThdCreateStatic>
  208e46:	4603      	mov	r3, r0
  208e48:	4a8d      	ldr	r2, [pc, #564]	@ (209080 <rt_test_005_002_execute+0x260>)
  208e4a:	6013      	str	r3, [r2, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  208e4c:	4b89      	ldr	r3, [pc, #548]	@ (209074 <rt_test_005_002_execute+0x254>)
  208e4e:	685c      	ldr	r4, [r3, #4]
  208e50:	f7ff ff2e 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208e54:	4603      	mov	r3, r0
  208e56:	1f1a      	subs	r2, r3, #4
  208e58:	4b8a      	ldr	r3, [pc, #552]	@ (209084 <rt_test_005_002_execute+0x264>)
  208e5a:	9300      	str	r3, [sp, #0]
  208e5c:	4b87      	ldr	r3, [pc, #540]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208e5e:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208e62:	4620      	mov	r0, r4
  208e64:	f7fa fa8c 	bl	203380 <chThdCreateStatic>
  208e68:	4603      	mov	r3, r0
  208e6a:	4a85      	ldr	r2, [pc, #532]	@ (209080 <rt_test_005_002_execute+0x260>)
  208e6c:	6053      	str	r3, [r2, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  208e6e:	4b81      	ldr	r3, [pc, #516]	@ (209074 <rt_test_005_002_execute+0x254>)
  208e70:	689c      	ldr	r4, [r3, #8]
  208e72:	f7ff ff1d 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208e76:	4603      	mov	r3, r0
  208e78:	1eda      	subs	r2, r3, #3
  208e7a:	4b83      	ldr	r3, [pc, #524]	@ (209088 <rt_test_005_002_execute+0x268>)
  208e7c:	9300      	str	r3, [sp, #0]
  208e7e:	4b7f      	ldr	r3, [pc, #508]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208e80:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208e84:	4620      	mov	r0, r4
  208e86:	f7fa fa7b 	bl	203380 <chThdCreateStatic>
  208e8a:	4603      	mov	r3, r0
  208e8c:	4a7c      	ldr	r2, [pc, #496]	@ (209080 <rt_test_005_002_execute+0x260>)
  208e8e:	6093      	str	r3, [r2, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
  208e90:	4b78      	ldr	r3, [pc, #480]	@ (209074 <rt_test_005_002_execute+0x254>)
  208e92:	68dc      	ldr	r4, [r3, #12]
  208e94:	f7ff ff0c 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208e98:	4603      	mov	r3, r0
  208e9a:	1e9a      	subs	r2, r3, #2
  208e9c:	4b7b      	ldr	r3, [pc, #492]	@ (20908c <rt_test_005_002_execute+0x26c>)
  208e9e:	9300      	str	r3, [sp, #0]
  208ea0:	4b76      	ldr	r3, [pc, #472]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208ea2:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208ea6:	4620      	mov	r0, r4
  208ea8:	f7fa fa6a 	bl	203380 <chThdCreateStatic>
  208eac:	4603      	mov	r3, r0
  208eae:	4a74      	ldr	r2, [pc, #464]	@ (209080 <rt_test_005_002_execute+0x260>)
  208eb0:	60d3      	str	r3, [r2, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  208eb2:	4b70      	ldr	r3, [pc, #448]	@ (209074 <rt_test_005_002_execute+0x254>)
  208eb4:	691c      	ldr	r4, [r3, #16]
  208eb6:	f7ff fefb 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208eba:	4603      	mov	r3, r0
  208ebc:	1e5a      	subs	r2, r3, #1
  208ebe:	4b74      	ldr	r3, [pc, #464]	@ (209090 <rt_test_005_002_execute+0x270>)
  208ec0:	9300      	str	r3, [sp, #0]
  208ec2:	4b6e      	ldr	r3, [pc, #440]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208ec4:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208ec8:	4620      	mov	r0, r4
  208eca:	f7fa fa59 	bl	203380 <chThdCreateStatic>
  208ece:	4603      	mov	r3, r0
  208ed0:	4a6b      	ldr	r2, [pc, #428]	@ (209080 <rt_test_005_002_execute+0x260>)
  208ed2:	6113      	str	r3, [r2, #16]
    test_wait_threads();
  208ed4:	f7fe ff94 	bl	207e00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  208ed8:	496e      	ldr	r1, [pc, #440]	@ (209094 <rt_test_005_002_execute+0x274>)
  208eda:	486f      	ldr	r0, [pc, #444]	@ (209098 <rt_test_005_002_execute+0x278>)
  208edc:	f7fe fbd8 	bl	207690 <__test_assert_sequence>
  208ee0:	4603      	mov	r3, r0
  208ee2:	2b00      	cmp	r3, #0
  208ee4:	f040 80c1 	bne.w	20906a <rt_test_005_002_execute+0x24a>
  }
  test_end_step(1);

  /* [5.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
  208ee8:	4b61      	ldr	r3, [pc, #388]	@ (209070 <rt_test_005_002_execute+0x250>)
  208eea:	2202      	movs	r2, #2
  208eec:	601a      	str	r2, [r3, #0]
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  208eee:	4b61      	ldr	r3, [pc, #388]	@ (209074 <rt_test_005_002_execute+0x254>)
  208ef0:	691c      	ldr	r4, [r3, #16]
  208ef2:	f7ff fedd 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208ef6:	4603      	mov	r3, r0
  208ef8:	1e5a      	subs	r2, r3, #1
  208efa:	4b65      	ldr	r3, [pc, #404]	@ (209090 <rt_test_005_002_execute+0x270>)
  208efc:	9300      	str	r3, [sp, #0]
  208efe:	4b5f      	ldr	r3, [pc, #380]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208f00:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208f04:	4620      	mov	r0, r4
  208f06:	f7fa fa3b 	bl	203380 <chThdCreateStatic>
  208f0a:	4603      	mov	r3, r0
  208f0c:	4a5c      	ldr	r2, [pc, #368]	@ (209080 <rt_test_005_002_execute+0x260>)
  208f0e:	6113      	str	r3, [r2, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
  208f10:	4b58      	ldr	r3, [pc, #352]	@ (209074 <rt_test_005_002_execute+0x254>)
  208f12:	68dc      	ldr	r4, [r3, #12]
  208f14:	f7ff fecc 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208f18:	4603      	mov	r3, r0
  208f1a:	1e9a      	subs	r2, r3, #2
  208f1c:	4b5b      	ldr	r3, [pc, #364]	@ (20908c <rt_test_005_002_execute+0x26c>)
  208f1e:	9300      	str	r3, [sp, #0]
  208f20:	4b56      	ldr	r3, [pc, #344]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208f22:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208f26:	4620      	mov	r0, r4
  208f28:	f7fa fa2a 	bl	203380 <chThdCreateStatic>
  208f2c:	4603      	mov	r3, r0
  208f2e:	4a54      	ldr	r2, [pc, #336]	@ (209080 <rt_test_005_002_execute+0x260>)
  208f30:	60d3      	str	r3, [r2, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  208f32:	4b50      	ldr	r3, [pc, #320]	@ (209074 <rt_test_005_002_execute+0x254>)
  208f34:	689c      	ldr	r4, [r3, #8]
  208f36:	f7ff febb 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208f3a:	4603      	mov	r3, r0
  208f3c:	1eda      	subs	r2, r3, #3
  208f3e:	4b52      	ldr	r3, [pc, #328]	@ (209088 <rt_test_005_002_execute+0x268>)
  208f40:	9300      	str	r3, [sp, #0]
  208f42:	4b4e      	ldr	r3, [pc, #312]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208f44:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208f48:	4620      	mov	r0, r4
  208f4a:	f7fa fa19 	bl	203380 <chThdCreateStatic>
  208f4e:	4603      	mov	r3, r0
  208f50:	4a4b      	ldr	r2, [pc, #300]	@ (209080 <rt_test_005_002_execute+0x260>)
  208f52:	6093      	str	r3, [r2, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  208f54:	4b47      	ldr	r3, [pc, #284]	@ (209074 <rt_test_005_002_execute+0x254>)
  208f56:	685c      	ldr	r4, [r3, #4]
  208f58:	f7ff feaa 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208f5c:	4603      	mov	r3, r0
  208f5e:	1f1a      	subs	r2, r3, #4
  208f60:	4b48      	ldr	r3, [pc, #288]	@ (209084 <rt_test_005_002_execute+0x264>)
  208f62:	9300      	str	r3, [sp, #0]
  208f64:	4b45      	ldr	r3, [pc, #276]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208f66:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208f6a:	4620      	mov	r0, r4
  208f6c:	f7fa fa08 	bl	203380 <chThdCreateStatic>
  208f70:	4603      	mov	r3, r0
  208f72:	4a43      	ldr	r2, [pc, #268]	@ (209080 <rt_test_005_002_execute+0x260>)
  208f74:	6053      	str	r3, [r2, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  208f76:	4b3f      	ldr	r3, [pc, #252]	@ (209074 <rt_test_005_002_execute+0x254>)
  208f78:	681c      	ldr	r4, [r3, #0]
  208f7a:	f7ff fe99 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208f7e:	4603      	mov	r3, r0
  208f80:	1f5a      	subs	r2, r3, #5
  208f82:	4b3d      	ldr	r3, [pc, #244]	@ (209078 <rt_test_005_002_execute+0x258>)
  208f84:	9300      	str	r3, [sp, #0]
  208f86:	4b3d      	ldr	r3, [pc, #244]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208f88:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208f8c:	4620      	mov	r0, r4
  208f8e:	f7fa f9f7 	bl	203380 <chThdCreateStatic>
  208f92:	4603      	mov	r3, r0
  208f94:	4a3a      	ldr	r2, [pc, #232]	@ (209080 <rt_test_005_002_execute+0x260>)
  208f96:	6013      	str	r3, [r2, #0]
    test_wait_threads();
  208f98:	f7fe ff32 	bl	207e00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  208f9c:	493d      	ldr	r1, [pc, #244]	@ (209094 <rt_test_005_002_execute+0x274>)
  208f9e:	483e      	ldr	r0, [pc, #248]	@ (209098 <rt_test_005_002_execute+0x278>)
  208fa0:	f7fe fb76 	bl	207690 <__test_assert_sequence>
  208fa4:	4603      	mov	r3, r0
  208fa6:	2b00      	cmp	r3, #0
  208fa8:	d15f      	bne.n	20906a <rt_test_005_002_execute+0x24a>
  }
  test_end_step(2);

  /* [5.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
  208faa:	4b31      	ldr	r3, [pc, #196]	@ (209070 <rt_test_005_002_execute+0x250>)
  208fac:	2203      	movs	r2, #3
  208fae:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  208fb0:	4b30      	ldr	r3, [pc, #192]	@ (209074 <rt_test_005_002_execute+0x254>)
  208fb2:	685c      	ldr	r4, [r3, #4]
  208fb4:	f7ff fe7c 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208fb8:	4603      	mov	r3, r0
  208fba:	1f1a      	subs	r2, r3, #4
  208fbc:	4b31      	ldr	r3, [pc, #196]	@ (209084 <rt_test_005_002_execute+0x264>)
  208fbe:	9300      	str	r3, [sp, #0]
  208fc0:	4b2e      	ldr	r3, [pc, #184]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208fc2:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208fc6:	4620      	mov	r0, r4
  208fc8:	f7fa f9da 	bl	203380 <chThdCreateStatic>
  208fcc:	4603      	mov	r3, r0
  208fce:	4a2c      	ldr	r2, [pc, #176]	@ (209080 <rt_test_005_002_execute+0x260>)
  208fd0:	6053      	str	r3, [r2, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  208fd2:	4b28      	ldr	r3, [pc, #160]	@ (209074 <rt_test_005_002_execute+0x254>)
  208fd4:	681c      	ldr	r4, [r3, #0]
  208fd6:	f7ff fe6b 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208fda:	4603      	mov	r3, r0
  208fdc:	1f5a      	subs	r2, r3, #5
  208fde:	4b26      	ldr	r3, [pc, #152]	@ (209078 <rt_test_005_002_execute+0x258>)
  208fe0:	9300      	str	r3, [sp, #0]
  208fe2:	4b26      	ldr	r3, [pc, #152]	@ (20907c <rt_test_005_002_execute+0x25c>)
  208fe4:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  208fe8:	4620      	mov	r0, r4
  208fea:	f7fa f9c9 	bl	203380 <chThdCreateStatic>
  208fee:	4603      	mov	r3, r0
  208ff0:	4a23      	ldr	r2, [pc, #140]	@ (209080 <rt_test_005_002_execute+0x260>)
  208ff2:	6013      	str	r3, [r2, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  208ff4:	4b1f      	ldr	r3, [pc, #124]	@ (209074 <rt_test_005_002_execute+0x254>)
  208ff6:	691c      	ldr	r4, [r3, #16]
  208ff8:	f7ff fe5a 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  208ffc:	4603      	mov	r3, r0
  208ffe:	1e5a      	subs	r2, r3, #1
  209000:	4b23      	ldr	r3, [pc, #140]	@ (209090 <rt_test_005_002_execute+0x270>)
  209002:	9300      	str	r3, [sp, #0]
  209004:	4b1d      	ldr	r3, [pc, #116]	@ (20907c <rt_test_005_002_execute+0x25c>)
  209006:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20900a:	4620      	mov	r0, r4
  20900c:	f7fa f9b8 	bl	203380 <chThdCreateStatic>
  209010:	4603      	mov	r3, r0
  209012:	4a1b      	ldr	r2, [pc, #108]	@ (209080 <rt_test_005_002_execute+0x260>)
  209014:	6113      	str	r3, [r2, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
  209016:	4b17      	ldr	r3, [pc, #92]	@ (209074 <rt_test_005_002_execute+0x254>)
  209018:	68dc      	ldr	r4, [r3, #12]
  20901a:	f7ff fe49 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  20901e:	4603      	mov	r3, r0
  209020:	1e9a      	subs	r2, r3, #2
  209022:	4b1a      	ldr	r3, [pc, #104]	@ (20908c <rt_test_005_002_execute+0x26c>)
  209024:	9300      	str	r3, [sp, #0]
  209026:	4b15      	ldr	r3, [pc, #84]	@ (20907c <rt_test_005_002_execute+0x25c>)
  209028:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20902c:	4620      	mov	r0, r4
  20902e:	f7fa f9a7 	bl	203380 <chThdCreateStatic>
  209032:	4603      	mov	r3, r0
  209034:	4a12      	ldr	r2, [pc, #72]	@ (209080 <rt_test_005_002_execute+0x260>)
  209036:	60d3      	str	r3, [r2, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  209038:	4b0e      	ldr	r3, [pc, #56]	@ (209074 <rt_test_005_002_execute+0x254>)
  20903a:	689c      	ldr	r4, [r3, #8]
  20903c:	f7ff fe38 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  209040:	4603      	mov	r3, r0
  209042:	1eda      	subs	r2, r3, #3
  209044:	4b10      	ldr	r3, [pc, #64]	@ (209088 <rt_test_005_002_execute+0x268>)
  209046:	9300      	str	r3, [sp, #0]
  209048:	4b0c      	ldr	r3, [pc, #48]	@ (20907c <rt_test_005_002_execute+0x25c>)
  20904a:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20904e:	4620      	mov	r0, r4
  209050:	f7fa f996 	bl	203380 <chThdCreateStatic>
  209054:	4603      	mov	r3, r0
  209056:	4a0a      	ldr	r2, [pc, #40]	@ (209080 <rt_test_005_002_execute+0x260>)
  209058:	6093      	str	r3, [r2, #8]
    test_wait_threads();
  20905a:	f7fe fed1 	bl	207e00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  20905e:	490d      	ldr	r1, [pc, #52]	@ (209094 <rt_test_005_002_execute+0x274>)
  209060:	480d      	ldr	r0, [pc, #52]	@ (209098 <rt_test_005_002_execute+0x278>)
  209062:	f7fe fb15 	bl	207690 <__test_assert_sequence>
  209066:	4603      	mov	r3, r0
  209068:	2b00      	cmp	r3, #0
  }
  test_end_step(3);
}
  20906a:	b002      	add	sp, #8
  20906c:	bd10      	pop	{r4, pc}
  20906e:	bf00      	nop
  209070:	20000bb4 	.word	0x20000bb4
  209074:	08012220 	.word	0x08012220
  209078:	0801170c 	.word	0x0801170c
  20907c:	00208cc1 	.word	0x00208cc1
  209080:	20001900 	.word	0x20001900
  209084:	080116e4 	.word	0x080116e4
  209088:	080116e8 	.word	0x080116e8
  20908c:	080116ec 	.word	0x080116ec
  209090:	080116f0 	.word	0x080116f0
  209094:	080116f4 	.word	0x080116f4
  209098:	08011708 	.word	0x08011708
  20909c:	00000000 	.word	0x00000000

002090a0 <rt_test_005_003_execute>:
 * - [5.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void rt_test_005_003_execute(void) {
  2090a0:	b500      	push	{lr}
  2090a2:	b083      	sub	sp, #12
  tprio_t prio, p1;

  /* [5.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
  2090a4:	4b29      	ldr	r3, [pc, #164]	@ (20914c <rt_test_005_003_execute+0xac>)
  2090a6:	2201      	movs	r2, #1
  2090a8:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
  2090aa:	f7ff fe01 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  2090ae:	9001      	str	r0, [sp, #4]
    p1 = chThdSetPriority(prio + 1);
  2090b0:	9b01      	ldr	r3, [sp, #4]
  2090b2:	3301      	adds	r3, #1
  2090b4:	4618      	mov	r0, r3
  2090b6:	f7fa fa5b 	bl	203570 <chThdSetPriority>
  2090ba:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio, "unexpected returned priority level");
  2090bc:	9a00      	ldr	r2, [sp, #0]
  2090be:	9b01      	ldr	r3, [sp, #4]
  2090c0:	429a      	cmp	r2, r3
  2090c2:	bf0c      	ite	eq
  2090c4:	2301      	moveq	r3, #1
  2090c6:	2300      	movne	r3, #0
  2090c8:	b2db      	uxtb	r3, r3
  2090ca:	4921      	ldr	r1, [pc, #132]	@ (209150 <rt_test_005_003_execute+0xb0>)
  2090cc:	4618      	mov	r0, r3
  2090ce:	f7fe fac7 	bl	207660 <__test_assert>
  2090d2:	4603      	mov	r3, r0
  2090d4:	2b00      	cmp	r3, #0
  2090d6:	d135      	bne.n	209144 <rt_test_005_003_execute+0xa4>
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
  2090d8:	f7ff fdea 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  2090dc:	4602      	mov	r2, r0
  2090de:	9b01      	ldr	r3, [sp, #4]
  2090e0:	3301      	adds	r3, #1
  2090e2:	429a      	cmp	r2, r3
  2090e4:	bf0c      	ite	eq
  2090e6:	2301      	moveq	r3, #1
  2090e8:	2300      	movne	r3, #0
  2090ea:	b2db      	uxtb	r3, r3
  2090ec:	4919      	ldr	r1, [pc, #100]	@ (209154 <rt_test_005_003_execute+0xb4>)
  2090ee:	4618      	mov	r0, r3
  2090f0:	f7fe fab6 	bl	207660 <__test_assert>
  2090f4:	4603      	mov	r3, r0
  2090f6:	2b00      	cmp	r3, #0
  2090f8:	d124      	bne.n	209144 <rt_test_005_003_execute+0xa4>
  }
  test_end_step(1);

  /* [5.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
  2090fa:	4b14      	ldr	r3, [pc, #80]	@ (20914c <rt_test_005_003_execute+0xac>)
  2090fc:	2202      	movs	r2, #2
  2090fe:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(p1);
  209100:	9800      	ldr	r0, [sp, #0]
  209102:	f7fa fa35 	bl	203570 <chThdSetPriority>
  209106:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio + 1, "unexpected returned priority level");
  209108:	9b01      	ldr	r3, [sp, #4]
  20910a:	3301      	adds	r3, #1
  20910c:	9a00      	ldr	r2, [sp, #0]
  20910e:	429a      	cmp	r2, r3
  209110:	bf0c      	ite	eq
  209112:	2301      	moveq	r3, #1
  209114:	2300      	movne	r3, #0
  209116:	b2db      	uxtb	r3, r3
  209118:	490d      	ldr	r1, [pc, #52]	@ (209150 <rt_test_005_003_execute+0xb0>)
  20911a:	4618      	mov	r0, r3
  20911c:	f7fe faa0 	bl	207660 <__test_assert>
  209120:	4603      	mov	r3, r0
  209122:	2b00      	cmp	r3, #0
  209124:	d10e      	bne.n	209144 <rt_test_005_003_execute+0xa4>
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
  209126:	f7ff fdc3 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  20912a:	4602      	mov	r2, r0
  20912c:	9b01      	ldr	r3, [sp, #4]
  20912e:	4293      	cmp	r3, r2
  209130:	bf0c      	ite	eq
  209132:	2301      	moveq	r3, #1
  209134:	2300      	movne	r3, #0
  209136:	b2db      	uxtb	r3, r3
  209138:	4906      	ldr	r1, [pc, #24]	@ (209154 <rt_test_005_003_execute+0xb4>)
  20913a:	4618      	mov	r0, r3
  20913c:	f7fe fa90 	bl	207660 <__test_assert>
  209140:	4603      	mov	r3, r0
  209142:	2b00      	cmp	r3, #0
  }
  test_end_step(2);
}
  209144:	b003      	add	sp, #12
  209146:	f85d fb04 	ldr.w	pc, [sp], #4
  20914a:	bf00      	nop
  20914c:	20000bb4 	.word	0x20000bb4
  209150:	08011710 	.word	0x08011710
  209154:	08011734 	.word	0x08011734
	...

00209160 <rt_test_005_004_execute>:
 * - [5.4.3] Raising thread priority above the boosted level.
 * - [5.4.4] Restoring original conditions.
 * .
 */

static void rt_test_005_004_execute(void) {
  209160:	b500      	push	{lr}
  209162:	b083      	sub	sp, #12
  tprio_t prio, p1;

  /* [5.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
  209164:	4b54      	ldr	r3, [pc, #336]	@ (2092b8 <rt_test_005_004_execute+0x158>)
  209166:	2201      	movs	r2, #1
  209168:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
  20916a:	f7ff fda1 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  20916e:	9001      	str	r0, [sp, #4]
    chThdGetSelfX()->hdr.pqueue.prio += 2;
  209170:	f7ff fd96 	bl	208ca0 <chThdGetSelfX.lto_priv.6>
  209174:	4603      	mov	r3, r0
  209176:	689a      	ldr	r2, [r3, #8]
  209178:	3202      	adds	r2, #2
  20917a:	609a      	str	r2, [r3, #8]
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  20917c:	f7ff fd98 	bl	208cb0 <chThdGetPriorityX.lto_priv.0>
  209180:	4602      	mov	r2, r0
  209182:	9b01      	ldr	r3, [sp, #4]
  209184:	3302      	adds	r3, #2
  209186:	429a      	cmp	r2, r3
  209188:	bf0c      	ite	eq
  20918a:	2301      	moveq	r3, #1
  20918c:	2300      	movne	r3, #0
  20918e:	b2db      	uxtb	r3, r3
  209190:	494a      	ldr	r1, [pc, #296]	@ (2092bc <rt_test_005_004_execute+0x15c>)
  209192:	4618      	mov	r0, r3
  209194:	f7fe fa64 	bl	207660 <__test_assert>
  209198:	4603      	mov	r3, r0
  20919a:	2b00      	cmp	r3, #0
  20919c:	f040 8088 	bne.w	2092b0 <rt_test_005_004_execute+0x150>
  }
  test_end_step(1);

  /* [5.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
  2091a0:	4b45      	ldr	r3, [pc, #276]	@ (2092b8 <rt_test_005_004_execute+0x158>)
  2091a2:	2202      	movs	r2, #2
  2091a4:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(prio + 1);
  2091a6:	9b01      	ldr	r3, [sp, #4]
  2091a8:	3301      	adds	r3, #1
  2091aa:	4618      	mov	r0, r3
  2091ac:	f7fa f9e0 	bl	203570 <chThdSetPriority>
  2091b0:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio, "unexpected returned priority level");
  2091b2:	9a00      	ldr	r2, [sp, #0]
  2091b4:	9b01      	ldr	r3, [sp, #4]
  2091b6:	429a      	cmp	r2, r3
  2091b8:	bf0c      	ite	eq
  2091ba:	2301      	moveq	r3, #1
  2091bc:	2300      	movne	r3, #0
  2091be:	b2db      	uxtb	r3, r3
  2091c0:	493f      	ldr	r1, [pc, #252]	@ (2092c0 <rt_test_005_004_execute+0x160>)
  2091c2:	4618      	mov	r0, r3
  2091c4:	f7fe fa4c 	bl	207660 <__test_assert>
  2091c8:	4603      	mov	r3, r0
  2091ca:	2b00      	cmp	r3, #0
  2091cc:	d170      	bne.n	2092b0 <rt_test_005_004_execute+0x150>
    test_assert(chThdGetSelfX()->hdr.pqueue.prio == prio + 2, "unexpected priority level");
  2091ce:	f7ff fd67 	bl	208ca0 <chThdGetSelfX.lto_priv.6>
  2091d2:	4603      	mov	r3, r0
  2091d4:	689a      	ldr	r2, [r3, #8]
  2091d6:	9b01      	ldr	r3, [sp, #4]
  2091d8:	3302      	adds	r3, #2
  2091da:	429a      	cmp	r2, r3
  2091dc:	bf0c      	ite	eq
  2091de:	2301      	moveq	r3, #1
  2091e0:	2300      	movne	r3, #0
  2091e2:	b2db      	uxtb	r3, r3
  2091e4:	4935      	ldr	r1, [pc, #212]	@ (2092bc <rt_test_005_004_execute+0x15c>)
  2091e6:	4618      	mov	r0, r3
  2091e8:	f7fe fa3a 	bl	207660 <__test_assert>
  2091ec:	4603      	mov	r3, r0
  2091ee:	2b00      	cmp	r3, #0
  2091f0:	d15e      	bne.n	2092b0 <rt_test_005_004_execute+0x150>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
  2091f2:	f7ff fd55 	bl	208ca0 <chThdGetSelfX.lto_priv.6>
  2091f6:	4603      	mov	r3, r0
  2091f8:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
  2091fa:	9b01      	ldr	r3, [sp, #4]
  2091fc:	3301      	adds	r3, #1
  2091fe:	429a      	cmp	r2, r3
  209200:	bf0c      	ite	eq
  209202:	2301      	moveq	r3, #1
  209204:	2300      	movne	r3, #0
  209206:	b2db      	uxtb	r3, r3
  209208:	492e      	ldr	r1, [pc, #184]	@ (2092c4 <rt_test_005_004_execute+0x164>)
  20920a:	4618      	mov	r0, r3
  20920c:	f7fe fa28 	bl	207660 <__test_assert>
  209210:	4603      	mov	r3, r0
  209212:	2b00      	cmp	r3, #0
  209214:	d14c      	bne.n	2092b0 <rt_test_005_004_execute+0x150>
  }
  test_end_step(2);

  /* [5.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
  209216:	4b28      	ldr	r3, [pc, #160]	@ (2092b8 <rt_test_005_004_execute+0x158>)
  209218:	2203      	movs	r2, #3
  20921a:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(prio + 3);
  20921c:	9b01      	ldr	r3, [sp, #4]
  20921e:	3303      	adds	r3, #3
  209220:	4618      	mov	r0, r3
  209222:	f7fa f9a5 	bl	203570 <chThdSetPriority>
  209226:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio + 1, "unexpected returned priority level");
  209228:	9b01      	ldr	r3, [sp, #4]
  20922a:	3301      	adds	r3, #1
  20922c:	9a00      	ldr	r2, [sp, #0]
  20922e:	429a      	cmp	r2, r3
  209230:	bf0c      	ite	eq
  209232:	2301      	moveq	r3, #1
  209234:	2300      	movne	r3, #0
  209236:	b2db      	uxtb	r3, r3
  209238:	4921      	ldr	r1, [pc, #132]	@ (2092c0 <rt_test_005_004_execute+0x160>)
  20923a:	4618      	mov	r0, r3
  20923c:	f7fe fa10 	bl	207660 <__test_assert>
  209240:	4603      	mov	r3, r0
  209242:	2b00      	cmp	r3, #0
  209244:	d134      	bne.n	2092b0 <rt_test_005_004_execute+0x150>
    test_assert(chThdGetSelfX()->hdr.pqueue.prio == prio + 3, "unexpected priority level");
  209246:	f7ff fd2b 	bl	208ca0 <chThdGetSelfX.lto_priv.6>
  20924a:	4603      	mov	r3, r0
  20924c:	689a      	ldr	r2, [r3, #8]
  20924e:	9b01      	ldr	r3, [sp, #4]
  209250:	3303      	adds	r3, #3
  209252:	429a      	cmp	r2, r3
  209254:	bf0c      	ite	eq
  209256:	2301      	moveq	r3, #1
  209258:	2300      	movne	r3, #0
  20925a:	b2db      	uxtb	r3, r3
  20925c:	4917      	ldr	r1, [pc, #92]	@ (2092bc <rt_test_005_004_execute+0x15c>)
  20925e:	4618      	mov	r0, r3
  209260:	f7fe f9fe 	bl	207660 <__test_assert>
  209264:	4603      	mov	r3, r0
  209266:	2b00      	cmp	r3, #0
  209268:	d122      	bne.n	2092b0 <rt_test_005_004_execute+0x150>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
  20926a:	f7ff fd19 	bl	208ca0 <chThdGetSelfX.lto_priv.6>
  20926e:	4603      	mov	r3, r0
  209270:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
  209272:	9b01      	ldr	r3, [sp, #4]
  209274:	3303      	adds	r3, #3
  209276:	429a      	cmp	r2, r3
  209278:	bf0c      	ite	eq
  20927a:	2301      	moveq	r3, #1
  20927c:	2300      	movne	r3, #0
  20927e:	b2db      	uxtb	r3, r3
  209280:	4911      	ldr	r1, [pc, #68]	@ (2092c8 <rt_test_005_004_execute+0x168>)
  209282:	4618      	mov	r0, r3
  209284:	f7fe f9ec 	bl	207660 <__test_assert>
  209288:	4603      	mov	r3, r0
  20928a:	2b00      	cmp	r3, #0
  20928c:	d110      	bne.n	2092b0 <rt_test_005_004_execute+0x150>
  }
  test_end_step(3);

  /* [5.4.4] Restoring original conditions.*/
  test_set_step(4);
  20928e:	4b0a      	ldr	r3, [pc, #40]	@ (2092b8 <rt_test_005_004_execute+0x158>)
  209290:	2204      	movs	r2, #4
  209292:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  209294:	f7ff fcdc 	bl	208c50 <chSysLock.lto_priv.21>
    chThdGetSelfX()->hdr.pqueue.prio = prio;
  209298:	f7ff fd02 	bl	208ca0 <chThdGetSelfX.lto_priv.6>
  20929c:	4602      	mov	r2, r0
  20929e:	9b01      	ldr	r3, [sp, #4]
  2092a0:	6093      	str	r3, [r2, #8]
    chThdGetSelfX()->realprio = prio;
  2092a2:	f7ff fcfd 	bl	208ca0 <chThdGetSelfX.lto_priv.6>
  2092a6:	4602      	mov	r2, r0
  2092a8:	9b01      	ldr	r3, [sp, #4]
  2092aa:	64d3      	str	r3, [r2, #76]	@ 0x4c
    chSysUnlock();
  2092ac:	f7ff fce0 	bl	208c70 <chSysUnlock.lto_priv.21>
  }
  test_end_step(4);
}
  2092b0:	b003      	add	sp, #12
  2092b2:	f85d fb04 	ldr.w	pc, [sp], #4
  2092b6:	bf00      	nop
  2092b8:	20000bb4 	.word	0x20000bb4
  2092bc:	08011734 	.word	0x08011734
  2092c0:	08011710 	.word	0x08011710
  2092c4:	08011750 	.word	0x08011750
  2092c8:	08011778 	.word	0x08011778
  2092cc:	00000000 	.word	0x00000000

002092d0 <chTimeAddX.lto_priv.3>:
                                   sysinterval_t interval) {
  2092d0:	b082      	sub	sp, #8
  2092d2:	9001      	str	r0, [sp, #4]
  2092d4:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
  2092d6:	9a01      	ldr	r2, [sp, #4]
  2092d8:	9b00      	ldr	r3, [sp, #0]
  2092da:	4413      	add	r3, r2
}
  2092dc:	4618      	mov	r0, r3
  2092de:	b002      	add	sp, #8
  2092e0:	4770      	bx	lr
  2092e2:	bf00      	nop
	...

002092f0 <port_timer_get_time.lto_priv.8>:
static inline systime_t port_timer_get_time(void) {
  2092f0:	b508      	push	{r3, lr}
  return stGetCounter();
  2092f2:	f7f7 faf5 	bl	2008e0 <stGetCounter>
  2092f6:	4603      	mov	r3, r0
}
  2092f8:	4618      	mov	r0, r3
  2092fa:	bd08      	pop	{r3, pc}
  2092fc:	0000      	movs	r0, r0
	...

00209300 <chSysLock.lto_priv.22>:
static inline void chSysLock(void) {
  209300:	b082      	sub	sp, #8
  209302:	2330      	movs	r3, #48	@ 0x30
  209304:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  209306:	9b01      	ldr	r3, [sp, #4]
  209308:	f383 8811 	msr	BASEPRI, r3
}
  20930c:	bf00      	nop
}
  20930e:	bf00      	nop
}
  209310:	bf00      	nop
  209312:	b002      	add	sp, #8
  209314:	4770      	bx	lr
  209316:	bf00      	nop
	...

00209320 <chSysUnlock.lto_priv.22>:
static inline void chSysUnlock(void) {
  209320:	b082      	sub	sp, #8
  209322:	2300      	movs	r3, #0
  209324:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  209326:	9b01      	ldr	r3, [sp, #4]
  209328:	f383 8811 	msr	BASEPRI, r3
}
  20932c:	bf00      	nop
}
  20932e:	bf00      	nop
}
  209330:	bf00      	nop
  209332:	b002      	add	sp, #8
  209334:	4770      	bx	lr
  209336:	bf00      	nop
	...

00209340 <chVTGetSystemTimeX.lto_priv.8>:
static inline systime_t chVTGetSystemTimeX(void) {
  209340:	b508      	push	{r3, lr}
  return port_timer_get_time();
  209342:	f7ff ffd5 	bl	2092f0 <port_timer_get_time.lto_priv.8>
  209346:	4603      	mov	r3, r0
}
  209348:	4618      	mov	r0, r3
  20934a:	bd08      	pop	{r3, pc}
  20934c:	0000      	movs	r0, r0
	...

00209350 <chThdGetSelfX.lto_priv.7>:
  return __sch_get_currthread();
  209350:	4b01      	ldr	r3, [pc, #4]	@ (209358 <chThdGetSelfX.lto_priv.7+0x8>)
  209352:	68db      	ldr	r3, [r3, #12]
}
  209354:	4618      	mov	r0, r3
  209356:	4770      	bx	lr
  209358:	20000890 	.word	0x20000890
  20935c:	00000000 	.word	0x00000000

00209360 <chThdGetPriorityX.lto_priv.1>:
static inline tprio_t chThdGetPriorityX(void) {
  209360:	b508      	push	{r3, lr}
  return chThdGetSelfX()->hdr.pqueue.prio;
  209362:	f7ff fff5 	bl	209350 <chThdGetSelfX.lto_priv.7>
  209366:	4603      	mov	r3, r0
  209368:	689b      	ldr	r3, [r3, #8]
}
  20936a:	4618      	mov	r0, r3
  20936c:	bd08      	pop	{r3, pc}
  20936e:	bf00      	nop

00209370 <thread1.lto_priv.0>:
 * Shared code.
 ****************************************************************************/

static thread_reference_t tr1;

static THD_FUNCTION(thread1, p) {
  209370:	b500      	push	{lr}
  209372:	b083      	sub	sp, #12
  209374:	9001      	str	r0, [sp, #4]

  chSysLock();
  209376:	f7ff ffc3 	bl	209300 <chSysLock.lto_priv.22>
  chThdResumeI(&tr1, MSG_OK);
  20937a:	2100      	movs	r1, #0
  20937c:	4807      	ldr	r0, [pc, #28]	@ (20939c <thread1.lto_priv.0+0x2c>)
  20937e:	f7fa f99f 	bl	2036c0 <chThdResumeI>
  chSchRescheduleS();
  209382:	f7f9 fc75 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  209386:	f7ff ffcb 	bl	209320 <chSysUnlock.lto_priv.22>
  test_emit_token(*(char *)p);
  20938a:	9b01      	ldr	r3, [sp, #4]
  20938c:	781b      	ldrb	r3, [r3, #0]
  20938e:	4618      	mov	r0, r3
  209390:	f7fe f9c6 	bl	207720 <test_emit_token>
}
  209394:	bf00      	nop
  209396:	b003      	add	sp, #12
  209398:	f85d fb04 	ldr.w	pc, [sp], #4
  20939c:	20001914 	.word	0x20001914

002093a0 <rt_test_006_001_setup>:
 *   the state of the reference are tested.
 * .
 */

static void rt_test_006_001_setup(void) {
  tr1 = NULL;
  2093a0:	4b02      	ldr	r3, [pc, #8]	@ (2093ac <rt_test_006_001_setup+0xc>)
  2093a2:	2200      	movs	r2, #0
  2093a4:	601a      	str	r2, [r3, #0]
}
  2093a6:	bf00      	nop
  2093a8:	4770      	bx	lr
  2093aa:	bf00      	nop
  2093ac:	20001914 	.word	0x20001914

002093b0 <rt_test_006_001_execute>:

static void rt_test_006_001_execute(void) {
  2093b0:	b510      	push	{r4, lr}
  2093b2:	b084      	sub	sp, #16
  msg_t msg;

  /* [6.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
  2093b4:	4b3c      	ldr	r3, [pc, #240]	@ (2094a8 <rt_test_006_001_execute+0xf8>)
  2093b6:	2201      	movs	r2, #1
  2093b8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
  2093ba:	4b3c      	ldr	r3, [pc, #240]	@ (2094ac <rt_test_006_001_execute+0xfc>)
  2093bc:	681c      	ldr	r4, [r3, #0]
  2093be:	f7ff ffcf 	bl	209360 <chThdGetPriorityX.lto_priv.1>
  2093c2:	4603      	mov	r3, r0
  2093c4:	1e5a      	subs	r2, r3, #1
  2093c6:	4b3a      	ldr	r3, [pc, #232]	@ (2094b0 <rt_test_006_001_execute+0x100>)
  2093c8:	9300      	str	r3, [sp, #0]
  2093ca:	4b3a      	ldr	r3, [pc, #232]	@ (2094b4 <rt_test_006_001_execute+0x104>)
  2093cc:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  2093d0:	4620      	mov	r0, r4
  2093d2:	f7f9 ffd5 	bl	203380 <chThdCreateStatic>
  2093d6:	4603      	mov	r3, r0
  2093d8:	4a37      	ldr	r2, [pc, #220]	@ (2094b8 <rt_test_006_001_execute+0x108>)
  2093da:	6013      	str	r3, [r2, #0]
    chSysLock();
  2093dc:	f7ff ff90 	bl	209300 <chSysLock.lto_priv.22>
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
  2093e0:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
  2093e4:	4835      	ldr	r0, [pc, #212]	@ (2094bc <rt_test_006_001_execute+0x10c>)
  2093e6:	f7fa f943 	bl	203670 <chThdSuspendTimeoutS>
  2093ea:	9003      	str	r0, [sp, #12]
    chSysUnlock();
  2093ec:	f7ff ff98 	bl	209320 <chSysUnlock.lto_priv.22>
    test_assert(NULL == tr1, "not NULL");
  2093f0:	4b32      	ldr	r3, [pc, #200]	@ (2094bc <rt_test_006_001_execute+0x10c>)
  2093f2:	681b      	ldr	r3, [r3, #0]
  2093f4:	2b00      	cmp	r3, #0
  2093f6:	bf0c      	ite	eq
  2093f8:	2301      	moveq	r3, #1
  2093fa:	2300      	movne	r3, #0
  2093fc:	b2db      	uxtb	r3, r3
  2093fe:	4930      	ldr	r1, [pc, #192]	@ (2094c0 <rt_test_006_001_execute+0x110>)
  209400:	4618      	mov	r0, r3
  209402:	f7fe f92d 	bl	207660 <__test_assert>
  209406:	4603      	mov	r3, r0
  209408:	2b00      	cmp	r3, #0
  20940a:	d14a      	bne.n	2094a2 <rt_test_006_001_execute+0xf2>
    test_assert(MSG_OK == msg,"wrong returned message");
  20940c:	9b03      	ldr	r3, [sp, #12]
  20940e:	2b00      	cmp	r3, #0
  209410:	bf0c      	ite	eq
  209412:	2301      	moveq	r3, #1
  209414:	2300      	movne	r3, #0
  209416:	b2db      	uxtb	r3, r3
  209418:	492a      	ldr	r1, [pc, #168]	@ (2094c4 <rt_test_006_001_execute+0x114>)
  20941a:	4618      	mov	r0, r3
  20941c:	f7fe f920 	bl	207660 <__test_assert>
  209420:	4603      	mov	r3, r0
  209422:	2b00      	cmp	r3, #0
  209424:	d13d      	bne.n	2094a2 <rt_test_006_001_execute+0xf2>
    test_wait_threads();
  209426:	f7fe fceb 	bl	207e00 <test_wait_threads>
  test_end_step(1);

  /* [6.1.2] The function chThdSuspendTimeoutS() is invoked, the thread
     is not resumed so a timeout must occur. On return the message and
     the state of the reference are tested.*/
  test_set_step(2);
  20942a:	4b1f      	ldr	r3, [pc, #124]	@ (2094a8 <rt_test_006_001_execute+0xf8>)
  20942c:	2202      	movs	r2, #2
  20942e:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  209430:	f7ff ff66 	bl	209300 <chSysLock.lto_priv.22>
    time = chVTGetSystemTimeX();
  209434:	f7ff ff84 	bl	209340 <chVTGetSystemTimeX.lto_priv.8>
  209438:	9002      	str	r0, [sp, #8]
    msg = chThdSuspendTimeoutS(&tr1, TIME_MS2I(10));
  20943a:	2164      	movs	r1, #100	@ 0x64
  20943c:	481f      	ldr	r0, [pc, #124]	@ (2094bc <rt_test_006_001_execute+0x10c>)
  20943e:	f7fa f917 	bl	203670 <chThdSuspendTimeoutS>
  209442:	9003      	str	r0, [sp, #12]
    chSysUnlock();
  209444:	f7ff ff6c 	bl	209320 <chSysUnlock.lto_priv.22>
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(10)),
  209448:	2164      	movs	r1, #100	@ 0x64
  20944a:	9802      	ldr	r0, [sp, #8]
  20944c:	f7ff ff40 	bl	2092d0 <chTimeAddX.lto_priv.3>
  209450:	4604      	mov	r4, r0
  209452:	2167      	movs	r1, #103	@ 0x67
  209454:	9802      	ldr	r0, [sp, #8]
  209456:	f7ff ff3b 	bl	2092d0 <chTimeAddX.lto_priv.3>
  20945a:	4603      	mov	r3, r0
  20945c:	4a1a      	ldr	r2, [pc, #104]	@ (2094c8 <rt_test_006_001_execute+0x118>)
  20945e:	4619      	mov	r1, r3
  209460:	4620      	mov	r0, r4
  209462:	f7fe f945 	bl	2076f0 <__test_assert_time_window>
  209466:	4603      	mov	r3, r0
  209468:	2b00      	cmp	r3, #0
  20946a:	d11a      	bne.n	2094a2 <rt_test_006_001_execute+0xf2>
                            chTimeAddX(time, TIME_MS2I(10) + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
  20946c:	4b13      	ldr	r3, [pc, #76]	@ (2094bc <rt_test_006_001_execute+0x10c>)
  20946e:	681b      	ldr	r3, [r3, #0]
  209470:	2b00      	cmp	r3, #0
  209472:	bf0c      	ite	eq
  209474:	2301      	moveq	r3, #1
  209476:	2300      	movne	r3, #0
  209478:	b2db      	uxtb	r3, r3
  20947a:	4911      	ldr	r1, [pc, #68]	@ (2094c0 <rt_test_006_001_execute+0x110>)
  20947c:	4618      	mov	r0, r3
  20947e:	f7fe f8ef 	bl	207660 <__test_assert>
  209482:	4603      	mov	r3, r0
  209484:	2b00      	cmp	r3, #0
  209486:	d10c      	bne.n	2094a2 <rt_test_006_001_execute+0xf2>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
  209488:	9b03      	ldr	r3, [sp, #12]
  20948a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  20948e:	bf0c      	ite	eq
  209490:	2301      	moveq	r3, #1
  209492:	2300      	movne	r3, #0
  209494:	b2db      	uxtb	r3, r3
  209496:	490b      	ldr	r1, [pc, #44]	@ (2094c4 <rt_test_006_001_execute+0x114>)
  209498:	4618      	mov	r0, r3
  20949a:	f7fe f8e1 	bl	207660 <__test_assert>
  20949e:	4603      	mov	r3, r0
  2094a0:	2b00      	cmp	r3, #0
  }
  test_end_step(2);
}
  2094a2:	b004      	add	sp, #16
  2094a4:	bd10      	pop	{r4, pc}
  2094a6:	bf00      	nop
  2094a8:	20000bb4 	.word	0x20000bb4
  2094ac:	08012220 	.word	0x08012220
  2094b0:	080116f0 	.word	0x080116f0
  2094b4:	00209371 	.word	0x00209371
  2094b8:	20001900 	.word	0x20001900
  2094bc:	20001914 	.word	0x20001914
  2094c0:	08011798 	.word	0x08011798
  2094c4:	080117a4 	.word	0x080117a4
  2094c8:	080116d0 	.word	0x080116d0
  2094cc:	00000000 	.word	0x00000000

002094d0 <chTimeAddX.lto_priv.4>:
                                   sysinterval_t interval) {
  2094d0:	b082      	sub	sp, #8
  2094d2:	9001      	str	r0, [sp, #4]
  2094d4:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
  2094d6:	9a01      	ldr	r2, [sp, #4]
  2094d8:	9b00      	ldr	r3, [sp, #0]
  2094da:	4413      	add	r3, r2
}
  2094dc:	4618      	mov	r0, r3
  2094de:	b002      	add	sp, #8
  2094e0:	4770      	bx	lr
  2094e2:	bf00      	nop
	...

002094f0 <ch_queue_isempty.lto_priv.0>:
static inline bool ch_queue_isempty(const ch_queue_t *qp) {
  2094f0:	b082      	sub	sp, #8
  2094f2:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next == qp);
  2094f4:	9b01      	ldr	r3, [sp, #4]
  2094f6:	681b      	ldr	r3, [r3, #0]
  2094f8:	9a01      	ldr	r2, [sp, #4]
  2094fa:	429a      	cmp	r2, r3
  2094fc:	bf0c      	ite	eq
  2094fe:	2301      	moveq	r3, #1
  209500:	2300      	movne	r3, #0
  209502:	b2db      	uxtb	r3, r3
}
  209504:	4618      	mov	r0, r3
  209506:	b002      	add	sp, #8
  209508:	4770      	bx	lr
  20950a:	bf00      	nop
  20950c:	0000      	movs	r0, r0
	...

00209510 <chSysLock.lto_priv.23>:
static inline void chSysLock(void) {
  209510:	b082      	sub	sp, #8
  209512:	2330      	movs	r3, #48	@ 0x30
  209514:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  209516:	9b01      	ldr	r3, [sp, #4]
  209518:	f383 8811 	msr	BASEPRI, r3
}
  20951c:	bf00      	nop
}
  20951e:	bf00      	nop
}
  209520:	bf00      	nop
  209522:	b002      	add	sp, #8
  209524:	4770      	bx	lr
  209526:	bf00      	nop
	...

00209530 <chSysUnlock.lto_priv.23>:
static inline void chSysUnlock(void) {
  209530:	b082      	sub	sp, #8
  209532:	2300      	movs	r3, #0
  209534:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  209536:	9b01      	ldr	r3, [sp, #4]
  209538:	f383 8811 	msr	BASEPRI, r3
}
  20953c:	bf00      	nop
}
  20953e:	bf00      	nop
}
  209540:	bf00      	nop
  209542:	b002      	add	sp, #8
  209544:	4770      	bx	lr
  209546:	bf00      	nop
	...

00209550 <chThdGetSelfX.lto_priv.8>:
  return __sch_get_currthread();
  209550:	4b01      	ldr	r3, [pc, #4]	@ (209558 <chThdGetSelfX.lto_priv.8+0x8>)
  209552:	68db      	ldr	r3, [r3, #12]
}
  209554:	4618      	mov	r0, r3
  209556:	4770      	bx	lr
  209558:	20000890 	.word	0x20000890
  20955c:	00000000 	.word	0x00000000

00209560 <chThdGetPriorityX.lto_priv.2>:
static inline tprio_t chThdGetPriorityX(void) {
  209560:	b508      	push	{r3, lr}
  return chThdGetSelfX()->hdr.pqueue.prio;
  209562:	f7ff fff5 	bl	209550 <chThdGetSelfX.lto_priv.8>
  209566:	4603      	mov	r3, r0
  209568:	689b      	ldr	r3, [r3, #8]
}
  20956a:	4618      	mov	r0, r3
  20956c:	bd08      	pop	{r3, pc}
  20956e:	bf00      	nop

00209570 <chSemReset.lto_priv.0>:
static inline void chSemReset(semaphore_t *sp, cnt_t n) {
  209570:	b500      	push	{lr}
  209572:	b083      	sub	sp, #12
  209574:	9001      	str	r0, [sp, #4]
  209576:	9100      	str	r1, [sp, #0]
  chSemResetWithMessage(sp, n, MSG_RESET);
  209578:	f06f 0201 	mvn.w	r2, #1
  20957c:	9900      	ldr	r1, [sp, #0]
  20957e:	9801      	ldr	r0, [sp, #4]
  209580:	f7fa fa5e 	bl	203a40 <chSemResetWithMessage>
}
  209584:	bf00      	nop
  209586:	b003      	add	sp, #12
  209588:	f85d fb04 	ldr.w	pc, [sp], #4
  20958c:	0000      	movs	r0, r0
	...

00209590 <chSemGetCounterI.lto_priv.1>:
static inline cnt_t chSemGetCounterI(const semaphore_t *sp) {
  209590:	b082      	sub	sp, #8
  209592:	9001      	str	r0, [sp, #4]
  return sp->cnt;
  209594:	9b01      	ldr	r3, [sp, #4]
  209596:	689b      	ldr	r3, [r3, #8]
}
  209598:	4618      	mov	r0, r3
  20959a:	b002      	add	sp, #8
  20959c:	4770      	bx	lr
  20959e:	bf00      	nop

002095a0 <chBSemObjectInit>:
 *                      - @a false, the initial state is not taken.
 *                      - @a true, the initial state is taken.
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {
  2095a0:	b500      	push	{lr}
  2095a2:	b083      	sub	sp, #12
  2095a4:	9001      	str	r0, [sp, #4]
  2095a6:	460b      	mov	r3, r1
  2095a8:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemObjectInit(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
  2095ac:	9a01      	ldr	r2, [sp, #4]
  2095ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
  2095b2:	f083 0301 	eor.w	r3, r3, #1
  2095b6:	b2db      	uxtb	r3, r3
  2095b8:	4619      	mov	r1, r3
  2095ba:	4610      	mov	r0, r2
  2095bc:	f7fa fa30 	bl	203a20 <chSemObjectInit>
}
  2095c0:	bf00      	nop
  2095c2:	b003      	add	sp, #12
  2095c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002095d0 <chBSemWait>:
 * @retval MSG_RESET    if the binary semaphore has been reset using
 *                      @p chBSemReset().
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {
  2095d0:	b500      	push	{lr}
  2095d2:	b083      	sub	sp, #12
  2095d4:	9001      	str	r0, [sp, #4]

  return chSemWait(&bsp->sem);
  2095d6:	9b01      	ldr	r3, [sp, #4]
  2095d8:	4618      	mov	r0, r3
  2095da:	f7fa fa69 	bl	203ab0 <chSemWait>
  2095de:	4603      	mov	r3, r0
}
  2095e0:	4618      	mov	r0, r3
  2095e2:	b003      	add	sp, #12
  2095e4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

002095f0 <chBSemReset>:
 *                      - @a false, the new state is not taken.
 *                      - @a true, the new state is taken.
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {
  2095f0:	b500      	push	{lr}
  2095f2:	b083      	sub	sp, #12
  2095f4:	9001      	str	r0, [sp, #4]
  2095f6:	460b      	mov	r3, r1
  2095f8:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
  2095fc:	9a01      	ldr	r2, [sp, #4]
  2095fe:	f89d 3003 	ldrb.w	r3, [sp, #3]
  209602:	f083 0301 	eor.w	r3, r3, #1
  209606:	b2db      	uxtb	r3, r3
  209608:	4619      	mov	r1, r3
  20960a:	4610      	mov	r0, r2
  20960c:	f7ff ffb0 	bl	209570 <chSemReset.lto_priv.0>
}
  209610:	bf00      	nop
  209612:	b003      	add	sp, #12
  209614:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00209620 <chBSemSignalI>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t object
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {
  209620:	b500      	push	{lr}
  209622:	b083      	sub	sp, #12
  209624:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
  209626:	9b01      	ldr	r3, [sp, #4]
  209628:	689b      	ldr	r3, [r3, #8]
  20962a:	2b00      	cmp	r3, #0
  20962c:	dc03      	bgt.n	209636 <chBSemSignalI+0x16>
    chSemSignalI(&bsp->sem);
  20962e:	9b01      	ldr	r3, [sp, #4]
  209630:	4618      	mov	r0, r3
  209632:	f7fa fae5 	bl	203c00 <chSemSignalI>
  }
}
  209636:	bf00      	nop
  209638:	b003      	add	sp, #12
  20963a:	f85d fb04 	ldr.w	pc, [sp], #4
  20963e:	bf00      	nop

00209640 <chBSemSignal>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t object
 *
 * @api
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {
  209640:	b500      	push	{lr}
  209642:	b083      	sub	sp, #12
  209644:	9001      	str	r0, [sp, #4]

  chSysLock();
  209646:	f7ff ff63 	bl	209510 <chSysLock.lto_priv.23>
  chBSemSignalI(bsp);
  20964a:	9801      	ldr	r0, [sp, #4]
  20964c:	f7ff ffe8 	bl	209620 <chBSemSignalI>
  chSchRescheduleS();
  209650:	f7f9 fb0e 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  209654:	f7ff ff6c 	bl	209530 <chSysUnlock.lto_priv.23>
}
  209658:	bf00      	nop
  20965a:	b003      	add	sp, #12
  20965c:	f85d fb04 	ldr.w	pc, [sp], #4

00209660 <chBSemGetStateI>:
 * @retval false        if the binary semaphore is not taken.
 * @retval true         if the binary semaphore is taken.
 *
 * @iclass
 */
static inline bool chBSemGetStateI(const binary_semaphore_t *bsp) {
  209660:	b082      	sub	sp, #8
  209662:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
  209664:	9b01      	ldr	r3, [sp, #4]
  209666:	689b      	ldr	r3, [r3, #8]
  209668:	2b00      	cmp	r3, #0
  20966a:	bfd4      	ite	le
  20966c:	2301      	movle	r3, #1
  20966e:	2300      	movgt	r3, #0
  209670:	b2db      	uxtb	r3, r3
}
  209672:	4618      	mov	r0, r3
  209674:	b002      	add	sp, #8
  209676:	4770      	bx	lr
	...

00209680 <osalSysLock.lto_priv.3>:
static inline void osalSysLock(void) {
  209680:	b508      	push	{r3, lr}
  chSysLock();
  209682:	f7ff ff45 	bl	209510 <chSysLock.lto_priv.23>
}
  209686:	bf00      	nop
  209688:	bd08      	pop	{r3, pc}
  20968a:	bf00      	nop
  20968c:	0000      	movs	r0, r0
	...

00209690 <osalSysUnlock.lto_priv.3>:
static inline void osalSysUnlock(void) {
  209690:	b508      	push	{r3, lr}
  chSysUnlock();
  209692:	f7ff ff4d 	bl	209530 <chSysUnlock.lto_priv.23>
}
  209696:	bf00      	nop
  209698:	bd08      	pop	{r3, pc}
  20969a:	bf00      	nop
  20969c:	0000      	movs	r0, r0
	...

002096a0 <thread1.lto_priv.1>:

#include "ch.h"

static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {
  2096a0:	b500      	push	{lr}
  2096a2:	b083      	sub	sp, #12
  2096a4:	9001      	str	r0, [sp, #4]

  chSemWait(&sem1);
  2096a6:	4806      	ldr	r0, [pc, #24]	@ (2096c0 <thread1.lto_priv.1+0x20>)
  2096a8:	f7fa fa02 	bl	203ab0 <chSemWait>
  test_emit_token(*(char *)p);
  2096ac:	9b01      	ldr	r3, [sp, #4]
  2096ae:	781b      	ldrb	r3, [r3, #0]
  2096b0:	4618      	mov	r0, r3
  2096b2:	f7fe f835 	bl	207720 <test_emit_token>
}
  2096b6:	bf00      	nop
  2096b8:	b003      	add	sp, #12
  2096ba:	f85d fb04 	ldr.w	pc, [sp], #4
  2096be:	bf00      	nop
  2096c0:	20001918 	.word	0x20001918
	...

002096d0 <thread2>:

static THD_FUNCTION(thread2, p) {
  2096d0:	b500      	push	{lr}
  2096d2:	b083      	sub	sp, #12
  2096d4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
  2096d6:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  2096da:	f7f9 ff89 	bl	2035f0 <chThdSleep>
  chSysLock();
  2096de:	f7ff ff17 	bl	209510 <chSysLock.lto_priv.23>
  chSemSignalI(&sem1); /* For coverage reasons */
  2096e2:	4805      	ldr	r0, [pc, #20]	@ (2096f8 <thread2+0x28>)
  2096e4:	f7fa fa8c 	bl	203c00 <chSemSignalI>
  chSchRescheduleS();
  2096e8:	f7f9 fac2 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  2096ec:	f7ff ff20 	bl	209530 <chSysUnlock.lto_priv.23>
}
  2096f0:	bf00      	nop
  2096f2:	b003      	add	sp, #12
  2096f4:	f85d fb04 	ldr.w	pc, [sp], #4
  2096f8:	20001918 	.word	0x20001918
  2096fc:	00000000 	.word	0x00000000

00209700 <thread3>:

static THD_FUNCTION(thread3, p) {
  209700:	b500      	push	{lr}
  209702:	b083      	sub	sp, #12
  209704:	9001      	str	r0, [sp, #4]

  (void)p;
  chSemWait(&sem1);
  209706:	4805      	ldr	r0, [pc, #20]	@ (20971c <thread3+0x1c>)
  209708:	f7fa f9d2 	bl	203ab0 <chSemWait>
  chSemSignal(&sem1);
  20970c:	4803      	ldr	r0, [pc, #12]	@ (20971c <thread3+0x1c>)
  20970e:	f7fa fa57 	bl	203bc0 <chSemSignal>
}
  209712:	bf00      	nop
  209714:	b003      	add	sp, #12
  209716:	f85d fb04 	ldr.w	pc, [sp], #4
  20971a:	bf00      	nop
  20971c:	20001918 	.word	0x20001918

00209720 <thread4>:

static THD_FUNCTION(thread4, p) {
  209720:	b500      	push	{lr}
  209722:	b083      	sub	sp, #12
  209724:	9001      	str	r0, [sp, #4]

  chBSemSignal((binary_semaphore_t *)p);
  209726:	9801      	ldr	r0, [sp, #4]
  209728:	f7ff ff8a 	bl	209640 <chBSemSignal>
}
  20972c:	bf00      	nop
  20972e:	b003      	add	sp, #12
  209730:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00209740 <rt_test_007_001_setup>:
 * - [7.1.3] The function chSemReset() is invoked, after return the
 *   counter is tested.
 * .
 */

static void rt_test_007_001_setup(void) {
  209740:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 1);
  209742:	2101      	movs	r1, #1
  209744:	4802      	ldr	r0, [pc, #8]	@ (209750 <rt_test_007_001_setup+0x10>)
  209746:	f7fa f96b 	bl	203a20 <chSemObjectInit>
}
  20974a:	bf00      	nop
  20974c:	bd08      	pop	{r3, pc}
  20974e:	bf00      	nop
  209750:	20001918 	.word	0x20001918
	...

00209760 <rt_test_007_001_teardown>:

static void rt_test_007_001_teardown(void) {
  209760:	b508      	push	{r3, lr}
  chSemReset(&sem1, 0);
  209762:	2100      	movs	r1, #0
  209764:	4802      	ldr	r0, [pc, #8]	@ (209770 <rt_test_007_001_teardown+0x10>)
  209766:	f7ff ff03 	bl	209570 <chSemReset.lto_priv.0>
}
  20976a:	bf00      	nop
  20976c:	bd08      	pop	{r3, pc}
  20976e:	bf00      	nop
  209770:	20001918 	.word	0x20001918
	...

00209780 <rt_test_007_001_execute>:

static void rt_test_007_001_execute(void) {
  209780:	b500      	push	{lr}
  209782:	b083      	sub	sp, #12

  /* [7.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
  209784:	4b34      	ldr	r3, [pc, #208]	@ (209858 <rt_test_007_001_execute+0xd8>)
  209786:	2201      	movs	r2, #1
  209788:	601a      	str	r2, [r3, #0]
  {
    msg_t msg;

    msg = chSemWait(&sem1);
  20978a:	4834      	ldr	r0, [pc, #208]	@ (20985c <rt_test_007_001_execute+0xdc>)
  20978c:	f7fa f990 	bl	203ab0 <chSemWait>
  209790:	9001      	str	r0, [sp, #4]
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
  209792:	f7ff ff75 	bl	209680 <osalSysLock.lto_priv.3>
  209796:	4831      	ldr	r0, [pc, #196]	@ (20985c <rt_test_007_001_execute+0xdc>)
  209798:	f7ff fefa 	bl	209590 <chSemGetCounterI.lto_priv.1>
  20979c:	4603      	mov	r3, r0
  20979e:	2b00      	cmp	r3, #0
  2097a0:	bf0c      	ite	eq
  2097a2:	2301      	moveq	r3, #1
  2097a4:	2300      	movne	r3, #0
  2097a6:	b2db      	uxtb	r3, r3
  2097a8:	492d      	ldr	r1, [pc, #180]	@ (209860 <rt_test_007_001_execute+0xe0>)
  2097aa:	4618      	mov	r0, r3
  2097ac:	f7fd ff58 	bl	207660 <__test_assert>
  2097b0:	4603      	mov	r3, r0
  2097b2:	2b00      	cmp	r3, #0
  2097b4:	d002      	beq.n	2097bc <rt_test_007_001_execute+0x3c>
  2097b6:	f7ff ff6b 	bl	209690 <osalSysUnlock.lto_priv.3>
  2097ba:	e049      	b.n	209850 <rt_test_007_001_execute+0xd0>
  2097bc:	f7ff ff68 	bl	209690 <osalSysUnlock.lto_priv.3>
    test_assert(MSG_OK == msg, "wrong returned message");
  2097c0:	9b01      	ldr	r3, [sp, #4]
  2097c2:	2b00      	cmp	r3, #0
  2097c4:	bf0c      	ite	eq
  2097c6:	2301      	moveq	r3, #1
  2097c8:	2300      	movne	r3, #0
  2097ca:	b2db      	uxtb	r3, r3
  2097cc:	4925      	ldr	r1, [pc, #148]	@ (209864 <rt_test_007_001_execute+0xe4>)
  2097ce:	4618      	mov	r0, r3
  2097d0:	f7fd ff46 	bl	207660 <__test_assert>
  2097d4:	4603      	mov	r3, r0
  2097d6:	2b00      	cmp	r3, #0
  2097d8:	d13a      	bne.n	209850 <rt_test_007_001_execute+0xd0>
  }
  test_end_step(1);

  /* [7.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
  2097da:	4b1f      	ldr	r3, [pc, #124]	@ (209858 <rt_test_007_001_execute+0xd8>)
  2097dc:	2202      	movs	r2, #2
  2097de:	601a      	str	r2, [r3, #0]
  {
    chSemSignal(&sem1);
  2097e0:	481e      	ldr	r0, [pc, #120]	@ (20985c <rt_test_007_001_execute+0xdc>)
  2097e2:	f7fa f9ed 	bl	203bc0 <chSemSignal>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
  2097e6:	f7ff ff4b 	bl	209680 <osalSysLock.lto_priv.3>
  2097ea:	481c      	ldr	r0, [pc, #112]	@ (20985c <rt_test_007_001_execute+0xdc>)
  2097ec:	f7ff fed0 	bl	209590 <chSemGetCounterI.lto_priv.1>
  2097f0:	4603      	mov	r3, r0
  2097f2:	2b01      	cmp	r3, #1
  2097f4:	bf0c      	ite	eq
  2097f6:	2301      	moveq	r3, #1
  2097f8:	2300      	movne	r3, #0
  2097fa:	b2db      	uxtb	r3, r3
  2097fc:	4918      	ldr	r1, [pc, #96]	@ (209860 <rt_test_007_001_execute+0xe0>)
  2097fe:	4618      	mov	r0, r3
  209800:	f7fd ff2e 	bl	207660 <__test_assert>
  209804:	4603      	mov	r3, r0
  209806:	2b00      	cmp	r3, #0
  209808:	d002      	beq.n	209810 <rt_test_007_001_execute+0x90>
  20980a:	f7ff ff41 	bl	209690 <osalSysUnlock.lto_priv.3>
  20980e:	e01f      	b.n	209850 <rt_test_007_001_execute+0xd0>
  209810:	f7ff ff3e 	bl	209690 <osalSysUnlock.lto_priv.3>
  }
  test_end_step(2);

  /* [7.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
  209814:	4b10      	ldr	r3, [pc, #64]	@ (209858 <rt_test_007_001_execute+0xd8>)
  209816:	2203      	movs	r2, #3
  209818:	601a      	str	r2, [r3, #0]
  {
    chSemReset(&sem1, 2);
  20981a:	2102      	movs	r1, #2
  20981c:	480f      	ldr	r0, [pc, #60]	@ (20985c <rt_test_007_001_execute+0xdc>)
  20981e:	f7ff fea7 	bl	209570 <chSemReset.lto_priv.0>
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
  209822:	f7ff ff2d 	bl	209680 <osalSysLock.lto_priv.3>
  209826:	480d      	ldr	r0, [pc, #52]	@ (20985c <rt_test_007_001_execute+0xdc>)
  209828:	f7ff feb2 	bl	209590 <chSemGetCounterI.lto_priv.1>
  20982c:	4603      	mov	r3, r0
  20982e:	2b02      	cmp	r3, #2
  209830:	bf0c      	ite	eq
  209832:	2301      	moveq	r3, #1
  209834:	2300      	movne	r3, #0
  209836:	b2db      	uxtb	r3, r3
  209838:	4909      	ldr	r1, [pc, #36]	@ (209860 <rt_test_007_001_execute+0xe0>)
  20983a:	4618      	mov	r0, r3
  20983c:	f7fd ff10 	bl	207660 <__test_assert>
  209840:	4603      	mov	r3, r0
  209842:	2b00      	cmp	r3, #0
  209844:	d002      	beq.n	20984c <rt_test_007_001_execute+0xcc>
  209846:	f7ff ff23 	bl	209690 <osalSysUnlock.lto_priv.3>
  20984a:	e001      	b.n	209850 <rt_test_007_001_execute+0xd0>
  20984c:	f7ff ff20 	bl	209690 <osalSysUnlock.lto_priv.3>
  }
  test_end_step(3);
}
  209850:	b003      	add	sp, #12
  209852:	f85d fb04 	ldr.w	pc, [sp], #4
  209856:	bf00      	nop
  209858:	20000bb4 	.word	0x20000bb4
  20985c:	20001918 	.word	0x20001918
  209860:	080117bc 	.word	0x080117bc
  209864:	080117a4 	.word	0x080117a4
	...

00209870 <rt_test_007_002_setup>:
 * - [7.2.2] The semaphore is signaled 5 times. The thread activation
 *   sequence is tested.
 * .
 */

static void rt_test_007_002_setup(void) {
  209870:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
  209872:	2100      	movs	r1, #0
  209874:	4802      	ldr	r0, [pc, #8]	@ (209880 <rt_test_007_002_setup+0x10>)
  209876:	f7fa f8d3 	bl	203a20 <chSemObjectInit>
}
  20987a:	bf00      	nop
  20987c:	bd08      	pop	{r3, pc}
  20987e:	bf00      	nop
  209880:	20001918 	.word	0x20001918
	...

00209890 <rt_test_007_002_execute>:

static void rt_test_007_002_execute(void) {
  209890:	b510      	push	{r4, lr}
  209892:	b082      	sub	sp, #8

  /* [7.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
  209894:	4b39      	ldr	r3, [pc, #228]	@ (20997c <rt_test_007_002_execute+0xec>)
  209896:	2201      	movs	r2, #1
  209898:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  20989a:	4b39      	ldr	r3, [pc, #228]	@ (209980 <rt_test_007_002_execute+0xf0>)
  20989c:	681c      	ldr	r4, [r3, #0]
  20989e:	f7ff fe5f 	bl	209560 <chThdGetPriorityX.lto_priv.2>
  2098a2:	4603      	mov	r3, r0
  2098a4:	1d5a      	adds	r2, r3, #5
  2098a6:	4b37      	ldr	r3, [pc, #220]	@ (209984 <rt_test_007_002_execute+0xf4>)
  2098a8:	9300      	str	r3, [sp, #0]
  2098aa:	4b37      	ldr	r3, [pc, #220]	@ (209988 <rt_test_007_002_execute+0xf8>)
  2098ac:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  2098b0:	4620      	mov	r0, r4
  2098b2:	f7f9 fd65 	bl	203380 <chThdCreateStatic>
  2098b6:	4603      	mov	r3, r0
  2098b8:	4a34      	ldr	r2, [pc, #208]	@ (20998c <rt_test_007_002_execute+0xfc>)
  2098ba:	6013      	str	r3, [r2, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  2098bc:	4b30      	ldr	r3, [pc, #192]	@ (209980 <rt_test_007_002_execute+0xf0>)
  2098be:	685c      	ldr	r4, [r3, #4]
  2098c0:	f7ff fe4e 	bl	209560 <chThdGetPriorityX.lto_priv.2>
  2098c4:	4603      	mov	r3, r0
  2098c6:	1c5a      	adds	r2, r3, #1
  2098c8:	4b31      	ldr	r3, [pc, #196]	@ (209990 <rt_test_007_002_execute+0x100>)
  2098ca:	9300      	str	r3, [sp, #0]
  2098cc:	4b2e      	ldr	r3, [pc, #184]	@ (209988 <rt_test_007_002_execute+0xf8>)
  2098ce:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  2098d2:	4620      	mov	r0, r4
  2098d4:	f7f9 fd54 	bl	203380 <chThdCreateStatic>
  2098d8:	4603      	mov	r3, r0
  2098da:	4a2c      	ldr	r2, [pc, #176]	@ (20998c <rt_test_007_002_execute+0xfc>)
  2098dc:	6053      	str	r3, [r2, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  2098de:	4b28      	ldr	r3, [pc, #160]	@ (209980 <rt_test_007_002_execute+0xf0>)
  2098e0:	689c      	ldr	r4, [r3, #8]
  2098e2:	f7ff fe3d 	bl	209560 <chThdGetPriorityX.lto_priv.2>
  2098e6:	4603      	mov	r3, r0
  2098e8:	1cda      	adds	r2, r3, #3
  2098ea:	4b2a      	ldr	r3, [pc, #168]	@ (209994 <rt_test_007_002_execute+0x104>)
  2098ec:	9300      	str	r3, [sp, #0]
  2098ee:	4b26      	ldr	r3, [pc, #152]	@ (209988 <rt_test_007_002_execute+0xf8>)
  2098f0:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  2098f4:	4620      	mov	r0, r4
  2098f6:	f7f9 fd43 	bl	203380 <chThdCreateStatic>
  2098fa:	4603      	mov	r3, r0
  2098fc:	4a23      	ldr	r2, [pc, #140]	@ (20998c <rt_test_007_002_execute+0xfc>)
  2098fe:	6093      	str	r3, [r2, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
  209900:	4b1f      	ldr	r3, [pc, #124]	@ (209980 <rt_test_007_002_execute+0xf0>)
  209902:	68dc      	ldr	r4, [r3, #12]
  209904:	f7ff fe2c 	bl	209560 <chThdGetPriorityX.lto_priv.2>
  209908:	4603      	mov	r3, r0
  20990a:	1d1a      	adds	r2, r3, #4
  20990c:	4b22      	ldr	r3, [pc, #136]	@ (209998 <rt_test_007_002_execute+0x108>)
  20990e:	9300      	str	r3, [sp, #0]
  209910:	4b1d      	ldr	r3, [pc, #116]	@ (209988 <rt_test_007_002_execute+0xf8>)
  209912:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  209916:	4620      	mov	r0, r4
  209918:	f7f9 fd32 	bl	203380 <chThdCreateStatic>
  20991c:	4603      	mov	r3, r0
  20991e:	4a1b      	ldr	r2, [pc, #108]	@ (20998c <rt_test_007_002_execute+0xfc>)
  209920:	60d3      	str	r3, [r2, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  209922:	4b17      	ldr	r3, [pc, #92]	@ (209980 <rt_test_007_002_execute+0xf0>)
  209924:	691c      	ldr	r4, [r3, #16]
  209926:	f7ff fe1b 	bl	209560 <chThdGetPriorityX.lto_priv.2>
  20992a:	4603      	mov	r3, r0
  20992c:	1c9a      	adds	r2, r3, #2
  20992e:	4b1b      	ldr	r3, [pc, #108]	@ (20999c <rt_test_007_002_execute+0x10c>)
  209930:	9300      	str	r3, [sp, #0]
  209932:	4b15      	ldr	r3, [pc, #84]	@ (209988 <rt_test_007_002_execute+0xf8>)
  209934:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  209938:	4620      	mov	r0, r4
  20993a:	f7f9 fd21 	bl	203380 <chThdCreateStatic>
  20993e:	4603      	mov	r3, r0
  209940:	4a12      	ldr	r2, [pc, #72]	@ (20998c <rt_test_007_002_execute+0xfc>)
  209942:	6113      	str	r3, [r2, #16]
  }
  test_end_step(1);

  /* [7.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
  209944:	4b0d      	ldr	r3, [pc, #52]	@ (20997c <rt_test_007_002_execute+0xec>)
  209946:	2202      	movs	r2, #2
  209948:	601a      	str	r2, [r3, #0]
  {
    chSemSignal(&sem1);
  20994a:	4815      	ldr	r0, [pc, #84]	@ (2099a0 <rt_test_007_002_execute+0x110>)
  20994c:	f7fa f938 	bl	203bc0 <chSemSignal>
    chSemSignal(&sem1);
  209950:	4813      	ldr	r0, [pc, #76]	@ (2099a0 <rt_test_007_002_execute+0x110>)
  209952:	f7fa f935 	bl	203bc0 <chSemSignal>
    chSemSignal(&sem1);
  209956:	4812      	ldr	r0, [pc, #72]	@ (2099a0 <rt_test_007_002_execute+0x110>)
  209958:	f7fa f932 	bl	203bc0 <chSemSignal>
    chSemSignal(&sem1);
  20995c:	4810      	ldr	r0, [pc, #64]	@ (2099a0 <rt_test_007_002_execute+0x110>)
  20995e:	f7fa f92f 	bl	203bc0 <chSemSignal>
    chSemSignal(&sem1);
  209962:	480f      	ldr	r0, [pc, #60]	@ (2099a0 <rt_test_007_002_execute+0x110>)
  209964:	f7fa f92c 	bl	203bc0 <chSemSignal>
    test_wait_threads();
  209968:	f7fe fa4a 	bl	207e00 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
  20996c:	490d      	ldr	r1, [pc, #52]	@ (2099a4 <rt_test_007_002_execute+0x114>)
  20996e:	480e      	ldr	r0, [pc, #56]	@ (2099a8 <rt_test_007_002_execute+0x118>)
  209970:	f7fd fe8e 	bl	207690 <__test_assert_sequence>
  209974:	4603      	mov	r3, r0
  209976:	2b00      	cmp	r3, #0
#endif
  }
  test_end_step(2);
}
  209978:	b002      	add	sp, #8
  20997a:	bd10      	pop	{r4, pc}
  20997c:	20000bb4 	.word	0x20000bb4
  209980:	08012220 	.word	0x08012220
  209984:	080116f0 	.word	0x080116f0
  209988:	002096a1 	.word	0x002096a1
  20998c:	20001900 	.word	0x20001900
  209990:	080116ec 	.word	0x080116ec
  209994:	080116e8 	.word	0x080116e8
  209998:	080116e4 	.word	0x080116e4
  20999c:	0801170c 	.word	0x0801170c
  2099a0:	20001918 	.word	0x20001918
  2099a4:	080116f4 	.word	0x080116f4
  2099a8:	08011708 	.word	0x08011708
  2099ac:	00000000 	.word	0x00000000

002099b0 <rt_test_007_003_setup>:
 * - [7.3.2] Testing non-timeout condition.
 * - [7.3.3] Testing timeout condition.
 * .
 */

static void rt_test_007_003_setup(void) {
  2099b0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
  2099b2:	2100      	movs	r1, #0
  2099b4:	4802      	ldr	r0, [pc, #8]	@ (2099c0 <rt_test_007_003_setup+0x10>)
  2099b6:	f7fa f833 	bl	203a20 <chSemObjectInit>
}
  2099ba:	bf00      	nop
  2099bc:	bd08      	pop	{r3, pc}
  2099be:	bf00      	nop
  2099c0:	20001918 	.word	0x20001918
	...

002099d0 <rt_test_007_003_execute>:

static void rt_test_007_003_execute(void) {
  2099d0:	b510      	push	{r4, lr}
  2099d2:	b086      	sub	sp, #24
  unsigned i;
  systime_t target_time;
  msg_t msg;

  /* [7.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
  2099d4:	4b68      	ldr	r3, [pc, #416]	@ (209b78 <rt_test_007_003_execute+0x1a8>)
  2099d6:	2201      	movs	r2, #1
  2099d8:	601a      	str	r2, [r3, #0]
  {
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  2099da:	2100      	movs	r1, #0
  2099dc:	4867      	ldr	r0, [pc, #412]	@ (209b7c <rt_test_007_003_execute+0x1ac>)
  2099de:	f7fa f89f 	bl	203b20 <chSemWaitTimeout>
  2099e2:	9004      	str	r0, [sp, #16]
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
  2099e4:	9b04      	ldr	r3, [sp, #16]
  2099e6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  2099ea:	bf0c      	ite	eq
  2099ec:	2301      	moveq	r3, #1
  2099ee:	2300      	movne	r3, #0
  2099f0:	b2db      	uxtb	r3, r3
  2099f2:	4963      	ldr	r1, [pc, #396]	@ (209b80 <rt_test_007_003_execute+0x1b0>)
  2099f4:	4618      	mov	r0, r3
  2099f6:	f7fd fe33 	bl	207660 <__test_assert>
  2099fa:	4603      	mov	r3, r0
  2099fc:	2b00      	cmp	r3, #0
  2099fe:	f040 80b9 	bne.w	209b74 <rt_test_007_003_execute+0x1a4>
    test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
  209a02:	485e      	ldr	r0, [pc, #376]	@ (209b7c <rt_test_007_003_execute+0x1ac>)
  209a04:	f7ff fd74 	bl	2094f0 <ch_queue_isempty.lto_priv.0>
  209a08:	4603      	mov	r3, r0
  209a0a:	495e      	ldr	r1, [pc, #376]	@ (209b84 <rt_test_007_003_execute+0x1b4>)
  209a0c:	4618      	mov	r0, r3
  209a0e:	f7fd fe27 	bl	207660 <__test_assert>
  209a12:	4603      	mov	r3, r0
  209a14:	2b00      	cmp	r3, #0
  209a16:	f040 80ad 	bne.w	209b74 <rt_test_007_003_execute+0x1a4>
    test_assert(sem1.cnt == 0, "counter not zero");
  209a1a:	4b58      	ldr	r3, [pc, #352]	@ (209b7c <rt_test_007_003_execute+0x1ac>)
  209a1c:	689b      	ldr	r3, [r3, #8]
  209a1e:	2b00      	cmp	r3, #0
  209a20:	bf0c      	ite	eq
  209a22:	2301      	moveq	r3, #1
  209a24:	2300      	movne	r3, #0
  209a26:	b2db      	uxtb	r3, r3
  209a28:	4957      	ldr	r1, [pc, #348]	@ (209b88 <rt_test_007_003_execute+0x1b8>)
  209a2a:	4618      	mov	r0, r3
  209a2c:	f7fd fe18 	bl	207660 <__test_assert>
  209a30:	4603      	mov	r3, r0
  209a32:	2b00      	cmp	r3, #0
  209a34:	f040 809e 	bne.w	209b74 <rt_test_007_003_execute+0x1a4>
  }
  test_end_step(1);

  /* [7.3.2] Testing non-timeout condition.*/
  test_set_step(2);
  209a38:	4b4f      	ldr	r3, [pc, #316]	@ (209b78 <rt_test_007_003_execute+0x1a8>)
  209a3a:	2202      	movs	r2, #2
  209a3c:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  209a3e:	4b53      	ldr	r3, [pc, #332]	@ (209b8c <rt_test_007_003_execute+0x1bc>)
  209a40:	681c      	ldr	r4, [r3, #0]
  209a42:	f7ff fd8d 	bl	209560 <chThdGetPriorityX.lto_priv.2>
  209a46:	4603      	mov	r3, r0
  209a48:	1e5a      	subs	r2, r3, #1
  209a4a:	2300      	movs	r3, #0
  209a4c:	9300      	str	r3, [sp, #0]
  209a4e:	4b50      	ldr	r3, [pc, #320]	@ (209b90 <rt_test_007_003_execute+0x1c0>)
  209a50:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  209a54:	4620      	mov	r0, r4
  209a56:	f7f9 fc93 	bl	203380 <chThdCreateStatic>
  209a5a:	4603      	mov	r3, r0
  209a5c:	4a4d      	ldr	r2, [pc, #308]	@ (209b94 <rt_test_007_003_execute+0x1c4>)
  209a5e:	6013      	str	r3, [r2, #0]
                                   thread2, 0);
    msg = chSemWaitTimeout(&sem1, TIME_MS2I(500));
  209a60:	f241 3188 	movw	r1, #5000	@ 0x1388
  209a64:	4845      	ldr	r0, [pc, #276]	@ (209b7c <rt_test_007_003_execute+0x1ac>)
  209a66:	f7fa f85b 	bl	203b20 <chSemWaitTimeout>
  209a6a:	9004      	str	r0, [sp, #16]
    test_wait_threads();
  209a6c:	f7fe f9c8 	bl	207e00 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
  209a70:	9b04      	ldr	r3, [sp, #16]
  209a72:	2b00      	cmp	r3, #0
  209a74:	bf0c      	ite	eq
  209a76:	2301      	moveq	r3, #1
  209a78:	2300      	movne	r3, #0
  209a7a:	b2db      	uxtb	r3, r3
  209a7c:	4940      	ldr	r1, [pc, #256]	@ (209b80 <rt_test_007_003_execute+0x1b0>)
  209a7e:	4618      	mov	r0, r3
  209a80:	f7fd fdee 	bl	207660 <__test_assert>
  209a84:	4603      	mov	r3, r0
  209a86:	2b00      	cmp	r3, #0
  209a88:	d174      	bne.n	209b74 <rt_test_007_003_execute+0x1a4>
    test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
  209a8a:	483c      	ldr	r0, [pc, #240]	@ (209b7c <rt_test_007_003_execute+0x1ac>)
  209a8c:	f7ff fd30 	bl	2094f0 <ch_queue_isempty.lto_priv.0>
  209a90:	4603      	mov	r3, r0
  209a92:	493c      	ldr	r1, [pc, #240]	@ (209b84 <rt_test_007_003_execute+0x1b4>)
  209a94:	4618      	mov	r0, r3
  209a96:	f7fd fde3 	bl	207660 <__test_assert>
  209a9a:	4603      	mov	r3, r0
  209a9c:	2b00      	cmp	r3, #0
  209a9e:	d169      	bne.n	209b74 <rt_test_007_003_execute+0x1a4>
    test_assert(sem1.cnt == 0, "counter not zero");
  209aa0:	4b36      	ldr	r3, [pc, #216]	@ (209b7c <rt_test_007_003_execute+0x1ac>)
  209aa2:	689b      	ldr	r3, [r3, #8]
  209aa4:	2b00      	cmp	r3, #0
  209aa6:	bf0c      	ite	eq
  209aa8:	2301      	moveq	r3, #1
  209aaa:	2300      	movne	r3, #0
  209aac:	b2db      	uxtb	r3, r3
  209aae:	4936      	ldr	r1, [pc, #216]	@ (209b88 <rt_test_007_003_execute+0x1b8>)
  209ab0:	4618      	mov	r0, r3
  209ab2:	f7fd fdd5 	bl	207660 <__test_assert>
  209ab6:	4603      	mov	r3, r0
  209ab8:	2b00      	cmp	r3, #0
  209aba:	d15b      	bne.n	209b74 <rt_test_007_003_execute+0x1a4>
  }
  test_end_step(2);

  /* [7.3.3] Testing timeout condition.*/
  test_set_step(3);
  209abc:	4b2e      	ldr	r3, [pc, #184]	@ (209b78 <rt_test_007_003_execute+0x1a8>)
  209abe:	2203      	movs	r2, #3
  209ac0:	601a      	str	r2, [r3, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
  209ac2:	f7fe f9c5 	bl	207e50 <test_wait_tick>
  209ac6:	4603      	mov	r3, r0
  209ac8:	f640 11c4 	movw	r1, #2500	@ 0x9c4
  209acc:	4618      	mov	r0, r3
  209ace:	f7ff fcff 	bl	2094d0 <chTimeAddX.lto_priv.4>
  209ad2:	9003      	str	r0, [sp, #12]
    for (i = 0; i < 5; i++) {
  209ad4:	2300      	movs	r3, #0
  209ad6:	9305      	str	r3, [sp, #20]
  209ad8:	e036      	b.n	209b48 <rt_test_007_003_execute+0x178>
      test_emit_token('A' + i);
  209ada:	9b05      	ldr	r3, [sp, #20]
  209adc:	b2db      	uxtb	r3, r3
  209ade:	3341      	adds	r3, #65	@ 0x41
  209ae0:	b2db      	uxtb	r3, r3
  209ae2:	4618      	mov	r0, r3
  209ae4:	f7fd fe1c 	bl	207720 <test_emit_token>
      msg = chSemWaitTimeout(&sem1, TIME_MS2I(50));
  209ae8:	f44f 71fa 	mov.w	r1, #500	@ 0x1f4
  209aec:	4823      	ldr	r0, [pc, #140]	@ (209b7c <rt_test_007_003_execute+0x1ac>)
  209aee:	f7fa f817 	bl	203b20 <chSemWaitTimeout>
  209af2:	9004      	str	r0, [sp, #16]
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
  209af4:	9b04      	ldr	r3, [sp, #16]
  209af6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  209afa:	bf0c      	ite	eq
  209afc:	2301      	moveq	r3, #1
  209afe:	2300      	movne	r3, #0
  209b00:	b2db      	uxtb	r3, r3
  209b02:	491f      	ldr	r1, [pc, #124]	@ (209b80 <rt_test_007_003_execute+0x1b0>)
  209b04:	4618      	mov	r0, r3
  209b06:	f7fd fdab 	bl	207660 <__test_assert>
  209b0a:	4603      	mov	r3, r0
  209b0c:	2b00      	cmp	r3, #0
  209b0e:	d131      	bne.n	209b74 <rt_test_007_003_execute+0x1a4>
      test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
  209b10:	481a      	ldr	r0, [pc, #104]	@ (209b7c <rt_test_007_003_execute+0x1ac>)
  209b12:	f7ff fced 	bl	2094f0 <ch_queue_isempty.lto_priv.0>
  209b16:	4603      	mov	r3, r0
  209b18:	491a      	ldr	r1, [pc, #104]	@ (209b84 <rt_test_007_003_execute+0x1b4>)
  209b1a:	4618      	mov	r0, r3
  209b1c:	f7fd fda0 	bl	207660 <__test_assert>
  209b20:	4603      	mov	r3, r0
  209b22:	2b00      	cmp	r3, #0
  209b24:	d126      	bne.n	209b74 <rt_test_007_003_execute+0x1a4>
      test_assert(sem1.cnt == 0, "counter not zero");
  209b26:	4b15      	ldr	r3, [pc, #84]	@ (209b7c <rt_test_007_003_execute+0x1ac>)
  209b28:	689b      	ldr	r3, [r3, #8]
  209b2a:	2b00      	cmp	r3, #0
  209b2c:	bf0c      	ite	eq
  209b2e:	2301      	moveq	r3, #1
  209b30:	2300      	movne	r3, #0
  209b32:	b2db      	uxtb	r3, r3
  209b34:	4914      	ldr	r1, [pc, #80]	@ (209b88 <rt_test_007_003_execute+0x1b8>)
  209b36:	4618      	mov	r0, r3
  209b38:	f7fd fd92 	bl	207660 <__test_assert>
  209b3c:	4603      	mov	r3, r0
  209b3e:	2b00      	cmp	r3, #0
  209b40:	d118      	bne.n	209b74 <rt_test_007_003_execute+0x1a4>
    for (i = 0; i < 5; i++) {
  209b42:	9b05      	ldr	r3, [sp, #20]
  209b44:	3301      	adds	r3, #1
  209b46:	9305      	str	r3, [sp, #20]
  209b48:	9b05      	ldr	r3, [sp, #20]
  209b4a:	2b04      	cmp	r3, #4
  209b4c:	d9c5      	bls.n	209ada <rt_test_007_003_execute+0x10a>
    }
    test_assert_sequence("ABCDE", "invalid sequence");
  209b4e:	4912      	ldr	r1, [pc, #72]	@ (209b98 <rt_test_007_003_execute+0x1c8>)
  209b50:	4812      	ldr	r0, [pc, #72]	@ (209b9c <rt_test_007_003_execute+0x1cc>)
  209b52:	f7fd fd9d 	bl	207690 <__test_assert_sequence>
  209b56:	4603      	mov	r3, r0
  209b58:	2b00      	cmp	r3, #0
  209b5a:	d10b      	bne.n	209b74 <rt_test_007_003_execute+0x1a4>
    test_assert_time_window(target_time,
  209b5c:	2114      	movs	r1, #20
  209b5e:	9803      	ldr	r0, [sp, #12]
  209b60:	f7ff fcb6 	bl	2094d0 <chTimeAddX.lto_priv.4>
  209b64:	4603      	mov	r3, r0
  209b66:	4a0e      	ldr	r2, [pc, #56]	@ (209ba0 <rt_test_007_003_execute+0x1d0>)
  209b68:	4619      	mov	r1, r3
  209b6a:	9803      	ldr	r0, [sp, #12]
  209b6c:	f7fd fdc0 	bl	2076f0 <__test_assert_time_window>
  209b70:	4603      	mov	r3, r0
  209b72:	2b00      	cmp	r3, #0
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
  }
  test_end_step(3);
}
  209b74:	b006      	add	sp, #24
  209b76:	bd10      	pop	{r4, pc}
  209b78:	20000bb4 	.word	0x20000bb4
  209b7c:	20001918 	.word	0x20001918
  209b80:	080117d0 	.word	0x080117d0
  209b84:	080117e8 	.word	0x080117e8
  209b88:	080117f8 	.word	0x080117f8
  209b8c:	08012220 	.word	0x08012220
  209b90:	002096d1 	.word	0x002096d1
  209b94:	20001900 	.word	0x20001900
  209b98:	080116f4 	.word	0x080116f4
  209b9c:	08011708 	.word	0x08011708
  209ba0:	080116d0 	.word	0x080116d0
	...

00209bb0 <rt_test_007_004_setup>:
 * - [7.4.2] The semaphore counter is increased by two, it is then
 *   tested to be one, the thread must have completed.
 * .
 */

static void rt_test_007_004_setup(void) {
  209bb0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
  209bb2:	2100      	movs	r1, #0
  209bb4:	4802      	ldr	r0, [pc, #8]	@ (209bc0 <rt_test_007_004_setup+0x10>)
  209bb6:	f7f9 ff33 	bl	203a20 <chSemObjectInit>
}
  209bba:	bf00      	nop
  209bbc:	bd08      	pop	{r3, pc}
  209bbe:	bf00      	nop
  209bc0:	20001918 	.word	0x20001918
	...

00209bd0 <rt_test_007_004_execute>:

static void rt_test_007_004_execute(void) {
  209bd0:	b510      	push	{r4, lr}
  209bd2:	b082      	sub	sp, #8

  /* [7.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
  209bd4:	4b20      	ldr	r3, [pc, #128]	@ (209c58 <rt_test_007_004_execute+0x88>)
  209bd6:	2201      	movs	r2, #1
  209bd8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
  209bda:	4b20      	ldr	r3, [pc, #128]	@ (209c5c <rt_test_007_004_execute+0x8c>)
  209bdc:	681c      	ldr	r4, [r3, #0]
  209bde:	f7ff fcbf 	bl	209560 <chThdGetPriorityX.lto_priv.2>
  209be2:	4603      	mov	r3, r0
  209be4:	1c5a      	adds	r2, r3, #1
  209be6:	4b1e      	ldr	r3, [pc, #120]	@ (209c60 <rt_test_007_004_execute+0x90>)
  209be8:	9300      	str	r3, [sp, #0]
  209bea:	4b1e      	ldr	r3, [pc, #120]	@ (209c64 <rt_test_007_004_execute+0x94>)
  209bec:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  209bf0:	4620      	mov	r0, r4
  209bf2:	f7f9 fbc5 	bl	203380 <chThdCreateStatic>
  209bf6:	4603      	mov	r3, r0
  209bf8:	4a1b      	ldr	r2, [pc, #108]	@ (209c68 <rt_test_007_004_execute+0x98>)
  209bfa:	6013      	str	r3, [r2, #0]
  }
  test_end_step(1);

  /* [7.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
  209bfc:	4b16      	ldr	r3, [pc, #88]	@ (209c58 <rt_test_007_004_execute+0x88>)
  209bfe:	2202      	movs	r2, #2
  209c00:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  209c02:	f7ff fc85 	bl	209510 <chSysLock.lto_priv.23>
    chSemAddCounterI(&sem1, 2);
  209c06:	2102      	movs	r1, #2
  209c08:	4818      	ldr	r0, [pc, #96]	@ (209c6c <rt_test_007_004_execute+0x9c>)
  209c0a:	f7fa f819 	bl	203c40 <chSemAddCounterI>
    chSchRescheduleS();
  209c0e:	f7f9 f82f 	bl	202c70 <chSchRescheduleS>
    chSysUnlock();
  209c12:	f7ff fc8d 	bl	209530 <chSysUnlock.lto_priv.23>
    test_wait_threads();
  209c16:	f7fe f8f3 	bl	207e00 <test_wait_threads>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
  209c1a:	f7ff fd31 	bl	209680 <osalSysLock.lto_priv.3>
  209c1e:	4813      	ldr	r0, [pc, #76]	@ (209c6c <rt_test_007_004_execute+0x9c>)
  209c20:	f7ff fcb6 	bl	209590 <chSemGetCounterI.lto_priv.1>
  209c24:	4603      	mov	r3, r0
  209c26:	2b01      	cmp	r3, #1
  209c28:	bf0c      	ite	eq
  209c2a:	2301      	moveq	r3, #1
  209c2c:	2300      	movne	r3, #0
  209c2e:	b2db      	uxtb	r3, r3
  209c30:	490f      	ldr	r1, [pc, #60]	@ (209c70 <rt_test_007_004_execute+0xa0>)
  209c32:	4618      	mov	r0, r3
  209c34:	f7fd fd14 	bl	207660 <__test_assert>
  209c38:	4603      	mov	r3, r0
  209c3a:	2b00      	cmp	r3, #0
  209c3c:	d002      	beq.n	209c44 <rt_test_007_004_execute+0x74>
  209c3e:	f7ff fd27 	bl	209690 <osalSysUnlock.lto_priv.3>
  209c42:	e007      	b.n	209c54 <rt_test_007_004_execute+0x84>
  209c44:	f7ff fd24 	bl	209690 <osalSysUnlock.lto_priv.3>
    test_assert_sequence("A", "invalid sequence");
  209c48:	490a      	ldr	r1, [pc, #40]	@ (209c74 <rt_test_007_004_execute+0xa4>)
  209c4a:	4805      	ldr	r0, [pc, #20]	@ (209c60 <rt_test_007_004_execute+0x90>)
  209c4c:	f7fd fd20 	bl	207690 <__test_assert_sequence>
  209c50:	4603      	mov	r3, r0
  209c52:	2b00      	cmp	r3, #0
  }
  test_end_step(2);
}
  209c54:	b002      	add	sp, #8
  209c56:	bd10      	pop	{r4, pc}
  209c58:	20000bb4 	.word	0x20000bb4
  209c5c:	08012220 	.word	0x08012220
  209c60:	080116f0 	.word	0x080116f0
  209c64:	002096a1 	.word	0x002096a1
  209c68:	20001900 	.word	0x20001900
  209c6c:	20001918 	.word	0x20001918
  209c70:	0801180c 	.word	0x0801180c
  209c74:	080116f4 	.word	0x080116f4
	...

00209c80 <rt_test_007_005_setup>:
 *   specifying the same semaphore for the wait and signal phases. The
 *   counter value must be one on exit.
 * .
 */

static void rt_test_007_005_setup(void) {
  209c80:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
  209c82:	2100      	movs	r1, #0
  209c84:	4802      	ldr	r0, [pc, #8]	@ (209c90 <rt_test_007_005_setup+0x10>)
  209c86:	f7f9 fecb 	bl	203a20 <chSemObjectInit>
}
  209c8a:	bf00      	nop
  209c8c:	bd08      	pop	{r3, pc}
  209c8e:	bf00      	nop
  209c90:	20001918 	.word	0x20001918
	...

00209ca0 <rt_test_007_005_teardown>:

static void rt_test_007_005_teardown(void) {
  209ca0:	b508      	push	{r3, lr}
  test_wait_threads();
  209ca2:	f7fe f8ad 	bl	207e00 <test_wait_threads>
}
  209ca6:	bf00      	nop
  209ca8:	bd08      	pop	{r3, pc}
  209caa:	bf00      	nop
  209cac:	0000      	movs	r0, r0
	...

00209cb0 <rt_test_007_005_execute>:

static void rt_test_007_005_execute(void) {
  209cb0:	b510      	push	{r4, lr}
  209cb2:	b082      	sub	sp, #8

  /* [7.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
  209cb4:	4b2a      	ldr	r3, [pc, #168]	@ (209d60 <rt_test_007_005_execute+0xb0>)
  209cb6:	2201      	movs	r2, #1
  209cb8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  209cba:	4b2a      	ldr	r3, [pc, #168]	@ (209d64 <rt_test_007_005_execute+0xb4>)
  209cbc:	681c      	ldr	r4, [r3, #0]
  209cbe:	f7ff fc4f 	bl	209560 <chThdGetPriorityX.lto_priv.2>
  209cc2:	4603      	mov	r3, r0
  209cc4:	1c5a      	adds	r2, r3, #1
  209cc6:	2300      	movs	r3, #0
  209cc8:	9300      	str	r3, [sp, #0]
  209cca:	4b27      	ldr	r3, [pc, #156]	@ (209d68 <rt_test_007_005_execute+0xb8>)
  209ccc:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  209cd0:	4620      	mov	r0, r4
  209cd2:	f7f9 fb55 	bl	203380 <chThdCreateStatic>
  209cd6:	4603      	mov	r3, r0
  209cd8:	4a24      	ldr	r2, [pc, #144]	@ (209d6c <rt_test_007_005_execute+0xbc>)
  209cda:	6013      	str	r3, [r2, #0]
  test_end_step(1);

  /* [7.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
  209cdc:	4b20      	ldr	r3, [pc, #128]	@ (209d60 <rt_test_007_005_execute+0xb0>)
  209cde:	2202      	movs	r2, #2
  209ce0:	601a      	str	r2, [r3, #0]
  {
    chSemSignalWait(&sem1, &sem1);
  209ce2:	4923      	ldr	r1, [pc, #140]	@ (209d70 <rt_test_007_005_execute+0xc0>)
  209ce4:	4822      	ldr	r0, [pc, #136]	@ (209d70 <rt_test_007_005_execute+0xc0>)
  209ce6:	f7f9 ffd3 	bl	203c90 <chSemSignalWait>
    test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
  209cea:	4821      	ldr	r0, [pc, #132]	@ (209d70 <rt_test_007_005_execute+0xc0>)
  209cec:	f7ff fc00 	bl	2094f0 <ch_queue_isempty.lto_priv.0>
  209cf0:	4603      	mov	r3, r0
  209cf2:	4920      	ldr	r1, [pc, #128]	@ (209d74 <rt_test_007_005_execute+0xc4>)
  209cf4:	4618      	mov	r0, r3
  209cf6:	f7fd fcb3 	bl	207660 <__test_assert>
  209cfa:	4603      	mov	r3, r0
  209cfc:	2b00      	cmp	r3, #0
  209cfe:	d12c      	bne.n	209d5a <rt_test_007_005_execute+0xaa>
    test_assert(sem1.cnt == 0, "counter not zero");
  209d00:	4b1b      	ldr	r3, [pc, #108]	@ (209d70 <rt_test_007_005_execute+0xc0>)
  209d02:	689b      	ldr	r3, [r3, #8]
  209d04:	2b00      	cmp	r3, #0
  209d06:	bf0c      	ite	eq
  209d08:	2301      	moveq	r3, #1
  209d0a:	2300      	movne	r3, #0
  209d0c:	b2db      	uxtb	r3, r3
  209d0e:	491a      	ldr	r1, [pc, #104]	@ (209d78 <rt_test_007_005_execute+0xc8>)
  209d10:	4618      	mov	r0, r3
  209d12:	f7fd fca5 	bl	207660 <__test_assert>
  209d16:	4603      	mov	r3, r0
  209d18:	2b00      	cmp	r3, #0
  209d1a:	d11e      	bne.n	209d5a <rt_test_007_005_execute+0xaa>
  test_end_step(2);

  /* [7.5.3] The function chSemSignalWait() is invoked again by
     specifying the same semaphore for the wait and signal phases. The
     counter value must be one on exit.*/
  test_set_step(3);
  209d1c:	4b10      	ldr	r3, [pc, #64]	@ (209d60 <rt_test_007_005_execute+0xb0>)
  209d1e:	2203      	movs	r2, #3
  209d20:	601a      	str	r2, [r3, #0]
  {
    chSemSignalWait(&sem1, &sem1);
  209d22:	4913      	ldr	r1, [pc, #76]	@ (209d70 <rt_test_007_005_execute+0xc0>)
  209d24:	4812      	ldr	r0, [pc, #72]	@ (209d70 <rt_test_007_005_execute+0xc0>)
  209d26:	f7f9 ffb3 	bl	203c90 <chSemSignalWait>
    test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
  209d2a:	4811      	ldr	r0, [pc, #68]	@ (209d70 <rt_test_007_005_execute+0xc0>)
  209d2c:	f7ff fbe0 	bl	2094f0 <ch_queue_isempty.lto_priv.0>
  209d30:	4603      	mov	r3, r0
  209d32:	4910      	ldr	r1, [pc, #64]	@ (209d74 <rt_test_007_005_execute+0xc4>)
  209d34:	4618      	mov	r0, r3
  209d36:	f7fd fc93 	bl	207660 <__test_assert>
  209d3a:	4603      	mov	r3, r0
  209d3c:	2b00      	cmp	r3, #0
  209d3e:	d10c      	bne.n	209d5a <rt_test_007_005_execute+0xaa>
    test_assert(sem1.cnt == 0, "counter not zero");
  209d40:	4b0b      	ldr	r3, [pc, #44]	@ (209d70 <rt_test_007_005_execute+0xc0>)
  209d42:	689b      	ldr	r3, [r3, #8]
  209d44:	2b00      	cmp	r3, #0
  209d46:	bf0c      	ite	eq
  209d48:	2301      	moveq	r3, #1
  209d4a:	2300      	movne	r3, #0
  209d4c:	b2db      	uxtb	r3, r3
  209d4e:	490a      	ldr	r1, [pc, #40]	@ (209d78 <rt_test_007_005_execute+0xc8>)
  209d50:	4618      	mov	r0, r3
  209d52:	f7fd fc85 	bl	207660 <__test_assert>
  209d56:	4603      	mov	r3, r0
  209d58:	2b00      	cmp	r3, #0
  }
  test_end_step(3);
}
  209d5a:	b002      	add	sp, #8
  209d5c:	bd10      	pop	{r4, pc}
  209d5e:	bf00      	nop
  209d60:	20000bb4 	.word	0x20000bb4
  209d64:	08012220 	.word	0x08012220
  209d68:	00209701 	.word	0x00209701
  209d6c:	20001900 	.word	0x20001900
  209d70:	20001918 	.word	0x20001918
  209d74:	080117e8 	.word	0x080117e8
  209d78:	080117f8 	.word	0x080117f8
  209d7c:	00000000 	.word	0x00000000

00209d80 <rt_test_007_006_teardown>:
 * - [7.6.6] Signaling the binary semaphore again, the internal state
 *   must not change from "not taken".
 * .
 */

static void rt_test_007_006_teardown(void) {
  209d80:	b508      	push	{r3, lr}
  test_wait_threads();
  209d82:	f7fe f83d 	bl	207e00 <test_wait_threads>
}
  209d86:	bf00      	nop
  209d88:	bd08      	pop	{r3, pc}
  209d8a:	bf00      	nop
  209d8c:	0000      	movs	r0, r0
	...

00209d90 <rt_test_007_006_execute>:

static void rt_test_007_006_execute(void) {
  209d90:	b510      	push	{r4, lr}
  209d92:	b086      	sub	sp, #24
  binary_semaphore_t bsem;
  msg_t msg;

  /* [7.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
  209d94:	4b76      	ldr	r3, [pc, #472]	@ (209f70 <rt_test_007_006_execute+0x1e0>)
  209d96:	2201      	movs	r2, #1
  209d98:	601a      	str	r2, [r3, #0]
  {
    chBSemObjectInit(&bsem, true);
  209d9a:	ab02      	add	r3, sp, #8
  209d9c:	2101      	movs	r1, #1
  209d9e:	4618      	mov	r0, r3
  209da0:	f7ff fbfe 	bl	2095a0 <chBSemObjectInit>
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  209da4:	f7ff fc6c 	bl	209680 <osalSysLock.lto_priv.3>
  209da8:	ab02      	add	r3, sp, #8
  209daa:	4618      	mov	r0, r3
  209dac:	f7ff fc58 	bl	209660 <chBSemGetStateI>
  209db0:	4603      	mov	r3, r0
  209db2:	4970      	ldr	r1, [pc, #448]	@ (209f74 <rt_test_007_006_execute+0x1e4>)
  209db4:	4618      	mov	r0, r3
  209db6:	f7fd fc53 	bl	207660 <__test_assert>
  209dba:	4603      	mov	r3, r0
  209dbc:	2b00      	cmp	r3, #0
  209dbe:	d002      	beq.n	209dc6 <rt_test_007_006_execute+0x36>
  209dc0:	f7ff fc66 	bl	209690 <osalSysUnlock.lto_priv.3>
  209dc4:	e0d2      	b.n	209f6c <rt_test_007_006_execute+0x1dc>
  209dc6:	f7ff fc63 	bl	209690 <osalSysUnlock.lto_priv.3>
  }
  test_end_step(1);

  /* [7.6.2] Resetting the binary semaphore in "taken" state, the state
     must not change.*/
  test_set_step(2);
  209dca:	4b69      	ldr	r3, [pc, #420]	@ (209f70 <rt_test_007_006_execute+0x1e0>)
  209dcc:	2202      	movs	r2, #2
  209dce:	601a      	str	r2, [r3, #0]
  {
    chBSemReset(&bsem, true);
  209dd0:	ab02      	add	r3, sp, #8
  209dd2:	2101      	movs	r1, #1
  209dd4:	4618      	mov	r0, r3
  209dd6:	f7ff fc0b 	bl	2095f0 <chBSemReset>
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  209dda:	f7ff fc51 	bl	209680 <osalSysLock.lto_priv.3>
  209dde:	ab02      	add	r3, sp, #8
  209de0:	4618      	mov	r0, r3
  209de2:	f7ff fc3d 	bl	209660 <chBSemGetStateI>
  209de6:	4603      	mov	r3, r0
  209de8:	4962      	ldr	r1, [pc, #392]	@ (209f74 <rt_test_007_006_execute+0x1e4>)
  209dea:	4618      	mov	r0, r3
  209dec:	f7fd fc38 	bl	207660 <__test_assert>
  209df0:	4603      	mov	r3, r0
  209df2:	2b00      	cmp	r3, #0
  209df4:	d002      	beq.n	209dfc <rt_test_007_006_execute+0x6c>
  209df6:	f7ff fc4b 	bl	209690 <osalSysUnlock.lto_priv.3>
  209dfa:	e0b7      	b.n	209f6c <rt_test_007_006_execute+0x1dc>
  209dfc:	f7ff fc48 	bl	209690 <osalSysUnlock.lto_priv.3>
  }
  test_end_step(2);

  /* [7.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
  209e00:	4b5b      	ldr	r3, [pc, #364]	@ (209f70 <rt_test_007_006_execute+0x1e0>)
  209e02:	2203      	movs	r2, #3
  209e04:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
  209e06:	4b5c      	ldr	r3, [pc, #368]	@ (209f78 <rt_test_007_006_execute+0x1e8>)
  209e08:	681c      	ldr	r4, [r3, #0]
                                   chThdGetPriorityX()-1, thread4, &bsem);
  209e0a:	f7ff fba9 	bl	209560 <chThdGetPriorityX.lto_priv.2>
  209e0e:	4603      	mov	r3, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
  209e10:	1e5a      	subs	r2, r3, #1
  209e12:	ab02      	add	r3, sp, #8
  209e14:	9300      	str	r3, [sp, #0]
  209e16:	4b59      	ldr	r3, [pc, #356]	@ (209f7c <rt_test_007_006_execute+0x1ec>)
  209e18:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  209e1c:	4620      	mov	r0, r4
  209e1e:	f7f9 faaf 	bl	203380 <chThdCreateStatic>
  209e22:	4603      	mov	r3, r0
  209e24:	4a56      	ldr	r2, [pc, #344]	@ (209f80 <rt_test_007_006_execute+0x1f0>)
  209e26:	6013      	str	r3, [r2, #0]
  }
  test_end_step(3);

  /* [7.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
  209e28:	4b51      	ldr	r3, [pc, #324]	@ (209f70 <rt_test_007_006_execute+0x1e0>)
  209e2a:	2204      	movs	r2, #4
  209e2c:	601a      	str	r2, [r3, #0]
  {
    msg = chBSemWait(&bsem);
  209e2e:	ab02      	add	r3, sp, #8
  209e30:	4618      	mov	r0, r3
  209e32:	f7ff fbcd 	bl	2095d0 <chBSemWait>
  209e36:	9005      	str	r0, [sp, #20]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  209e38:	f7ff fc22 	bl	209680 <osalSysLock.lto_priv.3>
  209e3c:	ab02      	add	r3, sp, #8
  209e3e:	4618      	mov	r0, r3
  209e40:	f7ff fc0e 	bl	209660 <chBSemGetStateI>
  209e44:	4603      	mov	r3, r0
  209e46:	494b      	ldr	r1, [pc, #300]	@ (209f74 <rt_test_007_006_execute+0x1e4>)
  209e48:	4618      	mov	r0, r3
  209e4a:	f7fd fc09 	bl	207660 <__test_assert>
  209e4e:	4603      	mov	r3, r0
  209e50:	2b00      	cmp	r3, #0
  209e52:	d002      	beq.n	209e5a <rt_test_007_006_execute+0xca>
  209e54:	f7ff fc1c 	bl	209690 <osalSysUnlock.lto_priv.3>
  209e58:	e088      	b.n	209f6c <rt_test_007_006_execute+0x1dc>
  209e5a:	f7ff fc19 	bl	209690 <osalSysUnlock.lto_priv.3>
    test_assert(msg == MSG_OK, "unexpected message");
  209e5e:	9b05      	ldr	r3, [sp, #20]
  209e60:	2b00      	cmp	r3, #0
  209e62:	bf0c      	ite	eq
  209e64:	2301      	moveq	r3, #1
  209e66:	2300      	movne	r3, #0
  209e68:	b2db      	uxtb	r3, r3
  209e6a:	4946      	ldr	r1, [pc, #280]	@ (209f84 <rt_test_007_006_execute+0x1f4>)
  209e6c:	4618      	mov	r0, r3
  209e6e:	f7fd fbf7 	bl	207660 <__test_assert>
  209e72:	4603      	mov	r3, r0
  209e74:	2b00      	cmp	r3, #0
  209e76:	d179      	bne.n	209f6c <rt_test_007_006_execute+0x1dc>
  test_end_step(4);

  /* [7.6.5] Signaling the binary semaphore, checking the binary
     semaphore state to be "not taken" and the underlying counter
     semaphore counter to be one.*/
  test_set_step(5);
  209e78:	4b3d      	ldr	r3, [pc, #244]	@ (209f70 <rt_test_007_006_execute+0x1e0>)
  209e7a:	2205      	movs	r2, #5
  209e7c:	601a      	str	r2, [r3, #0]
  {
    chBSemSignal(&bsem);
  209e7e:	ab02      	add	r3, sp, #8
  209e80:	4618      	mov	r0, r3
  209e82:	f7ff fbdd 	bl	209640 <chBSemSignal>
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
  209e86:	f7ff fbfb 	bl	209680 <osalSysLock.lto_priv.3>
  209e8a:	ab02      	add	r3, sp, #8
  209e8c:	4618      	mov	r0, r3
  209e8e:	f7ff fbe7 	bl	209660 <chBSemGetStateI>
  209e92:	4603      	mov	r3, r0
  209e94:	2b00      	cmp	r3, #0
  209e96:	bf14      	ite	ne
  209e98:	2301      	movne	r3, #1
  209e9a:	2300      	moveq	r3, #0
  209e9c:	b2db      	uxtb	r3, r3
  209e9e:	f083 0301 	eor.w	r3, r3, #1
  209ea2:	b2db      	uxtb	r3, r3
  209ea4:	f003 0301 	and.w	r3, r3, #1
  209ea8:	b2db      	uxtb	r3, r3
  209eaa:	4937      	ldr	r1, [pc, #220]	@ (209f88 <rt_test_007_006_execute+0x1f8>)
  209eac:	4618      	mov	r0, r3
  209eae:	f7fd fbd7 	bl	207660 <__test_assert>
  209eb2:	4603      	mov	r3, r0
  209eb4:	2b00      	cmp	r3, #0
  209eb6:	d002      	beq.n	209ebe <rt_test_007_006_execute+0x12e>
  209eb8:	f7ff fbea 	bl	209690 <osalSysUnlock.lto_priv.3>
  209ebc:	e056      	b.n	209f6c <rt_test_007_006_execute+0x1dc>
  209ebe:	f7ff fbe7 	bl	209690 <osalSysUnlock.lto_priv.3>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  209ec2:	f7ff fbdd 	bl	209680 <osalSysLock.lto_priv.3>
  209ec6:	ab02      	add	r3, sp, #8
  209ec8:	4618      	mov	r0, r3
  209eca:	f7ff fb61 	bl	209590 <chSemGetCounterI.lto_priv.1>
  209ece:	4603      	mov	r3, r0
  209ed0:	2b01      	cmp	r3, #1
  209ed2:	bf0c      	ite	eq
  209ed4:	2301      	moveq	r3, #1
  209ed6:	2300      	movne	r3, #0
  209ed8:	b2db      	uxtb	r3, r3
  209eda:	492c      	ldr	r1, [pc, #176]	@ (209f8c <rt_test_007_006_execute+0x1fc>)
  209edc:	4618      	mov	r0, r3
  209ede:	f7fd fbbf 	bl	207660 <__test_assert>
  209ee2:	4603      	mov	r3, r0
  209ee4:	2b00      	cmp	r3, #0
  209ee6:	d002      	beq.n	209eee <rt_test_007_006_execute+0x15e>
  209ee8:	f7ff fbd2 	bl	209690 <osalSysUnlock.lto_priv.3>
  209eec:	e03e      	b.n	209f6c <rt_test_007_006_execute+0x1dc>
  209eee:	f7ff fbcf 	bl	209690 <osalSysUnlock.lto_priv.3>
  }
  test_end_step(5);

  /* [7.6.6] Signaling the binary semaphore again, the internal state
     must not change from "not taken".*/
  test_set_step(6);
  209ef2:	4b1f      	ldr	r3, [pc, #124]	@ (209f70 <rt_test_007_006_execute+0x1e0>)
  209ef4:	2206      	movs	r2, #6
  209ef6:	601a      	str	r2, [r3, #0]
  {
    chBSemSignal(&bsem);
  209ef8:	ab02      	add	r3, sp, #8
  209efa:	4618      	mov	r0, r3
  209efc:	f7ff fba0 	bl	209640 <chBSemSignal>
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
  209f00:	f7ff fbbe 	bl	209680 <osalSysLock.lto_priv.3>
  209f04:	ab02      	add	r3, sp, #8
  209f06:	4618      	mov	r0, r3
  209f08:	f7ff fbaa 	bl	209660 <chBSemGetStateI>
  209f0c:	4603      	mov	r3, r0
  209f0e:	2b00      	cmp	r3, #0
  209f10:	bf14      	ite	ne
  209f12:	2301      	movne	r3, #1
  209f14:	2300      	moveq	r3, #0
  209f16:	b2db      	uxtb	r3, r3
  209f18:	f083 0301 	eor.w	r3, r3, #1
  209f1c:	b2db      	uxtb	r3, r3
  209f1e:	f003 0301 	and.w	r3, r3, #1
  209f22:	b2db      	uxtb	r3, r3
  209f24:	491a      	ldr	r1, [pc, #104]	@ (209f90 <rt_test_007_006_execute+0x200>)
  209f26:	4618      	mov	r0, r3
  209f28:	f7fd fb9a 	bl	207660 <__test_assert>
  209f2c:	4603      	mov	r3, r0
  209f2e:	2b00      	cmp	r3, #0
  209f30:	d002      	beq.n	209f38 <rt_test_007_006_execute+0x1a8>
  209f32:	f7ff fbad 	bl	209690 <osalSysUnlock.lto_priv.3>
  209f36:	e019      	b.n	209f6c <rt_test_007_006_execute+0x1dc>
  209f38:	f7ff fbaa 	bl	209690 <osalSysUnlock.lto_priv.3>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  209f3c:	f7ff fba0 	bl	209680 <osalSysLock.lto_priv.3>
  209f40:	ab02      	add	r3, sp, #8
  209f42:	4618      	mov	r0, r3
  209f44:	f7ff fb24 	bl	209590 <chSemGetCounterI.lto_priv.1>
  209f48:	4603      	mov	r3, r0
  209f4a:	2b01      	cmp	r3, #1
  209f4c:	bf0c      	ite	eq
  209f4e:	2301      	moveq	r3, #1
  209f50:	2300      	movne	r3, #0
  209f52:	b2db      	uxtb	r3, r3
  209f54:	490d      	ldr	r1, [pc, #52]	@ (209f8c <rt_test_007_006_execute+0x1fc>)
  209f56:	4618      	mov	r0, r3
  209f58:	f7fd fb82 	bl	207660 <__test_assert>
  209f5c:	4603      	mov	r3, r0
  209f5e:	2b00      	cmp	r3, #0
  209f60:	d002      	beq.n	209f68 <rt_test_007_006_execute+0x1d8>
  209f62:	f7ff fb95 	bl	209690 <osalSysUnlock.lto_priv.3>
  209f66:	e001      	b.n	209f6c <rt_test_007_006_execute+0x1dc>
  209f68:	f7ff fb92 	bl	209690 <osalSysUnlock.lto_priv.3>
  }
  test_end_step(6);
}
  209f6c:	b006      	add	sp, #24
  209f6e:	bd10      	pop	{r4, pc}
  209f70:	20000bb4 	.word	0x20000bb4
  209f74:	0801181c 	.word	0x0801181c
  209f78:	08012220 	.word	0x08012220
  209f7c:	00209721 	.word	0x00209721
  209f80:	20001900 	.word	0x20001900
  209f84:	08011828 	.word	0x08011828
  209f88:	0801183c 	.word	0x0801183c
  209f8c:	08011848 	.word	0x08011848
  209f90:	08011820 	.word	0x08011820
	...

00209fa0 <ch_queue_isempty.lto_priv.1>:
static inline bool ch_queue_isempty(const ch_queue_t *qp) {
  209fa0:	b082      	sub	sp, #8
  209fa2:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next == qp);
  209fa4:	9b01      	ldr	r3, [sp, #4]
  209fa6:	681b      	ldr	r3, [r3, #0]
  209fa8:	9a01      	ldr	r2, [sp, #4]
  209faa:	429a      	cmp	r2, r3
  209fac:	bf0c      	ite	eq
  209fae:	2301      	moveq	r3, #1
  209fb0:	2300      	movne	r3, #0
  209fb2:	b2db      	uxtb	r3, r3
}
  209fb4:	4618      	mov	r0, r3
  209fb6:	b002      	add	sp, #8
  209fb8:	4770      	bx	lr
  209fba:	bf00      	nop
  209fbc:	0000      	movs	r0, r0
	...

00209fc0 <chSysLock.lto_priv.24>:
static inline void chSysLock(void) {
  209fc0:	b082      	sub	sp, #8
  209fc2:	2330      	movs	r3, #48	@ 0x30
  209fc4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  209fc6:	9b01      	ldr	r3, [sp, #4]
  209fc8:	f383 8811 	msr	BASEPRI, r3
}
  209fcc:	bf00      	nop
}
  209fce:	bf00      	nop
}
  209fd0:	bf00      	nop
  209fd2:	b002      	add	sp, #8
  209fd4:	4770      	bx	lr
  209fd6:	bf00      	nop
	...

00209fe0 <chSysUnlock.lto_priv.24>:
static inline void chSysUnlock(void) {
  209fe0:	b082      	sub	sp, #8
  209fe2:	2300      	movs	r3, #0
  209fe4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  209fe6:	9b01      	ldr	r3, [sp, #4]
  209fe8:	f383 8811 	msr	BASEPRI, r3
}
  209fec:	bf00      	nop
}
  209fee:	bf00      	nop
}
  209ff0:	bf00      	nop
  209ff2:	b002      	add	sp, #8
  209ff4:	4770      	bx	lr
  209ff6:	bf00      	nop
	...

0020a000 <chThdGetSelfX.lto_priv.9>:
  return __sch_get_currthread();
  20a000:	4b01      	ldr	r3, [pc, #4]	@ (20a008 <chThdGetSelfX.lto_priv.9+0x8>)
  20a002:	68db      	ldr	r3, [r3, #12]
}
  20a004:	4618      	mov	r0, r3
  20a006:	4770      	bx	lr
  20a008:	20000890 	.word	0x20000890
  20a00c:	00000000 	.word	0x00000000

0020a010 <chThdGetPriorityX.lto_priv.3>:
static inline tprio_t chThdGetPriorityX(void) {
  20a010:	b508      	push	{r3, lr}
  return chThdGetSelfX()->hdr.pqueue.prio;
  20a012:	f7ff fff5 	bl	20a000 <chThdGetSelfX.lto_priv.9>
  20a016:	4603      	mov	r3, r0
  20a018:	689b      	ldr	r3, [r3, #8]
}
  20a01a:	4618      	mov	r0, r3
  20a01c:	bd08      	pop	{r3, pc}
  20a01e:	bf00      	nop

0020a020 <thread1.lto_priv.2>:
  }
  while (chTimeIsInRangeX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
  20a020:	b500      	push	{lr}
  20a022:	b083      	sub	sp, #12
  20a024:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
  20a026:	4807      	ldr	r0, [pc, #28]	@ (20a044 <thread1.lto_priv.2+0x24>)
  20a028:	f7f9 ff32 	bl	203e90 <chMtxLock>
  test_emit_token(*(char *)p);
  20a02c:	9b01      	ldr	r3, [sp, #4]
  20a02e:	781b      	ldrb	r3, [r3, #0]
  20a030:	4618      	mov	r0, r3
  20a032:	f7fd fb75 	bl	207720 <test_emit_token>
  chMtxUnlock(&m1);
  20a036:	4803      	ldr	r0, [pc, #12]	@ (20a044 <thread1.lto_priv.2+0x24>)
  20a038:	f7f9 ffda 	bl	203ff0 <chMtxUnlock>
}
  20a03c:	bf00      	nop
  20a03e:	b003      	add	sp, #12
  20a040:	f85d fb04 	ldr.w	pc, [sp], #4
  20a044:	20020000 	.word	0x20020000
	...

0020a050 <thread4A>:
  chMtxUnlock(&m2);
  test_emit_token('A');
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {
  20a050:	b500      	push	{lr}
  20a052:	b083      	sub	sp, #12
  20a054:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
  20a056:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  20a05a:	f7f9 fac9 	bl	2035f0 <chThdSleep>
  chMtxLock(&m1);
  20a05e:	4805      	ldr	r0, [pc, #20]	@ (20a074 <thread4A+0x24>)
  20a060:	f7f9 ff16 	bl	203e90 <chMtxLock>
  chMtxUnlock(&m1);
  20a064:	4803      	ldr	r0, [pc, #12]	@ (20a074 <thread4A+0x24>)
  20a066:	f7f9 ffc3 	bl	203ff0 <chMtxUnlock>
}
  20a06a:	bf00      	nop
  20a06c:	b003      	add	sp, #12
  20a06e:	f85d fb04 	ldr.w	pc, [sp], #4
  20a072:	bf00      	nop
  20a074:	20020000 	.word	0x20020000
	...

0020a080 <thread4B>:

static THD_FUNCTION(thread4B, p) {
  20a080:	b500      	push	{lr}
  20a082:	b083      	sub	sp, #12
  20a084:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(150);
  20a086:	f240 50dc 	movw	r0, #1500	@ 0x5dc
  20a08a:	f7f9 fab1 	bl	2035f0 <chThdSleep>
  chSysLock();
  20a08e:	f7ff ff97 	bl	209fc0 <chSysLock.lto_priv.24>
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
  20a092:	4807      	ldr	r0, [pc, #28]	@ (20a0b0 <thread4B+0x30>)
  20a094:	f7f9 ff0c 	bl	203eb0 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
  20a098:	4805      	ldr	r0, [pc, #20]	@ (20a0b0 <thread4B+0x30>)
  20a09a:	f7f9 fff9 	bl	204090 <chMtxUnlockS>
  chSchRescheduleS();
  20a09e:	f7f8 fde7 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  20a0a2:	f7ff ff9d 	bl	209fe0 <chSysUnlock.lto_priv.24>
}
  20a0a6:	bf00      	nop
  20a0a8:	b003      	add	sp, #12
  20a0aa:	f85d fb04 	ldr.w	pc, [sp], #4
  20a0ae:	bf00      	nop
  20a0b0:	20020010 	.word	0x20020010
	...

0020a0c0 <thread6>:

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
  20a0c0:	b500      	push	{lr}
  20a0c2:	b083      	sub	sp, #12
  20a0c4:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
  20a0c6:	4809      	ldr	r0, [pc, #36]	@ (20a0ec <thread6+0x2c>)
  20a0c8:	f7f9 fee2 	bl	203e90 <chMtxLock>
  chCondWait(&c1);
  20a0cc:	4808      	ldr	r0, [pc, #32]	@ (20a0f0 <thread6+0x30>)
  20a0ce:	f7fa f98f 	bl	2043f0 <chCondWait>
  test_emit_token(*(char *)p);
  20a0d2:	9b01      	ldr	r3, [sp, #4]
  20a0d4:	781b      	ldrb	r3, [r3, #0]
  20a0d6:	4618      	mov	r0, r3
  20a0d8:	f7fd fb22 	bl	207720 <test_emit_token>
  chMtxUnlock(&m1);
  20a0dc:	4803      	ldr	r0, [pc, #12]	@ (20a0ec <thread6+0x2c>)
  20a0de:	f7f9 ff87 	bl	203ff0 <chMtxUnlock>
}
  20a0e2:	bf00      	nop
  20a0e4:	b003      	add	sp, #12
  20a0e6:	f85d fb04 	ldr.w	pc, [sp], #4
  20a0ea:	bf00      	nop
  20a0ec:	20020000 	.word	0x20020000
  20a0f0:	20020020 	.word	0x20020020
	...

0020a100 <thread8>:

static THD_FUNCTION(thread8, p) {
  20a100:	b500      	push	{lr}
  20a102:	b083      	sub	sp, #12
  20a104:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
  20a106:	480d      	ldr	r0, [pc, #52]	@ (20a13c <thread8+0x3c>)
  20a108:	f7f9 fec2 	bl	203e90 <chMtxLock>
  chMtxLock(&m1);
  20a10c:	480c      	ldr	r0, [pc, #48]	@ (20a140 <thread8+0x40>)
  20a10e:	f7f9 febf 	bl	203e90 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
  20a112:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
  20a116:	480b      	ldr	r0, [pc, #44]	@ (20a144 <thread8+0x44>)
  20a118:	f7fa f9a2 	bl	204460 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
  20a11c:	9b01      	ldr	r3, [sp, #4]
  20a11e:	781b      	ldrb	r3, [r3, #0]
  20a120:	4618      	mov	r0, r3
  20a122:	f7fd fafd 	bl	207720 <test_emit_token>
  chMtxUnlock(&m1);
  20a126:	4806      	ldr	r0, [pc, #24]	@ (20a140 <thread8+0x40>)
  20a128:	f7f9 ff62 	bl	203ff0 <chMtxUnlock>
  chMtxUnlock(&m2);
  20a12c:	4803      	ldr	r0, [pc, #12]	@ (20a13c <thread8+0x3c>)
  20a12e:	f7f9 ff5f 	bl	203ff0 <chMtxUnlock>
}
  20a132:	bf00      	nop
  20a134:	b003      	add	sp, #12
  20a136:	f85d fb04 	ldr.w	pc, [sp], #4
  20a13a:	bf00      	nop
  20a13c:	20020010 	.word	0x20020010
  20a140:	20020000 	.word	0x20020000
  20a144:	20020020 	.word	0x20020020
	...

0020a150 <thread9>:

static THD_FUNCTION(thread9, p) {
  20a150:	b500      	push	{lr}
  20a152:	b083      	sub	sp, #12
  20a154:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
  20a156:	4807      	ldr	r0, [pc, #28]	@ (20a174 <thread9+0x24>)
  20a158:	f7f9 fe9a 	bl	203e90 <chMtxLock>
  test_emit_token(*(char *)p);
  20a15c:	9b01      	ldr	r3, [sp, #4]
  20a15e:	781b      	ldrb	r3, [r3, #0]
  20a160:	4618      	mov	r0, r3
  20a162:	f7fd fadd 	bl	207720 <test_emit_token>
  chMtxUnlock(&m2);
  20a166:	4803      	ldr	r0, [pc, #12]	@ (20a174 <thread9+0x24>)
  20a168:	f7f9 ff42 	bl	203ff0 <chMtxUnlock>
}
  20a16c:	bf00      	nop
  20a16e:	b003      	add	sp, #12
  20a170:	f85d fb04 	ldr.w	pc, [sp], #4
  20a174:	20020010 	.word	0x20020010
	...

0020a180 <rt_test_008_001_setup>:
 * - [8.1.4] Unlocking the mutex, the threads will wakeup in priority
 *   order because the mutext queue is an ordered one.
 * .
 */

static void rt_test_008_001_setup(void) {
  20a180:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
  20a182:	4802      	ldr	r0, [pc, #8]	@ (20a18c <rt_test_008_001_setup+0xc>)
  20a184:	f7f9 fe74 	bl	203e70 <chMtxObjectInit>
}
  20a188:	bf00      	nop
  20a18a:	bd08      	pop	{r3, pc}
  20a18c:	20020000 	.word	0x20020000

0020a190 <rt_test_008_001_execute>:

static void rt_test_008_001_execute(void) {
  20a190:	b500      	push	{lr}
  20a192:	b085      	sub	sp, #20
  tprio_t prio;

  /* [8.1.1] Getting the initial priority.*/
  test_set_step(1);
  20a194:	4b3a      	ldr	r3, [pc, #232]	@ (20a280 <rt_test_008_001_execute+0xf0>)
  20a196:	2201      	movs	r2, #1
  20a198:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
  20a19a:	f7ff ff39 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a19e:	9003      	str	r0, [sp, #12]
  }
  test_end_step(1);

  /* [8.1.2] Locking the mutex.*/
  test_set_step(2);
  20a1a0:	4b37      	ldr	r3, [pc, #220]	@ (20a280 <rt_test_008_001_execute+0xf0>)
  20a1a2:	2202      	movs	r2, #2
  20a1a4:	601a      	str	r2, [r3, #0]
  {
    chMtxLock(&m1);
  20a1a6:	4837      	ldr	r0, [pc, #220]	@ (20a284 <rt_test_008_001_execute+0xf4>)
  20a1a8:	f7f9 fe72 	bl	203e90 <chMtxLock>
  test_end_step(2);

  /* [8.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  20a1ac:	4b34      	ldr	r3, [pc, #208]	@ (20a280 <rt_test_008_001_execute+0xf0>)
  20a1ae:	2203      	movs	r2, #3
  20a1b0:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  20a1b2:	4b35      	ldr	r3, [pc, #212]	@ (20a288 <rt_test_008_001_execute+0xf8>)
  20a1b4:	6818      	ldr	r0, [r3, #0]
  20a1b6:	9b03      	ldr	r3, [sp, #12]
  20a1b8:	1c5a      	adds	r2, r3, #1
  20a1ba:	4b34      	ldr	r3, [pc, #208]	@ (20a28c <rt_test_008_001_execute+0xfc>)
  20a1bc:	9300      	str	r3, [sp, #0]
  20a1be:	4b34      	ldr	r3, [pc, #208]	@ (20a290 <rt_test_008_001_execute+0x100>)
  20a1c0:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a1c4:	f7f9 f8dc 	bl	203380 <chThdCreateStatic>
  20a1c8:	4603      	mov	r3, r0
  20a1ca:	4a32      	ldr	r2, [pc, #200]	@ (20a294 <rt_test_008_001_execute+0x104>)
  20a1cc:	6013      	str	r3, [r2, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  20a1ce:	4b2e      	ldr	r3, [pc, #184]	@ (20a288 <rt_test_008_001_execute+0xf8>)
  20a1d0:	6858      	ldr	r0, [r3, #4]
  20a1d2:	9b03      	ldr	r3, [sp, #12]
  20a1d4:	1c9a      	adds	r2, r3, #2
  20a1d6:	4b30      	ldr	r3, [pc, #192]	@ (20a298 <rt_test_008_001_execute+0x108>)
  20a1d8:	9300      	str	r3, [sp, #0]
  20a1da:	4b2d      	ldr	r3, [pc, #180]	@ (20a290 <rt_test_008_001_execute+0x100>)
  20a1dc:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a1e0:	f7f9 f8ce 	bl	203380 <chThdCreateStatic>
  20a1e4:	4603      	mov	r3, r0
  20a1e6:	4a2b      	ldr	r2, [pc, #172]	@ (20a294 <rt_test_008_001_execute+0x104>)
  20a1e8:	6053      	str	r3, [r2, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  20a1ea:	4b27      	ldr	r3, [pc, #156]	@ (20a288 <rt_test_008_001_execute+0xf8>)
  20a1ec:	6898      	ldr	r0, [r3, #8]
  20a1ee:	9b03      	ldr	r3, [sp, #12]
  20a1f0:	1cda      	adds	r2, r3, #3
  20a1f2:	4b2a      	ldr	r3, [pc, #168]	@ (20a29c <rt_test_008_001_execute+0x10c>)
  20a1f4:	9300      	str	r3, [sp, #0]
  20a1f6:	4b26      	ldr	r3, [pc, #152]	@ (20a290 <rt_test_008_001_execute+0x100>)
  20a1f8:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a1fc:	f7f9 f8c0 	bl	203380 <chThdCreateStatic>
  20a200:	4603      	mov	r3, r0
  20a202:	4a24      	ldr	r2, [pc, #144]	@ (20a294 <rt_test_008_001_execute+0x104>)
  20a204:	6093      	str	r3, [r2, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  20a206:	4b20      	ldr	r3, [pc, #128]	@ (20a288 <rt_test_008_001_execute+0xf8>)
  20a208:	68d8      	ldr	r0, [r3, #12]
  20a20a:	9b03      	ldr	r3, [sp, #12]
  20a20c:	1d1a      	adds	r2, r3, #4
  20a20e:	4b24      	ldr	r3, [pc, #144]	@ (20a2a0 <rt_test_008_001_execute+0x110>)
  20a210:	9300      	str	r3, [sp, #0]
  20a212:	4b1f      	ldr	r3, [pc, #124]	@ (20a290 <rt_test_008_001_execute+0x100>)
  20a214:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a218:	f7f9 f8b2 	bl	203380 <chThdCreateStatic>
  20a21c:	4603      	mov	r3, r0
  20a21e:	4a1d      	ldr	r2, [pc, #116]	@ (20a294 <rt_test_008_001_execute+0x104>)
  20a220:	60d3      	str	r3, [r2, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  20a222:	4b19      	ldr	r3, [pc, #100]	@ (20a288 <rt_test_008_001_execute+0xf8>)
  20a224:	6918      	ldr	r0, [r3, #16]
  20a226:	9b03      	ldr	r3, [sp, #12]
  20a228:	1d5a      	adds	r2, r3, #5
  20a22a:	4b1e      	ldr	r3, [pc, #120]	@ (20a2a4 <rt_test_008_001_execute+0x114>)
  20a22c:	9300      	str	r3, [sp, #0]
  20a22e:	4b18      	ldr	r3, [pc, #96]	@ (20a290 <rt_test_008_001_execute+0x100>)
  20a230:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a234:	f7f9 f8a4 	bl	203380 <chThdCreateStatic>
  20a238:	4603      	mov	r3, r0
  20a23a:	4a16      	ldr	r2, [pc, #88]	@ (20a294 <rt_test_008_001_execute+0x104>)
  20a23c:	6113      	str	r3, [r2, #16]
  }
  test_end_step(3);

  /* [8.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
  20a23e:	4b10      	ldr	r3, [pc, #64]	@ (20a280 <rt_test_008_001_execute+0xf0>)
  20a240:	2204      	movs	r2, #4
  20a242:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m1);
  20a244:	480f      	ldr	r0, [pc, #60]	@ (20a284 <rt_test_008_001_execute+0xf4>)
  20a246:	f7f9 fed3 	bl	203ff0 <chMtxUnlock>
    test_wait_threads();
  20a24a:	f7fd fdd9 	bl	207e00 <test_wait_threads>
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
  20a24e:	f7ff fedf 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a252:	4602      	mov	r2, r0
  20a254:	9b03      	ldr	r3, [sp, #12]
  20a256:	4293      	cmp	r3, r2
  20a258:	bf0c      	ite	eq
  20a25a:	2301      	moveq	r3, #1
  20a25c:	2300      	movne	r3, #0
  20a25e:	b2db      	uxtb	r3, r3
  20a260:	4911      	ldr	r1, [pc, #68]	@ (20a2a8 <rt_test_008_001_execute+0x118>)
  20a262:	4618      	mov	r0, r3
  20a264:	f7fd f9fc 	bl	207660 <__test_assert>
  20a268:	4603      	mov	r3, r0
  20a26a:	2b00      	cmp	r3, #0
  20a26c:	d105      	bne.n	20a27a <rt_test_008_001_execute+0xea>
    test_assert_sequence("ABCDE", "invalid sequence");
  20a26e:	490f      	ldr	r1, [pc, #60]	@ (20a2ac <rt_test_008_001_execute+0x11c>)
  20a270:	480f      	ldr	r0, [pc, #60]	@ (20a2b0 <rt_test_008_001_execute+0x120>)
  20a272:	f7fd fa0d 	bl	207690 <__test_assert_sequence>
  20a276:	4603      	mov	r3, r0
  20a278:	2b00      	cmp	r3, #0
  }
  test_end_step(4);
}
  20a27a:	b005      	add	sp, #20
  20a27c:	f85d fb04 	ldr.w	pc, [sp], #4
  20a280:	20000bb4 	.word	0x20000bb4
  20a284:	20020000 	.word	0x20020000
  20a288:	08012220 	.word	0x08012220
  20a28c:	0801170c 	.word	0x0801170c
  20a290:	0020a021 	.word	0x0020a021
  20a294:	20001900 	.word	0x20001900
  20a298:	080116e4 	.word	0x080116e4
  20a29c:	080116e8 	.word	0x080116e8
  20a2a0:	080116ec 	.word	0x080116ec
  20a2a4:	080116f0 	.word	0x080116f0
  20a2a8:	0801185c 	.word	0x0801185c
  20a2ac:	080116f4 	.word	0x080116f4
  20a2b0:	08011708 	.word	0x08011708
	...

0020a2c0 <rt_test_008_004_setup>:
 * - [8.4.7] Unlocking M2, the priority should fall back to P(A).
 * - [8.4.8] Unlocking M1, the priority should fall back to P(0).
 * .
 */

static void rt_test_008_004_setup(void) {
  20a2c0:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
  20a2c2:	4804      	ldr	r0, [pc, #16]	@ (20a2d4 <rt_test_008_004_setup+0x14>)
  20a2c4:	f7f9 fdd4 	bl	203e70 <chMtxObjectInit>
  chMtxObjectInit(&m2);
  20a2c8:	4803      	ldr	r0, [pc, #12]	@ (20a2d8 <rt_test_008_004_setup+0x18>)
  20a2ca:	f7f9 fdd1 	bl	203e70 <chMtxObjectInit>
}
  20a2ce:	bf00      	nop
  20a2d0:	bd08      	pop	{r3, pc}
  20a2d2:	bf00      	nop
  20a2d4:	20020000 	.word	0x20020000
  20a2d8:	20020010 	.word	0x20020010
  20a2dc:	00000000 	.word	0x00000000

0020a2e0 <rt_test_008_004_teardown>:

static void rt_test_008_004_teardown(void) {
  20a2e0:	b508      	push	{r3, lr}
  test_wait_threads();
  20a2e2:	f7fd fd8d 	bl	207e00 <test_wait_threads>
}
  20a2e6:	bf00      	nop
  20a2e8:	bd08      	pop	{r3, pc}
  20a2ea:	bf00      	nop
  20a2ec:	0000      	movs	r0, r0
	...

0020a2f0 <rt_test_008_004_execute>:

static void rt_test_008_004_execute(void) {
  20a2f0:	b500      	push	{lr}
  20a2f2:	b087      	sub	sp, #28
  tprio_t p, pa, pb;

  /* [8.4.1] Getting current thread priority P(0) and assigning to the
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
  20a2f4:	4b58      	ldr	r3, [pc, #352]	@ (20a458 <rt_test_008_004_execute+0x168>)
  20a2f6:	2201      	movs	r2, #1
  20a2f8:	601a      	str	r2, [r3, #0]
  {
    p = chThdGetPriorityX();
  20a2fa:	f7ff fe89 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a2fe:	9005      	str	r0, [sp, #20]
    pa = p + 1;
  20a300:	9b05      	ldr	r3, [sp, #20]
  20a302:	3301      	adds	r3, #1
  20a304:	9304      	str	r3, [sp, #16]
    pb = p + 2;
  20a306:	9b05      	ldr	r3, [sp, #20]
  20a308:	3302      	adds	r3, #2
  20a30a:	9303      	str	r3, [sp, #12]
  }
  test_end_step(1);

  /* [8.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  20a30c:	4b52      	ldr	r3, [pc, #328]	@ (20a458 <rt_test_008_004_execute+0x168>)
  20a30e:	2202      	movs	r2, #2
  20a310:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
  20a312:	4b52      	ldr	r3, [pc, #328]	@ (20a45c <rt_test_008_004_execute+0x16c>)
  20a314:	6818      	ldr	r0, [r3, #0]
  20a316:	4b52      	ldr	r3, [pc, #328]	@ (20a460 <rt_test_008_004_execute+0x170>)
  20a318:	9300      	str	r3, [sp, #0]
  20a31a:	4b52      	ldr	r3, [pc, #328]	@ (20a464 <rt_test_008_004_execute+0x174>)
  20a31c:	9a04      	ldr	r2, [sp, #16]
  20a31e:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a322:	f7f9 f82d 	bl	203380 <chThdCreateStatic>
  20a326:	4603      	mov	r3, r0
  20a328:	4a4f      	ldr	r2, [pc, #316]	@ (20a468 <rt_test_008_004_execute+0x178>)
  20a32a:	6013      	str	r3, [r2, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
  20a32c:	4b4b      	ldr	r3, [pc, #300]	@ (20a45c <rt_test_008_004_execute+0x16c>)
  20a32e:	6858      	ldr	r0, [r3, #4]
  20a330:	4b4e      	ldr	r3, [pc, #312]	@ (20a46c <rt_test_008_004_execute+0x17c>)
  20a332:	9300      	str	r3, [sp, #0]
  20a334:	4b4e      	ldr	r3, [pc, #312]	@ (20a470 <rt_test_008_004_execute+0x180>)
  20a336:	9a03      	ldr	r2, [sp, #12]
  20a338:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a33c:	f7f9 f820 	bl	203380 <chThdCreateStatic>
  20a340:	4603      	mov	r3, r0
  20a342:	4a49      	ldr	r2, [pc, #292]	@ (20a468 <rt_test_008_004_execute+0x178>)
  20a344:	6053      	str	r3, [r2, #4]
  test_end_step(2);

  /* [8.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
  20a346:	4b44      	ldr	r3, [pc, #272]	@ (20a458 <rt_test_008_004_execute+0x168>)
  20a348:	2203      	movs	r2, #3
  20a34a:	601a      	str	r2, [r3, #0]
  {
    chMtxLock(&m1);
  20a34c:	4849      	ldr	r0, [pc, #292]	@ (20a474 <rt_test_008_004_execute+0x184>)
  20a34e:	f7f9 fd9f 	bl	203e90 <chMtxLock>
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
  20a352:	f7ff fe5d 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a356:	4602      	mov	r2, r0
  20a358:	9b05      	ldr	r3, [sp, #20]
  20a35a:	4293      	cmp	r3, r2
  20a35c:	bf0c      	ite	eq
  20a35e:	2301      	moveq	r3, #1
  20a360:	2300      	movne	r3, #0
  20a362:	b2db      	uxtb	r3, r3
  20a364:	4944      	ldr	r1, [pc, #272]	@ (20a478 <rt_test_008_004_execute+0x188>)
  20a366:	4618      	mov	r0, r3
  20a368:	f7fd f97a 	bl	207660 <__test_assert>
  20a36c:	4603      	mov	r3, r0
  20a36e:	2b00      	cmp	r3, #0
  20a370:	d16e      	bne.n	20a450 <rt_test_008_004_execute+0x160>
  test_end_step(3);

  /* [8.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
  20a372:	4b39      	ldr	r3, [pc, #228]	@ (20a458 <rt_test_008_004_execute+0x168>)
  20a374:	2204      	movs	r2, #4
  20a376:	601a      	str	r2, [r3, #0]
  {
    chThdSleepMilliseconds(100);
  20a378:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  20a37c:	f7f9 f938 	bl	2035f0 <chThdSleep>
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  20a380:	f7ff fe46 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a384:	4602      	mov	r2, r0
  20a386:	9b04      	ldr	r3, [sp, #16]
  20a388:	4293      	cmp	r3, r2
  20a38a:	bf0c      	ite	eq
  20a38c:	2301      	moveq	r3, #1
  20a38e:	2300      	movne	r3, #0
  20a390:	b2db      	uxtb	r3, r3
  20a392:	4939      	ldr	r1, [pc, #228]	@ (20a478 <rt_test_008_004_execute+0x188>)
  20a394:	4618      	mov	r0, r3
  20a396:	f7fd f963 	bl	207660 <__test_assert>
  20a39a:	4603      	mov	r3, r0
  20a39c:	2b00      	cmp	r3, #0
  20a39e:	d157      	bne.n	20a450 <rt_test_008_004_execute+0x160>
  test_end_step(4);

  /* [8.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
  20a3a0:	4b2d      	ldr	r3, [pc, #180]	@ (20a458 <rt_test_008_004_execute+0x168>)
  20a3a2:	2205      	movs	r2, #5
  20a3a4:	601a      	str	r2, [r3, #0]
  {
    chMtxLock(&m2);
  20a3a6:	4835      	ldr	r0, [pc, #212]	@ (20a47c <rt_test_008_004_execute+0x18c>)
  20a3a8:	f7f9 fd72 	bl	203e90 <chMtxLock>
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  20a3ac:	f7ff fe30 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a3b0:	4602      	mov	r2, r0
  20a3b2:	9b04      	ldr	r3, [sp, #16]
  20a3b4:	4293      	cmp	r3, r2
  20a3b6:	bf0c      	ite	eq
  20a3b8:	2301      	moveq	r3, #1
  20a3ba:	2300      	movne	r3, #0
  20a3bc:	b2db      	uxtb	r3, r3
  20a3be:	492e      	ldr	r1, [pc, #184]	@ (20a478 <rt_test_008_004_execute+0x188>)
  20a3c0:	4618      	mov	r0, r3
  20a3c2:	f7fd f94d 	bl	207660 <__test_assert>
  20a3c6:	4603      	mov	r3, r0
  20a3c8:	2b00      	cmp	r3, #0
  20a3ca:	d141      	bne.n	20a450 <rt_test_008_004_execute+0x160>
  test_end_step(5);

  /* [8.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
  20a3cc:	4b22      	ldr	r3, [pc, #136]	@ (20a458 <rt_test_008_004_execute+0x168>)
  20a3ce:	2206      	movs	r2, #6
  20a3d0:	601a      	str	r2, [r3, #0]
  {
    chThdSleepMilliseconds(100);
  20a3d2:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  20a3d6:	f7f9 f90b 	bl	2035f0 <chThdSleep>
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
  20a3da:	f7ff fe19 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a3de:	4602      	mov	r2, r0
  20a3e0:	9b03      	ldr	r3, [sp, #12]
  20a3e2:	4293      	cmp	r3, r2
  20a3e4:	bf0c      	ite	eq
  20a3e6:	2301      	moveq	r3, #1
  20a3e8:	2300      	movne	r3, #0
  20a3ea:	b2db      	uxtb	r3, r3
  20a3ec:	4922      	ldr	r1, [pc, #136]	@ (20a478 <rt_test_008_004_execute+0x188>)
  20a3ee:	4618      	mov	r0, r3
  20a3f0:	f7fd f936 	bl	207660 <__test_assert>
  20a3f4:	4603      	mov	r3, r0
  20a3f6:	2b00      	cmp	r3, #0
  20a3f8:	d12a      	bne.n	20a450 <rt_test_008_004_execute+0x160>
  }
  test_end_step(6);

  /* [8.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
  20a3fa:	4b17      	ldr	r3, [pc, #92]	@ (20a458 <rt_test_008_004_execute+0x168>)
  20a3fc:	2207      	movs	r2, #7
  20a3fe:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m2);
  20a400:	481e      	ldr	r0, [pc, #120]	@ (20a47c <rt_test_008_004_execute+0x18c>)
  20a402:	f7f9 fdf5 	bl	203ff0 <chMtxUnlock>
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  20a406:	f7ff fe03 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a40a:	4602      	mov	r2, r0
  20a40c:	9b04      	ldr	r3, [sp, #16]
  20a40e:	4293      	cmp	r3, r2
  20a410:	bf0c      	ite	eq
  20a412:	2301      	moveq	r3, #1
  20a414:	2300      	movne	r3, #0
  20a416:	b2db      	uxtb	r3, r3
  20a418:	4917      	ldr	r1, [pc, #92]	@ (20a478 <rt_test_008_004_execute+0x188>)
  20a41a:	4618      	mov	r0, r3
  20a41c:	f7fd f920 	bl	207660 <__test_assert>
  20a420:	4603      	mov	r3, r0
  20a422:	2b00      	cmp	r3, #0
  20a424:	d114      	bne.n	20a450 <rt_test_008_004_execute+0x160>
  }
  test_end_step(7);

  /* [8.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
  20a426:	4b0c      	ldr	r3, [pc, #48]	@ (20a458 <rt_test_008_004_execute+0x168>)
  20a428:	2208      	movs	r2, #8
  20a42a:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m1);
  20a42c:	4811      	ldr	r0, [pc, #68]	@ (20a474 <rt_test_008_004_execute+0x184>)
  20a42e:	f7f9 fddf 	bl	203ff0 <chMtxUnlock>
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
  20a432:	f7ff fded 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a436:	4602      	mov	r2, r0
  20a438:	9b05      	ldr	r3, [sp, #20]
  20a43a:	4293      	cmp	r3, r2
  20a43c:	bf0c      	ite	eq
  20a43e:	2301      	moveq	r3, #1
  20a440:	2300      	movne	r3, #0
  20a442:	b2db      	uxtb	r3, r3
  20a444:	490c      	ldr	r1, [pc, #48]	@ (20a478 <rt_test_008_004_execute+0x188>)
  20a446:	4618      	mov	r0, r3
  20a448:	f7fd f90a 	bl	207660 <__test_assert>
  20a44c:	4603      	mov	r3, r0
  20a44e:	2b00      	cmp	r3, #0
  }
  test_end_step(8);
}
  20a450:	b007      	add	sp, #28
  20a452:	f85d fb04 	ldr.w	pc, [sp], #4
  20a456:	bf00      	nop
  20a458:	20000bb4 	.word	0x20000bb4
  20a45c:	08012220 	.word	0x08012220
  20a460:	080116f0 	.word	0x080116f0
  20a464:	0020a051 	.word	0x0020a051
  20a468:	20001900 	.word	0x20001900
  20a46c:	080116ec 	.word	0x080116ec
  20a470:	0020a081 	.word	0x0020a081
  20a474:	20020000 	.word	0x20020000
  20a478:	0801185c 	.word	0x0801185c
  20a47c:	20020010 	.word	0x20020010

0020a480 <rt_test_008_005_setup>:
 * - [8.5.6] Testing chMtxUnlockAll() behavior.
 * - [8.5.7] Testing that priority has not changed after operations.
 * .
 */

static void rt_test_008_005_setup(void) {
  20a480:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
  20a482:	4802      	ldr	r0, [pc, #8]	@ (20a48c <rt_test_008_005_setup+0xc>)
  20a484:	f7f9 fcf4 	bl	203e70 <chMtxObjectInit>
}
  20a488:	bf00      	nop
  20a48a:	bd08      	pop	{r3, pc}
  20a48c:	20020000 	.word	0x20020000

0020a490 <rt_test_008_005_execute>:

static void rt_test_008_005_execute(void) {
  20a490:	b500      	push	{lr}
  20a492:	b083      	sub	sp, #12
  bool b;
  tprio_t prio;

  /* [8.5.1] Getting current thread priority for later checks.*/
  test_set_step(1);
  20a494:	4b62      	ldr	r3, [pc, #392]	@ (20a620 <rt_test_008_005_execute+0x190>)
  20a496:	2201      	movs	r2, #1
  20a498:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
  20a49a:	f7ff fdb9 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a49e:	9001      	str	r0, [sp, #4]
  }
  test_end_step(1);

  /* [8.5.2] Locking the mutex first time, it must be possible because
     it is not owned.*/
  test_set_step(2);
  20a4a0:	4b5f      	ldr	r3, [pc, #380]	@ (20a620 <rt_test_008_005_execute+0x190>)
  20a4a2:	2202      	movs	r2, #2
  20a4a4:	601a      	str	r2, [r3, #0]
  {
    b = chMtxTryLock(&m1);
  20a4a6:	485f      	ldr	r0, [pc, #380]	@ (20a624 <rt_test_008_005_execute+0x194>)
  20a4a8:	f7f9 fd6a 	bl	203f80 <chMtxTryLock>
  20a4ac:	4603      	mov	r3, r0
  20a4ae:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(b, "already locked");
  20a4b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
  20a4b6:	495c      	ldr	r1, [pc, #368]	@ (20a628 <rt_test_008_005_execute+0x198>)
  20a4b8:	4618      	mov	r0, r3
  20a4ba:	f7fd f8d1 	bl	207660 <__test_assert>
  20a4be:	4603      	mov	r3, r0
  20a4c0:	2b00      	cmp	r3, #0
  20a4c2:	f040 80a9 	bne.w	20a618 <rt_test_008_005_execute+0x188>
  }
  test_end_step(2);

  /* [8.5.3] Locking the mutex second time, it must fail because it is
     already owned.*/
  test_set_step(3);
  20a4c6:	4b56      	ldr	r3, [pc, #344]	@ (20a620 <rt_test_008_005_execute+0x190>)
  20a4c8:	2203      	movs	r2, #3
  20a4ca:	601a      	str	r2, [r3, #0]
  {
    b = chMtxTryLock(&m1);
  20a4cc:	4855      	ldr	r0, [pc, #340]	@ (20a624 <rt_test_008_005_execute+0x194>)
  20a4ce:	f7f9 fd57 	bl	203f80 <chMtxTryLock>
  20a4d2:	4603      	mov	r3, r0
  20a4d4:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(!b, "not locked");
  20a4d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
  20a4dc:	2b00      	cmp	r3, #0
  20a4de:	bf14      	ite	ne
  20a4e0:	2301      	movne	r3, #1
  20a4e2:	2300      	moveq	r3, #0
  20a4e4:	b2db      	uxtb	r3, r3
  20a4e6:	f083 0301 	eor.w	r3, r3, #1
  20a4ea:	b2db      	uxtb	r3, r3
  20a4ec:	f003 0301 	and.w	r3, r3, #1
  20a4f0:	b2db      	uxtb	r3, r3
  20a4f2:	494e      	ldr	r1, [pc, #312]	@ (20a62c <rt_test_008_005_execute+0x19c>)
  20a4f4:	4618      	mov	r0, r3
  20a4f6:	f7fd f8b3 	bl	207660 <__test_assert>
  20a4fa:	4603      	mov	r3, r0
  20a4fc:	2b00      	cmp	r3, #0
  20a4fe:	f040 808b 	bne.w	20a618 <rt_test_008_005_execute+0x188>
  }
  test_end_step(3);

  /* [8.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
  20a502:	4b47      	ldr	r3, [pc, #284]	@ (20a620 <rt_test_008_005_execute+0x190>)
  20a504:	2204      	movs	r2, #4
  20a506:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m1);
  20a508:	4846      	ldr	r0, [pc, #280]	@ (20a624 <rt_test_008_005_execute+0x194>)
  20a50a:	f7f9 fd71 	bl	203ff0 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
  20a50e:	4b45      	ldr	r3, [pc, #276]	@ (20a624 <rt_test_008_005_execute+0x194>)
  20a510:	689b      	ldr	r3, [r3, #8]
  20a512:	2b00      	cmp	r3, #0
  20a514:	bf0c      	ite	eq
  20a516:	2301      	moveq	r3, #1
  20a518:	2300      	movne	r3, #0
  20a51a:	b2db      	uxtb	r3, r3
  20a51c:	4944      	ldr	r1, [pc, #272]	@ (20a630 <rt_test_008_005_execute+0x1a0>)
  20a51e:	4618      	mov	r0, r3
  20a520:	f7fd f89e 	bl	207660 <__test_assert>
  20a524:	4603      	mov	r3, r0
  20a526:	2b00      	cmp	r3, #0
  20a528:	d176      	bne.n	20a618 <rt_test_008_005_execute+0x188>
    test_assert(ch_queue_isempty(&m1.queue), "queue not empty");
  20a52a:	483e      	ldr	r0, [pc, #248]	@ (20a624 <rt_test_008_005_execute+0x194>)
  20a52c:	f7ff fd38 	bl	209fa0 <ch_queue_isempty.lto_priv.1>
  20a530:	4603      	mov	r3, r0
  20a532:	4940      	ldr	r1, [pc, #256]	@ (20a634 <rt_test_008_005_execute+0x1a4>)
  20a534:	4618      	mov	r0, r3
  20a536:	f7fd f893 	bl	207660 <__test_assert>
  20a53a:	4603      	mov	r3, r0
  20a53c:	2b00      	cmp	r3, #0
  20a53e:	d16b      	bne.n	20a618 <rt_test_008_005_execute+0x188>
  }
  test_end_step(4);

  /* [8.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
  20a540:	4b37      	ldr	r3, [pc, #220]	@ (20a620 <rt_test_008_005_execute+0x190>)
  20a542:	2205      	movs	r2, #5
  20a544:	601a      	str	r2, [r3, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
  20a546:	f7ff fd63 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a54a:	4602      	mov	r2, r0
  20a54c:	9b01      	ldr	r3, [sp, #4]
  20a54e:	4293      	cmp	r3, r2
  20a550:	bf0c      	ite	eq
  20a552:	2301      	moveq	r3, #1
  20a554:	2300      	movne	r3, #0
  20a556:	b2db      	uxtb	r3, r3
  20a558:	4937      	ldr	r1, [pc, #220]	@ (20a638 <rt_test_008_005_execute+0x1a8>)
  20a55a:	4618      	mov	r0, r3
  20a55c:	f7fd f880 	bl	207660 <__test_assert>
  20a560:	4603      	mov	r3, r0
  20a562:	2b00      	cmp	r3, #0
  20a564:	d158      	bne.n	20a618 <rt_test_008_005_execute+0x188>
  }
  test_end_step(5);

  /* [8.5.6] Testing chMtxUnlockAll() behavior.*/
  test_set_step(6);
  20a566:	4b2e      	ldr	r3, [pc, #184]	@ (20a620 <rt_test_008_005_execute+0x190>)
  20a568:	2206      	movs	r2, #6
  20a56a:	601a      	str	r2, [r3, #0]
  {
    b = chMtxTryLock(&m1);
  20a56c:	482d      	ldr	r0, [pc, #180]	@ (20a624 <rt_test_008_005_execute+0x194>)
  20a56e:	f7f9 fd07 	bl	203f80 <chMtxTryLock>
  20a572:	4603      	mov	r3, r0
  20a574:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(b, "already locked");
  20a578:	f89d 3003 	ldrb.w	r3, [sp, #3]
  20a57c:	492a      	ldr	r1, [pc, #168]	@ (20a628 <rt_test_008_005_execute+0x198>)
  20a57e:	4618      	mov	r0, r3
  20a580:	f7fd f86e 	bl	207660 <__test_assert>
  20a584:	4603      	mov	r3, r0
  20a586:	2b00      	cmp	r3, #0
  20a588:	d146      	bne.n	20a618 <rt_test_008_005_execute+0x188>
    b = chMtxTryLock(&m1);
  20a58a:	4826      	ldr	r0, [pc, #152]	@ (20a624 <rt_test_008_005_execute+0x194>)
  20a58c:	f7f9 fcf8 	bl	203f80 <chMtxTryLock>
  20a590:	4603      	mov	r3, r0
  20a592:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(!b, "not locked");
  20a596:	f89d 3003 	ldrb.w	r3, [sp, #3]
  20a59a:	2b00      	cmp	r3, #0
  20a59c:	bf14      	ite	ne
  20a59e:	2301      	movne	r3, #1
  20a5a0:	2300      	moveq	r3, #0
  20a5a2:	b2db      	uxtb	r3, r3
  20a5a4:	f083 0301 	eor.w	r3, r3, #1
  20a5a8:	b2db      	uxtb	r3, r3
  20a5aa:	f003 0301 	and.w	r3, r3, #1
  20a5ae:	b2db      	uxtb	r3, r3
  20a5b0:	491e      	ldr	r1, [pc, #120]	@ (20a62c <rt_test_008_005_execute+0x19c>)
  20a5b2:	4618      	mov	r0, r3
  20a5b4:	f7fd f854 	bl	207660 <__test_assert>
  20a5b8:	4603      	mov	r3, r0
  20a5ba:	2b00      	cmp	r3, #0
  20a5bc:	d12c      	bne.n	20a618 <rt_test_008_005_execute+0x188>

    chMtxUnlockAll();
  20a5be:	f7f9 fdf7 	bl	2041b0 <chMtxUnlockAll>
    test_assert(m1.owner == NULL, "still owned");
  20a5c2:	4b18      	ldr	r3, [pc, #96]	@ (20a624 <rt_test_008_005_execute+0x194>)
  20a5c4:	689b      	ldr	r3, [r3, #8]
  20a5c6:	2b00      	cmp	r3, #0
  20a5c8:	bf0c      	ite	eq
  20a5ca:	2301      	moveq	r3, #1
  20a5cc:	2300      	movne	r3, #0
  20a5ce:	b2db      	uxtb	r3, r3
  20a5d0:	4917      	ldr	r1, [pc, #92]	@ (20a630 <rt_test_008_005_execute+0x1a0>)
  20a5d2:	4618      	mov	r0, r3
  20a5d4:	f7fd f844 	bl	207660 <__test_assert>
  20a5d8:	4603      	mov	r3, r0
  20a5da:	2b00      	cmp	r3, #0
  20a5dc:	d11c      	bne.n	20a618 <rt_test_008_005_execute+0x188>
    test_assert(ch_queue_isempty(&m1.queue), "queue not empty");
  20a5de:	4811      	ldr	r0, [pc, #68]	@ (20a624 <rt_test_008_005_execute+0x194>)
  20a5e0:	f7ff fcde 	bl	209fa0 <ch_queue_isempty.lto_priv.1>
  20a5e4:	4603      	mov	r3, r0
  20a5e6:	4913      	ldr	r1, [pc, #76]	@ (20a634 <rt_test_008_005_execute+0x1a4>)
  20a5e8:	4618      	mov	r0, r3
  20a5ea:	f7fd f839 	bl	207660 <__test_assert>
  20a5ee:	4603      	mov	r3, r0
  20a5f0:	2b00      	cmp	r3, #0
  20a5f2:	d111      	bne.n	20a618 <rt_test_008_005_execute+0x188>
  }
  test_end_step(6);

  /* [8.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
  20a5f4:	4b0a      	ldr	r3, [pc, #40]	@ (20a620 <rt_test_008_005_execute+0x190>)
  20a5f6:	2207      	movs	r2, #7
  20a5f8:	601a      	str	r2, [r3, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
  20a5fa:	f7ff fd09 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a5fe:	4602      	mov	r2, r0
  20a600:	9b01      	ldr	r3, [sp, #4]
  20a602:	4293      	cmp	r3, r2
  20a604:	bf0c      	ite	eq
  20a606:	2301      	moveq	r3, #1
  20a608:	2300      	movne	r3, #0
  20a60a:	b2db      	uxtb	r3, r3
  20a60c:	490a      	ldr	r1, [pc, #40]	@ (20a638 <rt_test_008_005_execute+0x1a8>)
  20a60e:	4618      	mov	r0, r3
  20a610:	f7fd f826 	bl	207660 <__test_assert>
  20a614:	4603      	mov	r3, r0
  20a616:	2b00      	cmp	r3, #0
  }
  test_end_step(7);
}
  20a618:	b003      	add	sp, #12
  20a61a:	f85d fb04 	ldr.w	pc, [sp], #4
  20a61e:	bf00      	nop
  20a620:	20000bb4 	.word	0x20000bb4
  20a624:	20020000 	.word	0x20020000
  20a628:	08011874 	.word	0x08011874
  20a62c:	08011884 	.word	0x08011884
  20a630:	08011890 	.word	0x08011890
  20a634:	080117e8 	.word	0x080117e8
  20a638:	0801185c 	.word	0x0801185c
  20a63c:	00000000 	.word	0x00000000

0020a640 <rt_test_008_007_setup>:
 *   then waiting for the threads to terminate in priority order, the
 *   order is tested.
 * .
 */

static void rt_test_008_007_setup(void) {
  20a640:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
  20a642:	4804      	ldr	r0, [pc, #16]	@ (20a654 <rt_test_008_007_setup+0x14>)
  20a644:	f7f9 fe54 	bl	2042f0 <chCondObjectInit>
  chMtxObjectInit(&m1);
  20a648:	4803      	ldr	r0, [pc, #12]	@ (20a658 <rt_test_008_007_setup+0x18>)
  20a64a:	f7f9 fc11 	bl	203e70 <chMtxObjectInit>
}
  20a64e:	bf00      	nop
  20a650:	bd08      	pop	{r3, pc}
  20a652:	bf00      	nop
  20a654:	20020020 	.word	0x20020020
  20a658:	20020000 	.word	0x20020000
  20a65c:	00000000 	.word	0x00000000

0020a660 <rt_test_008_007_execute>:

static void rt_test_008_007_execute(void) {
  20a660:	b500      	push	{lr}
  20a662:	b085      	sub	sp, #20

  /* [8.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  20a664:	4b37      	ldr	r3, [pc, #220]	@ (20a744 <rt_test_008_007_execute+0xe4>)
  20a666:	2201      	movs	r2, #1
  20a668:	601a      	str	r2, [r3, #0]
  {
    tprio_t prio = chThdGetPriorityX();
  20a66a:	f7ff fcd1 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a66e:	9003      	str	r0, [sp, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
  20a670:	4b35      	ldr	r3, [pc, #212]	@ (20a748 <rt_test_008_007_execute+0xe8>)
  20a672:	6818      	ldr	r0, [r3, #0]
  20a674:	9b03      	ldr	r3, [sp, #12]
  20a676:	1c5a      	adds	r2, r3, #1
  20a678:	4b34      	ldr	r3, [pc, #208]	@ (20a74c <rt_test_008_007_execute+0xec>)
  20a67a:	9300      	str	r3, [sp, #0]
  20a67c:	4b34      	ldr	r3, [pc, #208]	@ (20a750 <rt_test_008_007_execute+0xf0>)
  20a67e:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a682:	f7f8 fe7d 	bl	203380 <chThdCreateStatic>
  20a686:	4603      	mov	r3, r0
  20a688:	4a32      	ldr	r2, [pc, #200]	@ (20a754 <rt_test_008_007_execute+0xf4>)
  20a68a:	6013      	str	r3, [r2, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
  20a68c:	4b2e      	ldr	r3, [pc, #184]	@ (20a748 <rt_test_008_007_execute+0xe8>)
  20a68e:	6858      	ldr	r0, [r3, #4]
  20a690:	9b03      	ldr	r3, [sp, #12]
  20a692:	1c9a      	adds	r2, r3, #2
  20a694:	4b30      	ldr	r3, [pc, #192]	@ (20a758 <rt_test_008_007_execute+0xf8>)
  20a696:	9300      	str	r3, [sp, #0]
  20a698:	4b2d      	ldr	r3, [pc, #180]	@ (20a750 <rt_test_008_007_execute+0xf0>)
  20a69a:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a69e:	f7f8 fe6f 	bl	203380 <chThdCreateStatic>
  20a6a2:	4603      	mov	r3, r0
  20a6a4:	4a2b      	ldr	r2, [pc, #172]	@ (20a754 <rt_test_008_007_execute+0xf4>)
  20a6a6:	6053      	str	r3, [r2, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
  20a6a8:	4b27      	ldr	r3, [pc, #156]	@ (20a748 <rt_test_008_007_execute+0xe8>)
  20a6aa:	6898      	ldr	r0, [r3, #8]
  20a6ac:	9b03      	ldr	r3, [sp, #12]
  20a6ae:	1cda      	adds	r2, r3, #3
  20a6b0:	4b2a      	ldr	r3, [pc, #168]	@ (20a75c <rt_test_008_007_execute+0xfc>)
  20a6b2:	9300      	str	r3, [sp, #0]
  20a6b4:	4b26      	ldr	r3, [pc, #152]	@ (20a750 <rt_test_008_007_execute+0xf0>)
  20a6b6:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a6ba:	f7f8 fe61 	bl	203380 <chThdCreateStatic>
  20a6be:	4603      	mov	r3, r0
  20a6c0:	4a24      	ldr	r2, [pc, #144]	@ (20a754 <rt_test_008_007_execute+0xf4>)
  20a6c2:	6093      	str	r3, [r2, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
  20a6c4:	4b20      	ldr	r3, [pc, #128]	@ (20a748 <rt_test_008_007_execute+0xe8>)
  20a6c6:	68d8      	ldr	r0, [r3, #12]
  20a6c8:	9b03      	ldr	r3, [sp, #12]
  20a6ca:	1d1a      	adds	r2, r3, #4
  20a6cc:	4b24      	ldr	r3, [pc, #144]	@ (20a760 <rt_test_008_007_execute+0x100>)
  20a6ce:	9300      	str	r3, [sp, #0]
  20a6d0:	4b1f      	ldr	r3, [pc, #124]	@ (20a750 <rt_test_008_007_execute+0xf0>)
  20a6d2:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a6d6:	f7f8 fe53 	bl	203380 <chThdCreateStatic>
  20a6da:	4603      	mov	r3, r0
  20a6dc:	4a1d      	ldr	r2, [pc, #116]	@ (20a754 <rt_test_008_007_execute+0xf4>)
  20a6de:	60d3      	str	r3, [r2, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
  20a6e0:	4b19      	ldr	r3, [pc, #100]	@ (20a748 <rt_test_008_007_execute+0xe8>)
  20a6e2:	6918      	ldr	r0, [r3, #16]
  20a6e4:	9b03      	ldr	r3, [sp, #12]
  20a6e6:	1d5a      	adds	r2, r3, #5
  20a6e8:	4b1e      	ldr	r3, [pc, #120]	@ (20a764 <rt_test_008_007_execute+0x104>)
  20a6ea:	9300      	str	r3, [sp, #0]
  20a6ec:	4b18      	ldr	r3, [pc, #96]	@ (20a750 <rt_test_008_007_execute+0xf0>)
  20a6ee:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a6f2:	f7f8 fe45 	bl	203380 <chThdCreateStatic>
  20a6f6:	4603      	mov	r3, r0
  20a6f8:	4a16      	ldr	r2, [pc, #88]	@ (20a754 <rt_test_008_007_execute+0xf4>)
  20a6fa:	6113      	str	r3, [r2, #16]
  test_end_step(1);

  /* [8.7.2] Atomically signaling the condition variable five times
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
  20a6fc:	4b11      	ldr	r3, [pc, #68]	@ (20a744 <rt_test_008_007_execute+0xe4>)
  20a6fe:	2202      	movs	r2, #2
  20a700:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  20a702:	f7ff fc5d 	bl	209fc0 <chSysLock.lto_priv.24>
    chCondSignalI(&c1);
  20a706:	4818      	ldr	r0, [pc, #96]	@ (20a768 <rt_test_008_007_execute+0x108>)
  20a708:	f7f9 fe22 	bl	204350 <chCondSignalI>
    chCondSignalI(&c1);
  20a70c:	4816      	ldr	r0, [pc, #88]	@ (20a768 <rt_test_008_007_execute+0x108>)
  20a70e:	f7f9 fe1f 	bl	204350 <chCondSignalI>
    chCondSignalI(&c1);
  20a712:	4815      	ldr	r0, [pc, #84]	@ (20a768 <rt_test_008_007_execute+0x108>)
  20a714:	f7f9 fe1c 	bl	204350 <chCondSignalI>
    chCondSignalI(&c1);
  20a718:	4813      	ldr	r0, [pc, #76]	@ (20a768 <rt_test_008_007_execute+0x108>)
  20a71a:	f7f9 fe19 	bl	204350 <chCondSignalI>
    chCondSignalI(&c1);
  20a71e:	4812      	ldr	r0, [pc, #72]	@ (20a768 <rt_test_008_007_execute+0x108>)
  20a720:	f7f9 fe16 	bl	204350 <chCondSignalI>
    chSchRescheduleS();
  20a724:	f7f8 faa4 	bl	202c70 <chSchRescheduleS>
    chSysUnlock();
  20a728:	f7ff fc5a 	bl	209fe0 <chSysUnlock.lto_priv.24>
    test_wait_threads();
  20a72c:	f7fd fb68 	bl	207e00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  20a730:	490e      	ldr	r1, [pc, #56]	@ (20a76c <rt_test_008_007_execute+0x10c>)
  20a732:	480f      	ldr	r0, [pc, #60]	@ (20a770 <rt_test_008_007_execute+0x110>)
  20a734:	f7fc ffac 	bl	207690 <__test_assert_sequence>
  20a738:	4603      	mov	r3, r0
  20a73a:	2b00      	cmp	r3, #0
  }
  test_end_step(2);
}
  20a73c:	b005      	add	sp, #20
  20a73e:	f85d fb04 	ldr.w	pc, [sp], #4
  20a742:	bf00      	nop
  20a744:	20000bb4 	.word	0x20000bb4
  20a748:	08012220 	.word	0x08012220
  20a74c:	0801170c 	.word	0x0801170c
  20a750:	0020a0c1 	.word	0x0020a0c1
  20a754:	20001900 	.word	0x20001900
  20a758:	080116e4 	.word	0x080116e4
  20a75c:	080116e8 	.word	0x080116e8
  20a760:	080116ec 	.word	0x080116ec
  20a764:	080116f0 	.word	0x080116f0
  20a768:	20020020 	.word	0x20020020
  20a76c:	080116f4 	.word	0x080116f4
  20a770:	08011708 	.word	0x08011708
	...

0020a780 <rt_test_008_008_setup>:
 * - [8.8.2] Broarcasting on the condition variable then waiting for
 *   the threads to terminate in priority order, the order is tested.
 * .
 */

static void rt_test_008_008_setup(void) {
  20a780:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
  20a782:	4804      	ldr	r0, [pc, #16]	@ (20a794 <rt_test_008_008_setup+0x14>)
  20a784:	f7f9 fdb4 	bl	2042f0 <chCondObjectInit>
  chMtxObjectInit(&m1);
  20a788:	4803      	ldr	r0, [pc, #12]	@ (20a798 <rt_test_008_008_setup+0x18>)
  20a78a:	f7f9 fb71 	bl	203e70 <chMtxObjectInit>
}
  20a78e:	bf00      	nop
  20a790:	bd08      	pop	{r3, pc}
  20a792:	bf00      	nop
  20a794:	20020020 	.word	0x20020020
  20a798:	20020000 	.word	0x20020000
  20a79c:	00000000 	.word	0x00000000

0020a7a0 <rt_test_008_008_execute>:

static void rt_test_008_008_execute(void) {
  20a7a0:	b500      	push	{lr}
  20a7a2:	b085      	sub	sp, #20

  /* [8.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  20a7a4:	4b2e      	ldr	r3, [pc, #184]	@ (20a860 <rt_test_008_008_execute+0xc0>)
  20a7a6:	2201      	movs	r2, #1
  20a7a8:	601a      	str	r2, [r3, #0]
  {
    tprio_t prio = chThdGetPriorityX();
  20a7aa:	f7ff fc31 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a7ae:	9003      	str	r0, [sp, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
  20a7b0:	4b2c      	ldr	r3, [pc, #176]	@ (20a864 <rt_test_008_008_execute+0xc4>)
  20a7b2:	6818      	ldr	r0, [r3, #0]
  20a7b4:	9b03      	ldr	r3, [sp, #12]
  20a7b6:	1c5a      	adds	r2, r3, #1
  20a7b8:	4b2b      	ldr	r3, [pc, #172]	@ (20a868 <rt_test_008_008_execute+0xc8>)
  20a7ba:	9300      	str	r3, [sp, #0]
  20a7bc:	4b2b      	ldr	r3, [pc, #172]	@ (20a86c <rt_test_008_008_execute+0xcc>)
  20a7be:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a7c2:	f7f8 fddd 	bl	203380 <chThdCreateStatic>
  20a7c6:	4603      	mov	r3, r0
  20a7c8:	4a29      	ldr	r2, [pc, #164]	@ (20a870 <rt_test_008_008_execute+0xd0>)
  20a7ca:	6013      	str	r3, [r2, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
  20a7cc:	4b25      	ldr	r3, [pc, #148]	@ (20a864 <rt_test_008_008_execute+0xc4>)
  20a7ce:	6858      	ldr	r0, [r3, #4]
  20a7d0:	9b03      	ldr	r3, [sp, #12]
  20a7d2:	1c9a      	adds	r2, r3, #2
  20a7d4:	4b27      	ldr	r3, [pc, #156]	@ (20a874 <rt_test_008_008_execute+0xd4>)
  20a7d6:	9300      	str	r3, [sp, #0]
  20a7d8:	4b24      	ldr	r3, [pc, #144]	@ (20a86c <rt_test_008_008_execute+0xcc>)
  20a7da:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a7de:	f7f8 fdcf 	bl	203380 <chThdCreateStatic>
  20a7e2:	4603      	mov	r3, r0
  20a7e4:	4a22      	ldr	r2, [pc, #136]	@ (20a870 <rt_test_008_008_execute+0xd0>)
  20a7e6:	6053      	str	r3, [r2, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
  20a7e8:	4b1e      	ldr	r3, [pc, #120]	@ (20a864 <rt_test_008_008_execute+0xc4>)
  20a7ea:	6898      	ldr	r0, [r3, #8]
  20a7ec:	9b03      	ldr	r3, [sp, #12]
  20a7ee:	1cda      	adds	r2, r3, #3
  20a7f0:	4b21      	ldr	r3, [pc, #132]	@ (20a878 <rt_test_008_008_execute+0xd8>)
  20a7f2:	9300      	str	r3, [sp, #0]
  20a7f4:	4b1d      	ldr	r3, [pc, #116]	@ (20a86c <rt_test_008_008_execute+0xcc>)
  20a7f6:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a7fa:	f7f8 fdc1 	bl	203380 <chThdCreateStatic>
  20a7fe:	4603      	mov	r3, r0
  20a800:	4a1b      	ldr	r2, [pc, #108]	@ (20a870 <rt_test_008_008_execute+0xd0>)
  20a802:	6093      	str	r3, [r2, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
  20a804:	4b17      	ldr	r3, [pc, #92]	@ (20a864 <rt_test_008_008_execute+0xc4>)
  20a806:	68d8      	ldr	r0, [r3, #12]
  20a808:	9b03      	ldr	r3, [sp, #12]
  20a80a:	1d1a      	adds	r2, r3, #4
  20a80c:	4b1b      	ldr	r3, [pc, #108]	@ (20a87c <rt_test_008_008_execute+0xdc>)
  20a80e:	9300      	str	r3, [sp, #0]
  20a810:	4b16      	ldr	r3, [pc, #88]	@ (20a86c <rt_test_008_008_execute+0xcc>)
  20a812:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a816:	f7f8 fdb3 	bl	203380 <chThdCreateStatic>
  20a81a:	4603      	mov	r3, r0
  20a81c:	4a14      	ldr	r2, [pc, #80]	@ (20a870 <rt_test_008_008_execute+0xd0>)
  20a81e:	60d3      	str	r3, [r2, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
  20a820:	4b10      	ldr	r3, [pc, #64]	@ (20a864 <rt_test_008_008_execute+0xc4>)
  20a822:	6918      	ldr	r0, [r3, #16]
  20a824:	9b03      	ldr	r3, [sp, #12]
  20a826:	1d5a      	adds	r2, r3, #5
  20a828:	4b15      	ldr	r3, [pc, #84]	@ (20a880 <rt_test_008_008_execute+0xe0>)
  20a82a:	9300      	str	r3, [sp, #0]
  20a82c:	4b0f      	ldr	r3, [pc, #60]	@ (20a86c <rt_test_008_008_execute+0xcc>)
  20a82e:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a832:	f7f8 fda5 	bl	203380 <chThdCreateStatic>
  20a836:	4603      	mov	r3, r0
  20a838:	4a0d      	ldr	r2, [pc, #52]	@ (20a870 <rt_test_008_008_execute+0xd0>)
  20a83a:	6113      	str	r3, [r2, #16]
  }
  test_end_step(1);

  /* [8.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
  20a83c:	4b08      	ldr	r3, [pc, #32]	@ (20a860 <rt_test_008_008_execute+0xc0>)
  20a83e:	2202      	movs	r2, #2
  20a840:	601a      	str	r2, [r3, #0]
  {
    chCondBroadcast(&c1);
  20a842:	4810      	ldr	r0, [pc, #64]	@ (20a884 <rt_test_008_008_execute+0xe4>)
  20a844:	f7f9 fda4 	bl	204390 <chCondBroadcast>
    test_wait_threads();
  20a848:	f7fd fada 	bl	207e00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  20a84c:	490e      	ldr	r1, [pc, #56]	@ (20a888 <rt_test_008_008_execute+0xe8>)
  20a84e:	480f      	ldr	r0, [pc, #60]	@ (20a88c <rt_test_008_008_execute+0xec>)
  20a850:	f7fc ff1e 	bl	207690 <__test_assert_sequence>
  20a854:	4603      	mov	r3, r0
  20a856:	2b00      	cmp	r3, #0
  }
  test_end_step(2);
}
  20a858:	b005      	add	sp, #20
  20a85a:	f85d fb04 	ldr.w	pc, [sp], #4
  20a85e:	bf00      	nop
  20a860:	20000bb4 	.word	0x20000bb4
  20a864:	08012220 	.word	0x08012220
  20a868:	0801170c 	.word	0x0801170c
  20a86c:	0020a0c1 	.word	0x0020a0c1
  20a870:	20001900 	.word	0x20001900
  20a874:	080116e4 	.word	0x080116e4
  20a878:	080116e8 	.word	0x080116e8
  20a87c:	080116ec 	.word	0x080116ec
  20a880:	080116f0 	.word	0x080116f0
  20a884:	20020020 	.word	0x20020020
  20a888:	080116f4 	.word	0x080116f4
  20a88c:	08011708 	.word	0x08011708

0020a890 <rt_test_008_009_setup>:
 * - [8.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.
 * - [8.9.7] Checking the order of operations.
 * .
 */

static void rt_test_008_009_setup(void) {
  20a890:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
  20a892:	4805      	ldr	r0, [pc, #20]	@ (20a8a8 <rt_test_008_009_setup+0x18>)
  20a894:	f7f9 fd2c 	bl	2042f0 <chCondObjectInit>
  chMtxObjectInit(&m1);
  20a898:	4804      	ldr	r0, [pc, #16]	@ (20a8ac <rt_test_008_009_setup+0x1c>)
  20a89a:	f7f9 fae9 	bl	203e70 <chMtxObjectInit>
  chMtxObjectInit(&m2);
  20a89e:	4804      	ldr	r0, [pc, #16]	@ (20a8b0 <rt_test_008_009_setup+0x20>)
  20a8a0:	f7f9 fae6 	bl	203e70 <chMtxObjectInit>
}
  20a8a4:	bf00      	nop
  20a8a6:	bd08      	pop	{r3, pc}
  20a8a8:	20020020 	.word	0x20020020
  20a8ac:	20020000 	.word	0x20020000
  20a8b0:	20020010 	.word	0x20020010
	...

0020a8c0 <rt_test_008_009_execute>:

static void rt_test_008_009_execute(void) {
  20a8c0:	b500      	push	{lr}
  20a8c2:	b085      	sub	sp, #20
  tprio_t prio;

  /* [8.9.1] Reading current base priority.*/
  test_set_step(1);
  20a8c4:	4b29      	ldr	r3, [pc, #164]	@ (20a96c <rt_test_008_009_execute+0xac>)
  20a8c6:	2201      	movs	r2, #1
  20a8c8:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
  20a8ca:	f7ff fba1 	bl	20a010 <chThdGetPriorityX.lto_priv.3>
  20a8ce:	9003      	str	r0, [sp, #12]
  }
  test_end_step(1);

  /* [8.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  20a8d0:	4b26      	ldr	r3, [pc, #152]	@ (20a96c <rt_test_008_009_execute+0xac>)
  20a8d2:	2202      	movs	r2, #2
  20a8d4:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
  20a8d6:	4b26      	ldr	r3, [pc, #152]	@ (20a970 <rt_test_008_009_execute+0xb0>)
  20a8d8:	6818      	ldr	r0, [r3, #0]
  20a8da:	9b03      	ldr	r3, [sp, #12]
  20a8dc:	1c5a      	adds	r2, r3, #1
  20a8de:	4b25      	ldr	r3, [pc, #148]	@ (20a974 <rt_test_008_009_execute+0xb4>)
  20a8e0:	9300      	str	r3, [sp, #0]
  20a8e2:	4b25      	ldr	r3, [pc, #148]	@ (20a978 <rt_test_008_009_execute+0xb8>)
  20a8e4:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a8e8:	f7f8 fd4a 	bl	203380 <chThdCreateStatic>
  20a8ec:	4603      	mov	r3, r0
  20a8ee:	4a23      	ldr	r2, [pc, #140]	@ (20a97c <rt_test_008_009_execute+0xbc>)
  20a8f0:	6013      	str	r3, [r2, #0]
  }
  test_end_step(2);

  /* [8.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  20a8f2:	4b1e      	ldr	r3, [pc, #120]	@ (20a96c <rt_test_008_009_execute+0xac>)
  20a8f4:	2203      	movs	r2, #3
  20a8f6:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
  20a8f8:	4b1d      	ldr	r3, [pc, #116]	@ (20a970 <rt_test_008_009_execute+0xb0>)
  20a8fa:	6858      	ldr	r0, [r3, #4]
  20a8fc:	9b03      	ldr	r3, [sp, #12]
  20a8fe:	1c9a      	adds	r2, r3, #2
  20a900:	4b1f      	ldr	r3, [pc, #124]	@ (20a980 <rt_test_008_009_execute+0xc0>)
  20a902:	9300      	str	r3, [sp, #0]
  20a904:	4b1f      	ldr	r3, [pc, #124]	@ (20a984 <rt_test_008_009_execute+0xc4>)
  20a906:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a90a:	f7f8 fd39 	bl	203380 <chThdCreateStatic>
  20a90e:	4603      	mov	r3, r0
  20a910:	4a1a      	ldr	r2, [pc, #104]	@ (20a97c <rt_test_008_009_execute+0xbc>)
  20a912:	6053      	str	r3, [r2, #4]
  }
  test_end_step(3);

  /* [8.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  20a914:	4b15      	ldr	r3, [pc, #84]	@ (20a96c <rt_test_008_009_execute+0xac>)
  20a916:	2204      	movs	r2, #4
  20a918:	601a      	str	r2, [r3, #0]
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
  20a91a:	4b15      	ldr	r3, [pc, #84]	@ (20a970 <rt_test_008_009_execute+0xb0>)
  20a91c:	6898      	ldr	r0, [r3, #8]
  20a91e:	9b03      	ldr	r3, [sp, #12]
  20a920:	1cda      	adds	r2, r3, #3
  20a922:	4b19      	ldr	r3, [pc, #100]	@ (20a988 <rt_test_008_009_execute+0xc8>)
  20a924:	9300      	str	r3, [sp, #0]
  20a926:	4b19      	ldr	r3, [pc, #100]	@ (20a98c <rt_test_008_009_execute+0xcc>)
  20a928:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20a92c:	f7f8 fd28 	bl	203380 <chThdCreateStatic>
  20a930:	4603      	mov	r3, r0
  20a932:	4a12      	ldr	r2, [pc, #72]	@ (20a97c <rt_test_008_009_execute+0xbc>)
  20a934:	6093      	str	r3, [r2, #8]
  test_end_step(4);

  /* [8.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
  20a936:	4b0d      	ldr	r3, [pc, #52]	@ (20a96c <rt_test_008_009_execute+0xac>)
  20a938:	2205      	movs	r2, #5
  20a93a:	601a      	str	r2, [r3, #0]
  {
    chCondSignal(&c1);
  20a93c:	4814      	ldr	r0, [pc, #80]	@ (20a990 <rt_test_008_009_execute+0xd0>)
  20a93e:	f7f9 fce7 	bl	204310 <chCondSignal>
  }
  test_end_step(5);

  /* [8.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
  20a942:	4b0a      	ldr	r3, [pc, #40]	@ (20a96c <rt_test_008_009_execute+0xac>)
  20a944:	2206      	movs	r2, #6
  20a946:	601a      	str	r2, [r3, #0]
  {
    chCondSignal(&c1);
  20a948:	4811      	ldr	r0, [pc, #68]	@ (20a990 <rt_test_008_009_execute+0xd0>)
  20a94a:	f7f9 fce1 	bl	204310 <chCondSignal>
  }
  test_end_step(6);

  /* [8.9.7] Checking the order of operations.*/
  test_set_step(7);
  20a94e:	4b07      	ldr	r3, [pc, #28]	@ (20a96c <rt_test_008_009_execute+0xac>)
  20a950:	2207      	movs	r2, #7
  20a952:	601a      	str	r2, [r3, #0]
  {
    test_wait_threads();
  20a954:	f7fd fa54 	bl	207e00 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
  20a958:	490e      	ldr	r1, [pc, #56]	@ (20a994 <rt_test_008_009_execute+0xd4>)
  20a95a:	480f      	ldr	r0, [pc, #60]	@ (20a998 <rt_test_008_009_execute+0xd8>)
  20a95c:	f7fc fe98 	bl	207690 <__test_assert_sequence>
  20a960:	4603      	mov	r3, r0
  20a962:	2b00      	cmp	r3, #0
  }
  test_end_step(7);
}
  20a964:	b005      	add	sp, #20
  20a966:	f85d fb04 	ldr.w	pc, [sp], #4
  20a96a:	bf00      	nop
  20a96c:	20000bb4 	.word	0x20000bb4
  20a970:	08012220 	.word	0x08012220
  20a974:	080116f0 	.word	0x080116f0
  20a978:	0020a101 	.word	0x0020a101
  20a97c:	20001900 	.word	0x20001900
  20a980:	080116e8 	.word	0x080116e8
  20a984:	0020a0c1 	.word	0x0020a0c1
  20a988:	080116ec 	.word	0x080116ec
  20a98c:	0020a151 	.word	0x0020a151
  20a990:	20020020 	.word	0x20020020
  20a994:	080116f4 	.word	0x080116f4
  20a998:	0801189c 	.word	0x0801189c
  20a99c:	00000000 	.word	0x00000000

0020a9a0 <chSysLock.lto_priv.25>:
static inline void chSysLock(void) {
  20a9a0:	b082      	sub	sp, #8
  20a9a2:	2330      	movs	r3, #48	@ 0x30
  20a9a4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a9a6:	9b01      	ldr	r3, [sp, #4]
  20a9a8:	f383 8811 	msr	BASEPRI, r3
}
  20a9ac:	bf00      	nop
}
  20a9ae:	bf00      	nop
}
  20a9b0:	bf00      	nop
  20a9b2:	b002      	add	sp, #8
  20a9b4:	4770      	bx	lr
  20a9b6:	bf00      	nop
	...

0020a9c0 <chSysUnlock.lto_priv.25>:
static inline void chSysUnlock(void) {
  20a9c0:	b082      	sub	sp, #8
  20a9c2:	2300      	movs	r3, #0
  20a9c4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a9c6:	9b01      	ldr	r3, [sp, #4]
  20a9c8:	f383 8811 	msr	BASEPRI, r3
}
  20a9cc:	bf00      	nop
}
  20a9ce:	bf00      	nop
}
  20a9d0:	bf00      	nop
  20a9d2:	b002      	add	sp, #8
  20a9d4:	4770      	bx	lr
  20a9d6:	bf00      	nop
	...

0020a9e0 <chThdGetSelfX.lto_priv.10>:
  return __sch_get_currthread();
  20a9e0:	4b01      	ldr	r3, [pc, #4]	@ (20a9e8 <chThdGetSelfX.lto_priv.10+0x8>)
  20a9e2:	68db      	ldr	r3, [r3, #12]
}
  20a9e4:	4618      	mov	r0, r3
  20a9e6:	4770      	bx	lr
  20a9e8:	20000890 	.word	0x20000890
  20a9ec:	00000000 	.word	0x00000000

0020a9f0 <chThdGetPriorityX.lto_priv.4>:
static inline tprio_t chThdGetPriorityX(void) {
  20a9f0:	b508      	push	{r3, lr}
  return chThdGetSelfX()->hdr.pqueue.prio;
  20a9f2:	f7ff fff5 	bl	20a9e0 <chThdGetSelfX.lto_priv.10>
  20a9f6:	4603      	mov	r3, r0
  20a9f8:	689b      	ldr	r3, [r3, #8]
}
  20a9fa:	4618      	mov	r0, r3
  20a9fc:	bd08      	pop	{r3, pc}
  20a9fe:	bf00      	nop

0020aa00 <chMsgWait.lto_priv.1>:
static inline thread_t *chMsgWait(void) {
  20aa00:	b500      	push	{lr}
  20aa02:	b083      	sub	sp, #12
  chSysLock();
  20aa04:	f7ff ffcc 	bl	20a9a0 <chSysLock.lto_priv.25>
  tp = chMsgWaitS();
  20aa08:	f7fa f8e2 	bl	204bd0 <chMsgWaitS>
  20aa0c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
  20aa0e:	f7ff ffd7 	bl	20a9c0 <chSysUnlock.lto_priv.25>
  return tp;
  20aa12:	9b01      	ldr	r3, [sp, #4]
}
  20aa14:	4618      	mov	r0, r3
  20aa16:	b003      	add	sp, #12
  20aa18:	f85d fb04 	ldr.w	pc, [sp], #4
  20aa1c:	0000      	movs	r0, r0
	...

0020aa20 <chMsgGet.lto_priv.1>:
static inline msg_t chMsgGet(thread_t *tp) {
  20aa20:	b082      	sub	sp, #8
  20aa22:	9001      	str	r0, [sp, #4]
  return tp->u.sentmsg;
  20aa24:	9b01      	ldr	r3, [sp, #4]
  20aa26:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
}
  20aa28:	4618      	mov	r0, r3
  20aa2a:	b002      	add	sp, #8
  20aa2c:	4770      	bx	lr
  20aa2e:	bf00      	nop

0020aa30 <msg_thread1>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
  20aa30:	b500      	push	{lr}
  20aa32:	b083      	sub	sp, #12
  20aa34:	9001      	str	r0, [sp, #4]

  chMsgSend(p, 'A');
  20aa36:	2141      	movs	r1, #65	@ 0x41
  20aa38:	9801      	ldr	r0, [sp, #4]
  20aa3a:	f7fa f8a1 	bl	204b80 <chMsgSend>
  chMsgSend(p, 'B');
  20aa3e:	2142      	movs	r1, #66	@ 0x42
  20aa40:	9801      	ldr	r0, [sp, #4]
  20aa42:	f7fa f89d 	bl	204b80 <chMsgSend>
  chMsgSend(p, 'C');
  20aa46:	2143      	movs	r1, #67	@ 0x43
  20aa48:	9801      	ldr	r0, [sp, #4]
  20aa4a:	f7fa f899 	bl	204b80 <chMsgSend>
  chMsgSend(p, 'D');
  20aa4e:	2144      	movs	r1, #68	@ 0x44
  20aa50:	9801      	ldr	r0, [sp, #4]
  20aa52:	f7fa f895 	bl	204b80 <chMsgSend>
}
  20aa56:	bf00      	nop
  20aa58:	b003      	add	sp, #12
  20aa5a:	f85d fb04 	ldr.w	pc, [sp], #4
  20aa5e:	bf00      	nop

0020aa60 <rt_test_009_001_execute>:
 * - [9.1.1] Starting the messenger thread.
 * - [9.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void rt_test_009_001_execute(void) {
  20aa60:	b530      	push	{r4, r5, lr}
  20aa62:	b087      	sub	sp, #28
  thread_t *tp;
  msg_t msg;

  /* [9.1.1] Starting the messenger thread.*/
  test_set_step(1);
  20aa64:	4b1e      	ldr	r3, [pc, #120]	@ (20aae0 <rt_test_009_001_execute+0x80>)
  20aa66:	2201      	movs	r2, #1
  20aa68:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
  20aa6a:	4b1e      	ldr	r3, [pc, #120]	@ (20aae4 <rt_test_009_001_execute+0x84>)
  20aa6c:	681c      	ldr	r4, [r3, #0]
  20aa6e:	f7ff ffbf 	bl	20a9f0 <chThdGetPriorityX.lto_priv.4>
  20aa72:	4603      	mov	r3, r0
  20aa74:	1c5d      	adds	r5, r3, #1
                                   msg_thread1, chThdGetSelfX());
  20aa76:	f7ff ffb3 	bl	20a9e0 <chThdGetSelfX.lto_priv.10>
  20aa7a:	4603      	mov	r3, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
  20aa7c:	9300      	str	r3, [sp, #0]
  20aa7e:	4b1a      	ldr	r3, [pc, #104]	@ (20aae8 <rt_test_009_001_execute+0x88>)
  20aa80:	462a      	mov	r2, r5
  20aa82:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20aa86:	4620      	mov	r0, r4
  20aa88:	f7f8 fc7a 	bl	203380 <chThdCreateStatic>
  20aa8c:	4603      	mov	r3, r0
  20aa8e:	4a17      	ldr	r2, [pc, #92]	@ (20aaec <rt_test_009_001_execute+0x8c>)
  20aa90:	6013      	str	r3, [r2, #0]
  }
  test_end_step(1);

  /* [9.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
  20aa92:	4b13      	ldr	r3, [pc, #76]	@ (20aae0 <rt_test_009_001_execute+0x80>)
  20aa94:	2202      	movs	r2, #2
  20aa96:	601a      	str	r2, [r3, #0]
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
  20aa98:	2300      	movs	r3, #0
  20aa9a:	9305      	str	r3, [sp, #20]
  20aa9c:	e012      	b.n	20aac4 <rt_test_009_001_execute+0x64>
      tp = chMsgWait();
  20aa9e:	f7ff ffaf 	bl	20aa00 <chMsgWait.lto_priv.1>
  20aaa2:	9004      	str	r0, [sp, #16]
      msg = chMsgGet(tp);
  20aaa4:	9804      	ldr	r0, [sp, #16]
  20aaa6:	f7ff ffbb 	bl	20aa20 <chMsgGet.lto_priv.1>
  20aaaa:	9003      	str	r0, [sp, #12]
      chMsgRelease(tp, msg);
  20aaac:	9903      	ldr	r1, [sp, #12]
  20aaae:	9804      	ldr	r0, [sp, #16]
  20aab0:	f7fa f8ae 	bl	204c10 <chMsgRelease>
      test_emit_token(msg);
  20aab4:	9b03      	ldr	r3, [sp, #12]
  20aab6:	b2db      	uxtb	r3, r3
  20aab8:	4618      	mov	r0, r3
  20aaba:	f7fc fe31 	bl	207720 <test_emit_token>
    for (i = 0; i < 4; i++) {
  20aabe:	9b05      	ldr	r3, [sp, #20]
  20aac0:	3301      	adds	r3, #1
  20aac2:	9305      	str	r3, [sp, #20]
  20aac4:	9b05      	ldr	r3, [sp, #20]
  20aac6:	2b03      	cmp	r3, #3
  20aac8:	d9e9      	bls.n	20aa9e <rt_test_009_001_execute+0x3e>
    }
    test_wait_threads();
  20aaca:	f7fd f999 	bl	207e00 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
  20aace:	4908      	ldr	r1, [pc, #32]	@ (20aaf0 <rt_test_009_001_execute+0x90>)
  20aad0:	4808      	ldr	r0, [pc, #32]	@ (20aaf4 <rt_test_009_001_execute+0x94>)
  20aad2:	f7fc fddd 	bl	207690 <__test_assert_sequence>
  20aad6:	4603      	mov	r3, r0
  20aad8:	2b00      	cmp	r3, #0
  }
  test_end_step(2);
}
  20aada:	b007      	add	sp, #28
  20aadc:	bd30      	pop	{r4, r5, pc}
  20aade:	bf00      	nop
  20aae0:	20000bb4 	.word	0x20000bb4
  20aae4:	08012220 	.word	0x08012220
  20aae8:	0020aa31 	.word	0x0020aa31
  20aaec:	20001900 	.word	0x20001900
  20aaf0:	080116f4 	.word	0x080116f4
  20aaf4:	080118a0 	.word	0x080118a0
	...

0020ab00 <chTimeAddX.lto_priv.5>:
                                   sysinterval_t interval) {
  20ab00:	b082      	sub	sp, #8
  20ab02:	9001      	str	r0, [sp, #4]
  20ab04:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
  20ab06:	9a01      	ldr	r2, [sp, #4]
  20ab08:	9b00      	ldr	r3, [sp, #0]
  20ab0a:	4413      	add	r3, r2
}
  20ab0c:	4618      	mov	r0, r3
  20ab0e:	b002      	add	sp, #8
  20ab10:	4770      	bx	lr
  20ab12:	bf00      	nop
	...

0020ab20 <chSysLock.lto_priv.26>:
static inline void chSysLock(void) {
  20ab20:	b082      	sub	sp, #8
  20ab22:	2330      	movs	r3, #48	@ 0x30
  20ab24:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ab26:	9b01      	ldr	r3, [sp, #4]
  20ab28:	f383 8811 	msr	BASEPRI, r3
}
  20ab2c:	bf00      	nop
}
  20ab2e:	bf00      	nop
}
  20ab30:	bf00      	nop
  20ab32:	b002      	add	sp, #8
  20ab34:	4770      	bx	lr
  20ab36:	bf00      	nop
	...

0020ab40 <chSysUnlock.lto_priv.26>:
static inline void chSysUnlock(void) {
  20ab40:	b082      	sub	sp, #8
  20ab42:	2300      	movs	r3, #0
  20ab44:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ab46:	9b01      	ldr	r3, [sp, #4]
  20ab48:	f383 8811 	msr	BASEPRI, r3
}
  20ab4c:	bf00      	nop
}
  20ab4e:	bf00      	nop
}
  20ab50:	bf00      	nop
  20ab52:	b002      	add	sp, #8
  20ab54:	4770      	bx	lr
  20ab56:	bf00      	nop
	...

0020ab60 <chThdGetSelfX.lto_priv.11>:
  return __sch_get_currthread();
  20ab60:	4b01      	ldr	r3, [pc, #4]	@ (20ab68 <chThdGetSelfX.lto_priv.11+0x8>)
  20ab62:	68db      	ldr	r3, [r3, #12]
}
  20ab64:	4618      	mov	r0, r3
  20ab66:	4770      	bx	lr
  20ab68:	20000890 	.word	0x20000890
  20ab6c:	00000000 	.word	0x00000000

0020ab70 <chThdGetPriorityX.lto_priv.5>:
static inline tprio_t chThdGetPriorityX(void) {
  20ab70:	b508      	push	{r3, lr}
  return chThdGetSelfX()->hdr.pqueue.prio;
  20ab72:	f7ff fff5 	bl	20ab60 <chThdGetSelfX.lto_priv.11>
  20ab76:	4603      	mov	r3, r0
  20ab78:	689b      	ldr	r3, [r3, #8]
}
  20ab7a:	4618      	mov	r0, r3
  20ab7c:	bd08      	pop	{r3, pc}
  20ab7e:	bf00      	nop

0020ab80 <chEvtRegisterMask>:
                                     eventmask_t events) {
  20ab80:	b500      	push	{lr}
  20ab82:	b085      	sub	sp, #20
  20ab84:	9003      	str	r0, [sp, #12]
  20ab86:	9102      	str	r1, [sp, #8]
  20ab88:	9201      	str	r2, [sp, #4]
  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
  20ab8a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  20ab8e:	9a01      	ldr	r2, [sp, #4]
  20ab90:	9902      	ldr	r1, [sp, #8]
  20ab92:	9803      	ldr	r0, [sp, #12]
  20ab94:	f7f9 fd04 	bl	2045a0 <chEvtRegisterMaskWithFlags>
}
  20ab98:	bf00      	nop
  20ab9a:	b005      	add	sp, #20
  20ab9c:	f85d fb04 	ldr.w	pc, [sp], #4

0020aba0 <chEvtIsListeningI>:
static inline bool chEvtIsListeningI(event_source_t *esp) {
  20aba0:	b082      	sub	sp, #8
  20aba2:	9001      	str	r0, [sp, #4]
  return (bool)(esp != (event_source_t *)esp->next);
  20aba4:	9b01      	ldr	r3, [sp, #4]
  20aba6:	681b      	ldr	r3, [r3, #0]
  20aba8:	9a01      	ldr	r2, [sp, #4]
  20abaa:	429a      	cmp	r2, r3
  20abac:	bf14      	ite	ne
  20abae:	2301      	movne	r3, #1
  20abb0:	2300      	moveq	r3, #0
  20abb2:	b2db      	uxtb	r3, r3
}
  20abb4:	4618      	mov	r0, r3
  20abb6:	b002      	add	sp, #8
  20abb8:	4770      	bx	lr
  20abba:	bf00      	nop
  20abbc:	0000      	movs	r0, r0
	...

0020abc0 <chEvtBroadcast>:
static inline void chEvtBroadcast(event_source_t *esp) {
  20abc0:	b500      	push	{lr}
  20abc2:	b083      	sub	sp, #12
  20abc4:	9001      	str	r0, [sp, #4]
  chEvtBroadcastFlags(esp, (eventflags_t)0);
  20abc6:	2100      	movs	r1, #0
  20abc8:	9801      	ldr	r0, [sp, #4]
  20abca:	f7f9 fdd9 	bl	204780 <chEvtBroadcastFlags>
}
  20abce:	bf00      	nop
  20abd0:	b003      	add	sp, #12
  20abd2:	f85d fb04 	ldr.w	pc, [sp], #4
  20abd6:	bf00      	nop
	...

0020abe0 <osalSysLock.lto_priv.4>:
static inline void osalSysLock(void) {
  20abe0:	b508      	push	{r3, lr}
  chSysLock();
  20abe2:	f7ff ff9d 	bl	20ab20 <chSysLock.lto_priv.26>
}
  20abe6:	bf00      	nop
  20abe8:	bd08      	pop	{r3, pc}
  20abea:	bf00      	nop
  20abec:	0000      	movs	r0, r0
	...

0020abf0 <osalSysUnlock.lto_priv.4>:
static inline void osalSysUnlock(void) {
  20abf0:	b508      	push	{r3, lr}
  chSysUnlock();
  20abf2:	f7ff ffa5 	bl	20ab40 <chSysUnlock.lto_priv.26>
}
  20abf6:	bf00      	nop
  20abf8:	bd08      	pop	{r3, pc}
  20abfa:	bf00      	nop
  20abfc:	0000      	movs	r0, r0
	...

0020ac00 <h1>:
 ****************************************************************************/

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
  20ac00:	b500      	push	{lr}
  20ac02:	b083      	sub	sp, #12
  20ac04:	9001      	str	r0, [sp, #4]
  20ac06:	2041      	movs	r0, #65	@ 0x41
  20ac08:	f7fc fd8a 	bl	207720 <test_emit_token>
  20ac0c:	bf00      	nop
  20ac0e:	b003      	add	sp, #12
  20ac10:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0020ac20 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
  20ac20:	b500      	push	{lr}
  20ac22:	b083      	sub	sp, #12
  20ac24:	9001      	str	r0, [sp, #4]
  20ac26:	2042      	movs	r0, #66	@ 0x42
  20ac28:	f7fc fd7a 	bl	207720 <test_emit_token>
  20ac2c:	bf00      	nop
  20ac2e:	b003      	add	sp, #12
  20ac30:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0020ac40 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
  20ac40:	b500      	push	{lr}
  20ac42:	b083      	sub	sp, #12
  20ac44:	9001      	str	r0, [sp, #4]
  20ac46:	2043      	movs	r0, #67	@ 0x43
  20ac48:	f7fc fd6a 	bl	207720 <test_emit_token>
  20ac4c:	bf00      	nop
  20ac4e:	b003      	add	sp, #12
  20ac50:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0020ac60 <evt_thread3>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static THD_FUNCTION(evt_thread3, p) {
  20ac60:	b500      	push	{lr}
  20ac62:	b083      	sub	sp, #12
  20ac64:	9001      	str	r0, [sp, #4]

  chThdSleepMilliseconds(50);
  20ac66:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  20ac6a:	f7f8 fcc1 	bl	2035f0 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
  20ac6e:	2101      	movs	r1, #1
  20ac70:	9801      	ldr	r0, [sp, #4]
  20ac72:	f7f9 fd3d 	bl	2046f0 <chEvtSignal>
}
  20ac76:	bf00      	nop
  20ac78:	b003      	add	sp, #12
  20ac7a:	f85d fb04 	ldr.w	pc, [sp], #4
  20ac7e:	bf00      	nop

0020ac80 <evt_thread7>:

static THD_FUNCTION(evt_thread7, p) {
  20ac80:	b500      	push	{lr}
  20ac82:	b083      	sub	sp, #12
  20ac84:	9001      	str	r0, [sp, #4]

  (void)p;
  chEvtBroadcast(&es1);
  20ac86:	4807      	ldr	r0, [pc, #28]	@ (20aca4 <evt_thread7+0x24>)
  20ac88:	f7ff ff9a 	bl	20abc0 <chEvtBroadcast>
  chThdSleepMilliseconds(50);
  20ac8c:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  20ac90:	f7f8 fcae 	bl	2035f0 <chThdSleep>
  chEvtBroadcast(&es2);
  20ac94:	4804      	ldr	r0, [pc, #16]	@ (20aca8 <evt_thread7+0x28>)
  20ac96:	f7ff ff93 	bl	20abc0 <chEvtBroadcast>
}
  20ac9a:	bf00      	nop
  20ac9c:	b003      	add	sp, #12
  20ac9e:	f85d fb04 	ldr.w	pc, [sp], #4
  20aca2:	bf00      	nop
  20aca4:	20020028 	.word	0x20020028
  20aca8:	2002002c 	.word	0x2002002c
  20acac:	00000000 	.word	0x00000000

0020acb0 <rt_test_010_001_execute>:
 * - [10.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void rt_test_010_001_execute(void) {
  20acb0:	b500      	push	{lr}
  20acb2:	b08b      	sub	sp, #44	@ 0x2c
  event_listener_t el1, el2;

  /* [10.1.1] An Event Source is initialized.*/
  test_set_step(1);
  20acb4:	4b34      	ldr	r3, [pc, #208]	@ (20ad88 <rt_test_010_001_execute+0xd8>)
  20acb6:	2201      	movs	r2, #1
  20acb8:	601a      	str	r2, [r3, #0]
  {
    chEvtObjectInit(&es1);
  20acba:	4834      	ldr	r0, [pc, #208]	@ (20ad8c <rt_test_010_001_execute+0xdc>)
  20acbc:	f7f9 fc48 	bl	204550 <chEvtObjectInit>
  }
  test_end_step(1);

  /* [10.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
  20acc0:	4b31      	ldr	r3, [pc, #196]	@ (20ad88 <rt_test_010_001_execute+0xd8>)
  20acc2:	2202      	movs	r2, #2
  20acc4:	601a      	str	r2, [r3, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
  20acc6:	ab05      	add	r3, sp, #20
  20acc8:	2201      	movs	r2, #1
  20acca:	4619      	mov	r1, r3
  20accc:	482f      	ldr	r0, [pc, #188]	@ (20ad8c <rt_test_010_001_execute+0xdc>)
  20acce:	f7ff ff57 	bl	20ab80 <chEvtRegisterMask>
    chEvtRegisterMask(&es1, &el2, 2);
  20acd2:	466b      	mov	r3, sp
  20acd4:	2202      	movs	r2, #2
  20acd6:	4619      	mov	r1, r3
  20acd8:	482c      	ldr	r0, [pc, #176]	@ (20ad8c <rt_test_010_001_execute+0xdc>)
  20acda:	f7ff ff51 	bl	20ab80 <chEvtRegisterMask>
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  20acde:	f7ff ff7f 	bl	20abe0 <osalSysLock.lto_priv.4>
  20ace2:	482a      	ldr	r0, [pc, #168]	@ (20ad8c <rt_test_010_001_execute+0xdc>)
  20ace4:	f7ff ff5c 	bl	20aba0 <chEvtIsListeningI>
  20ace8:	4603      	mov	r3, r0
  20acea:	4929      	ldr	r1, [pc, #164]	@ (20ad90 <rt_test_010_001_execute+0xe0>)
  20acec:	4618      	mov	r0, r3
  20acee:	f7fc fcb7 	bl	207660 <__test_assert>
  20acf2:	4603      	mov	r3, r0
  20acf4:	2b00      	cmp	r3, #0
  20acf6:	d002      	beq.n	20acfe <rt_test_010_001_execute+0x4e>
  20acf8:	f7ff ff7a 	bl	20abf0 <osalSysUnlock.lto_priv.4>
  20acfc:	e040      	b.n	20ad80 <rt_test_010_001_execute+0xd0>
  20acfe:	f7ff ff77 	bl	20abf0 <osalSysUnlock.lto_priv.4>
  }
  test_end_step(2);

  /* [10.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
  20ad02:	4b21      	ldr	r3, [pc, #132]	@ (20ad88 <rt_test_010_001_execute+0xd8>)
  20ad04:	2203      	movs	r2, #3
  20ad06:	601a      	str	r2, [r3, #0]
  {
    chEvtUnregister(&es1, &el1);
  20ad08:	ab05      	add	r3, sp, #20
  20ad0a:	4619      	mov	r1, r3
  20ad0c:	481f      	ldr	r0, [pc, #124]	@ (20ad8c <rt_test_010_001_execute+0xdc>)
  20ad0e:	f7f9 fc5f 	bl	2045d0 <chEvtUnregister>
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  20ad12:	f7ff ff65 	bl	20abe0 <osalSysLock.lto_priv.4>
  20ad16:	481d      	ldr	r0, [pc, #116]	@ (20ad8c <rt_test_010_001_execute+0xdc>)
  20ad18:	f7ff ff42 	bl	20aba0 <chEvtIsListeningI>
  20ad1c:	4603      	mov	r3, r0
  20ad1e:	491c      	ldr	r1, [pc, #112]	@ (20ad90 <rt_test_010_001_execute+0xe0>)
  20ad20:	4618      	mov	r0, r3
  20ad22:	f7fc fc9d 	bl	207660 <__test_assert>
  20ad26:	4603      	mov	r3, r0
  20ad28:	2b00      	cmp	r3, #0
  20ad2a:	d002      	beq.n	20ad32 <rt_test_010_001_execute+0x82>
  20ad2c:	f7ff ff60 	bl	20abf0 <osalSysUnlock.lto_priv.4>
  20ad30:	e026      	b.n	20ad80 <rt_test_010_001_execute+0xd0>
  20ad32:	f7ff ff5d 	bl	20abf0 <osalSysUnlock.lto_priv.4>
  }
  test_end_step(3);

  /* [10.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
  20ad36:	4b14      	ldr	r3, [pc, #80]	@ (20ad88 <rt_test_010_001_execute+0xd8>)
  20ad38:	2204      	movs	r2, #4
  20ad3a:	601a      	str	r2, [r3, #0]
  {
    chEvtUnregister(&es1, &el2);
  20ad3c:	466b      	mov	r3, sp
  20ad3e:	4619      	mov	r1, r3
  20ad40:	4812      	ldr	r0, [pc, #72]	@ (20ad8c <rt_test_010_001_execute+0xdc>)
  20ad42:	f7f9 fc45 	bl	2045d0 <chEvtUnregister>
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
  20ad46:	f7ff ff4b 	bl	20abe0 <osalSysLock.lto_priv.4>
  20ad4a:	4810      	ldr	r0, [pc, #64]	@ (20ad8c <rt_test_010_001_execute+0xdc>)
  20ad4c:	f7ff ff28 	bl	20aba0 <chEvtIsListeningI>
  20ad50:	4603      	mov	r3, r0
  20ad52:	2b00      	cmp	r3, #0
  20ad54:	bf14      	ite	ne
  20ad56:	2301      	movne	r3, #1
  20ad58:	2300      	moveq	r3, #0
  20ad5a:	b2db      	uxtb	r3, r3
  20ad5c:	f083 0301 	eor.w	r3, r3, #1
  20ad60:	b2db      	uxtb	r3, r3
  20ad62:	f003 0301 	and.w	r3, r3, #1
  20ad66:	b2db      	uxtb	r3, r3
  20ad68:	490a      	ldr	r1, [pc, #40]	@ (20ad94 <rt_test_010_001_execute+0xe4>)
  20ad6a:	4618      	mov	r0, r3
  20ad6c:	f7fc fc78 	bl	207660 <__test_assert>
  20ad70:	4603      	mov	r3, r0
  20ad72:	2b00      	cmp	r3, #0
  20ad74:	d002      	beq.n	20ad7c <rt_test_010_001_execute+0xcc>
  20ad76:	f7ff ff3b 	bl	20abf0 <osalSysUnlock.lto_priv.4>
  20ad7a:	e001      	b.n	20ad80 <rt_test_010_001_execute+0xd0>
  20ad7c:	f7ff ff38 	bl	20abf0 <osalSysUnlock.lto_priv.4>
  }
  test_end_step(4);
}
  20ad80:	b00b      	add	sp, #44	@ 0x2c
  20ad82:	f85d fb04 	ldr.w	pc, [sp], #4
  20ad86:	bf00      	nop
  20ad88:	20000bb4 	.word	0x20000bb4
  20ad8c:	20020028 	.word	0x20020028
  20ad90:	080118a8 	.word	0x080118a8
  20ad94:	080118b4 	.word	0x080118b4
	...

0020ada0 <rt_test_010_002_setup>:
 * - [10.2.1] Three evenf flag bits are raised then chEvtDispatch() is
 *   invoked, the sequence of handlers calls is tested.
 * .
 */

static void rt_test_010_002_setup(void) {
  20ada0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
  20ada2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20ada6:	f7f9 fc53 	bl	204650 <chEvtGetAndClearEvents>
}
  20adaa:	bf00      	nop
  20adac:	bd08      	pop	{r3, pc}
  20adae:	bf00      	nop

0020adb0 <rt_test_010_002_execute>:

static void rt_test_010_002_execute(void) {
  20adb0:	b508      	push	{r3, lr}

  /* [10.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
  20adb2:	4b07      	ldr	r3, [pc, #28]	@ (20add0 <rt_test_010_002_execute+0x20>)
  20adb4:	2201      	movs	r2, #1
  20adb6:	601a      	str	r2, [r3, #0]
  {
    chEvtDispatch(evhndl, 7);
  20adb8:	2107      	movs	r1, #7
  20adba:	4806      	ldr	r0, [pc, #24]	@ (20add4 <rt_test_010_002_execute+0x24>)
  20adbc:	f7f9 fcf8 	bl	2047b0 <chEvtDispatch>
    test_assert_sequence("ABC", "invalid sequence");
  20adc0:	4905      	ldr	r1, [pc, #20]	@ (20add8 <rt_test_010_002_execute+0x28>)
  20adc2:	4806      	ldr	r0, [pc, #24]	@ (20addc <rt_test_010_002_execute+0x2c>)
  20adc4:	f7fc fc64 	bl	207690 <__test_assert_sequence>
  20adc8:	4603      	mov	r3, r0
  20adca:	2b00      	cmp	r3, #0
  }
  test_end_step(1);
}
  20adcc:	bd08      	pop	{r3, pc}
  20adce:	bf00      	nop
  20add0:	20000bb4 	.word	0x20000bb4
  20add4:	080124bc 	.word	0x080124bc
  20add8:	080116f4 	.word	0x080116f4
  20addc:	0801189c 	.word	0x0801189c

0020ade0 <rt_test_010_003_setup>:
 *   been received after 50mS and that the event flags mask has been
 *   emptied.
 * .
 */

static void rt_test_010_003_setup(void) {
  20ade0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
  20ade2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20ade6:	f7f9 fc33 	bl	204650 <chEvtGetAndClearEvents>
}
  20adea:	bf00      	nop
  20adec:	bd08      	pop	{r3, pc}
  20adee:	bf00      	nop

0020adf0 <rt_test_010_003_execute>:

static void rt_test_010_003_execute(void) {
  20adf0:	b530      	push	{r4, r5, lr}
  20adf2:	b085      	sub	sp, #20
  eventmask_t m;
  systime_t target_time;

  /* [10.3.1] Setting three event flags.*/
  test_set_step(1);
  20adf4:	4b54      	ldr	r3, [pc, #336]	@ (20af48 <rt_test_010_003_execute+0x158>)
  20adf6:	2201      	movs	r2, #1
  20adf8:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(7);
  20adfa:	2007      	movs	r0, #7
  20adfc:	f7f9 fc38 	bl	204670 <chEvtAddEvents>
  }
  test_end_step(1);

  /* [10.3.2] Calling chEvtWaitOne() three times, each time a single
     flag must be returned in order of priority.*/
  test_set_step(2);
  20ae00:	4b51      	ldr	r3, [pc, #324]	@ (20af48 <rt_test_010_003_execute+0x158>)
  20ae02:	2202      	movs	r2, #2
  20ae04:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
  20ae06:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20ae0a:	f7f9 fd01 	bl	204810 <chEvtWaitOne>
  20ae0e:	9003      	str	r0, [sp, #12]
    test_assert(m == 1, "single event error");
  20ae10:	9b03      	ldr	r3, [sp, #12]
  20ae12:	2b01      	cmp	r3, #1
  20ae14:	bf0c      	ite	eq
  20ae16:	2301      	moveq	r3, #1
  20ae18:	2300      	movne	r3, #0
  20ae1a:	b2db      	uxtb	r3, r3
  20ae1c:	494b      	ldr	r1, [pc, #300]	@ (20af4c <rt_test_010_003_execute+0x15c>)
  20ae1e:	4618      	mov	r0, r3
  20ae20:	f7fc fc1e 	bl	207660 <__test_assert>
  20ae24:	4603      	mov	r3, r0
  20ae26:	2b00      	cmp	r3, #0
  20ae28:	f040 808c 	bne.w	20af44 <rt_test_010_003_execute+0x154>
    m = chEvtWaitOne(ALL_EVENTS);
  20ae2c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20ae30:	f7f9 fcee 	bl	204810 <chEvtWaitOne>
  20ae34:	9003      	str	r0, [sp, #12]
    test_assert(m == 2, "single event error");
  20ae36:	9b03      	ldr	r3, [sp, #12]
  20ae38:	2b02      	cmp	r3, #2
  20ae3a:	bf0c      	ite	eq
  20ae3c:	2301      	moveq	r3, #1
  20ae3e:	2300      	movne	r3, #0
  20ae40:	b2db      	uxtb	r3, r3
  20ae42:	4942      	ldr	r1, [pc, #264]	@ (20af4c <rt_test_010_003_execute+0x15c>)
  20ae44:	4618      	mov	r0, r3
  20ae46:	f7fc fc0b 	bl	207660 <__test_assert>
  20ae4a:	4603      	mov	r3, r0
  20ae4c:	2b00      	cmp	r3, #0
  20ae4e:	d179      	bne.n	20af44 <rt_test_010_003_execute+0x154>
    m = chEvtWaitOne(ALL_EVENTS);
  20ae50:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20ae54:	f7f9 fcdc 	bl	204810 <chEvtWaitOne>
  20ae58:	9003      	str	r0, [sp, #12]
    test_assert(m == 4, "single event error");
  20ae5a:	9b03      	ldr	r3, [sp, #12]
  20ae5c:	2b04      	cmp	r3, #4
  20ae5e:	bf0c      	ite	eq
  20ae60:	2301      	moveq	r3, #1
  20ae62:	2300      	movne	r3, #0
  20ae64:	b2db      	uxtb	r3, r3
  20ae66:	4939      	ldr	r1, [pc, #228]	@ (20af4c <rt_test_010_003_execute+0x15c>)
  20ae68:	4618      	mov	r0, r3
  20ae6a:	f7fc fbf9 	bl	207660 <__test_assert>
  20ae6e:	4603      	mov	r3, r0
  20ae70:	2b00      	cmp	r3, #0
  20ae72:	d167      	bne.n	20af44 <rt_test_010_003_execute+0x154>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  20ae74:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20ae78:	f7f9 fbea 	bl	204650 <chEvtGetAndClearEvents>
  20ae7c:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
  20ae7e:	9b03      	ldr	r3, [sp, #12]
  20ae80:	2b00      	cmp	r3, #0
  20ae82:	bf0c      	ite	eq
  20ae84:	2301      	moveq	r3, #1
  20ae86:	2300      	movne	r3, #0
  20ae88:	b2db      	uxtb	r3, r3
  20ae8a:	4931      	ldr	r1, [pc, #196]	@ (20af50 <rt_test_010_003_execute+0x160>)
  20ae8c:	4618      	mov	r0, r3
  20ae8e:	f7fc fbe7 	bl	207660 <__test_assert>
  20ae92:	4603      	mov	r3, r0
  20ae94:	2b00      	cmp	r3, #0
  20ae96:	d155      	bne.n	20af44 <rt_test_010_003_execute+0x154>
  }
  test_end_step(2);

  /* [10.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  20ae98:	4b2b      	ldr	r3, [pc, #172]	@ (20af48 <rt_test_010_003_execute+0x158>)
  20ae9a:	2203      	movs	r2, #3
  20ae9c:	601a      	str	r2, [r3, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
  20ae9e:	f7fc ffd7 	bl	207e50 <test_wait_tick>
  20aea2:	4603      	mov	r3, r0
  20aea4:	f44f 71fa 	mov.w	r1, #500	@ 0x1f4
  20aea8:	4618      	mov	r0, r3
  20aeaa:	f7ff fe29 	bl	20ab00 <chTimeAddX.lto_priv.5>
  20aeae:	9002      	str	r0, [sp, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20aeb0:	4b28      	ldr	r3, [pc, #160]	@ (20af54 <rt_test_010_003_execute+0x164>)
  20aeb2:	681c      	ldr	r4, [r3, #0]
  20aeb4:	f7ff fe5c 	bl	20ab70 <chThdGetPriorityX.lto_priv.5>
  20aeb8:	4603      	mov	r3, r0
  20aeba:	1e5d      	subs	r5, r3, #1
                                   evt_thread3, chThdGetSelfX());
  20aebc:	f7ff fe50 	bl	20ab60 <chThdGetSelfX.lto_priv.11>
  20aec0:	4603      	mov	r3, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20aec2:	9300      	str	r3, [sp, #0]
  20aec4:	4b24      	ldr	r3, [pc, #144]	@ (20af58 <rt_test_010_003_execute+0x168>)
  20aec6:	462a      	mov	r2, r5
  20aec8:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20aecc:	4620      	mov	r0, r4
  20aece:	f7f8 fa57 	bl	203380 <chThdCreateStatic>
  20aed2:	4603      	mov	r3, r0
  20aed4:	4a21      	ldr	r2, [pc, #132]	@ (20af5c <rt_test_010_003_execute+0x16c>)
  20aed6:	6013      	str	r3, [r2, #0]
  test_end_step(3);

  /* [10.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  20aed8:	4b1b      	ldr	r3, [pc, #108]	@ (20af48 <rt_test_010_003_execute+0x158>)
  20aeda:	2204      	movs	r2, #4
  20aedc:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
  20aede:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20aee2:	f7f9 fc95 	bl	204810 <chEvtWaitOne>
  20aee6:	9003      	str	r0, [sp, #12]
    test_assert_time_window(target_time,
  20aee8:	2114      	movs	r1, #20
  20aeea:	9802      	ldr	r0, [sp, #8]
  20aeec:	f7ff fe08 	bl	20ab00 <chTimeAddX.lto_priv.5>
  20aef0:	4603      	mov	r3, r0
  20aef2:	4a1b      	ldr	r2, [pc, #108]	@ (20af60 <rt_test_010_003_execute+0x170>)
  20aef4:	4619      	mov	r1, r3
  20aef6:	9802      	ldr	r0, [sp, #8]
  20aef8:	f7fc fbfa 	bl	2076f0 <__test_assert_time_window>
  20aefc:	4603      	mov	r3, r0
  20aefe:	2b00      	cmp	r3, #0
  20af00:	d120      	bne.n	20af44 <rt_test_010_003_execute+0x154>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    test_assert(m == 1, "event flag error");
  20af02:	9b03      	ldr	r3, [sp, #12]
  20af04:	2b01      	cmp	r3, #1
  20af06:	bf0c      	ite	eq
  20af08:	2301      	moveq	r3, #1
  20af0a:	2300      	movne	r3, #0
  20af0c:	b2db      	uxtb	r3, r3
  20af0e:	4915      	ldr	r1, [pc, #84]	@ (20af64 <rt_test_010_003_execute+0x174>)
  20af10:	4618      	mov	r0, r3
  20af12:	f7fc fba5 	bl	207660 <__test_assert>
  20af16:	4603      	mov	r3, r0
  20af18:	2b00      	cmp	r3, #0
  20af1a:	d113      	bne.n	20af44 <rt_test_010_003_execute+0x154>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  20af1c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20af20:	f7f9 fb96 	bl	204650 <chEvtGetAndClearEvents>
  20af24:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
  20af26:	9b03      	ldr	r3, [sp, #12]
  20af28:	2b00      	cmp	r3, #0
  20af2a:	bf0c      	ite	eq
  20af2c:	2301      	moveq	r3, #1
  20af2e:	2300      	movne	r3, #0
  20af30:	b2db      	uxtb	r3, r3
  20af32:	4907      	ldr	r1, [pc, #28]	@ (20af50 <rt_test_010_003_execute+0x160>)
  20af34:	4618      	mov	r0, r3
  20af36:	f7fc fb93 	bl	207660 <__test_assert>
  20af3a:	4603      	mov	r3, r0
  20af3c:	2b00      	cmp	r3, #0
  20af3e:	d101      	bne.n	20af44 <rt_test_010_003_execute+0x154>
    test_wait_threads();
  20af40:	f7fc ff5e 	bl	207e00 <test_wait_threads>
  }
  test_end_step(4);
}
  20af44:	b005      	add	sp, #20
  20af46:	bd30      	pop	{r4, r5, pc}
  20af48:	20000bb4 	.word	0x20000bb4
  20af4c:	080118c4 	.word	0x080118c4
  20af50:	080118d8 	.word	0x080118d8
  20af54:	08012220 	.word	0x08012220
  20af58:	0020ac61 	.word	0x0020ac61
  20af5c:	20001900 	.word	0x20001900
  20af60:	080116d0 	.word	0x080116d0
  20af64:	080118e4 	.word	0x080118e4
	...

0020af70 <rt_test_010_004_setup>:
 *   been received after 50mS and that the event flags mask has been
 *   emptied.
 * .
 */

static void rt_test_010_004_setup(void) {
  20af70:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
  20af72:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20af76:	f7f9 fb6b 	bl	204650 <chEvtGetAndClearEvents>
}
  20af7a:	bf00      	nop
  20af7c:	bd08      	pop	{r3, pc}
  20af7e:	bf00      	nop

0020af80 <rt_test_010_004_execute>:

static void rt_test_010_004_execute(void) {
  20af80:	b530      	push	{r4, r5, lr}
  20af82:	b085      	sub	sp, #20
  eventmask_t m;
  systime_t target_time;

  /* [10.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
  20af84:	4b42      	ldr	r3, [pc, #264]	@ (20b090 <rt_test_010_004_execute+0x110>)
  20af86:	2201      	movs	r2, #1
  20af88:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(5);
  20af8a:	2005      	movs	r0, #5
  20af8c:	f7f9 fb70 	bl	204670 <chEvtAddEvents>
  }
  test_end_step(1);

  /* [10.4.2] Calling chEvtWaitAny() one time, the two flags must be
     returned.*/
  test_set_step(2);
  20af90:	4b3f      	ldr	r3, [pc, #252]	@ (20b090 <rt_test_010_004_execute+0x110>)
  20af92:	2202      	movs	r2, #2
  20af94:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
  20af96:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20af9a:	f7f9 fc69 	bl	204870 <chEvtWaitAny>
  20af9e:	9003      	str	r0, [sp, #12]
    test_assert(m == 5, "unexpected pending bit");
  20afa0:	9b03      	ldr	r3, [sp, #12]
  20afa2:	2b05      	cmp	r3, #5
  20afa4:	bf0c      	ite	eq
  20afa6:	2301      	moveq	r3, #1
  20afa8:	2300      	movne	r3, #0
  20afaa:	b2db      	uxtb	r3, r3
  20afac:	4939      	ldr	r1, [pc, #228]	@ (20b094 <rt_test_010_004_execute+0x114>)
  20afae:	4618      	mov	r0, r3
  20afb0:	f7fc fb56 	bl	207660 <__test_assert>
  20afb4:	4603      	mov	r3, r0
  20afb6:	2b00      	cmp	r3, #0
  20afb8:	d167      	bne.n	20b08a <rt_test_010_004_execute+0x10a>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  20afba:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20afbe:	f7f9 fb47 	bl	204650 <chEvtGetAndClearEvents>
  20afc2:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
  20afc4:	9b03      	ldr	r3, [sp, #12]
  20afc6:	2b00      	cmp	r3, #0
  20afc8:	bf0c      	ite	eq
  20afca:	2301      	moveq	r3, #1
  20afcc:	2300      	movne	r3, #0
  20afce:	b2db      	uxtb	r3, r3
  20afd0:	4931      	ldr	r1, [pc, #196]	@ (20b098 <rt_test_010_004_execute+0x118>)
  20afd2:	4618      	mov	r0, r3
  20afd4:	f7fc fb44 	bl	207660 <__test_assert>
  20afd8:	4603      	mov	r3, r0
  20afda:	2b00      	cmp	r3, #0
  20afdc:	d155      	bne.n	20b08a <rt_test_010_004_execute+0x10a>
  }
  test_end_step(2);

  /* [10.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  20afde:	4b2c      	ldr	r3, [pc, #176]	@ (20b090 <rt_test_010_004_execute+0x110>)
  20afe0:	2203      	movs	r2, #3
  20afe2:	601a      	str	r2, [r3, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
  20afe4:	f7fc ff34 	bl	207e50 <test_wait_tick>
  20afe8:	4603      	mov	r3, r0
  20afea:	f44f 71fa 	mov.w	r1, #500	@ 0x1f4
  20afee:	4618      	mov	r0, r3
  20aff0:	f7ff fd86 	bl	20ab00 <chTimeAddX.lto_priv.5>
  20aff4:	9002      	str	r0, [sp, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20aff6:	4b29      	ldr	r3, [pc, #164]	@ (20b09c <rt_test_010_004_execute+0x11c>)
  20aff8:	681c      	ldr	r4, [r3, #0]
  20affa:	f7ff fdb9 	bl	20ab70 <chThdGetPriorityX.lto_priv.5>
  20affe:	4603      	mov	r3, r0
  20b000:	1e5d      	subs	r5, r3, #1
                                   evt_thread3, chThdGetSelfX());
  20b002:	f7ff fdad 	bl	20ab60 <chThdGetSelfX.lto_priv.11>
  20b006:	4603      	mov	r3, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20b008:	9300      	str	r3, [sp, #0]
  20b00a:	4b25      	ldr	r3, [pc, #148]	@ (20b0a0 <rt_test_010_004_execute+0x120>)
  20b00c:	462a      	mov	r2, r5
  20b00e:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20b012:	4620      	mov	r0, r4
  20b014:	f7f8 f9b4 	bl	203380 <chThdCreateStatic>
  20b018:	4603      	mov	r3, r0
  20b01a:	4a22      	ldr	r2, [pc, #136]	@ (20b0a4 <rt_test_010_004_execute+0x124>)
  20b01c:	6013      	str	r3, [r2, #0]
  test_end_step(3);

  /* [10.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  20b01e:	4b1c      	ldr	r3, [pc, #112]	@ (20b090 <rt_test_010_004_execute+0x110>)
  20b020:	2204      	movs	r2, #4
  20b022:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
  20b024:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b028:	f7f9 fc22 	bl	204870 <chEvtWaitAny>
  20b02c:	9003      	str	r0, [sp, #12]
    test_assert_time_window(target_time,
  20b02e:	2114      	movs	r1, #20
  20b030:	9802      	ldr	r0, [sp, #8]
  20b032:	f7ff fd65 	bl	20ab00 <chTimeAddX.lto_priv.5>
  20b036:	4603      	mov	r3, r0
  20b038:	4a1b      	ldr	r2, [pc, #108]	@ (20b0a8 <rt_test_010_004_execute+0x128>)
  20b03a:	4619      	mov	r1, r3
  20b03c:	9802      	ldr	r0, [sp, #8]
  20b03e:	f7fc fb57 	bl	2076f0 <__test_assert_time_window>
  20b042:	4603      	mov	r3, r0
  20b044:	2b00      	cmp	r3, #0
  20b046:	d120      	bne.n	20b08a <rt_test_010_004_execute+0x10a>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    test_assert(m == 1, "event flag error");
  20b048:	9b03      	ldr	r3, [sp, #12]
  20b04a:	2b01      	cmp	r3, #1
  20b04c:	bf0c      	ite	eq
  20b04e:	2301      	moveq	r3, #1
  20b050:	2300      	movne	r3, #0
  20b052:	b2db      	uxtb	r3, r3
  20b054:	4915      	ldr	r1, [pc, #84]	@ (20b0ac <rt_test_010_004_execute+0x12c>)
  20b056:	4618      	mov	r0, r3
  20b058:	f7fc fb02 	bl	207660 <__test_assert>
  20b05c:	4603      	mov	r3, r0
  20b05e:	2b00      	cmp	r3, #0
  20b060:	d113      	bne.n	20b08a <rt_test_010_004_execute+0x10a>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  20b062:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b066:	f7f9 faf3 	bl	204650 <chEvtGetAndClearEvents>
  20b06a:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
  20b06c:	9b03      	ldr	r3, [sp, #12]
  20b06e:	2b00      	cmp	r3, #0
  20b070:	bf0c      	ite	eq
  20b072:	2301      	moveq	r3, #1
  20b074:	2300      	movne	r3, #0
  20b076:	b2db      	uxtb	r3, r3
  20b078:	4907      	ldr	r1, [pc, #28]	@ (20b098 <rt_test_010_004_execute+0x118>)
  20b07a:	4618      	mov	r0, r3
  20b07c:	f7fc faf0 	bl	207660 <__test_assert>
  20b080:	4603      	mov	r3, r0
  20b082:	2b00      	cmp	r3, #0
  20b084:	d101      	bne.n	20b08a <rt_test_010_004_execute+0x10a>
    test_wait_threads();
  20b086:	f7fc febb 	bl	207e00 <test_wait_threads>
  }
  test_end_step(4);
}
  20b08a:	b005      	add	sp, #20
  20b08c:	bd30      	pop	{r4, r5, pc}
  20b08e:	bf00      	nop
  20b090:	20000bb4 	.word	0x20000bb4
  20b094:	080118f8 	.word	0x080118f8
  20b098:	080118d8 	.word	0x080118d8
  20b09c:	08012220 	.word	0x08012220
  20b0a0:	0020ac61 	.word	0x0020ac61
  20b0a4:	20001900 	.word	0x20001900
  20b0a8:	080116d0 	.word	0x080116d0
  20b0ac:	080118e4 	.word	0x080118e4

0020b0b0 <rt_test_010_005_setup>:
 *   flags have been received after 50mS and that the event flags mask
 *   has been emptied.
 * .
 */

static void rt_test_010_005_setup(void) {
  20b0b0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
  20b0b2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b0b6:	f7f9 facb 	bl	204650 <chEvtGetAndClearEvents>
}
  20b0ba:	bf00      	nop
  20b0bc:	bd08      	pop	{r3, pc}
  20b0be:	bf00      	nop

0020b0c0 <rt_test_010_005_execute>:

static void rt_test_010_005_execute(void) {
  20b0c0:	b530      	push	{r4, r5, lr}
  20b0c2:	b085      	sub	sp, #20
  eventmask_t m;
  systime_t target_time;

  /* [10.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
  20b0c4:	4b44      	ldr	r3, [pc, #272]	@ (20b1d8 <rt_test_010_005_execute+0x118>)
  20b0c6:	2201      	movs	r2, #1
  20b0c8:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(5);
  20b0ca:	2005      	movs	r0, #5
  20b0cc:	f7f9 fad0 	bl	204670 <chEvtAddEvents>
  }
  test_end_step(1);

  /* [10.5.2] Calling chEvtWaitAll() one time, the two flags must be
     returned.*/
  test_set_step(2);
  20b0d0:	4b41      	ldr	r3, [pc, #260]	@ (20b1d8 <rt_test_010_005_execute+0x118>)
  20b0d2:	2202      	movs	r2, #2
  20b0d4:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAll(5);
  20b0d6:	2005      	movs	r0, #5
  20b0d8:	f7f9 fbfa 	bl	2048d0 <chEvtWaitAll>
  20b0dc:	9003      	str	r0, [sp, #12]
    test_assert(m == 5, "unexpected pending bit");
  20b0de:	9b03      	ldr	r3, [sp, #12]
  20b0e0:	2b05      	cmp	r3, #5
  20b0e2:	bf0c      	ite	eq
  20b0e4:	2301      	moveq	r3, #1
  20b0e6:	2300      	movne	r3, #0
  20b0e8:	b2db      	uxtb	r3, r3
  20b0ea:	493c      	ldr	r1, [pc, #240]	@ (20b1dc <rt_test_010_005_execute+0x11c>)
  20b0ec:	4618      	mov	r0, r3
  20b0ee:	f7fc fab7 	bl	207660 <__test_assert>
  20b0f2:	4603      	mov	r3, r0
  20b0f4:	2b00      	cmp	r3, #0
  20b0f6:	d16c      	bne.n	20b1d2 <rt_test_010_005_execute+0x112>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  20b0f8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b0fc:	f7f9 faa8 	bl	204650 <chEvtGetAndClearEvents>
  20b100:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
  20b102:	9b03      	ldr	r3, [sp, #12]
  20b104:	2b00      	cmp	r3, #0
  20b106:	bf0c      	ite	eq
  20b108:	2301      	moveq	r3, #1
  20b10a:	2300      	movne	r3, #0
  20b10c:	b2db      	uxtb	r3, r3
  20b10e:	4934      	ldr	r1, [pc, #208]	@ (20b1e0 <rt_test_010_005_execute+0x120>)
  20b110:	4618      	mov	r0, r3
  20b112:	f7fc faa5 	bl	207660 <__test_assert>
  20b116:	4603      	mov	r3, r0
  20b118:	2b00      	cmp	r3, #0
  20b11a:	d15a      	bne.n	20b1d2 <rt_test_010_005_execute+0x112>
  }
  test_end_step(2);

  /* [10.5.3] Setting one event flag.*/
  test_set_step(3);
  20b11c:	4b2e      	ldr	r3, [pc, #184]	@ (20b1d8 <rt_test_010_005_execute+0x118>)
  20b11e:	2203      	movs	r2, #3
  20b120:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(4);
  20b122:	2004      	movs	r0, #4
  20b124:	f7f9 faa4 	bl	204670 <chEvtAddEvents>
  }
  test_end_step(3);

  /* [10.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
  20b128:	4b2b      	ldr	r3, [pc, #172]	@ (20b1d8 <rt_test_010_005_execute+0x118>)
  20b12a:	2204      	movs	r2, #4
  20b12c:	601a      	str	r2, [r3, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
  20b12e:	f7fc fe8f 	bl	207e50 <test_wait_tick>
  20b132:	4603      	mov	r3, r0
  20b134:	f44f 71fa 	mov.w	r1, #500	@ 0x1f4
  20b138:	4618      	mov	r0, r3
  20b13a:	f7ff fce1 	bl	20ab00 <chTimeAddX.lto_priv.5>
  20b13e:	9002      	str	r0, [sp, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20b140:	4b28      	ldr	r3, [pc, #160]	@ (20b1e4 <rt_test_010_005_execute+0x124>)
  20b142:	681c      	ldr	r4, [r3, #0]
  20b144:	f7ff fd14 	bl	20ab70 <chThdGetPriorityX.lto_priv.5>
  20b148:	4603      	mov	r3, r0
  20b14a:	1e5d      	subs	r5, r3, #1
                                   evt_thread3, chThdGetSelfX());
  20b14c:	f7ff fd08 	bl	20ab60 <chThdGetSelfX.lto_priv.11>
  20b150:	4603      	mov	r3, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20b152:	9300      	str	r3, [sp, #0]
  20b154:	4b24      	ldr	r3, [pc, #144]	@ (20b1e8 <rt_test_010_005_execute+0x128>)
  20b156:	462a      	mov	r2, r5
  20b158:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20b15c:	4620      	mov	r0, r4
  20b15e:	f7f8 f90f 	bl	203380 <chThdCreateStatic>
  20b162:	4603      	mov	r3, r0
  20b164:	4a21      	ldr	r2, [pc, #132]	@ (20b1ec <rt_test_010_005_execute+0x12c>)
  20b166:	6013      	str	r3, [r2, #0]
  test_end_step(4);

  /* [10.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
  20b168:	4b1b      	ldr	r3, [pc, #108]	@ (20b1d8 <rt_test_010_005_execute+0x118>)
  20b16a:	2205      	movs	r2, #5
  20b16c:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAll(5);
  20b16e:	2005      	movs	r0, #5
  20b170:	f7f9 fbae 	bl	2048d0 <chEvtWaitAll>
  20b174:	9003      	str	r0, [sp, #12]
    test_assert_time_window(target_time,
  20b176:	2114      	movs	r1, #20
  20b178:	9802      	ldr	r0, [sp, #8]
  20b17a:	f7ff fcc1 	bl	20ab00 <chTimeAddX.lto_priv.5>
  20b17e:	4603      	mov	r3, r0
  20b180:	4a1b      	ldr	r2, [pc, #108]	@ (20b1f0 <rt_test_010_005_execute+0x130>)
  20b182:	4619      	mov	r1, r3
  20b184:	9802      	ldr	r0, [sp, #8]
  20b186:	f7fc fab3 	bl	2076f0 <__test_assert_time_window>
  20b18a:	4603      	mov	r3, r0
  20b18c:	2b00      	cmp	r3, #0
  20b18e:	d120      	bne.n	20b1d2 <rt_test_010_005_execute+0x112>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    test_assert(m == 5, "event flags error");
  20b190:	9b03      	ldr	r3, [sp, #12]
  20b192:	2b05      	cmp	r3, #5
  20b194:	bf0c      	ite	eq
  20b196:	2301      	moveq	r3, #1
  20b198:	2300      	movne	r3, #0
  20b19a:	b2db      	uxtb	r3, r3
  20b19c:	4915      	ldr	r1, [pc, #84]	@ (20b1f4 <rt_test_010_005_execute+0x134>)
  20b19e:	4618      	mov	r0, r3
  20b1a0:	f7fc fa5e 	bl	207660 <__test_assert>
  20b1a4:	4603      	mov	r3, r0
  20b1a6:	2b00      	cmp	r3, #0
  20b1a8:	d113      	bne.n	20b1d2 <rt_test_010_005_execute+0x112>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  20b1aa:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b1ae:	f7f9 fa4f 	bl	204650 <chEvtGetAndClearEvents>
  20b1b2:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
  20b1b4:	9b03      	ldr	r3, [sp, #12]
  20b1b6:	2b00      	cmp	r3, #0
  20b1b8:	bf0c      	ite	eq
  20b1ba:	2301      	moveq	r3, #1
  20b1bc:	2300      	movne	r3, #0
  20b1be:	b2db      	uxtb	r3, r3
  20b1c0:	4907      	ldr	r1, [pc, #28]	@ (20b1e0 <rt_test_010_005_execute+0x120>)
  20b1c2:	4618      	mov	r0, r3
  20b1c4:	f7fc fa4c 	bl	207660 <__test_assert>
  20b1c8:	4603      	mov	r3, r0
  20b1ca:	2b00      	cmp	r3, #0
  20b1cc:	d101      	bne.n	20b1d2 <rt_test_010_005_execute+0x112>
    test_wait_threads();
  20b1ce:	f7fc fe17 	bl	207e00 <test_wait_threads>
  }
  test_end_step(5);
}
  20b1d2:	b005      	add	sp, #20
  20b1d4:	bd30      	pop	{r4, r5, pc}
  20b1d6:	bf00      	nop
  20b1d8:	20000bb4 	.word	0x20000bb4
  20b1dc:	080118f8 	.word	0x080118f8
  20b1e0:	080118d8 	.word	0x080118d8
  20b1e4:	08012220 	.word	0x08012220
  20b1e8:	0020ac61 	.word	0x0020ac61
  20b1ec:	20001900 	.word	0x20001900
  20b1f0:	080116d0 	.word	0x080116d0
  20b1f4:	08011910 	.word	0x08011910
	...

0020b200 <rt_test_010_006_setup>:
 * - [10.6.2] The functions are invoked first with a 50mS timeout, the
 *   timeout condition is tested.
 * .
 */

static void rt_test_010_006_setup(void) {
  20b200:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
  20b202:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b206:	f7f9 fa23 	bl	204650 <chEvtGetAndClearEvents>
}
  20b20a:	bf00      	nop
  20b20c:	bd08      	pop	{r3, pc}
  20b20e:	bf00      	nop

0020b210 <rt_test_010_006_execute>:

static void rt_test_010_006_execute(void) {
  20b210:	b500      	push	{lr}
  20b212:	b083      	sub	sp, #12
  eventmask_t m;

  /* [10.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
  20b214:	4b3e      	ldr	r3, [pc, #248]	@ (20b310 <rt_test_010_006_execute+0x100>)
  20b216:	2201      	movs	r2, #1
  20b218:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  20b21a:	2100      	movs	r1, #0
  20b21c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b220:	f7f9 fb7e 	bl	204920 <chEvtWaitOneTimeout>
  20b224:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
  20b226:	9b01      	ldr	r3, [sp, #4]
  20b228:	2b00      	cmp	r3, #0
  20b22a:	bf0c      	ite	eq
  20b22c:	2301      	moveq	r3, #1
  20b22e:	2300      	movne	r3, #0
  20b230:	b2db      	uxtb	r3, r3
  20b232:	4938      	ldr	r1, [pc, #224]	@ (20b314 <rt_test_010_006_execute+0x104>)
  20b234:	4618      	mov	r0, r3
  20b236:	f7fc fa13 	bl	207660 <__test_assert>
  20b23a:	4603      	mov	r3, r0
  20b23c:	2b00      	cmp	r3, #0
  20b23e:	d163      	bne.n	20b308 <rt_test_010_006_execute+0xf8>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  20b240:	2100      	movs	r1, #0
  20b242:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b246:	f7f9 fbab 	bl	2049a0 <chEvtWaitAnyTimeout>
  20b24a:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
  20b24c:	9b01      	ldr	r3, [sp, #4]
  20b24e:	2b00      	cmp	r3, #0
  20b250:	bf0c      	ite	eq
  20b252:	2301      	moveq	r3, #1
  20b254:	2300      	movne	r3, #0
  20b256:	b2db      	uxtb	r3, r3
  20b258:	492e      	ldr	r1, [pc, #184]	@ (20b314 <rt_test_010_006_execute+0x104>)
  20b25a:	4618      	mov	r0, r3
  20b25c:	f7fc fa00 	bl	207660 <__test_assert>
  20b260:	4603      	mov	r3, r0
  20b262:	2b00      	cmp	r3, #0
  20b264:	d150      	bne.n	20b308 <rt_test_010_006_execute+0xf8>
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  20b266:	2100      	movs	r1, #0
  20b268:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b26c:	f7f9 fbd8 	bl	204a20 <chEvtWaitAllTimeout>
  20b270:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
  20b272:	9b01      	ldr	r3, [sp, #4]
  20b274:	2b00      	cmp	r3, #0
  20b276:	bf0c      	ite	eq
  20b278:	2301      	moveq	r3, #1
  20b27a:	2300      	movne	r3, #0
  20b27c:	b2db      	uxtb	r3, r3
  20b27e:	4925      	ldr	r1, [pc, #148]	@ (20b314 <rt_test_010_006_execute+0x104>)
  20b280:	4618      	mov	r0, r3
  20b282:	f7fc f9ed 	bl	207660 <__test_assert>
  20b286:	4603      	mov	r3, r0
  20b288:	2b00      	cmp	r3, #0
  20b28a:	d13d      	bne.n	20b308 <rt_test_010_006_execute+0xf8>
  }
  test_end_step(1);

  /* [10.6.2] The functions are invoked first with a 50mS timeout, the
     timeout condition is tested.*/
  test_set_step(2);
  20b28c:	4b20      	ldr	r3, [pc, #128]	@ (20b310 <rt_test_010_006_execute+0x100>)
  20b28e:	2202      	movs	r2, #2
  20b290:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
  20b292:	f44f 71fa 	mov.w	r1, #500	@ 0x1f4
  20b296:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b29a:	f7f9 fb41 	bl	204920 <chEvtWaitOneTimeout>
  20b29e:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
  20b2a0:	9b01      	ldr	r3, [sp, #4]
  20b2a2:	2b00      	cmp	r3, #0
  20b2a4:	bf0c      	ite	eq
  20b2a6:	2301      	moveq	r3, #1
  20b2a8:	2300      	movne	r3, #0
  20b2aa:	b2db      	uxtb	r3, r3
  20b2ac:	4919      	ldr	r1, [pc, #100]	@ (20b314 <rt_test_010_006_execute+0x104>)
  20b2ae:	4618      	mov	r0, r3
  20b2b0:	f7fc f9d6 	bl	207660 <__test_assert>
  20b2b4:	4603      	mov	r3, r0
  20b2b6:	2b00      	cmp	r3, #0
  20b2b8:	d126      	bne.n	20b308 <rt_test_010_006_execute+0xf8>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_MS2I(50));
  20b2ba:	f44f 71fa 	mov.w	r1, #500	@ 0x1f4
  20b2be:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b2c2:	f7f9 fb6d 	bl	2049a0 <chEvtWaitAnyTimeout>
  20b2c6:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
  20b2c8:	9b01      	ldr	r3, [sp, #4]
  20b2ca:	2b00      	cmp	r3, #0
  20b2cc:	bf0c      	ite	eq
  20b2ce:	2301      	moveq	r3, #1
  20b2d0:	2300      	movne	r3, #0
  20b2d2:	b2db      	uxtb	r3, r3
  20b2d4:	490f      	ldr	r1, [pc, #60]	@ (20b314 <rt_test_010_006_execute+0x104>)
  20b2d6:	4618      	mov	r0, r3
  20b2d8:	f7fc f9c2 	bl	207660 <__test_assert>
  20b2dc:	4603      	mov	r3, r0
  20b2de:	2b00      	cmp	r3, #0
  20b2e0:	d112      	bne.n	20b308 <rt_test_010_006_execute+0xf8>
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_MS2I(50));
  20b2e2:	f44f 71fa 	mov.w	r1, #500	@ 0x1f4
  20b2e6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b2ea:	f7f9 fb99 	bl	204a20 <chEvtWaitAllTimeout>
  20b2ee:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
  20b2f0:	9b01      	ldr	r3, [sp, #4]
  20b2f2:	2b00      	cmp	r3, #0
  20b2f4:	bf0c      	ite	eq
  20b2f6:	2301      	moveq	r3, #1
  20b2f8:	2300      	movne	r3, #0
  20b2fa:	b2db      	uxtb	r3, r3
  20b2fc:	4905      	ldr	r1, [pc, #20]	@ (20b314 <rt_test_010_006_execute+0x104>)
  20b2fe:	4618      	mov	r0, r3
  20b300:	f7fc f9ae 	bl	207660 <__test_assert>
  20b304:	4603      	mov	r3, r0
  20b306:	2b00      	cmp	r3, #0
  }
  test_end_step(2);
}
  20b308:	b003      	add	sp, #12
  20b30a:	f85d fb04 	ldr.w	pc, [sp], #4
  20b30e:	bf00      	nop
  20b310:	20000bb4 	.word	0x20000bb4
  20b314:	08011924 	.word	0x08011924
	...

0020b320 <rt_test_010_007_setup>:
 *   has been emptied.
 * - [10.7.4] Unregistering from the Event Sources.
 * .
 */

static void rt_test_010_007_setup(void) {
  20b320:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
  20b322:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b326:	f7f9 f993 	bl	204650 <chEvtGetAndClearEvents>
  chEvtObjectInit(&es1);
  20b32a:	4804      	ldr	r0, [pc, #16]	@ (20b33c <rt_test_010_007_setup+0x1c>)
  20b32c:	f7f9 f910 	bl	204550 <chEvtObjectInit>
  chEvtObjectInit(&es2);
  20b330:	4803      	ldr	r0, [pc, #12]	@ (20b340 <rt_test_010_007_setup+0x20>)
  20b332:	f7f9 f90d 	bl	204550 <chEvtObjectInit>
}
  20b336:	bf00      	nop
  20b338:	bd08      	pop	{r3, pc}
  20b33a:	bf00      	nop
  20b33c:	20020028 	.word	0x20020028
  20b340:	2002002c 	.word	0x2002002c
	...

0020b350 <rt_test_010_007_execute>:

static void rt_test_010_007_execute(void) {
  20b350:	b510      	push	{r4, lr}
  20b352:	b08e      	sub	sp, #56	@ 0x38
  event_listener_t el1, el2;
  systime_t target_time;

  /* [10.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
  20b354:	4b46      	ldr	r3, [pc, #280]	@ (20b470 <rt_test_010_007_execute+0x120>)
  20b356:	2201      	movs	r2, #1
  20b358:	601a      	str	r2, [r3, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
  20b35a:	ab07      	add	r3, sp, #28
  20b35c:	2201      	movs	r2, #1
  20b35e:	4619      	mov	r1, r3
  20b360:	4844      	ldr	r0, [pc, #272]	@ (20b474 <rt_test_010_007_execute+0x124>)
  20b362:	f7ff fc0d 	bl	20ab80 <chEvtRegisterMask>
    chEvtRegisterMask(&es2, &el2, 4);
  20b366:	ab02      	add	r3, sp, #8
  20b368:	2204      	movs	r2, #4
  20b36a:	4619      	mov	r1, r3
  20b36c:	4842      	ldr	r0, [pc, #264]	@ (20b478 <rt_test_010_007_execute+0x128>)
  20b36e:	f7ff fc07 	bl	20ab80 <chEvtRegisterMask>
  test_end_step(1);

  /* [10.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
  20b372:	4b3f      	ldr	r3, [pc, #252]	@ (20b470 <rt_test_010_007_execute+0x120>)
  20b374:	2202      	movs	r2, #2
  20b376:	601a      	str	r2, [r3, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
  20b378:	f7fc fd6a 	bl	207e50 <test_wait_tick>
  20b37c:	4603      	mov	r3, r0
  20b37e:	f44f 71fa 	mov.w	r1, #500	@ 0x1f4
  20b382:	4618      	mov	r0, r3
  20b384:	f7ff fbbc 	bl	20ab00 <chTimeAddX.lto_priv.5>
  20b388:	900d      	str	r0, [sp, #52]	@ 0x34
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20b38a:	4b3c      	ldr	r3, [pc, #240]	@ (20b47c <rt_test_010_007_execute+0x12c>)
  20b38c:	681c      	ldr	r4, [r3, #0]
  20b38e:	f7ff fbef 	bl	20ab70 <chThdGetPriorityX.lto_priv.5>
  20b392:	4603      	mov	r3, r0
  20b394:	1e5a      	subs	r2, r3, #1
  20b396:	4b3a      	ldr	r3, [pc, #232]	@ (20b480 <rt_test_010_007_execute+0x130>)
  20b398:	9300      	str	r3, [sp, #0]
  20b39a:	4b3a      	ldr	r3, [pc, #232]	@ (20b484 <rt_test_010_007_execute+0x134>)
  20b39c:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20b3a0:	4620      	mov	r0, r4
  20b3a2:	f7f7 ffed 	bl	203380 <chThdCreateStatic>
  20b3a6:	4603      	mov	r3, r0
  20b3a8:	4a37      	ldr	r2, [pc, #220]	@ (20b488 <rt_test_010_007_execute+0x138>)
  20b3aa:	6013      	str	r3, [r2, #0]
  test_end_step(2);

  /* [10.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
  20b3ac:	4b30      	ldr	r3, [pc, #192]	@ (20b470 <rt_test_010_007_execute+0x120>)
  20b3ae:	2203      	movs	r2, #3
  20b3b0:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAll(5);
  20b3b2:	2005      	movs	r0, #5
  20b3b4:	f7f9 fa8c 	bl	2048d0 <chEvtWaitAll>
  20b3b8:	900c      	str	r0, [sp, #48]	@ 0x30
    test_assert_time_window(target_time,
  20b3ba:	2114      	movs	r1, #20
  20b3bc:	980d      	ldr	r0, [sp, #52]	@ 0x34
  20b3be:	f7ff fb9f 	bl	20ab00 <chTimeAddX.lto_priv.5>
  20b3c2:	4603      	mov	r3, r0
  20b3c4:	4a31      	ldr	r2, [pc, #196]	@ (20b48c <rt_test_010_007_execute+0x13c>)
  20b3c6:	4619      	mov	r1, r3
  20b3c8:	980d      	ldr	r0, [sp, #52]	@ 0x34
  20b3ca:	f7fc f991 	bl	2076f0 <__test_assert_time_window>
  20b3ce:	4603      	mov	r3, r0
  20b3d0:	2b00      	cmp	r3, #0
  20b3d2:	d14b      	bne.n	20b46c <rt_test_010_007_execute+0x11c>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  20b3d4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  20b3d8:	f7f9 f93a 	bl	204650 <chEvtGetAndClearEvents>
  20b3dc:	900c      	str	r0, [sp, #48]	@ 0x30
    test_assert(m == 0, "stuck event");
  20b3de:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
  20b3e0:	2b00      	cmp	r3, #0
  20b3e2:	bf0c      	ite	eq
  20b3e4:	2301      	moveq	r3, #1
  20b3e6:	2300      	movne	r3, #0
  20b3e8:	b2db      	uxtb	r3, r3
  20b3ea:	4929      	ldr	r1, [pc, #164]	@ (20b490 <rt_test_010_007_execute+0x140>)
  20b3ec:	4618      	mov	r0, r3
  20b3ee:	f7fc f937 	bl	207660 <__test_assert>
  20b3f2:	4603      	mov	r3, r0
  20b3f4:	2b00      	cmp	r3, #0
  20b3f6:	d139      	bne.n	20b46c <rt_test_010_007_execute+0x11c>
    test_wait_threads();
  20b3f8:	f7fc fd02 	bl	207e00 <test_wait_threads>
  }
  test_end_step(3);

  /* [10.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
  20b3fc:	4b1c      	ldr	r3, [pc, #112]	@ (20b470 <rt_test_010_007_execute+0x120>)
  20b3fe:	2204      	movs	r2, #4
  20b400:	601a      	str	r2, [r3, #0]
  {
    chEvtUnregister(&es1, &el1);
  20b402:	ab07      	add	r3, sp, #28
  20b404:	4619      	mov	r1, r3
  20b406:	481b      	ldr	r0, [pc, #108]	@ (20b474 <rt_test_010_007_execute+0x124>)
  20b408:	f7f9 f8e2 	bl	2045d0 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
  20b40c:	ab02      	add	r3, sp, #8
  20b40e:	4619      	mov	r1, r3
  20b410:	4819      	ldr	r0, [pc, #100]	@ (20b478 <rt_test_010_007_execute+0x128>)
  20b412:	f7f9 f8dd 	bl	2045d0 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
  20b416:	4817      	ldr	r0, [pc, #92]	@ (20b474 <rt_test_010_007_execute+0x124>)
  20b418:	f7ff fbc2 	bl	20aba0 <chEvtIsListeningI>
  20b41c:	4603      	mov	r3, r0
  20b41e:	2b00      	cmp	r3, #0
  20b420:	bf14      	ite	ne
  20b422:	2301      	movne	r3, #1
  20b424:	2300      	moveq	r3, #0
  20b426:	b2db      	uxtb	r3, r3
  20b428:	f083 0301 	eor.w	r3, r3, #1
  20b42c:	b2db      	uxtb	r3, r3
  20b42e:	f003 0301 	and.w	r3, r3, #1
  20b432:	b2db      	uxtb	r3, r3
  20b434:	4917      	ldr	r1, [pc, #92]	@ (20b494 <rt_test_010_007_execute+0x144>)
  20b436:	4618      	mov	r0, r3
  20b438:	f7fc f912 	bl	207660 <__test_assert>
  20b43c:	4603      	mov	r3, r0
  20b43e:	2b00      	cmp	r3, #0
  20b440:	d114      	bne.n	20b46c <rt_test_010_007_execute+0x11c>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  20b442:	480d      	ldr	r0, [pc, #52]	@ (20b478 <rt_test_010_007_execute+0x128>)
  20b444:	f7ff fbac 	bl	20aba0 <chEvtIsListeningI>
  20b448:	4603      	mov	r3, r0
  20b44a:	2b00      	cmp	r3, #0
  20b44c:	bf14      	ite	ne
  20b44e:	2301      	movne	r3, #1
  20b450:	2300      	moveq	r3, #0
  20b452:	b2db      	uxtb	r3, r3
  20b454:	f083 0301 	eor.w	r3, r3, #1
  20b458:	b2db      	uxtb	r3, r3
  20b45a:	f003 0301 	and.w	r3, r3, #1
  20b45e:	b2db      	uxtb	r3, r3
  20b460:	490c      	ldr	r1, [pc, #48]	@ (20b494 <rt_test_010_007_execute+0x144>)
  20b462:	4618      	mov	r0, r3
  20b464:	f7fc f8fc 	bl	207660 <__test_assert>
  20b468:	4603      	mov	r3, r0
  20b46a:	2b00      	cmp	r3, #0
  }
  test_end_step(4);
}
  20b46c:	b00e      	add	sp, #56	@ 0x38
  20b46e:	bd10      	pop	{r4, pc}
  20b470:	20000bb4 	.word	0x20000bb4
  20b474:	20020028 	.word	0x20020028
  20b478:	2002002c 	.word	0x2002002c
  20b47c:	08012220 	.word	0x08012220
  20b480:	080116f0 	.word	0x080116f0
  20b484:	0020ac81 	.word	0x0020ac81
  20b488:	20001900 	.word	0x20001900
  20b48c:	080116d0 	.word	0x080116d0
  20b490:	080118d8 	.word	0x080118d8
  20b494:	080118b4 	.word	0x080118b4
	...

0020b4a0 <chThdGetSelfX.lto_priv.12>:
  return __sch_get_currthread();
  20b4a0:	4b01      	ldr	r3, [pc, #4]	@ (20b4a8 <chThdGetSelfX.lto_priv.12+0x8>)
  20b4a2:	68db      	ldr	r3, [r3, #12]
}
  20b4a4:	4618      	mov	r0, r3
  20b4a6:	4770      	bx	lr
  20b4a8:	20000890 	.word	0x20000890
  20b4ac:	00000000 	.word	0x00000000

0020b4b0 <chThdGetPriorityX.lto_priv.6>:
static inline tprio_t chThdGetPriorityX(void) {
  20b4b0:	b508      	push	{r3, lr}
  return chThdGetSelfX()->hdr.pqueue.prio;
  20b4b2:	f7ff fff5 	bl	20b4a0 <chThdGetSelfX.lto_priv.12>
  20b4b6:	4603      	mov	r3, r0
  20b4b8:	689b      	ldr	r3, [r3, #8]
}
  20b4ba:	4618      	mov	r0, r3
  20b4bc:	bd08      	pop	{r3, pc}
  20b4be:	bf00      	nop

0020b4c0 <chPoolObjectInit.lto_priv.1>:
                                    memgetfunc_t provider) {
  20b4c0:	b500      	push	{lr}
  20b4c2:	b085      	sub	sp, #20
  20b4c4:	9003      	str	r0, [sp, #12]
  20b4c6:	9102      	str	r1, [sp, #8]
  20b4c8:	9201      	str	r2, [sp, #4]
  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
  20b4ca:	9b01      	ldr	r3, [sp, #4]
  20b4cc:	2204      	movs	r2, #4
  20b4ce:	9902      	ldr	r1, [sp, #8]
  20b4d0:	9803      	ldr	r0, [sp, #12]
  20b4d2:	f7fa faad 	bl	205a30 <chPoolObjectInitAligned>
}
  20b4d6:	bf00      	nop
  20b4d8:	b005      	add	sp, #20
  20b4da:	f85d fb04 	ldr.w	pc, [sp], #4
  20b4de:	bf00      	nop

0020b4e0 <dyn_thread1>:
#endif
#if CH_CFG_USE_MEMPOOLS
static memory_pool_t mp1;
#endif

static THD_FUNCTION(dyn_thread1, p) {
  20b4e0:	b500      	push	{lr}
  20b4e2:	b083      	sub	sp, #12
  20b4e4:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
  20b4e6:	9b01      	ldr	r3, [sp, #4]
  20b4e8:	781b      	ldrb	r3, [r3, #0]
  20b4ea:	4618      	mov	r0, r3
  20b4ec:	f7fc f918 	bl	207720 <test_emit_token>
}
  20b4f0:	bf00      	nop
  20b4f2:	b003      	add	sp, #12
  20b4f4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0020b500 <rt_test_011_001_setup>:
 *   freeing memory.
 * - [11.1.7] Getting heap info again for verification.
 * .
 */

static void rt_test_011_001_setup(void) {
  20b500:	b508      	push	{r3, lr}
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
  20b502:	f44f 6252 	mov.w	r2, #3360	@ 0xd20
  20b506:	4903      	ldr	r1, [pc, #12]	@ (20b514 <rt_test_011_001_setup+0x14>)
  20b508:	4803      	ldr	r0, [pc, #12]	@ (20b518 <rt_test_011_001_setup+0x18>)
  20b50a:	f7fa f809 	bl	205520 <chHeapObjectInit>
}
  20b50e:	bf00      	nop
  20b510:	bd08      	pop	{r3, pc}
  20b512:	bf00      	nop
  20b514:	20000be0 	.word	0x20000be0
  20b518:	20001924 	.word	0x20001924
  20b51c:	00000000 	.word	0x00000000

0020b520 <rt_test_011_001_execute>:

static void rt_test_011_001_execute(void) {
  20b520:	b500      	push	{lr}
  20b522:	b08b      	sub	sp, #44	@ 0x2c
  size_t n1, total1, largest1;
  size_t n2, total2, largest2;
  tprio_t prio;

  /* [11.1.1] Getting base priority for threads.*/
  test_set_step(1);
  20b524:	4b5f      	ldr	r3, [pc, #380]	@ (20b6a4 <rt_test_011_001_execute+0x184>)
  20b526:	2201      	movs	r2, #1
  20b528:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
  20b52a:	f7ff ffc1 	bl	20b4b0 <chThdGetPriorityX.lto_priv.6>
  20b52e:	9009      	str	r0, [sp, #36]	@ 0x24
  }
  test_end_step(1);

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
  20b530:	4b5c      	ldr	r3, [pc, #368]	@ (20b6a4 <rt_test_011_001_execute+0x184>)
  20b532:	2202      	movs	r2, #2
  20b534:	601a      	str	r2, [r3, #0]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
  20b536:	aa05      	add	r2, sp, #20
  20b538:	ab06      	add	r3, sp, #24
  20b53a:	4619      	mov	r1, r3
  20b53c:	485a      	ldr	r0, [pc, #360]	@ (20b6a8 <rt_test_011_001_execute+0x188>)
  20b53e:	f7fa f967 	bl	205810 <chHeapStatus>
  20b542:	9008      	str	r0, [sp, #32]
    test_assert(n1 == 1, "heap fragmented");
  20b544:	9b08      	ldr	r3, [sp, #32]
  20b546:	2b01      	cmp	r3, #1
  20b548:	bf0c      	ite	eq
  20b54a:	2301      	moveq	r3, #1
  20b54c:	2300      	movne	r3, #0
  20b54e:	b2db      	uxtb	r3, r3
  20b550:	4956      	ldr	r1, [pc, #344]	@ (20b6ac <rt_test_011_001_execute+0x18c>)
  20b552:	4618      	mov	r0, r3
  20b554:	f7fc f884 	bl	207660 <__test_assert>
  20b558:	4603      	mov	r3, r0
  20b55a:	2b00      	cmp	r3, #0
  20b55c:	f040 809f 	bne.w	20b69e <rt_test_011_001_execute+0x17e>
  }
  test_end_step(2);

  /* [11.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
  20b560:	4b50      	ldr	r3, [pc, #320]	@ (20b6a4 <rt_test_011_001_execute+0x184>)
  20b562:	2203      	movs	r2, #3
  20b564:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateFromHeap(&heap1,
  20b566:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  20b568:	3b01      	subs	r3, #1
  20b56a:	4a51      	ldr	r2, [pc, #324]	@ (20b6b0 <rt_test_011_001_execute+0x190>)
  20b56c:	9201      	str	r2, [sp, #4]
  20b56e:	4a51      	ldr	r2, [pc, #324]	@ (20b6b4 <rt_test_011_001_execute+0x194>)
  20b570:	9200      	str	r2, [sp, #0]
  20b572:	4a51      	ldr	r2, [pc, #324]	@ (20b6b8 <rt_test_011_001_execute+0x198>)
  20b574:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20b578:	484b      	ldr	r0, [pc, #300]	@ (20b6a8 <rt_test_011_001_execute+0x188>)
  20b57a:	f7f9 fba9 	bl	204cd0 <chThdCreateFromHeap>
  20b57e:	4603      	mov	r3, r0
  20b580:	4a4e      	ldr	r2, [pc, #312]	@ (20b6bc <rt_test_011_001_execute+0x19c>)
  20b582:	6013      	str	r3, [r2, #0]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn1",
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
  20b584:	4b4d      	ldr	r3, [pc, #308]	@ (20b6bc <rt_test_011_001_execute+0x19c>)
  20b586:	681b      	ldr	r3, [r3, #0]
  20b588:	2b00      	cmp	r3, #0
  20b58a:	bf14      	ite	ne
  20b58c:	2301      	movne	r3, #1
  20b58e:	2300      	moveq	r3, #0
  20b590:	b2db      	uxtb	r3, r3
  20b592:	494b      	ldr	r1, [pc, #300]	@ (20b6c0 <rt_test_011_001_execute+0x1a0>)
  20b594:	4618      	mov	r0, r3
  20b596:	f7fc f863 	bl	207660 <__test_assert>
  20b59a:	4603      	mov	r3, r0
  20b59c:	2b00      	cmp	r3, #0
  20b59e:	d17e      	bne.n	20b69e <rt_test_011_001_execute+0x17e>
  }
  test_end_step(3);

  /* [11.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
  20b5a0:	4b40      	ldr	r3, [pc, #256]	@ (20b6a4 <rt_test_011_001_execute+0x184>)
  20b5a2:	2204      	movs	r2, #4
  20b5a4:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateFromHeap(&heap1,
  20b5a6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  20b5a8:	3b02      	subs	r3, #2
  20b5aa:	4a46      	ldr	r2, [pc, #280]	@ (20b6c4 <rt_test_011_001_execute+0x1a4>)
  20b5ac:	9201      	str	r2, [sp, #4]
  20b5ae:	4a41      	ldr	r2, [pc, #260]	@ (20b6b4 <rt_test_011_001_execute+0x194>)
  20b5b0:	9200      	str	r2, [sp, #0]
  20b5b2:	4a45      	ldr	r2, [pc, #276]	@ (20b6c8 <rt_test_011_001_execute+0x1a8>)
  20b5b4:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20b5b8:	483b      	ldr	r0, [pc, #236]	@ (20b6a8 <rt_test_011_001_execute+0x188>)
  20b5ba:	f7f9 fb89 	bl	204cd0 <chThdCreateFromHeap>
  20b5be:	4603      	mov	r3, r0
  20b5c0:	4a3e      	ldr	r2, [pc, #248]	@ (20b6bc <rt_test_011_001_execute+0x19c>)
  20b5c2:	6053      	str	r3, [r2, #4]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
  20b5c4:	4b3d      	ldr	r3, [pc, #244]	@ (20b6bc <rt_test_011_001_execute+0x19c>)
  20b5c6:	685b      	ldr	r3, [r3, #4]
  20b5c8:	2b00      	cmp	r3, #0
  20b5ca:	bf14      	ite	ne
  20b5cc:	2301      	movne	r3, #1
  20b5ce:	2300      	moveq	r3, #0
  20b5d0:	b2db      	uxtb	r3, r3
  20b5d2:	493b      	ldr	r1, [pc, #236]	@ (20b6c0 <rt_test_011_001_execute+0x1a0>)
  20b5d4:	4618      	mov	r0, r3
  20b5d6:	f7fc f843 	bl	207660 <__test_assert>
  20b5da:	4603      	mov	r3, r0
  20b5dc:	2b00      	cmp	r3, #0
  20b5de:	d15e      	bne.n	20b69e <rt_test_011_001_execute+0x17e>
  }
  test_end_step(4);

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
  20b5e0:	4b30      	ldr	r3, [pc, #192]	@ (20b6a4 <rt_test_011_001_execute+0x184>)
  20b5e2:	2205      	movs	r2, #5
  20b5e4:	601a      	str	r2, [r3, #0]
  {
    threads[2] = chThdCreateFromHeap(&heap1,
  20b5e6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  20b5e8:	3b03      	subs	r3, #3
  20b5ea:	4a38      	ldr	r2, [pc, #224]	@ (20b6cc <rt_test_011_001_execute+0x1ac>)
  20b5ec:	9201      	str	r2, [sp, #4]
  20b5ee:	4a31      	ldr	r2, [pc, #196]	@ (20b6b4 <rt_test_011_001_execute+0x194>)
  20b5f0:	9200      	str	r2, [sp, #0]
  20b5f2:	4a37      	ldr	r2, [pc, #220]	@ (20b6d0 <rt_test_011_001_execute+0x1b0>)
  20b5f4:	f04f 4100 	mov.w	r1, #2147483648	@ 0x80000000
  20b5f8:	482b      	ldr	r0, [pc, #172]	@ (20b6a8 <rt_test_011_001_execute+0x188>)
  20b5fa:	f7f9 fb69 	bl	204cd0 <chThdCreateFromHeap>
  20b5fe:	4603      	mov	r3, r0
  20b600:	4a2e      	ldr	r2, [pc, #184]	@ (20b6bc <rt_test_011_001_execute+0x19c>)
  20b602:	6093      	str	r3, [r2, #8]
                                     (((size_t)-1) >> 1U) + 1U,
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
  20b604:	4b2d      	ldr	r3, [pc, #180]	@ (20b6bc <rt_test_011_001_execute+0x19c>)
  20b606:	689b      	ldr	r3, [r3, #8]
  20b608:	2b00      	cmp	r3, #0
  20b60a:	bf0c      	ite	eq
  20b60c:	2301      	moveq	r3, #1
  20b60e:	2300      	movne	r3, #0
  20b610:	b2db      	uxtb	r3, r3
  20b612:	4930      	ldr	r1, [pc, #192]	@ (20b6d4 <rt_test_011_001_execute+0x1b4>)
  20b614:	4618      	mov	r0, r3
  20b616:	f7fc f823 	bl	207660 <__test_assert>
  20b61a:	4603      	mov	r3, r0
  20b61c:	2b00      	cmp	r3, #0
  20b61e:	d13e      	bne.n	20b69e <rt_test_011_001_execute+0x17e>
  }
  test_end_step(5);

  /* [11.1.6] Letting threads execute then checking the start order and
     freeing memory.*/
  test_set_step(6);
  20b620:	4b20      	ldr	r3, [pc, #128]	@ (20b6a4 <rt_test_011_001_execute+0x184>)
  20b622:	2206      	movs	r2, #6
  20b624:	601a      	str	r2, [r3, #0]
  {
    test_wait_threads();
  20b626:	f7fc fbeb 	bl	207e00 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
  20b62a:	492b      	ldr	r1, [pc, #172]	@ (20b6d8 <rt_test_011_001_execute+0x1b8>)
  20b62c:	482b      	ldr	r0, [pc, #172]	@ (20b6dc <rt_test_011_001_execute+0x1bc>)
  20b62e:	f7fc f82f 	bl	207690 <__test_assert_sequence>
  20b632:	4603      	mov	r3, r0
  20b634:	2b00      	cmp	r3, #0
  20b636:	d132      	bne.n	20b69e <rt_test_011_001_execute+0x17e>
  }
  test_end_step(6);

  /* [11.1.7] Getting heap info again for verification.*/
  test_set_step(7);
  20b638:	4b1a      	ldr	r3, [pc, #104]	@ (20b6a4 <rt_test_011_001_execute+0x184>)
  20b63a:	2207      	movs	r2, #7
  20b63c:	601a      	str	r2, [r3, #0]
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
  20b63e:	aa03      	add	r2, sp, #12
  20b640:	ab04      	add	r3, sp, #16
  20b642:	4619      	mov	r1, r3
  20b644:	4818      	ldr	r0, [pc, #96]	@ (20b6a8 <rt_test_011_001_execute+0x188>)
  20b646:	f7fa f8e3 	bl	205810 <chHeapStatus>
  20b64a:	9007      	str	r0, [sp, #28]
    test_assert(n1 == n2, "fragmentation changed");
  20b64c:	9a08      	ldr	r2, [sp, #32]
  20b64e:	9b07      	ldr	r3, [sp, #28]
  20b650:	429a      	cmp	r2, r3
  20b652:	bf0c      	ite	eq
  20b654:	2301      	moveq	r3, #1
  20b656:	2300      	movne	r3, #0
  20b658:	b2db      	uxtb	r3, r3
  20b65a:	4921      	ldr	r1, [pc, #132]	@ (20b6e0 <rt_test_011_001_execute+0x1c0>)
  20b65c:	4618      	mov	r0, r3
  20b65e:	f7fb ffff 	bl	207660 <__test_assert>
  20b662:	4603      	mov	r3, r0
  20b664:	2b00      	cmp	r3, #0
  20b666:	d11a      	bne.n	20b69e <rt_test_011_001_execute+0x17e>
    test_assert(total1 == total2, "total free space changed");
  20b668:	9a06      	ldr	r2, [sp, #24]
  20b66a:	9b04      	ldr	r3, [sp, #16]
  20b66c:	429a      	cmp	r2, r3
  20b66e:	bf0c      	ite	eq
  20b670:	2301      	moveq	r3, #1
  20b672:	2300      	movne	r3, #0
  20b674:	b2db      	uxtb	r3, r3
  20b676:	491b      	ldr	r1, [pc, #108]	@ (20b6e4 <rt_test_011_001_execute+0x1c4>)
  20b678:	4618      	mov	r0, r3
  20b67a:	f7fb fff1 	bl	207660 <__test_assert>
  20b67e:	4603      	mov	r3, r0
  20b680:	2b00      	cmp	r3, #0
  20b682:	d10c      	bne.n	20b69e <rt_test_011_001_execute+0x17e>
    test_assert(largest1 == largest2, "largest fragment size changed");
  20b684:	9a05      	ldr	r2, [sp, #20]
  20b686:	9b03      	ldr	r3, [sp, #12]
  20b688:	429a      	cmp	r2, r3
  20b68a:	bf0c      	ite	eq
  20b68c:	2301      	moveq	r3, #1
  20b68e:	2300      	movne	r3, #0
  20b690:	b2db      	uxtb	r3, r3
  20b692:	4915      	ldr	r1, [pc, #84]	@ (20b6e8 <rt_test_011_001_execute+0x1c8>)
  20b694:	4618      	mov	r0, r3
  20b696:	f7fb ffe3 	bl	207660 <__test_assert>
  20b69a:	4603      	mov	r3, r0
  20b69c:	2b00      	cmp	r3, #0
  }
  test_end_step(7);
}
  20b69e:	b00b      	add	sp, #44	@ 0x2c
  20b6a0:	f85d fb04 	ldr.w	pc, [sp], #4
  20b6a4:	20000bb4 	.word	0x20000bb4
  20b6a8:	20001924 	.word	0x20001924
  20b6ac:	08011934 	.word	0x08011934
  20b6b0:	080116f0 	.word	0x080116f0
  20b6b4:	0020b4e1 	.word	0x0020b4e1
  20b6b8:	08011944 	.word	0x08011944
  20b6bc:	20001900 	.word	0x20001900
  20b6c0:	0801194c 	.word	0x0801194c
  20b6c4:	080116ec 	.word	0x080116ec
  20b6c8:	08011964 	.word	0x08011964
  20b6cc:	080116e8 	.word	0x080116e8
  20b6d0:	0801196c 	.word	0x0801196c
  20b6d4:	08011974 	.word	0x08011974
  20b6d8:	080116f4 	.word	0x080116f4
  20b6dc:	08011990 	.word	0x08011990
  20b6e0:	08011994 	.word	0x08011994
  20b6e4:	080119ac 	.word	0x080119ac
  20b6e8:	080119c8 	.word	0x080119c8
  20b6ec:	00000000 	.word	0x00000000

0020b6f0 <rt_test_011_002_setup>:
 *   execution sequence.
 * - [11.2.6] Testing that the pool contains four elements again.
 * .
 */

static void rt_test_011_002_setup(void) {
  20b6f0:	b508      	push	{r3, lr}
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
  20b6f2:	2200      	movs	r2, #0
  20b6f4:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20b6f8:	4802      	ldr	r0, [pc, #8]	@ (20b704 <rt_test_011_002_setup+0x14>)
  20b6fa:	f7ff fee1 	bl	20b4c0 <chPoolObjectInit.lto_priv.1>
}
  20b6fe:	bf00      	nop
  20b700:	bd08      	pop	{r3, pc}
  20b702:	bf00      	nop
  20b704:	20001948 	.word	0x20001948
	...

0020b710 <rt_test_011_002_execute>:

static void rt_test_011_002_execute(void) {
  20b710:	b500      	push	{lr}
  20b712:	b085      	sub	sp, #20
  unsigned i;
  tprio_t prio;

  /* [11.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
  20b714:	4b60      	ldr	r3, [pc, #384]	@ (20b898 <rt_test_011_002_execute+0x188>)
  20b716:	2201      	movs	r2, #1
  20b718:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < 4; i++)
  20b71a:	2300      	movs	r3, #0
  20b71c:	9303      	str	r3, [sp, #12]
  20b71e:	e00a      	b.n	20b736 <rt_test_011_002_execute+0x26>
      chPoolFree(&mp1, wa[i]);
  20b720:	4a5e      	ldr	r2, [pc, #376]	@ (20b89c <rt_test_011_002_execute+0x18c>)
  20b722:	9b03      	ldr	r3, [sp, #12]
  20b724:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  20b728:	4619      	mov	r1, r3
  20b72a:	485d      	ldr	r0, [pc, #372]	@ (20b8a0 <rt_test_011_002_execute+0x190>)
  20b72c:	f7fa fa00 	bl	205b30 <chPoolFree>
    for (i = 0; i < 4; i++)
  20b730:	9b03      	ldr	r3, [sp, #12]
  20b732:	3301      	adds	r3, #1
  20b734:	9303      	str	r3, [sp, #12]
  20b736:	9b03      	ldr	r3, [sp, #12]
  20b738:	2b03      	cmp	r3, #3
  20b73a:	d9f1      	bls.n	20b720 <rt_test_011_002_execute+0x10>
  }
  test_end_step(1);

  /* [11.2.2] Getting base priority for threads.*/
  test_set_step(2);
  20b73c:	4b56      	ldr	r3, [pc, #344]	@ (20b898 <rt_test_011_002_execute+0x188>)
  20b73e:	2202      	movs	r2, #2
  20b740:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
  20b742:	f7ff feb5 	bl	20b4b0 <chThdGetPriorityX.lto_priv.6>
  20b746:	9002      	str	r0, [sp, #8]
  }
  test_end_step(2);

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  20b748:	4b53      	ldr	r3, [pc, #332]	@ (20b898 <rt_test_011_002_execute+0x188>)
  20b74a:	2203      	movs	r2, #3
  20b74c:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
  20b74e:	9b02      	ldr	r3, [sp, #8]
  20b750:	1e5a      	subs	r2, r3, #1
  20b752:	4b54      	ldr	r3, [pc, #336]	@ (20b8a4 <rt_test_011_002_execute+0x194>)
  20b754:	9300      	str	r3, [sp, #0]
  20b756:	4b54      	ldr	r3, [pc, #336]	@ (20b8a8 <rt_test_011_002_execute+0x198>)
  20b758:	4954      	ldr	r1, [pc, #336]	@ (20b8ac <rt_test_011_002_execute+0x19c>)
  20b75a:	4851      	ldr	r0, [pc, #324]	@ (20b8a0 <rt_test_011_002_execute+0x190>)
  20b75c:	f7f9 faf8 	bl	204d50 <chThdCreateFromMemoryPool>
  20b760:	4603      	mov	r3, r0
  20b762:	4a53      	ldr	r2, [pc, #332]	@ (20b8b0 <rt_test_011_002_execute+0x1a0>)
  20b764:	6013      	str	r3, [r2, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
  20b766:	9b02      	ldr	r3, [sp, #8]
  20b768:	1e9a      	subs	r2, r3, #2
  20b76a:	4b52      	ldr	r3, [pc, #328]	@ (20b8b4 <rt_test_011_002_execute+0x1a4>)
  20b76c:	9300      	str	r3, [sp, #0]
  20b76e:	4b4e      	ldr	r3, [pc, #312]	@ (20b8a8 <rt_test_011_002_execute+0x198>)
  20b770:	4951      	ldr	r1, [pc, #324]	@ (20b8b8 <rt_test_011_002_execute+0x1a8>)
  20b772:	484b      	ldr	r0, [pc, #300]	@ (20b8a0 <rt_test_011_002_execute+0x190>)
  20b774:	f7f9 faec 	bl	204d50 <chThdCreateFromMemoryPool>
  20b778:	4603      	mov	r3, r0
  20b77a:	4a4d      	ldr	r2, [pc, #308]	@ (20b8b0 <rt_test_011_002_execute+0x1a0>)
  20b77c:	6053      	str	r3, [r2, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
  20b77e:	9b02      	ldr	r3, [sp, #8]
  20b780:	1eda      	subs	r2, r3, #3
  20b782:	4b4e      	ldr	r3, [pc, #312]	@ (20b8bc <rt_test_011_002_execute+0x1ac>)
  20b784:	9300      	str	r3, [sp, #0]
  20b786:	4b48      	ldr	r3, [pc, #288]	@ (20b8a8 <rt_test_011_002_execute+0x198>)
  20b788:	494d      	ldr	r1, [pc, #308]	@ (20b8c0 <rt_test_011_002_execute+0x1b0>)
  20b78a:	4845      	ldr	r0, [pc, #276]	@ (20b8a0 <rt_test_011_002_execute+0x190>)
  20b78c:	f7f9 fae0 	bl	204d50 <chThdCreateFromMemoryPool>
  20b790:	4603      	mov	r3, r0
  20b792:	4a47      	ldr	r2, [pc, #284]	@ (20b8b0 <rt_test_011_002_execute+0x1a0>)
  20b794:	6093      	str	r3, [r2, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
  20b796:	9b02      	ldr	r3, [sp, #8]
  20b798:	1f1a      	subs	r2, r3, #4
  20b79a:	4b4a      	ldr	r3, [pc, #296]	@ (20b8c4 <rt_test_011_002_execute+0x1b4>)
  20b79c:	9300      	str	r3, [sp, #0]
  20b79e:	4b42      	ldr	r3, [pc, #264]	@ (20b8a8 <rt_test_011_002_execute+0x198>)
  20b7a0:	4949      	ldr	r1, [pc, #292]	@ (20b8c8 <rt_test_011_002_execute+0x1b8>)
  20b7a2:	483f      	ldr	r0, [pc, #252]	@ (20b8a0 <rt_test_011_002_execute+0x190>)
  20b7a4:	f7f9 fad4 	bl	204d50 <chThdCreateFromMemoryPool>
  20b7a8:	4603      	mov	r3, r0
  20b7aa:	4a41      	ldr	r2, [pc, #260]	@ (20b8b0 <rt_test_011_002_execute+0x1a0>)
  20b7ac:	60d3      	str	r3, [r2, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
  20b7ae:	9b02      	ldr	r3, [sp, #8]
  20b7b0:	1f5a      	subs	r2, r3, #5
  20b7b2:	4b46      	ldr	r3, [pc, #280]	@ (20b8cc <rt_test_011_002_execute+0x1bc>)
  20b7b4:	9300      	str	r3, [sp, #0]
  20b7b6:	4b3c      	ldr	r3, [pc, #240]	@ (20b8a8 <rt_test_011_002_execute+0x198>)
  20b7b8:	4945      	ldr	r1, [pc, #276]	@ (20b8d0 <rt_test_011_002_execute+0x1c0>)
  20b7ba:	4839      	ldr	r0, [pc, #228]	@ (20b8a0 <rt_test_011_002_execute+0x190>)
  20b7bc:	f7f9 fac8 	bl	204d50 <chThdCreateFromMemoryPool>
  20b7c0:	4603      	mov	r3, r0
  20b7c2:	4a3b      	ldr	r2, [pc, #236]	@ (20b8b0 <rt_test_011_002_execute+0x1a0>)
  20b7c4:	6113      	str	r3, [r2, #16]
  }
  test_end_step(3);

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  20b7c6:	4b34      	ldr	r3, [pc, #208]	@ (20b898 <rt_test_011_002_execute+0x188>)
  20b7c8:	2204      	movs	r2, #4
  20b7ca:	601a      	str	r2, [r3, #0]
  {
    test_assert((threads[0] != NULL) &&
  20b7cc:	4b38      	ldr	r3, [pc, #224]	@ (20b8b0 <rt_test_011_002_execute+0x1a0>)
  20b7ce:	681b      	ldr	r3, [r3, #0]
  20b7d0:	2b00      	cmp	r3, #0
  20b7d2:	d00d      	beq.n	20b7f0 <rt_test_011_002_execute+0xe0>
  20b7d4:	4b36      	ldr	r3, [pc, #216]	@ (20b8b0 <rt_test_011_002_execute+0x1a0>)
  20b7d6:	685b      	ldr	r3, [r3, #4]
  20b7d8:	2b00      	cmp	r3, #0
  20b7da:	d009      	beq.n	20b7f0 <rt_test_011_002_execute+0xe0>
  20b7dc:	4b34      	ldr	r3, [pc, #208]	@ (20b8b0 <rt_test_011_002_execute+0x1a0>)
  20b7de:	689b      	ldr	r3, [r3, #8]
  20b7e0:	2b00      	cmp	r3, #0
  20b7e2:	d005      	beq.n	20b7f0 <rt_test_011_002_execute+0xe0>
  20b7e4:	4b32      	ldr	r3, [pc, #200]	@ (20b8b0 <rt_test_011_002_execute+0x1a0>)
  20b7e6:	68db      	ldr	r3, [r3, #12]
  20b7e8:	2b00      	cmp	r3, #0
  20b7ea:	d001      	beq.n	20b7f0 <rt_test_011_002_execute+0xe0>
  20b7ec:	2301      	movs	r3, #1
  20b7ee:	e000      	b.n	20b7f2 <rt_test_011_002_execute+0xe2>
  20b7f0:	2300      	movs	r3, #0
  20b7f2:	f003 0301 	and.w	r3, r3, #1
  20b7f6:	b2db      	uxtb	r3, r3
  20b7f8:	4936      	ldr	r1, [pc, #216]	@ (20b8d4 <rt_test_011_002_execute+0x1c4>)
  20b7fa:	4618      	mov	r0, r3
  20b7fc:	f7fb ff30 	bl	207660 <__test_assert>
  20b800:	4603      	mov	r3, r0
  20b802:	2b00      	cmp	r3, #0
  20b804:	d144      	bne.n	20b890 <rt_test_011_002_execute+0x180>
                (threads[1] != NULL) &&
                (threads[2] != NULL) &&
                (threads[3] != NULL),
                "thread creation failed");
    test_assert(threads[4] == NULL,
  20b806:	4b2a      	ldr	r3, [pc, #168]	@ (20b8b0 <rt_test_011_002_execute+0x1a0>)
  20b808:	691b      	ldr	r3, [r3, #16]
  20b80a:	2b00      	cmp	r3, #0
  20b80c:	bf0c      	ite	eq
  20b80e:	2301      	moveq	r3, #1
  20b810:	2300      	movne	r3, #0
  20b812:	b2db      	uxtb	r3, r3
  20b814:	4930      	ldr	r1, [pc, #192]	@ (20b8d8 <rt_test_011_002_execute+0x1c8>)
  20b816:	4618      	mov	r0, r3
  20b818:	f7fb ff22 	bl	207660 <__test_assert>
  20b81c:	4603      	mov	r3, r0
  20b81e:	2b00      	cmp	r3, #0
  20b820:	d136      	bne.n	20b890 <rt_test_011_002_execute+0x180>
  }
  test_end_step(4);

  /* [11.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
  20b822:	4b1d      	ldr	r3, [pc, #116]	@ (20b898 <rt_test_011_002_execute+0x188>)
  20b824:	2205      	movs	r2, #5
  20b826:	601a      	str	r2, [r3, #0]
  {
    test_wait_threads();
  20b828:	f7fc faea 	bl	207e00 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
  20b82c:	492b      	ldr	r1, [pc, #172]	@ (20b8dc <rt_test_011_002_execute+0x1cc>)
  20b82e:	482c      	ldr	r0, [pc, #176]	@ (20b8e0 <rt_test_011_002_execute+0x1d0>)
  20b830:	f7fb ff2e 	bl	207690 <__test_assert_sequence>
  20b834:	4603      	mov	r3, r0
  20b836:	2b00      	cmp	r3, #0
  20b838:	d12a      	bne.n	20b890 <rt_test_011_002_execute+0x180>
  }
  test_end_step(5);

  /* [11.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
  20b83a:	4b17      	ldr	r3, [pc, #92]	@ (20b898 <rt_test_011_002_execute+0x188>)
  20b83c:	2206      	movs	r2, #6
  20b83e:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < 4; i++)
  20b840:	2300      	movs	r3, #0
  20b842:	9303      	str	r3, [sp, #12]
  20b844:	e012      	b.n	20b86c <rt_test_011_002_execute+0x15c>
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
  20b846:	4816      	ldr	r0, [pc, #88]	@ (20b8a0 <rt_test_011_002_execute+0x190>)
  20b848:	f7fa f952 	bl	205af0 <chPoolAlloc>
  20b84c:	4603      	mov	r3, r0
  20b84e:	2b00      	cmp	r3, #0
  20b850:	bf14      	ite	ne
  20b852:	2301      	movne	r3, #1
  20b854:	2300      	moveq	r3, #0
  20b856:	b2db      	uxtb	r3, r3
  20b858:	4922      	ldr	r1, [pc, #136]	@ (20b8e4 <rt_test_011_002_execute+0x1d4>)
  20b85a:	4618      	mov	r0, r3
  20b85c:	f7fb ff00 	bl	207660 <__test_assert>
  20b860:	4603      	mov	r3, r0
  20b862:	2b00      	cmp	r3, #0
  20b864:	d114      	bne.n	20b890 <rt_test_011_002_execute+0x180>
    for (i = 0; i < 4; i++)
  20b866:	9b03      	ldr	r3, [sp, #12]
  20b868:	3301      	adds	r3, #1
  20b86a:	9303      	str	r3, [sp, #12]
  20b86c:	9b03      	ldr	r3, [sp, #12]
  20b86e:	2b03      	cmp	r3, #3
  20b870:	d9e9      	bls.n	20b846 <rt_test_011_002_execute+0x136>
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
  20b872:	480b      	ldr	r0, [pc, #44]	@ (20b8a0 <rt_test_011_002_execute+0x190>)
  20b874:	f7fa f93c 	bl	205af0 <chPoolAlloc>
  20b878:	4603      	mov	r3, r0
  20b87a:	2b00      	cmp	r3, #0
  20b87c:	bf0c      	ite	eq
  20b87e:	2301      	moveq	r3, #1
  20b880:	2300      	movne	r3, #0
  20b882:	b2db      	uxtb	r3, r3
  20b884:	4918      	ldr	r1, [pc, #96]	@ (20b8e8 <rt_test_011_002_execute+0x1d8>)
  20b886:	4618      	mov	r0, r3
  20b888:	f7fb feea 	bl	207660 <__test_assert>
  20b88c:	4603      	mov	r3, r0
  20b88e:	2b00      	cmp	r3, #0
  }
  test_end_step(6);
}
  20b890:	b005      	add	sp, #20
  20b892:	f85d fb04 	ldr.w	pc, [sp], #4
  20b896:	bf00      	nop
  20b898:	20000bb4 	.word	0x20000bb4
  20b89c:	08012220 	.word	0x08012220
  20b8a0:	20001948 	.word	0x20001948
  20b8a4:	080116f0 	.word	0x080116f0
  20b8a8:	0020b4e1 	.word	0x0020b4e1
  20b8ac:	08011944 	.word	0x08011944
  20b8b0:	20001900 	.word	0x20001900
  20b8b4:	080116ec 	.word	0x080116ec
  20b8b8:	08011964 	.word	0x08011964
  20b8bc:	080116e8 	.word	0x080116e8
  20b8c0:	0801196c 	.word	0x0801196c
  20b8c4:	080116e4 	.word	0x080116e4
  20b8c8:	080119e8 	.word	0x080119e8
  20b8cc:	0801170c 	.word	0x0801170c
  20b8d0:	080119f0 	.word	0x080119f0
  20b8d4:	0801194c 	.word	0x0801194c
  20b8d8:	08011974 	.word	0x08011974
  20b8dc:	080116f4 	.word	0x080116f4
  20b8e0:	080118a0 	.word	0x080118a0
  20b8e4:	080119f8 	.word	0x080119f8
  20b8e8:	08011a08 	.word	0x08011a08
  20b8ec:	00000000 	.word	0x00000000

0020b8f0 <chTimeAddX.lto_priv.6>:
                                   sysinterval_t interval) {
  20b8f0:	b082      	sub	sp, #8
  20b8f2:	9001      	str	r0, [sp, #4]
  20b8f4:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
  20b8f6:	9a01      	ldr	r2, [sp, #4]
  20b8f8:	9b00      	ldr	r3, [sp, #0]
  20b8fa:	4413      	add	r3, r2
}
  20b8fc:	4618      	mov	r0, r3
  20b8fe:	b002      	add	sp, #8
  20b900:	4770      	bx	lr
  20b902:	bf00      	nop
	...

0020b910 <chTimeIsInRangeX.lto_priv.4>:
                                    systime_t end) {
  20b910:	b084      	sub	sp, #16
  20b912:	9003      	str	r0, [sp, #12]
  20b914:	9102      	str	r1, [sp, #8]
  20b916:	9201      	str	r2, [sp, #4]
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
  20b918:	9a03      	ldr	r2, [sp, #12]
  20b91a:	9b02      	ldr	r3, [sp, #8]
  20b91c:	1ad2      	subs	r2, r2, r3
                (systime_t)((systime_t)end - (systime_t)start));
  20b91e:	9901      	ldr	r1, [sp, #4]
  20b920:	9b02      	ldr	r3, [sp, #8]
  20b922:	1acb      	subs	r3, r1, r3
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
  20b924:	429a      	cmp	r2, r3
  20b926:	bf34      	ite	cc
  20b928:	2301      	movcc	r3, #1
  20b92a:	2300      	movcs	r3, #0
  20b92c:	b2db      	uxtb	r3, r3
}
  20b92e:	4618      	mov	r0, r3
  20b930:	b004      	add	sp, #16
  20b932:	4770      	bx	lr
	...

0020b940 <port_timer_get_time.lto_priv.9>:
static inline systime_t port_timer_get_time(void) {
  20b940:	b508      	push	{r3, lr}
  return stGetCounter();
  20b942:	f7f4 ffcd 	bl	2008e0 <stGetCounter>
  20b946:	4603      	mov	r3, r0
}
  20b948:	4618      	mov	r0, r3
  20b94a:	bd08      	pop	{r3, pc}
  20b94c:	0000      	movs	r0, r0
	...

0020b950 <chSysLock.lto_priv.27>:
static inline void chSysLock(void) {
  20b950:	b082      	sub	sp, #8
  20b952:	2330      	movs	r3, #48	@ 0x30
  20b954:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b956:	9b01      	ldr	r3, [sp, #4]
  20b958:	f383 8811 	msr	BASEPRI, r3
}
  20b95c:	bf00      	nop
}
  20b95e:	bf00      	nop
}
  20b960:	bf00      	nop
  20b962:	b002      	add	sp, #8
  20b964:	4770      	bx	lr
  20b966:	bf00      	nop
	...

0020b970 <chSysUnlock.lto_priv.27>:
static inline void chSysUnlock(void) {
  20b970:	b082      	sub	sp, #8
  20b972:	2300      	movs	r3, #0
  20b974:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b976:	9b01      	ldr	r3, [sp, #4]
  20b978:	f383 8811 	msr	BASEPRI, r3
}
  20b97c:	bf00      	nop
}
  20b97e:	bf00      	nop
}
  20b980:	bf00      	nop
  20b982:	b002      	add	sp, #8
  20b984:	4770      	bx	lr
  20b986:	bf00      	nop
	...

0020b990 <chVTGetSystemTimeX.lto_priv.9>:
static inline systime_t chVTGetSystemTimeX(void) {
  20b990:	b508      	push	{r3, lr}
  return port_timer_get_time();
  20b992:	f7ff ffd5 	bl	20b940 <port_timer_get_time.lto_priv.9>
  20b996:	4603      	mov	r3, r0
}
  20b998:	4618      	mov	r0, r3
  20b99a:	bd08      	pop	{r3, pc}
  20b99c:	0000      	movs	r0, r0
	...

0020b9a0 <chVTIsSystemTimeWithinX.lto_priv.1>:
static inline bool chVTIsSystemTimeWithinX(systime_t start, systime_t end) {
  20b9a0:	b500      	push	{lr}
  20b9a2:	b083      	sub	sp, #12
  20b9a4:	9001      	str	r0, [sp, #4]
  20b9a6:	9100      	str	r1, [sp, #0]
  return chTimeIsInRangeX(chVTGetSystemTimeX(), start, end);
  20b9a8:	f7ff fff2 	bl	20b990 <chVTGetSystemTimeX.lto_priv.9>
  20b9ac:	4603      	mov	r3, r0
  20b9ae:	9a00      	ldr	r2, [sp, #0]
  20b9b0:	9901      	ldr	r1, [sp, #4]
  20b9b2:	4618      	mov	r0, r3
  20b9b4:	f7ff ffac 	bl	20b910 <chTimeIsInRangeX.lto_priv.4>
  20b9b8:	4603      	mov	r3, r0
}
  20b9ba:	4618      	mov	r0, r3
  20b9bc:	b003      	add	sp, #12
  20b9be:	f85d fb04 	ldr.w	pc, [sp], #4
  20b9c2:	bf00      	nop
	...

0020b9d0 <chThdGetSelfX.lto_priv.13>:
  return __sch_get_currthread();
  20b9d0:	4b01      	ldr	r3, [pc, #4]	@ (20b9d8 <chThdGetSelfX.lto_priv.13+0x8>)
  20b9d2:	68db      	ldr	r3, [r3, #12]
}
  20b9d4:	4618      	mov	r0, r3
  20b9d6:	4770      	bx	lr
  20b9d8:	20000890 	.word	0x20000890
  20b9dc:	00000000 	.word	0x00000000

0020b9e0 <chThdGetPriorityX.lto_priv.7>:
static inline tprio_t chThdGetPriorityX(void) {
  20b9e0:	b508      	push	{r3, lr}
  return chThdGetSelfX()->hdr.pqueue.prio;
  20b9e2:	f7ff fff5 	bl	20b9d0 <chThdGetSelfX.lto_priv.13>
  20b9e6:	4603      	mov	r3, r0
  20b9e8:	689b      	ldr	r3, [r3, #8]
}
  20b9ea:	4618      	mov	r0, r3
  20b9ec:	bd08      	pop	{r3, pc}
  20b9ee:	bf00      	nop

0020b9f0 <chThdShouldTerminateX>:
static inline bool chThdShouldTerminateX(void) {
  20b9f0:	b508      	push	{r3, lr}
  return (bool)((chThdGetSelfX()->flags & CH_FLAGS_TERMINATE) != (tmode_t)0);
  20b9f2:	f7ff ffed 	bl	20b9d0 <chThdGetSelfX.lto_priv.13>
  20b9f6:	4603      	mov	r3, r0
  20b9f8:	7f5b      	ldrb	r3, [r3, #29]
  20b9fa:	b25b      	sxtb	r3, r3
  20b9fc:	b2db      	uxtb	r3, r3
  20b9fe:	09db      	lsrs	r3, r3, #7
  20ba00:	b2db      	uxtb	r3, r3
}
  20ba02:	4618      	mov	r0, r3
  20ba04:	bd08      	pop	{r3, pc}
  20ba06:	bf00      	nop
	...

0020ba10 <chSemReset.lto_priv.1>:
static inline void chSemReset(semaphore_t *sp, cnt_t n) {
  20ba10:	b500      	push	{lr}
  20ba12:	b083      	sub	sp, #12
  20ba14:	9001      	str	r0, [sp, #4]
  20ba16:	9100      	str	r1, [sp, #0]
  chSemResetWithMessage(sp, n, MSG_RESET);
  20ba18:	f06f 0201 	mvn.w	r2, #1
  20ba1c:	9900      	ldr	r1, [sp, #0]
  20ba1e:	9801      	ldr	r0, [sp, #4]
  20ba20:	f7f8 f80e 	bl	203a40 <chSemResetWithMessage>
}
  20ba24:	bf00      	nop
  20ba26:	b003      	add	sp, #12
  20ba28:	f85d fb04 	ldr.w	pc, [sp], #4
  20ba2c:	0000      	movs	r0, r0
	...

0020ba30 <chMsgWait.lto_priv.2>:
static inline thread_t *chMsgWait(void) {
  20ba30:	b500      	push	{lr}
  20ba32:	b083      	sub	sp, #12
  chSysLock();
  20ba34:	f7ff ff8c 	bl	20b950 <chSysLock.lto_priv.27>
  tp = chMsgWaitS();
  20ba38:	f7f9 f8ca 	bl	204bd0 <chMsgWaitS>
  20ba3c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
  20ba3e:	f7ff ff97 	bl	20b970 <chSysUnlock.lto_priv.27>
  return tp;
  20ba42:	9b01      	ldr	r3, [sp, #4]
}
  20ba44:	4618      	mov	r0, r3
  20ba46:	b003      	add	sp, #12
  20ba48:	f85d fb04 	ldr.w	pc, [sp], #4
  20ba4c:	0000      	movs	r0, r0
	...

0020ba50 <chMsgGet.lto_priv.2>:
static inline msg_t chMsgGet(thread_t *tp) {
  20ba50:	b082      	sub	sp, #8
  20ba52:	9001      	str	r0, [sp, #4]
  return tp->u.sentmsg;
  20ba54:	9b01      	ldr	r3, [sp, #4]
  20ba56:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
}
  20ba58:	4618      	mov	r0, r3
  20ba5a:	b002      	add	sp, #8
  20ba5c:	4770      	bx	lr
  20ba5e:	bf00      	nop

0020ba60 <test_printn.lto_priv.1>:
static inline void test_printn(uint32_t n) {
  20ba60:	b500      	push	{lr}
  20ba62:	b083      	sub	sp, #12
  20ba64:	9001      	str	r0, [sp, #4]
  test_printf("%u", n);
  20ba66:	9901      	ldr	r1, [sp, #4]
  20ba68:	4803      	ldr	r0, [pc, #12]	@ (20ba78 <test_printn.lto_priv.1+0x18>)
  20ba6a:	f7fc f951 	bl	207d10 <test_printf>
}
  20ba6e:	bf00      	nop
  20ba70:	b003      	add	sp, #12
  20ba72:	f85d fb04 	ldr.w	pc, [sp], #4
  20ba76:	bf00      	nop
  20ba78:	08010dbc 	.word	0x08010dbc
  20ba7c:	00000000 	.word	0x00000000

0020ba80 <test_print.lto_priv.1>:
static inline void test_print(const char *msgp) {
  20ba80:	b500      	push	{lr}
  20ba82:	b083      	sub	sp, #12
  20ba84:	9001      	str	r0, [sp, #4]
  test_printf("%s", msgp);
  20ba86:	9901      	ldr	r1, [sp, #4]
  20ba88:	4803      	ldr	r0, [pc, #12]	@ (20ba98 <test_print.lto_priv.1+0x18>)
  20ba8a:	f7fc f941 	bl	207d10 <test_printf>
}
  20ba8e:	bf00      	nop
  20ba90:	b003      	add	sp, #12
  20ba92:	f85d fb04 	ldr.w	pc, [sp], #4
  20ba96:	bf00      	nop
  20ba98:	08010dc0 	.word	0x08010dc0
  20ba9c:	00000000 	.word	0x00000000

0020baa0 <test_println.lto_priv.1>:
static inline void test_println(const char *msgp) {
  20baa0:	b500      	push	{lr}
  20baa2:	b083      	sub	sp, #12
  20baa4:	9001      	str	r0, [sp, #4]
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
  20baa6:	9901      	ldr	r1, [sp, #4]
  20baa8:	4803      	ldr	r0, [pc, #12]	@ (20bab8 <test_println.lto_priv.1+0x18>)
  20baaa:	f7fc f931 	bl	207d10 <test_printf>
}
  20baae:	bf00      	nop
  20bab0:	b003      	add	sp, #12
  20bab2:	f85d fb04 	ldr.w	pc, [sp], #4
  20bab6:	bf00      	nop
  20bab8:	08010bb4 	.word	0x08010bb4
  20babc:	00000000 	.word	0x00000000

0020bac0 <tmo>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(virtual_timer_t *vtp, void *param) {
  20bac0:	b082      	sub	sp, #8
  20bac2:	9001      	str	r0, [sp, #4]
  20bac4:	9100      	str	r1, [sp, #0]

  (void)vtp;
  (void)param;
}
  20bac6:	bf00      	nop
  20bac8:	b002      	add	sp, #8
  20baca:	4770      	bx	lr
  20bacc:	0000      	movs	r0, r0
	...

0020bad0 <bmk_thread1>:

#if CH_CFG_USE_MESSAGES
static THD_FUNCTION(bmk_thread1, p) {
  20bad0:	b500      	push	{lr}
  20bad2:	b085      	sub	sp, #20
  20bad4:	9001      	str	r0, [sp, #4]
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
  20bad6:	f7ff ffab 	bl	20ba30 <chMsgWait.lto_priv.2>
  20bada:	9003      	str	r0, [sp, #12]
    msg = chMsgGet(tp);
  20badc:	9803      	ldr	r0, [sp, #12]
  20bade:	f7ff ffb7 	bl	20ba50 <chMsgGet.lto_priv.2>
  20bae2:	9002      	str	r0, [sp, #8]
    chMsgRelease(tp, msg);
  20bae4:	9902      	ldr	r1, [sp, #8]
  20bae6:	9803      	ldr	r0, [sp, #12]
  20bae8:	f7f9 f892 	bl	204c10 <chMsgRelease>
  } while (msg);
  20baec:	9b02      	ldr	r3, [sp, #8]
  20baee:	2b00      	cmp	r3, #0
  20baf0:	d1f1      	bne.n	20bad6 <bmk_thread1+0x6>
}
  20baf2:	bf00      	nop
  20baf4:	bf00      	nop
  20baf6:	b005      	add	sp, #20
  20baf8:	f85d fb04 	ldr.w	pc, [sp], #4
  20bafc:	0000      	movs	r0, r0
	...

0020bb00 <msg_loop_test>:

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
  20bb00:	b500      	push	{lr}
  20bb02:	b087      	sub	sp, #28
  20bb04:	9001      	str	r0, [sp, #4]
  systime_t start, end;

  uint32_t n = 0;
  20bb06:	2300      	movs	r3, #0
  20bb08:	9305      	str	r3, [sp, #20]
  start = test_wait_tick();
  20bb0a:	f7fc f9a1 	bl	207e50 <test_wait_tick>
  20bb0e:	9004      	str	r0, [sp, #16]
  end = chTimeAddX(start, TIME_MS2I(1000));
  20bb10:	f242 7110 	movw	r1, #10000	@ 0x2710
  20bb14:	9804      	ldr	r0, [sp, #16]
  20bb16:	f7ff feeb 	bl	20b8f0 <chTimeAddX.lto_priv.6>
  20bb1a:	9003      	str	r0, [sp, #12]
  do {
    (void)chMsgSend(tp, 1);
  20bb1c:	2101      	movs	r1, #1
  20bb1e:	9801      	ldr	r0, [sp, #4]
  20bb20:	f7f9 f82e 	bl	204b80 <chMsgSend>
    n++;
  20bb24:	9b05      	ldr	r3, [sp, #20]
  20bb26:	3301      	adds	r3, #1
  20bb28:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
  20bb2a:	9903      	ldr	r1, [sp, #12]
  20bb2c:	9804      	ldr	r0, [sp, #16]
  20bb2e:	f7ff ff37 	bl	20b9a0 <chVTIsSystemTimeWithinX.lto_priv.1>
  20bb32:	4603      	mov	r3, r0
  20bb34:	2b00      	cmp	r3, #0
  20bb36:	d1f1      	bne.n	20bb1c <msg_loop_test+0x1c>
  (void)chMsgSend(tp, 0);
  20bb38:	2100      	movs	r1, #0
  20bb3a:	9801      	ldr	r0, [sp, #4]
  20bb3c:	f7f9 f820 	bl	204b80 <chMsgSend>
  return n;
  20bb40:	9b05      	ldr	r3, [sp, #20]
}
  20bb42:	4618      	mov	r0, r3
  20bb44:	b007      	add	sp, #28
  20bb46:	f85d fb04 	ldr.w	pc, [sp], #4
  20bb4a:	bf00      	nop
  20bb4c:	0000      	movs	r0, r0
	...

0020bb50 <bmk_thread3>:
#endif

static THD_FUNCTION(bmk_thread3, p) {
  20bb50:	b500      	push	{lr}
  20bb52:	b083      	sub	sp, #12
  20bb54:	9001      	str	r0, [sp, #4]

  chThdExit((msg_t)p);
  20bb56:	9b01      	ldr	r3, [sp, #4]
  20bb58:	4618      	mov	r0, r3
  20bb5a:	f7f7 fc99 	bl	203490 <chThdExit>
}
  20bb5e:	bf00      	nop
  20bb60:	b003      	add	sp, #12
  20bb62:	f85d fb04 	ldr.w	pc, [sp], #4
  20bb66:	bf00      	nop
	...

0020bb70 <bmk_thread4>:

static THD_FUNCTION(bmk_thread4, p) {
  20bb70:	b500      	push	{lr}
  20bb72:	b085      	sub	sp, #20
  20bb74:	9001      	str	r0, [sp, #4]
  msg_t msg;
  thread_t *self = chThdGetSelfX();
  20bb76:	f7ff ff2b 	bl	20b9d0 <chThdGetSelfX.lto_priv.13>
  20bb7a:	9003      	str	r0, [sp, #12]

  (void)p;
  chSysLock();
  20bb7c:	f7ff fee8 	bl	20b950 <chSysLock.lto_priv.27>
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
  20bb80:	2003      	movs	r0, #3
  20bb82:	f7f6 ffe5 	bl	202b50 <chSchGoSleepS>
    msg = self->u.rdymsg;
  20bb86:	9b03      	ldr	r3, [sp, #12]
  20bb88:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  20bb8a:	9302      	str	r3, [sp, #8]
  } while (msg == MSG_OK);
  20bb8c:	9b02      	ldr	r3, [sp, #8]
  20bb8e:	2b00      	cmp	r3, #0
  20bb90:	d0f6      	beq.n	20bb80 <bmk_thread4+0x10>
  chSysUnlock();
  20bb92:	f7ff feed 	bl	20b970 <chSysUnlock.lto_priv.27>
}
  20bb96:	bf00      	nop
  20bb98:	b005      	add	sp, #20
  20bb9a:	f85d fb04 	ldr.w	pc, [sp], #4
  20bb9e:	bf00      	nop

0020bba0 <bmk_thread7>:

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {
  20bba0:	b500      	push	{lr}
  20bba2:	b083      	sub	sp, #12
  20bba4:	9001      	str	r0, [sp, #4]

  (void)p;
  while (!chThdShouldTerminateX())
  20bba6:	e002      	b.n	20bbae <bmk_thread7+0xe>
    chSemWait(&sem1);
  20bba8:	4807      	ldr	r0, [pc, #28]	@ (20bbc8 <bmk_thread7+0x28>)
  20bbaa:	f7f7 ff81 	bl	203ab0 <chSemWait>
  while (!chThdShouldTerminateX())
  20bbae:	f7ff ff1f 	bl	20b9f0 <chThdShouldTerminateX>
  20bbb2:	4603      	mov	r3, r0
  20bbb4:	f083 0301 	eor.w	r3, r3, #1
  20bbb8:	b2db      	uxtb	r3, r3
  20bbba:	2b00      	cmp	r3, #0
  20bbbc:	d1f4      	bne.n	20bba8 <bmk_thread7+0x8>
}
  20bbbe:	bf00      	nop
  20bbc0:	bf00      	nop
  20bbc2:	b003      	add	sp, #12
  20bbc4:	f85d fb04 	ldr.w	pc, [sp], #4
  20bbc8:	20001958 	.word	0x20001958
  20bbcc:	00000000 	.word	0x00000000

0020bbd0 <bmk_thread8>:
#endif

static THD_FUNCTION(bmk_thread8, p) {
  20bbd0:	b500      	push	{lr}
  20bbd2:	b083      	sub	sp, #12
  20bbd4:	9001      	str	r0, [sp, #4]

  do {
    chThdYield();
  20bbd6:	f7f7 fd3b 	bl	203650 <chThdYield>
    chThdYield();
  20bbda:	f7f7 fd39 	bl	203650 <chThdYield>
    chThdYield();
  20bbde:	f7f7 fd37 	bl	203650 <chThdYield>
    chThdYield();
  20bbe2:	f7f7 fd35 	bl	203650 <chThdYield>
    (*(uint32_t *)p) += 4;
  20bbe6:	9b01      	ldr	r3, [sp, #4]
  20bbe8:	681b      	ldr	r3, [r3, #0]
  20bbea:	1d1a      	adds	r2, r3, #4
  20bbec:	9b01      	ldr	r3, [sp, #4]
  20bbee:	601a      	str	r2, [r3, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
  20bbf0:	f7ff fefe 	bl	20b9f0 <chThdShouldTerminateX>
  20bbf4:	4603      	mov	r3, r0
  20bbf6:	f083 0301 	eor.w	r3, r3, #1
  20bbfa:	b2db      	uxtb	r3, r3
  20bbfc:	2b00      	cmp	r3, #0
  20bbfe:	d1ea      	bne.n	20bbd6 <bmk_thread8+0x6>
}
  20bc00:	bf00      	nop
  20bc02:	bf00      	nop
  20bc04:	b003      	add	sp, #12
  20bc06:	f85d fb04 	ldr.w	pc, [sp], #4
  20bc0a:	bf00      	nop
  20bc0c:	0000      	movs	r0, r0
	...

0020bc10 <rt_test_012_001_execute>:
 *   second time window.
 * - [12.1.3] Score is printed.
 * .
 */

static void rt_test_012_001_execute(void) {
  20bc10:	b510      	push	{r4, lr}
  20bc12:	b084      	sub	sp, #16
  uint32_t n;

  /* [12.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
  20bc14:	4b1a      	ldr	r3, [pc, #104]	@ (20bc80 <rt_test_012_001_execute+0x70>)
  20bc16:	2201      	movs	r2, #1
  20bc18:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
  20bc1a:	4b1a      	ldr	r3, [pc, #104]	@ (20bc84 <rt_test_012_001_execute+0x74>)
  20bc1c:	681c      	ldr	r4, [r3, #0]
  20bc1e:	f7ff fedf 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20bc22:	4603      	mov	r3, r0
  20bc24:	1e5a      	subs	r2, r3, #1
  20bc26:	2300      	movs	r3, #0
  20bc28:	9300      	str	r3, [sp, #0]
  20bc2a:	4b17      	ldr	r3, [pc, #92]	@ (20bc88 <rt_test_012_001_execute+0x78>)
  20bc2c:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20bc30:	4620      	mov	r0, r4
  20bc32:	f7f7 fba5 	bl	203380 <chThdCreateStatic>
  20bc36:	4603      	mov	r3, r0
  20bc38:	4a14      	ldr	r2, [pc, #80]	@ (20bc8c <rt_test_012_001_execute+0x7c>)
  20bc3a:	6013      	str	r3, [r2, #0]
  }
  test_end_step(1);

  /* [12.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
  20bc3c:	4b10      	ldr	r3, [pc, #64]	@ (20bc80 <rt_test_012_001_execute+0x70>)
  20bc3e:	2202      	movs	r2, #2
  20bc40:	601a      	str	r2, [r3, #0]
  {
    n = msg_loop_test(threads[0]);
  20bc42:	4b12      	ldr	r3, [pc, #72]	@ (20bc8c <rt_test_012_001_execute+0x7c>)
  20bc44:	681b      	ldr	r3, [r3, #0]
  20bc46:	4618      	mov	r0, r3
  20bc48:	f7ff ff5a 	bl	20bb00 <msg_loop_test>
  20bc4c:	9003      	str	r0, [sp, #12]
    test_wait_threads();
  20bc4e:	f7fc f8d7 	bl	207e00 <test_wait_threads>
  }
  test_end_step(2);

  /* [12.1.3] Score is printed.*/
  test_set_step(3);
  20bc52:	4b0b      	ldr	r3, [pc, #44]	@ (20bc80 <rt_test_012_001_execute+0x70>)
  20bc54:	2203      	movs	r2, #3
  20bc56:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20bc58:	480d      	ldr	r0, [pc, #52]	@ (20bc90 <rt_test_012_001_execute+0x80>)
  20bc5a:	f7ff ff11 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n);
  20bc5e:	9803      	ldr	r0, [sp, #12]
  20bc60:	f7ff fefe 	bl	20ba60 <test_printn.lto_priv.1>
    test_print(" msgs/S, ");
  20bc64:	480b      	ldr	r0, [pc, #44]	@ (20bc94 <rt_test_012_001_execute+0x84>)
  20bc66:	f7ff ff0b 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n << 1);
  20bc6a:	9b03      	ldr	r3, [sp, #12]
  20bc6c:	005b      	lsls	r3, r3, #1
  20bc6e:	4618      	mov	r0, r3
  20bc70:	f7ff fef6 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" ctxswc/S");
  20bc74:	4808      	ldr	r0, [pc, #32]	@ (20bc98 <rt_test_012_001_execute+0x88>)
  20bc76:	f7ff ff13 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(3);
}
  20bc7a:	bf00      	nop
  20bc7c:	b004      	add	sp, #16
  20bc7e:	bd10      	pop	{r4, pc}
  20bc80:	20000bb4 	.word	0x20000bb4
  20bc84:	08012220 	.word	0x08012220
  20bc88:	0020bad1 	.word	0x0020bad1
  20bc8c:	20001900 	.word	0x20001900
  20bc90:	08011a1c 	.word	0x08011a1c
  20bc94:	08011a2c 	.word	0x08011a2c
  20bc98:	08011a38 	.word	0x08011a38
  20bc9c:	00000000 	.word	0x00000000

0020bca0 <rt_test_012_002_execute>:
 *   second time window.
 * - [12.2.3] Score is printed.
 * .
 */

static void rt_test_012_002_execute(void) {
  20bca0:	b510      	push	{r4, lr}
  20bca2:	b084      	sub	sp, #16
  uint32_t n;

  /* [12.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  20bca4:	4b1a      	ldr	r3, [pc, #104]	@ (20bd10 <rt_test_012_002_execute+0x70>)
  20bca6:	2201      	movs	r2, #1
  20bca8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  20bcaa:	4b1a      	ldr	r3, [pc, #104]	@ (20bd14 <rt_test_012_002_execute+0x74>)
  20bcac:	681c      	ldr	r4, [r3, #0]
  20bcae:	f7ff fe97 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20bcb2:	4603      	mov	r3, r0
  20bcb4:	1c5a      	adds	r2, r3, #1
  20bcb6:	2300      	movs	r3, #0
  20bcb8:	9300      	str	r3, [sp, #0]
  20bcba:	4b17      	ldr	r3, [pc, #92]	@ (20bd18 <rt_test_012_002_execute+0x78>)
  20bcbc:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20bcc0:	4620      	mov	r0, r4
  20bcc2:	f7f7 fb5d 	bl	203380 <chThdCreateStatic>
  20bcc6:	4603      	mov	r3, r0
  20bcc8:	4a14      	ldr	r2, [pc, #80]	@ (20bd1c <rt_test_012_002_execute+0x7c>)
  20bcca:	6013      	str	r3, [r2, #0]
  }
  test_end_step(1);

  /* [12.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
  20bccc:	4b10      	ldr	r3, [pc, #64]	@ (20bd10 <rt_test_012_002_execute+0x70>)
  20bcce:	2202      	movs	r2, #2
  20bcd0:	601a      	str	r2, [r3, #0]
  {
    n = msg_loop_test(threads[0]);
  20bcd2:	4b12      	ldr	r3, [pc, #72]	@ (20bd1c <rt_test_012_002_execute+0x7c>)
  20bcd4:	681b      	ldr	r3, [r3, #0]
  20bcd6:	4618      	mov	r0, r3
  20bcd8:	f7ff ff12 	bl	20bb00 <msg_loop_test>
  20bcdc:	9003      	str	r0, [sp, #12]
    test_wait_threads();
  20bcde:	f7fc f88f 	bl	207e00 <test_wait_threads>
  }
  test_end_step(2);

  /* [12.2.3] Score is printed.*/
  test_set_step(3);
  20bce2:	4b0b      	ldr	r3, [pc, #44]	@ (20bd10 <rt_test_012_002_execute+0x70>)
  20bce4:	2203      	movs	r2, #3
  20bce6:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20bce8:	480d      	ldr	r0, [pc, #52]	@ (20bd20 <rt_test_012_002_execute+0x80>)
  20bcea:	f7ff fec9 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n);
  20bcee:	9803      	ldr	r0, [sp, #12]
  20bcf0:	f7ff feb6 	bl	20ba60 <test_printn.lto_priv.1>
    test_print(" msgs/S, ");
  20bcf4:	480b      	ldr	r0, [pc, #44]	@ (20bd24 <rt_test_012_002_execute+0x84>)
  20bcf6:	f7ff fec3 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n << 1);
  20bcfa:	9b03      	ldr	r3, [sp, #12]
  20bcfc:	005b      	lsls	r3, r3, #1
  20bcfe:	4618      	mov	r0, r3
  20bd00:	f7ff feae 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" ctxswc/S");
  20bd04:	4808      	ldr	r0, [pc, #32]	@ (20bd28 <rt_test_012_002_execute+0x88>)
  20bd06:	f7ff fecb 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(3);
}
  20bd0a:	bf00      	nop
  20bd0c:	b004      	add	sp, #16
  20bd0e:	bd10      	pop	{r4, pc}
  20bd10:	20000bb4 	.word	0x20000bb4
  20bd14:	08012220 	.word	0x08012220
  20bd18:	0020bad1 	.word	0x0020bad1
  20bd1c:	20001900 	.word	0x20001900
  20bd20:	08011a1c 	.word	0x08011a1c
  20bd24:	08011a2c 	.word	0x08011a2c
  20bd28:	08011a38 	.word	0x08011a38
  20bd2c:	00000000 	.word	0x00000000

0020bd30 <rt_test_012_003_execute>:
 *   second time window.
 * - [12.3.4] Score is printed.
 * .
 */

static void rt_test_012_003_execute(void) {
  20bd30:	b510      	push	{r4, lr}
  20bd32:	b084      	sub	sp, #16
  uint32_t n;

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  20bd34:	4b3e      	ldr	r3, [pc, #248]	@ (20be30 <rt_test_012_003_execute+0x100>)
  20bd36:	2201      	movs	r2, #1
  20bd38:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  20bd3a:	4b3e      	ldr	r3, [pc, #248]	@ (20be34 <rt_test_012_003_execute+0x104>)
  20bd3c:	681c      	ldr	r4, [r3, #0]
  20bd3e:	f7ff fe4f 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20bd42:	4603      	mov	r3, r0
  20bd44:	1c5a      	adds	r2, r3, #1
  20bd46:	2300      	movs	r3, #0
  20bd48:	9300      	str	r3, [sp, #0]
  20bd4a:	4b3b      	ldr	r3, [pc, #236]	@ (20be38 <rt_test_012_003_execute+0x108>)
  20bd4c:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20bd50:	4620      	mov	r0, r4
  20bd52:	f7f7 fb15 	bl	203380 <chThdCreateStatic>
  20bd56:	4603      	mov	r3, r0
  20bd58:	4a38      	ldr	r2, [pc, #224]	@ (20be3c <rt_test_012_003_execute+0x10c>)
  20bd5a:	6013      	str	r3, [r2, #0]
  }
  test_end_step(1);

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  20bd5c:	4b34      	ldr	r3, [pc, #208]	@ (20be30 <rt_test_012_003_execute+0x100>)
  20bd5e:	2202      	movs	r2, #2
  20bd60:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
  20bd62:	4b34      	ldr	r3, [pc, #208]	@ (20be34 <rt_test_012_003_execute+0x104>)
  20bd64:	685c      	ldr	r4, [r3, #4]
  20bd66:	f7ff fe3b 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20bd6a:	4603      	mov	r3, r0
  20bd6c:	1e9a      	subs	r2, r3, #2
  20bd6e:	2300      	movs	r3, #0
  20bd70:	9300      	str	r3, [sp, #0]
  20bd72:	4b33      	ldr	r3, [pc, #204]	@ (20be40 <rt_test_012_003_execute+0x110>)
  20bd74:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20bd78:	4620      	mov	r0, r4
  20bd7a:	f7f7 fb01 	bl	203380 <chThdCreateStatic>
  20bd7e:	4603      	mov	r3, r0
  20bd80:	4a2e      	ldr	r2, [pc, #184]	@ (20be3c <rt_test_012_003_execute+0x10c>)
  20bd82:	6053      	str	r3, [r2, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
  20bd84:	4b2b      	ldr	r3, [pc, #172]	@ (20be34 <rt_test_012_003_execute+0x104>)
  20bd86:	689c      	ldr	r4, [r3, #8]
  20bd88:	f7ff fe2a 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20bd8c:	4603      	mov	r3, r0
  20bd8e:	1eda      	subs	r2, r3, #3
  20bd90:	2300      	movs	r3, #0
  20bd92:	9300      	str	r3, [sp, #0]
  20bd94:	4b2a      	ldr	r3, [pc, #168]	@ (20be40 <rt_test_012_003_execute+0x110>)
  20bd96:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20bd9a:	4620      	mov	r0, r4
  20bd9c:	f7f7 faf0 	bl	203380 <chThdCreateStatic>
  20bda0:	4603      	mov	r3, r0
  20bda2:	4a26      	ldr	r2, [pc, #152]	@ (20be3c <rt_test_012_003_execute+0x10c>)
  20bda4:	6093      	str	r3, [r2, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
  20bda6:	4b23      	ldr	r3, [pc, #140]	@ (20be34 <rt_test_012_003_execute+0x104>)
  20bda8:	68dc      	ldr	r4, [r3, #12]
  20bdaa:	f7ff fe19 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20bdae:	4603      	mov	r3, r0
  20bdb0:	1f1a      	subs	r2, r3, #4
  20bdb2:	2300      	movs	r3, #0
  20bdb4:	9300      	str	r3, [sp, #0]
  20bdb6:	4b22      	ldr	r3, [pc, #136]	@ (20be40 <rt_test_012_003_execute+0x110>)
  20bdb8:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20bdbc:	4620      	mov	r0, r4
  20bdbe:	f7f7 fadf 	bl	203380 <chThdCreateStatic>
  20bdc2:	4603      	mov	r3, r0
  20bdc4:	4a1d      	ldr	r2, [pc, #116]	@ (20be3c <rt_test_012_003_execute+0x10c>)
  20bdc6:	60d3      	str	r3, [r2, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
  20bdc8:	4b1a      	ldr	r3, [pc, #104]	@ (20be34 <rt_test_012_003_execute+0x104>)
  20bdca:	691c      	ldr	r4, [r3, #16]
  20bdcc:	f7ff fe08 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20bdd0:	4603      	mov	r3, r0
  20bdd2:	1f5a      	subs	r2, r3, #5
  20bdd4:	2300      	movs	r3, #0
  20bdd6:	9300      	str	r3, [sp, #0]
  20bdd8:	4b19      	ldr	r3, [pc, #100]	@ (20be40 <rt_test_012_003_execute+0x110>)
  20bdda:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20bdde:	4620      	mov	r0, r4
  20bde0:	f7f7 face 	bl	203380 <chThdCreateStatic>
  20bde4:	4603      	mov	r3, r0
  20bde6:	4a15      	ldr	r2, [pc, #84]	@ (20be3c <rt_test_012_003_execute+0x10c>)
  20bde8:	6113      	str	r3, [r2, #16]
  }
  test_end_step(2);

  /* [12.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
  20bdea:	4b11      	ldr	r3, [pc, #68]	@ (20be30 <rt_test_012_003_execute+0x100>)
  20bdec:	2203      	movs	r2, #3
  20bdee:	601a      	str	r2, [r3, #0]
  {
    n = msg_loop_test(threads[0]);
  20bdf0:	4b12      	ldr	r3, [pc, #72]	@ (20be3c <rt_test_012_003_execute+0x10c>)
  20bdf2:	681b      	ldr	r3, [r3, #0]
  20bdf4:	4618      	mov	r0, r3
  20bdf6:	f7ff fe83 	bl	20bb00 <msg_loop_test>
  20bdfa:	9003      	str	r0, [sp, #12]
    test_wait_threads();
  20bdfc:	f7fc f800 	bl	207e00 <test_wait_threads>
  }
  test_end_step(3);

  /* [12.3.4] Score is printed.*/
  test_set_step(4);
  20be00:	4b0b      	ldr	r3, [pc, #44]	@ (20be30 <rt_test_012_003_execute+0x100>)
  20be02:	2204      	movs	r2, #4
  20be04:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20be06:	480f      	ldr	r0, [pc, #60]	@ (20be44 <rt_test_012_003_execute+0x114>)
  20be08:	f7ff fe3a 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n);
  20be0c:	9803      	ldr	r0, [sp, #12]
  20be0e:	f7ff fe27 	bl	20ba60 <test_printn.lto_priv.1>
    test_print(" msgs/S, ");
  20be12:	480d      	ldr	r0, [pc, #52]	@ (20be48 <rt_test_012_003_execute+0x118>)
  20be14:	f7ff fe34 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n << 1);
  20be18:	9b03      	ldr	r3, [sp, #12]
  20be1a:	005b      	lsls	r3, r3, #1
  20be1c:	4618      	mov	r0, r3
  20be1e:	f7ff fe1f 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" ctxswc/S");
  20be22:	480a      	ldr	r0, [pc, #40]	@ (20be4c <rt_test_012_003_execute+0x11c>)
  20be24:	f7ff fe3c 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(4);
}
  20be28:	bf00      	nop
  20be2a:	b004      	add	sp, #16
  20be2c:	bd10      	pop	{r4, pc}
  20be2e:	bf00      	nop
  20be30:	20000bb4 	.word	0x20000bb4
  20be34:	08012220 	.word	0x08012220
  20be38:	0020bad1 	.word	0x0020bad1
  20be3c:	20001900 	.word	0x20001900
  20be40:	0020bb51 	.word	0x0020bb51
  20be44:	08011a1c 	.word	0x08011a1c
  20be48:	08011a2c 	.word	0x08011a2c
  20be4c:	08011a38 	.word	0x08011a38

0020be50 <rt_test_012_004_execute>:
 * - [12.4.3] Stopping the target thread.
 * - [12.4.4] Score is printed.
 * .
 */

static void rt_test_012_004_execute(void) {
  20be50:	b510      	push	{r4, lr}
  20be52:	b086      	sub	sp, #24
  thread_t *tp;
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  20be54:	4b30      	ldr	r3, [pc, #192]	@ (20bf18 <rt_test_012_004_execute+0xc8>)
  20be56:	2201      	movs	r2, #1
  20be58:	601a      	str	r2, [r3, #0]
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
  20be5a:	4b30      	ldr	r3, [pc, #192]	@ (20bf1c <rt_test_012_004_execute+0xcc>)
  20be5c:	681c      	ldr	r4, [r3, #0]
  20be5e:	f7ff fdbf 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20be62:	4603      	mov	r3, r0
  20be64:	1c5a      	adds	r2, r3, #1
  20be66:	2300      	movs	r3, #0
  20be68:	9300      	str	r3, [sp, #0]
  20be6a:	4b2d      	ldr	r3, [pc, #180]	@ (20bf20 <rt_test_012_004_execute+0xd0>)
  20be6c:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20be70:	4620      	mov	r0, r4
  20be72:	f7f7 fa85 	bl	203380 <chThdCreateStatic>
  20be76:	4603      	mov	r3, r0
  20be78:	4a2a      	ldr	r2, [pc, #168]	@ (20bf24 <rt_test_012_004_execute+0xd4>)
  20be7a:	6013      	str	r3, [r2, #0]
  20be7c:	4b29      	ldr	r3, [pc, #164]	@ (20bf24 <rt_test_012_004_execute+0xd4>)
  20be7e:	681b      	ldr	r3, [r3, #0]
  20be80:	9304      	str	r3, [sp, #16]
  }
  test_end_step(1);

  /* [12.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
  20be82:	4b25      	ldr	r3, [pc, #148]	@ (20bf18 <rt_test_012_004_execute+0xc8>)
  20be84:	2202      	movs	r2, #2
  20be86:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
  20be88:	2300      	movs	r3, #0
  20be8a:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
  20be8c:	f7fb ffe0 	bl	207e50 <test_wait_tick>
  20be90:	9003      	str	r0, [sp, #12]
    end = chTimeAddX(start, TIME_MS2I(1000));
  20be92:	f242 7110 	movw	r1, #10000	@ 0x2710
  20be96:	9803      	ldr	r0, [sp, #12]
  20be98:	f7ff fd2a 	bl	20b8f0 <chTimeAddX.lto_priv.6>
  20be9c:	9002      	str	r0, [sp, #8]
    do {
      chSysLock();
  20be9e:	f7ff fd57 	bl	20b950 <chSysLock.lto_priv.27>
      chSchWakeupS(tp, MSG_OK);
  20bea2:	2100      	movs	r1, #0
  20bea4:	9804      	ldr	r0, [sp, #16]
  20bea6:	f7f6 feb3 	bl	202c10 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
  20beaa:	2100      	movs	r1, #0
  20beac:	9804      	ldr	r0, [sp, #16]
  20beae:	f7f6 feaf 	bl	202c10 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
  20beb2:	2100      	movs	r1, #0
  20beb4:	9804      	ldr	r0, [sp, #16]
  20beb6:	f7f6 feab 	bl	202c10 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
  20beba:	2100      	movs	r1, #0
  20bebc:	9804      	ldr	r0, [sp, #16]
  20bebe:	f7f6 fea7 	bl	202c10 <chSchWakeupS>
      chSysUnlock();
  20bec2:	f7ff fd55 	bl	20b970 <chSysUnlock.lto_priv.27>
      n += 4;
  20bec6:	9b05      	ldr	r3, [sp, #20]
  20bec8:	3304      	adds	r3, #4
  20beca:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  20becc:	9902      	ldr	r1, [sp, #8]
  20bece:	9803      	ldr	r0, [sp, #12]
  20bed0:	f7ff fd66 	bl	20b9a0 <chVTIsSystemTimeWithinX.lto_priv.1>
  20bed4:	4603      	mov	r3, r0
  20bed6:	2b00      	cmp	r3, #0
  20bed8:	d1e1      	bne.n	20be9e <rt_test_012_004_execute+0x4e>
  }
  test_end_step(2);

  /* [12.4.3] Stopping the target thread.*/
  test_set_step(3);
  20beda:	4b0f      	ldr	r3, [pc, #60]	@ (20bf18 <rt_test_012_004_execute+0xc8>)
  20bedc:	2203      	movs	r2, #3
  20bede:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  20bee0:	f7ff fd36 	bl	20b950 <chSysLock.lto_priv.27>
    chSchWakeupS(tp, MSG_TIMEOUT);
  20bee4:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
  20bee8:	9804      	ldr	r0, [sp, #16]
  20beea:	f7f6 fe91 	bl	202c10 <chSchWakeupS>
    chSysUnlock();
  20beee:	f7ff fd3f 	bl	20b970 <chSysUnlock.lto_priv.27>
    test_wait_threads();
  20bef2:	f7fb ff85 	bl	207e00 <test_wait_threads>
  }
  test_end_step(3);

  /* [12.4.4] Score is printed.*/
  test_set_step(4);
  20bef6:	4b08      	ldr	r3, [pc, #32]	@ (20bf18 <rt_test_012_004_execute+0xc8>)
  20bef8:	2204      	movs	r2, #4
  20befa:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20befc:	480a      	ldr	r0, [pc, #40]	@ (20bf28 <rt_test_012_004_execute+0xd8>)
  20befe:	f7ff fdbf 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n * 2);
  20bf02:	9b05      	ldr	r3, [sp, #20]
  20bf04:	005b      	lsls	r3, r3, #1
  20bf06:	4618      	mov	r0, r3
  20bf08:	f7ff fdaa 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" ctxswc/S");
  20bf0c:	4807      	ldr	r0, [pc, #28]	@ (20bf2c <rt_test_012_004_execute+0xdc>)
  20bf0e:	f7ff fdc7 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(4);
}
  20bf12:	bf00      	nop
  20bf14:	b006      	add	sp, #24
  20bf16:	bd10      	pop	{r4, pc}
  20bf18:	20000bb4 	.word	0x20000bb4
  20bf1c:	08012220 	.word	0x08012220
  20bf20:	0020bb71 	.word	0x0020bb71
  20bf24:	20001900 	.word	0x20001900
  20bf28:	08011a1c 	.word	0x08011a1c
  20bf2c:	08011a38 	.word	0x08011a38

0020bf30 <rt_test_012_005_execute>:
 *   repeated continuously in a one-second time window.
 * - [12.5.2] Score is printed.
 * .
 */

static void rt_test_012_005_execute(void) {
  20bf30:	b500      	push	{lr}
  20bf32:	b087      	sub	sp, #28
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
  20bf34:	f7ff fd54 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20bf38:	4603      	mov	r3, r0
  20bf3a:	3b01      	subs	r3, #1
  20bf3c:	9304      	str	r3, [sp, #16]
  systime_t start, end;

  /* [12.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  20bf3e:	4b1b      	ldr	r3, [pc, #108]	@ (20bfac <rt_test_012_005_execute+0x7c>)
  20bf40:	2201      	movs	r2, #1
  20bf42:	601a      	str	r2, [r3, #0]
  {
    n = 0;
  20bf44:	2300      	movs	r3, #0
  20bf46:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
  20bf48:	f7fb ff82 	bl	207e50 <test_wait_tick>
  20bf4c:	9003      	str	r0, [sp, #12]
    end = chTimeAddX(start, TIME_MS2I(1000));
  20bf4e:	f242 7110 	movw	r1, #10000	@ 0x2710
  20bf52:	9803      	ldr	r0, [sp, #12]
  20bf54:	f7ff fccc 	bl	20b8f0 <chTimeAddX.lto_priv.6>
  20bf58:	9002      	str	r0, [sp, #8]
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
  20bf5a:	4b15      	ldr	r3, [pc, #84]	@ (20bfb0 <rt_test_012_005_execute+0x80>)
  20bf5c:	6818      	ldr	r0, [r3, #0]
  20bf5e:	2300      	movs	r3, #0
  20bf60:	9300      	str	r3, [sp, #0]
  20bf62:	4b14      	ldr	r3, [pc, #80]	@ (20bfb4 <rt_test_012_005_execute+0x84>)
  20bf64:	9a04      	ldr	r2, [sp, #16]
  20bf66:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20bf6a:	f7f7 fa09 	bl	203380 <chThdCreateStatic>
  20bf6e:	4603      	mov	r3, r0
  20bf70:	4618      	mov	r0, r3
  20bf72:	f7f7 fad5 	bl	203520 <chThdWait>
      n++;
  20bf76:	9b05      	ldr	r3, [sp, #20]
  20bf78:	3301      	adds	r3, #1
  20bf7a:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  20bf7c:	9902      	ldr	r1, [sp, #8]
  20bf7e:	9803      	ldr	r0, [sp, #12]
  20bf80:	f7ff fd0e 	bl	20b9a0 <chVTIsSystemTimeWithinX.lto_priv.1>
  20bf84:	4603      	mov	r3, r0
  20bf86:	2b00      	cmp	r3, #0
  20bf88:	d1e7      	bne.n	20bf5a <rt_test_012_005_execute+0x2a>
  }
  test_end_step(1);

  /* [12.5.2] Score is printed.*/
  test_set_step(2);
  20bf8a:	4b08      	ldr	r3, [pc, #32]	@ (20bfac <rt_test_012_005_execute+0x7c>)
  20bf8c:	2202      	movs	r2, #2
  20bf8e:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20bf90:	4809      	ldr	r0, [pc, #36]	@ (20bfb8 <rt_test_012_005_execute+0x88>)
  20bf92:	f7ff fd75 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n);
  20bf96:	9805      	ldr	r0, [sp, #20]
  20bf98:	f7ff fd62 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" threads/S");
  20bf9c:	4807      	ldr	r0, [pc, #28]	@ (20bfbc <rt_test_012_005_execute+0x8c>)
  20bf9e:	f7ff fd7f 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(2);
}
  20bfa2:	bf00      	nop
  20bfa4:	b007      	add	sp, #28
  20bfa6:	f85d fb04 	ldr.w	pc, [sp], #4
  20bfaa:	bf00      	nop
  20bfac:	20000bb4 	.word	0x20000bb4
  20bfb0:	08012220 	.word	0x08012220
  20bfb4:	0020bb51 	.word	0x0020bb51
  20bfb8:	08011a1c 	.word	0x08011a1c
  20bfbc:	08011a44 	.word	0x08011a44

0020bfc0 <rt_test_012_006_execute>:
 *   one-second time window.
 * - [12.6.2] Score is printed.
 * .
 */

static void rt_test_012_006_execute(void) {
  20bfc0:	b500      	push	{lr}
  20bfc2:	b087      	sub	sp, #28
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
  20bfc4:	f7ff fd0c 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20bfc8:	4603      	mov	r3, r0
  20bfca:	3301      	adds	r3, #1
  20bfcc:	9304      	str	r3, [sp, #16]
  systime_t start, end;

  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
  20bfce:	4b1b      	ldr	r3, [pc, #108]	@ (20c03c <rt_test_012_006_execute+0x7c>)
  20bfd0:	2201      	movs	r2, #1
  20bfd2:	601a      	str	r2, [r3, #0]
  {
    n = 0;
  20bfd4:	2300      	movs	r3, #0
  20bfd6:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
  20bfd8:	f7fb ff3a 	bl	207e50 <test_wait_tick>
  20bfdc:	9003      	str	r0, [sp, #12]
    end = chTimeAddX(start, TIME_MS2I(1000));
  20bfde:	f242 7110 	movw	r1, #10000	@ 0x2710
  20bfe2:	9803      	ldr	r0, [sp, #12]
  20bfe4:	f7ff fc84 	bl	20b8f0 <chTimeAddX.lto_priv.6>
  20bfe8:	9002      	str	r0, [sp, #8]
    do {
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
  20bfea:	4b15      	ldr	r3, [pc, #84]	@ (20c040 <rt_test_012_006_execute+0x80>)
  20bfec:	6818      	ldr	r0, [r3, #0]
  20bfee:	2300      	movs	r3, #0
  20bff0:	9300      	str	r3, [sp, #0]
  20bff2:	4b14      	ldr	r3, [pc, #80]	@ (20c044 <rt_test_012_006_execute+0x84>)
  20bff4:	9a04      	ldr	r2, [sp, #16]
  20bff6:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20bffa:	f7f7 f9c1 	bl	203380 <chThdCreateStatic>
  20bffe:	4603      	mov	r3, r0
  20c000:	4618      	mov	r0, r3
  20c002:	f7f7 fa15 	bl	203430 <chThdRelease>
#else
      chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL);
#endif
      n++;
  20c006:	9b05      	ldr	r3, [sp, #20]
  20c008:	3301      	adds	r3, #1
  20c00a:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  20c00c:	9902      	ldr	r1, [sp, #8]
  20c00e:	9803      	ldr	r0, [sp, #12]
  20c010:	f7ff fcc6 	bl	20b9a0 <chVTIsSystemTimeWithinX.lto_priv.1>
  20c014:	4603      	mov	r3, r0
  20c016:	2b00      	cmp	r3, #0
  20c018:	d1e7      	bne.n	20bfea <rt_test_012_006_execute+0x2a>
  }
  test_end_step(1);

  /* [12.6.2] Score is printed.*/
  test_set_step(2);
  20c01a:	4b08      	ldr	r3, [pc, #32]	@ (20c03c <rt_test_012_006_execute+0x7c>)
  20c01c:	2202      	movs	r2, #2
  20c01e:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20c020:	4809      	ldr	r0, [pc, #36]	@ (20c048 <rt_test_012_006_execute+0x88>)
  20c022:	f7ff fd2d 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n);
  20c026:	9805      	ldr	r0, [sp, #20]
  20c028:	f7ff fd1a 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" threads/S");
  20c02c:	4807      	ldr	r0, [pc, #28]	@ (20c04c <rt_test_012_006_execute+0x8c>)
  20c02e:	f7ff fd37 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(2);
}
  20c032:	bf00      	nop
  20c034:	b007      	add	sp, #28
  20c036:	f85d fb04 	ldr.w	pc, [sp], #4
  20c03a:	bf00      	nop
  20c03c:	20000bb4 	.word	0x20000bb4
  20c040:	08012220 	.word	0x08012220
  20c044:	0020bb51 	.word	0x0020bb51
  20c048:	08011a1c 	.word	0x08011a1c
  20c04c:	08011a44 	.word	0x08011a44

0020c050 <rt_test_012_007_setup>:
 * - [12.7.3] The five threads are terminated.
 * - [12.7.4] The score is printed.
 * .
 */

static void rt_test_012_007_setup(void) {
  20c050:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
  20c052:	2100      	movs	r1, #0
  20c054:	4802      	ldr	r0, [pc, #8]	@ (20c060 <rt_test_012_007_setup+0x10>)
  20c056:	f7f7 fce3 	bl	203a20 <chSemObjectInit>
}
  20c05a:	bf00      	nop
  20c05c:	bd08      	pop	{r3, pc}
  20c05e:	bf00      	nop
  20c060:	20001958 	.word	0x20001958
	...

0020c070 <rt_test_012_007_execute>:

static void rt_test_012_007_execute(void) {
  20c070:	b510      	push	{r4, lr}
  20c072:	b086      	sub	sp, #24
  uint32_t n;

  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
  20c074:	4b4c      	ldr	r3, [pc, #304]	@ (20c1a8 <rt_test_012_007_execute+0x138>)
  20c076:	2201      	movs	r2, #1
  20c078:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
  20c07a:	4b4c      	ldr	r3, [pc, #304]	@ (20c1ac <rt_test_012_007_execute+0x13c>)
  20c07c:	681c      	ldr	r4, [r3, #0]
  20c07e:	f7ff fcaf 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20c082:	4603      	mov	r3, r0
  20c084:	1d5a      	adds	r2, r3, #5
  20c086:	2300      	movs	r3, #0
  20c088:	9300      	str	r3, [sp, #0]
  20c08a:	4b49      	ldr	r3, [pc, #292]	@ (20c1b0 <rt_test_012_007_execute+0x140>)
  20c08c:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20c090:	4620      	mov	r0, r4
  20c092:	f7f7 f975 	bl	203380 <chThdCreateStatic>
  20c096:	4603      	mov	r3, r0
  20c098:	4a46      	ldr	r2, [pc, #280]	@ (20c1b4 <rt_test_012_007_execute+0x144>)
  20c09a:	6013      	str	r3, [r2, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
  20c09c:	4b43      	ldr	r3, [pc, #268]	@ (20c1ac <rt_test_012_007_execute+0x13c>)
  20c09e:	685c      	ldr	r4, [r3, #4]
  20c0a0:	f7ff fc9e 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20c0a4:	4603      	mov	r3, r0
  20c0a6:	1d1a      	adds	r2, r3, #4
  20c0a8:	2300      	movs	r3, #0
  20c0aa:	9300      	str	r3, [sp, #0]
  20c0ac:	4b40      	ldr	r3, [pc, #256]	@ (20c1b0 <rt_test_012_007_execute+0x140>)
  20c0ae:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20c0b2:	4620      	mov	r0, r4
  20c0b4:	f7f7 f964 	bl	203380 <chThdCreateStatic>
  20c0b8:	4603      	mov	r3, r0
  20c0ba:	4a3e      	ldr	r2, [pc, #248]	@ (20c1b4 <rt_test_012_007_execute+0x144>)
  20c0bc:	6053      	str	r3, [r2, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
  20c0be:	4b3b      	ldr	r3, [pc, #236]	@ (20c1ac <rt_test_012_007_execute+0x13c>)
  20c0c0:	689c      	ldr	r4, [r3, #8]
  20c0c2:	f7ff fc8d 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20c0c6:	4603      	mov	r3, r0
  20c0c8:	1cda      	adds	r2, r3, #3
  20c0ca:	2300      	movs	r3, #0
  20c0cc:	9300      	str	r3, [sp, #0]
  20c0ce:	4b38      	ldr	r3, [pc, #224]	@ (20c1b0 <rt_test_012_007_execute+0x140>)
  20c0d0:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20c0d4:	4620      	mov	r0, r4
  20c0d6:	f7f7 f953 	bl	203380 <chThdCreateStatic>
  20c0da:	4603      	mov	r3, r0
  20c0dc:	4a35      	ldr	r2, [pc, #212]	@ (20c1b4 <rt_test_012_007_execute+0x144>)
  20c0de:	6093      	str	r3, [r2, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
  20c0e0:	4b32      	ldr	r3, [pc, #200]	@ (20c1ac <rt_test_012_007_execute+0x13c>)
  20c0e2:	68dc      	ldr	r4, [r3, #12]
  20c0e4:	f7ff fc7c 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20c0e8:	4603      	mov	r3, r0
  20c0ea:	1c9a      	adds	r2, r3, #2
  20c0ec:	2300      	movs	r3, #0
  20c0ee:	9300      	str	r3, [sp, #0]
  20c0f0:	4b2f      	ldr	r3, [pc, #188]	@ (20c1b0 <rt_test_012_007_execute+0x140>)
  20c0f2:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20c0f6:	4620      	mov	r0, r4
  20c0f8:	f7f7 f942 	bl	203380 <chThdCreateStatic>
  20c0fc:	4603      	mov	r3, r0
  20c0fe:	4a2d      	ldr	r2, [pc, #180]	@ (20c1b4 <rt_test_012_007_execute+0x144>)
  20c100:	60d3      	str	r3, [r2, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
  20c102:	4b2a      	ldr	r3, [pc, #168]	@ (20c1ac <rt_test_012_007_execute+0x13c>)
  20c104:	691c      	ldr	r4, [r3, #16]
  20c106:	f7ff fc6b 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20c10a:	4603      	mov	r3, r0
  20c10c:	1c5a      	adds	r2, r3, #1
  20c10e:	2300      	movs	r3, #0
  20c110:	9300      	str	r3, [sp, #0]
  20c112:	4b27      	ldr	r3, [pc, #156]	@ (20c1b0 <rt_test_012_007_execute+0x140>)
  20c114:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20c118:	4620      	mov	r0, r4
  20c11a:	f7f7 f931 	bl	203380 <chThdCreateStatic>
  20c11e:	4603      	mov	r3, r0
  20c120:	4a24      	ldr	r2, [pc, #144]	@ (20c1b4 <rt_test_012_007_execute+0x144>)
  20c122:	6113      	str	r3, [r2, #16]
  }
  test_end_step(1);

  /* [12.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
  20c124:	4b20      	ldr	r3, [pc, #128]	@ (20c1a8 <rt_test_012_007_execute+0x138>)
  20c126:	2202      	movs	r2, #2
  20c128:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
  20c12a:	2300      	movs	r3, #0
  20c12c:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
  20c12e:	f7fb fe8f 	bl	207e50 <test_wait_tick>
  20c132:	9004      	str	r0, [sp, #16]
    end = chTimeAddX(start, TIME_MS2I(1000));
  20c134:	f242 7110 	movw	r1, #10000	@ 0x2710
  20c138:	9804      	ldr	r0, [sp, #16]
  20c13a:	f7ff fbd9 	bl	20b8f0 <chTimeAddX.lto_priv.6>
  20c13e:	9003      	str	r0, [sp, #12]
    do {
      chSemReset(&sem1, 0);
  20c140:	2100      	movs	r1, #0
  20c142:	481d      	ldr	r0, [pc, #116]	@ (20c1b8 <rt_test_012_007_execute+0x148>)
  20c144:	f7ff fc64 	bl	20ba10 <chSemReset.lto_priv.1>
      n++;
  20c148:	9b05      	ldr	r3, [sp, #20]
  20c14a:	3301      	adds	r3, #1
  20c14c:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  20c14e:	9903      	ldr	r1, [sp, #12]
  20c150:	9804      	ldr	r0, [sp, #16]
  20c152:	f7ff fc25 	bl	20b9a0 <chVTIsSystemTimeWithinX.lto_priv.1>
  20c156:	4603      	mov	r3, r0
  20c158:	2b00      	cmp	r3, #0
  20c15a:	d1f1      	bne.n	20c140 <rt_test_012_007_execute+0xd0>
  }
  test_end_step(2);

  /* [12.7.3] The five threads are terminated.*/
  test_set_step(3);
  20c15c:	4b12      	ldr	r3, [pc, #72]	@ (20c1a8 <rt_test_012_007_execute+0x138>)
  20c15e:	2203      	movs	r2, #3
  20c160:	601a      	str	r2, [r3, #0]
  {
    test_terminate_threads();
  20c162:	f7fb fe2d 	bl	207dc0 <test_terminate_threads>
    chSemReset(&sem1, 0);
  20c166:	2100      	movs	r1, #0
  20c168:	4813      	ldr	r0, [pc, #76]	@ (20c1b8 <rt_test_012_007_execute+0x148>)
  20c16a:	f7ff fc51 	bl	20ba10 <chSemReset.lto_priv.1>
    test_wait_threads();
  20c16e:	f7fb fe47 	bl	207e00 <test_wait_threads>
  }
  test_end_step(3);

  /* [12.7.4] The score is printed.*/
  test_set_step(4);
  20c172:	4b0d      	ldr	r3, [pc, #52]	@ (20c1a8 <rt_test_012_007_execute+0x138>)
  20c174:	2204      	movs	r2, #4
  20c176:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20c178:	4810      	ldr	r0, [pc, #64]	@ (20c1bc <rt_test_012_007_execute+0x14c>)
  20c17a:	f7ff fc81 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n);
  20c17e:	9805      	ldr	r0, [sp, #20]
  20c180:	f7ff fc6e 	bl	20ba60 <test_printn.lto_priv.1>
    test_print(" reschedules/S, ");
  20c184:	480e      	ldr	r0, [pc, #56]	@ (20c1c0 <rt_test_012_007_execute+0x150>)
  20c186:	f7ff fc7b 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n * 6);
  20c18a:	9a05      	ldr	r2, [sp, #20]
  20c18c:	4613      	mov	r3, r2
  20c18e:	005b      	lsls	r3, r3, #1
  20c190:	4413      	add	r3, r2
  20c192:	005b      	lsls	r3, r3, #1
  20c194:	4618      	mov	r0, r3
  20c196:	f7ff fc63 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" ctxswc/S");
  20c19a:	480a      	ldr	r0, [pc, #40]	@ (20c1c4 <rt_test_012_007_execute+0x154>)
  20c19c:	f7ff fc80 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(4);
}
  20c1a0:	bf00      	nop
  20c1a2:	b006      	add	sp, #24
  20c1a4:	bd10      	pop	{r4, pc}
  20c1a6:	bf00      	nop
  20c1a8:	20000bb4 	.word	0x20000bb4
  20c1ac:	08012220 	.word	0x08012220
  20c1b0:	0020bba1 	.word	0x0020bba1
  20c1b4:	20001900 	.word	0x20001900
  20c1b8:	20001958 	.word	0x20001958
  20c1bc:	08011a1c 	.word	0x08011a1c
  20c1c0:	08011a50 	.word	0x08011a50
  20c1c4:	08011a38 	.word	0x08011a38
	...

0020c1d0 <rt_test_012_008_execute>:
 * - [12.8.2] Waiting one second then terminating the 5 threads.
 * - [12.8.3] The score is printed.
 * .
 */

static void rt_test_012_008_execute(void) {
  20c1d0:	b510      	push	{r4, lr}
  20c1d2:	b084      	sub	sp, #16
  uint32_t n;

  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
  20c1d4:	4b3b      	ldr	r3, [pc, #236]	@ (20c2c4 <rt_test_012_008_execute+0xf4>)
  20c1d6:	2201      	movs	r2, #1
  20c1d8:	601a      	str	r2, [r3, #0]
  {
    n = 0;
  20c1da:	2300      	movs	r3, #0
  20c1dc:	9303      	str	r3, [sp, #12]
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  20c1de:	f7fb fe37 	bl	207e50 <test_wait_tick>
  20c1e2:	4b39      	ldr	r3, [pc, #228]	@ (20c2c8 <rt_test_012_008_execute+0xf8>)
  20c1e4:	681c      	ldr	r4, [r3, #0]
  20c1e6:	f7ff fbfb 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20c1ea:	4603      	mov	r3, r0
  20c1ec:	1e5a      	subs	r2, r3, #1
  20c1ee:	ab03      	add	r3, sp, #12
  20c1f0:	9300      	str	r3, [sp, #0]
  20c1f2:	4b36      	ldr	r3, [pc, #216]	@ (20c2cc <rt_test_012_008_execute+0xfc>)
  20c1f4:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20c1f8:	4620      	mov	r0, r4
  20c1fa:	f7f7 f8c1 	bl	203380 <chThdCreateStatic>
  20c1fe:	4603      	mov	r3, r0
  20c200:	4a33      	ldr	r2, [pc, #204]	@ (20c2d0 <rt_test_012_008_execute+0x100>)
  20c202:	6013      	str	r3, [r2, #0]

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  20c204:	4b30      	ldr	r3, [pc, #192]	@ (20c2c8 <rt_test_012_008_execute+0xf8>)
  20c206:	685c      	ldr	r4, [r3, #4]
  20c208:	f7ff fbea 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20c20c:	4603      	mov	r3, r0
  20c20e:	1e5a      	subs	r2, r3, #1
  20c210:	ab03      	add	r3, sp, #12
  20c212:	9300      	str	r3, [sp, #0]
  20c214:	4b2d      	ldr	r3, [pc, #180]	@ (20c2cc <rt_test_012_008_execute+0xfc>)
  20c216:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20c21a:	4620      	mov	r0, r4
  20c21c:	f7f7 f8b0 	bl	203380 <chThdCreateStatic>
  20c220:	4603      	mov	r3, r0
  20c222:	4a2b      	ldr	r2, [pc, #172]	@ (20c2d0 <rt_test_012_008_execute+0x100>)
  20c224:	6053      	str	r3, [r2, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  20c226:	4b28      	ldr	r3, [pc, #160]	@ (20c2c8 <rt_test_012_008_execute+0xf8>)
  20c228:	689c      	ldr	r4, [r3, #8]
  20c22a:	f7ff fbd9 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20c22e:	4603      	mov	r3, r0
  20c230:	1e5a      	subs	r2, r3, #1
  20c232:	ab03      	add	r3, sp, #12
  20c234:	9300      	str	r3, [sp, #0]
  20c236:	4b25      	ldr	r3, [pc, #148]	@ (20c2cc <rt_test_012_008_execute+0xfc>)
  20c238:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20c23c:	4620      	mov	r0, r4
  20c23e:	f7f7 f89f 	bl	203380 <chThdCreateStatic>
  20c242:	4603      	mov	r3, r0
  20c244:	4a22      	ldr	r2, [pc, #136]	@ (20c2d0 <rt_test_012_008_execute+0x100>)
  20c246:	6093      	str	r3, [r2, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  20c248:	4b1f      	ldr	r3, [pc, #124]	@ (20c2c8 <rt_test_012_008_execute+0xf8>)
  20c24a:	68dc      	ldr	r4, [r3, #12]
  20c24c:	f7ff fbc8 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20c250:	4603      	mov	r3, r0
  20c252:	1e5a      	subs	r2, r3, #1
  20c254:	ab03      	add	r3, sp, #12
  20c256:	9300      	str	r3, [sp, #0]
  20c258:	4b1c      	ldr	r3, [pc, #112]	@ (20c2cc <rt_test_012_008_execute+0xfc>)
  20c25a:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20c25e:	4620      	mov	r0, r4
  20c260:	f7f7 f88e 	bl	203380 <chThdCreateStatic>
  20c264:	4603      	mov	r3, r0
  20c266:	4a1a      	ldr	r2, [pc, #104]	@ (20c2d0 <rt_test_012_008_execute+0x100>)
  20c268:	60d3      	str	r3, [r2, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  20c26a:	4b17      	ldr	r3, [pc, #92]	@ (20c2c8 <rt_test_012_008_execute+0xf8>)
  20c26c:	691c      	ldr	r4, [r3, #16]
  20c26e:	f7ff fbb7 	bl	20b9e0 <chThdGetPriorityX.lto_priv.7>
  20c272:	4603      	mov	r3, r0
  20c274:	1e5a      	subs	r2, r3, #1
  20c276:	ab03      	add	r3, sp, #12
  20c278:	9300      	str	r3, [sp, #0]
  20c27a:	4b14      	ldr	r3, [pc, #80]	@ (20c2cc <rt_test_012_008_execute+0xfc>)
  20c27c:	f44f 7128 	mov.w	r1, #672	@ 0x2a0
  20c280:	4620      	mov	r0, r4
  20c282:	f7f7 f87d 	bl	203380 <chThdCreateStatic>
  20c286:	4603      	mov	r3, r0
  20c288:	4a11      	ldr	r2, [pc, #68]	@ (20c2d0 <rt_test_012_008_execute+0x100>)
  20c28a:	6113      	str	r3, [r2, #16]
  }
  test_end_step(1);

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
  20c28c:	4b0d      	ldr	r3, [pc, #52]	@ (20c2c4 <rt_test_012_008_execute+0xf4>)
  20c28e:	2202      	movs	r2, #2
  20c290:	601a      	str	r2, [r3, #0]
  {
    chThdSleepSeconds(1);
  20c292:	f242 7010 	movw	r0, #10000	@ 0x2710
  20c296:	f7f7 f9ab 	bl	2035f0 <chThdSleep>
    test_terminate_threads();
  20c29a:	f7fb fd91 	bl	207dc0 <test_terminate_threads>
    test_wait_threads();
  20c29e:	f7fb fdaf 	bl	207e00 <test_wait_threads>
  }
  test_end_step(2);

  /* [12.8.3] The score is printed.*/
  test_set_step(3);
  20c2a2:	4b08      	ldr	r3, [pc, #32]	@ (20c2c4 <rt_test_012_008_execute+0xf4>)
  20c2a4:	2203      	movs	r2, #3
  20c2a6:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20c2a8:	480a      	ldr	r0, [pc, #40]	@ (20c2d4 <rt_test_012_008_execute+0x104>)
  20c2aa:	f7ff fbe9 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n);
  20c2ae:	9b03      	ldr	r3, [sp, #12]
  20c2b0:	4618      	mov	r0, r3
  20c2b2:	f7ff fbd5 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" ctxswc/S");
  20c2b6:	4808      	ldr	r0, [pc, #32]	@ (20c2d8 <rt_test_012_008_execute+0x108>)
  20c2b8:	f7ff fbf2 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(3);
}
  20c2bc:	bf00      	nop
  20c2be:	b004      	add	sp, #16
  20c2c0:	bd10      	pop	{r4, pc}
  20c2c2:	bf00      	nop
  20c2c4:	20000bb4 	.word	0x20000bb4
  20c2c8:	08012220 	.word	0x08012220
  20c2cc:	0020bbd1 	.word	0x0020bbd1
  20c2d0:	20001900 	.word	0x20001900
  20c2d4:	08011a1c 	.word	0x08011a1c
  20c2d8:	08011a38 	.word	0x08011a38
  20c2dc:	00000000 	.word	0x00000000

0020c2e0 <rt_test_012_009_execute>:
 *   one-second time window.
 * - [12.9.2] The score is printed.
 * .
 */

static void rt_test_012_009_execute(void) {
  20c2e0:	b500      	push	{lr}
  20c2e2:	b085      	sub	sp, #20
  uint32_t n;

  /* [12.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
  20c2e4:	4b20      	ldr	r3, [pc, #128]	@ (20c368 <rt_test_012_009_execute+0x88>)
  20c2e6:	2201      	movs	r2, #1
  20c2e8:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
  20c2ea:	2300      	movs	r3, #0
  20c2ec:	9303      	str	r3, [sp, #12]
    start = test_wait_tick();
  20c2ee:	f7fb fdaf 	bl	207e50 <test_wait_tick>
  20c2f2:	9002      	str	r0, [sp, #8]
    end = chTimeAddX(start, TIME_MS2I(1000));
  20c2f4:	f242 7110 	movw	r1, #10000	@ 0x2710
  20c2f8:	9802      	ldr	r0, [sp, #8]
  20c2fa:	f7ff faf9 	bl	20b8f0 <chTimeAddX.lto_priv.6>
  20c2fe:	9001      	str	r0, [sp, #4]
    do {
      chSysLock();
  20c300:	f7ff fb26 	bl	20b950 <chSysLock.lto_priv.27>
      chVTDoSetI(&vt1, 1, tmo, NULL);
  20c304:	2300      	movs	r3, #0
  20c306:	4a19      	ldr	r2, [pc, #100]	@ (20c36c <rt_test_012_009_execute+0x8c>)
  20c308:	2101      	movs	r1, #1
  20c30a:	4819      	ldr	r0, [pc, #100]	@ (20c370 <rt_test_012_009_execute+0x90>)
  20c30c:	f7f6 f940 	bl	202590 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
  20c310:	2300      	movs	r3, #0
  20c312:	4a16      	ldr	r2, [pc, #88]	@ (20c36c <rt_test_012_009_execute+0x8c>)
  20c314:	f242 7110 	movw	r1, #10000	@ 0x2710
  20c318:	4816      	ldr	r0, [pc, #88]	@ (20c374 <rt_test_012_009_execute+0x94>)
  20c31a:	f7f6 f939 	bl	202590 <chVTDoSetI>
      chVTDoResetI(&vt1);
  20c31e:	4814      	ldr	r0, [pc, #80]	@ (20c370 <rt_test_012_009_execute+0x90>)
  20c320:	f7f6 f956 	bl	2025d0 <chVTDoResetI>
      chVTDoResetI(&vt2);
  20c324:	4813      	ldr	r0, [pc, #76]	@ (20c374 <rt_test_012_009_execute+0x94>)
  20c326:	f7f6 f953 	bl	2025d0 <chVTDoResetI>
      chSysUnlock();
  20c32a:	f7ff fb21 	bl	20b970 <chSysUnlock.lto_priv.27>
      n++;
  20c32e:	9b03      	ldr	r3, [sp, #12]
  20c330:	3301      	adds	r3, #1
  20c332:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  20c334:	9901      	ldr	r1, [sp, #4]
  20c336:	9802      	ldr	r0, [sp, #8]
  20c338:	f7ff fb32 	bl	20b9a0 <chVTIsSystemTimeWithinX.lto_priv.1>
  20c33c:	4603      	mov	r3, r0
  20c33e:	2b00      	cmp	r3, #0
  20c340:	d1de      	bne.n	20c300 <rt_test_012_009_execute+0x20>
  }
  test_end_step(1);

  /* [12.9.2] The score is printed.*/
  test_set_step(2);
  20c342:	4b09      	ldr	r3, [pc, #36]	@ (20c368 <rt_test_012_009_execute+0x88>)
  20c344:	2202      	movs	r2, #2
  20c346:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20c348:	480b      	ldr	r0, [pc, #44]	@ (20c378 <rt_test_012_009_execute+0x98>)
  20c34a:	f7ff fb99 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n * 2);
  20c34e:	9b03      	ldr	r3, [sp, #12]
  20c350:	005b      	lsls	r3, r3, #1
  20c352:	4618      	mov	r0, r3
  20c354:	f7ff fb84 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" timers/S");
  20c358:	4808      	ldr	r0, [pc, #32]	@ (20c37c <rt_test_012_009_execute+0x9c>)
  20c35a:	f7ff fba1 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(2);
}
  20c35e:	bf00      	nop
  20c360:	b005      	add	sp, #20
  20c362:	f85d fb04 	ldr.w	pc, [sp], #4
  20c366:	bf00      	nop
  20c368:	20000bb4 	.word	0x20000bb4
  20c36c:	0020bac1 	.word	0x0020bac1
  20c370:	20001974 	.word	0x20001974
  20c374:	2000198c 	.word	0x2000198c
  20c378:	08011a1c 	.word	0x08011a1c
  20c37c:	08011a64 	.word	0x08011a64

0020c380 <rt_test_012_010_setup>:
 *   repeated continuously in a one-second time window.
 * - [12.10.2] The score is printed.
 * .
 */

static void rt_test_012_010_setup(void) {
  20c380:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 1);
  20c382:	2101      	movs	r1, #1
  20c384:	4802      	ldr	r0, [pc, #8]	@ (20c390 <rt_test_012_010_setup+0x10>)
  20c386:	f7f7 fb4b 	bl	203a20 <chSemObjectInit>
}
  20c38a:	bf00      	nop
  20c38c:	bd08      	pop	{r3, pc}
  20c38e:	bf00      	nop
  20c390:	20001958 	.word	0x20001958
	...

0020c3a0 <rt_test_012_010_execute>:

static void rt_test_012_010_execute(void) {
  20c3a0:	b500      	push	{lr}
  20c3a2:	b085      	sub	sp, #20
  uint32_t n;

  /* [12.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  20c3a4:	4b20      	ldr	r3, [pc, #128]	@ (20c428 <rt_test_012_010_execute+0x88>)
  20c3a6:	2201      	movs	r2, #1
  20c3a8:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
  20c3aa:	2300      	movs	r3, #0
  20c3ac:	9303      	str	r3, [sp, #12]
    start = test_wait_tick();
  20c3ae:	f7fb fd4f 	bl	207e50 <test_wait_tick>
  20c3b2:	9002      	str	r0, [sp, #8]
    end = chTimeAddX(start, TIME_MS2I(1000));
  20c3b4:	f242 7110 	movw	r1, #10000	@ 0x2710
  20c3b8:	9802      	ldr	r0, [sp, #8]
  20c3ba:	f7ff fa99 	bl	20b8f0 <chTimeAddX.lto_priv.6>
  20c3be:	9001      	str	r0, [sp, #4]
    do {
      chSemWait(&sem1);
  20c3c0:	481a      	ldr	r0, [pc, #104]	@ (20c42c <rt_test_012_010_execute+0x8c>)
  20c3c2:	f7f7 fb75 	bl	203ab0 <chSemWait>
      chSemSignal(&sem1);
  20c3c6:	4819      	ldr	r0, [pc, #100]	@ (20c42c <rt_test_012_010_execute+0x8c>)
  20c3c8:	f7f7 fbfa 	bl	203bc0 <chSemSignal>
      chSemWait(&sem1);
  20c3cc:	4817      	ldr	r0, [pc, #92]	@ (20c42c <rt_test_012_010_execute+0x8c>)
  20c3ce:	f7f7 fb6f 	bl	203ab0 <chSemWait>
      chSemSignal(&sem1);
  20c3d2:	4816      	ldr	r0, [pc, #88]	@ (20c42c <rt_test_012_010_execute+0x8c>)
  20c3d4:	f7f7 fbf4 	bl	203bc0 <chSemSignal>
      chSemWait(&sem1);
  20c3d8:	4814      	ldr	r0, [pc, #80]	@ (20c42c <rt_test_012_010_execute+0x8c>)
  20c3da:	f7f7 fb69 	bl	203ab0 <chSemWait>
      chSemSignal(&sem1);
  20c3de:	4813      	ldr	r0, [pc, #76]	@ (20c42c <rt_test_012_010_execute+0x8c>)
  20c3e0:	f7f7 fbee 	bl	203bc0 <chSemSignal>
      chSemWait(&sem1);
  20c3e4:	4811      	ldr	r0, [pc, #68]	@ (20c42c <rt_test_012_010_execute+0x8c>)
  20c3e6:	f7f7 fb63 	bl	203ab0 <chSemWait>
      chSemSignal(&sem1);
  20c3ea:	4810      	ldr	r0, [pc, #64]	@ (20c42c <rt_test_012_010_execute+0x8c>)
  20c3ec:	f7f7 fbe8 	bl	203bc0 <chSemSignal>
      n++;
  20c3f0:	9b03      	ldr	r3, [sp, #12]
  20c3f2:	3301      	adds	r3, #1
  20c3f4:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  20c3f6:	9901      	ldr	r1, [sp, #4]
  20c3f8:	9802      	ldr	r0, [sp, #8]
  20c3fa:	f7ff fad1 	bl	20b9a0 <chVTIsSystemTimeWithinX.lto_priv.1>
  20c3fe:	4603      	mov	r3, r0
  20c400:	2b00      	cmp	r3, #0
  20c402:	d1dd      	bne.n	20c3c0 <rt_test_012_010_execute+0x20>
  }
  test_end_step(1);

  /* [12.10.2] The score is printed.*/
  test_set_step(2);
  20c404:	4b08      	ldr	r3, [pc, #32]	@ (20c428 <rt_test_012_010_execute+0x88>)
  20c406:	2202      	movs	r2, #2
  20c408:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20c40a:	4809      	ldr	r0, [pc, #36]	@ (20c430 <rt_test_012_010_execute+0x90>)
  20c40c:	f7ff fb38 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n * 4);
  20c410:	9b03      	ldr	r3, [sp, #12]
  20c412:	009b      	lsls	r3, r3, #2
  20c414:	4618      	mov	r0, r3
  20c416:	f7ff fb23 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" wait+signal/S");
  20c41a:	4806      	ldr	r0, [pc, #24]	@ (20c434 <rt_test_012_010_execute+0x94>)
  20c41c:	f7ff fb40 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(2);
}
  20c420:	bf00      	nop
  20c422:	b005      	add	sp, #20
  20c424:	f85d fb04 	ldr.w	pc, [sp], #4
  20c428:	20000bb4 	.word	0x20000bb4
  20c42c:	20001958 	.word	0x20001958
  20c430:	08011a1c 	.word	0x08011a1c
  20c434:	08011a70 	.word	0x08011a70
	...

0020c440 <rt_test_012_011_setup>:
 *   repeated continuously in a one-second time window.
 * - [12.11.2] The score is printed.
 * .
 */

static void rt_test_012_011_setup(void) {
  20c440:	b508      	push	{r3, lr}
  chMtxObjectInit(&mtx1);
  20c442:	4802      	ldr	r0, [pc, #8]	@ (20c44c <rt_test_012_011_setup+0xc>)
  20c444:	f7f7 fd14 	bl	203e70 <chMtxObjectInit>
}
  20c448:	bf00      	nop
  20c44a:	bd08      	pop	{r3, pc}
  20c44c:	20001964 	.word	0x20001964

0020c450 <rt_test_012_011_execute>:

static void rt_test_012_011_execute(void) {
  20c450:	b500      	push	{lr}
  20c452:	b085      	sub	sp, #20
  uint32_t n;

  /* [12.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  20c454:	4b20      	ldr	r3, [pc, #128]	@ (20c4d8 <rt_test_012_011_execute+0x88>)
  20c456:	2201      	movs	r2, #1
  20c458:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
  20c45a:	2300      	movs	r3, #0
  20c45c:	9303      	str	r3, [sp, #12]
    start = test_wait_tick();
  20c45e:	f7fb fcf7 	bl	207e50 <test_wait_tick>
  20c462:	9002      	str	r0, [sp, #8]
    end = chTimeAddX(start, TIME_MS2I(1000));
  20c464:	f242 7110 	movw	r1, #10000	@ 0x2710
  20c468:	9802      	ldr	r0, [sp, #8]
  20c46a:	f7ff fa41 	bl	20b8f0 <chTimeAddX.lto_priv.6>
  20c46e:	9001      	str	r0, [sp, #4]
    do {
      chMtxLock(&mtx1);
  20c470:	481a      	ldr	r0, [pc, #104]	@ (20c4dc <rt_test_012_011_execute+0x8c>)
  20c472:	f7f7 fd0d 	bl	203e90 <chMtxLock>
      chMtxUnlock(&mtx1);
  20c476:	4819      	ldr	r0, [pc, #100]	@ (20c4dc <rt_test_012_011_execute+0x8c>)
  20c478:	f7f7 fdba 	bl	203ff0 <chMtxUnlock>
      chMtxLock(&mtx1);
  20c47c:	4817      	ldr	r0, [pc, #92]	@ (20c4dc <rt_test_012_011_execute+0x8c>)
  20c47e:	f7f7 fd07 	bl	203e90 <chMtxLock>
      chMtxUnlock(&mtx1);
  20c482:	4816      	ldr	r0, [pc, #88]	@ (20c4dc <rt_test_012_011_execute+0x8c>)
  20c484:	f7f7 fdb4 	bl	203ff0 <chMtxUnlock>
      chMtxLock(&mtx1);
  20c488:	4814      	ldr	r0, [pc, #80]	@ (20c4dc <rt_test_012_011_execute+0x8c>)
  20c48a:	f7f7 fd01 	bl	203e90 <chMtxLock>
      chMtxUnlock(&mtx1);
  20c48e:	4813      	ldr	r0, [pc, #76]	@ (20c4dc <rt_test_012_011_execute+0x8c>)
  20c490:	f7f7 fdae 	bl	203ff0 <chMtxUnlock>
      chMtxLock(&mtx1);
  20c494:	4811      	ldr	r0, [pc, #68]	@ (20c4dc <rt_test_012_011_execute+0x8c>)
  20c496:	f7f7 fcfb 	bl	203e90 <chMtxLock>
      chMtxUnlock(&mtx1);
  20c49a:	4810      	ldr	r0, [pc, #64]	@ (20c4dc <rt_test_012_011_execute+0x8c>)
  20c49c:	f7f7 fda8 	bl	203ff0 <chMtxUnlock>
      n++;
  20c4a0:	9b03      	ldr	r3, [sp, #12]
  20c4a2:	3301      	adds	r3, #1
  20c4a4:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  20c4a6:	9901      	ldr	r1, [sp, #4]
  20c4a8:	9802      	ldr	r0, [sp, #8]
  20c4aa:	f7ff fa79 	bl	20b9a0 <chVTIsSystemTimeWithinX.lto_priv.1>
  20c4ae:	4603      	mov	r3, r0
  20c4b0:	2b00      	cmp	r3, #0
  20c4b2:	d1dd      	bne.n	20c470 <rt_test_012_011_execute+0x20>
  }
  test_end_step(1);

  /* [12.11.2] The score is printed.*/
  test_set_step(2);
  20c4b4:	4b08      	ldr	r3, [pc, #32]	@ (20c4d8 <rt_test_012_011_execute+0x88>)
  20c4b6:	2202      	movs	r2, #2
  20c4b8:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
  20c4ba:	4809      	ldr	r0, [pc, #36]	@ (20c4e0 <rt_test_012_011_execute+0x90>)
  20c4bc:	f7ff fae0 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(n * 4);
  20c4c0:	9b03      	ldr	r3, [sp, #12]
  20c4c2:	009b      	lsls	r3, r3, #2
  20c4c4:	4618      	mov	r0, r3
  20c4c6:	f7ff facb 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" lock+unlock/S");
  20c4ca:	4806      	ldr	r0, [pc, #24]	@ (20c4e4 <rt_test_012_011_execute+0x94>)
  20c4cc:	f7ff fae8 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(2);
}
  20c4d0:	bf00      	nop
  20c4d2:	b005      	add	sp, #20
  20c4d4:	f85d fb04 	ldr.w	pc, [sp], #4
  20c4d8:	20000bb4 	.word	0x20000bb4
  20c4dc:	20001964 	.word	0x20001964
  20c4e0:	08011a1c 	.word	0x08011a1c
  20c4e4:	08011a80 	.word	0x08011a80
	...

0020c4f0 <rt_test_012_012_execute>:
 * - [12.12.8] The size of an event listener is printed.
 * - [12.12.9] The size of a mailbox is printed.
 * .
 */

static void rt_test_012_012_execute(void) {
  20c4f0:	b508      	push	{r3, lr}

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
  20c4f2:	4b37      	ldr	r3, [pc, #220]	@ (20c5d0 <rt_test_012_012_execute+0xe0>)
  20c4f4:	2201      	movs	r2, #1
  20c4f6:	601a      	str	r2, [r3, #0]
  {
    test_print("--- OS    : ");
  20c4f8:	4836      	ldr	r0, [pc, #216]	@ (20c5d4 <rt_test_012_012_execute+0xe4>)
  20c4fa:	f7ff fac1 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(sizeof(os_instance_t));
  20c4fe:	20e8      	movs	r0, #232	@ 0xe8
  20c500:	f7ff faae 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" bytes");
  20c504:	4834      	ldr	r0, [pc, #208]	@ (20c5d8 <rt_test_012_012_execute+0xe8>)
  20c506:	f7ff facb 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(1);

  /* [12.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
  20c50a:	4b31      	ldr	r3, [pc, #196]	@ (20c5d0 <rt_test_012_012_execute+0xe0>)
  20c50c:	2202      	movs	r2, #2
  20c50e:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Thread: ");
  20c510:	4832      	ldr	r0, [pc, #200]	@ (20c5dc <rt_test_012_012_execute+0xec>)
  20c512:	f7ff fab5 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(sizeof(thread_t));
  20c516:	2050      	movs	r0, #80	@ 0x50
  20c518:	f7ff faa2 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" bytes");
  20c51c:	482e      	ldr	r0, [pc, #184]	@ (20c5d8 <rt_test_012_012_execute+0xe8>)
  20c51e:	f7ff fabf 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(2);

  /* [12.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
  20c522:	4b2b      	ldr	r3, [pc, #172]	@ (20c5d0 <rt_test_012_012_execute+0xe0>)
  20c524:	2203      	movs	r2, #3
  20c526:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Timer : ");
  20c528:	482d      	ldr	r0, [pc, #180]	@ (20c5e0 <rt_test_012_012_execute+0xf0>)
  20c52a:	f7ff faa9 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(sizeof(virtual_timer_t));
  20c52e:	2018      	movs	r0, #24
  20c530:	f7ff fa96 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" bytes");
  20c534:	4828      	ldr	r0, [pc, #160]	@ (20c5d8 <rt_test_012_012_execute+0xe8>)
  20c536:	f7ff fab3 	bl	20baa0 <test_println.lto_priv.1>
  }
  test_end_step(3);

  /* [12.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
  20c53a:	4b25      	ldr	r3, [pc, #148]	@ (20c5d0 <rt_test_012_012_execute+0xe0>)
  20c53c:	2204      	movs	r2, #4
  20c53e:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
  20c540:	4828      	ldr	r0, [pc, #160]	@ (20c5e4 <rt_test_012_012_execute+0xf4>)
  20c542:	f7ff fa9d 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(sizeof(semaphore_t));
  20c546:	200c      	movs	r0, #12
  20c548:	f7ff fa8a 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" bytes");
  20c54c:	4822      	ldr	r0, [pc, #136]	@ (20c5d8 <rt_test_012_012_execute+0xe8>)
  20c54e:	f7ff faa7 	bl	20baa0 <test_println.lto_priv.1>
#endif
  }
  test_end_step(4);

  /* [12.12.5] The size of a mutex is printed.*/
  test_set_step(5);
  20c552:	4b1f      	ldr	r3, [pc, #124]	@ (20c5d0 <rt_test_012_012_execute+0xe0>)
  20c554:	2205      	movs	r2, #5
  20c556:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
  20c558:	4823      	ldr	r0, [pc, #140]	@ (20c5e8 <rt_test_012_012_execute+0xf8>)
  20c55a:	f7ff fa91 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(sizeof(mutex_t));
  20c55e:	2010      	movs	r0, #16
  20c560:	f7ff fa7e 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" bytes");
  20c564:	481c      	ldr	r0, [pc, #112]	@ (20c5d8 <rt_test_012_012_execute+0xe8>)
  20c566:	f7ff fa9b 	bl	20baa0 <test_println.lto_priv.1>
#endif
  }
  test_end_step(5);

  /* [12.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
  20c56a:	4b19      	ldr	r3, [pc, #100]	@ (20c5d0 <rt_test_012_012_execute+0xe0>)
  20c56c:	2206      	movs	r2, #6
  20c56e:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
  20c570:	481e      	ldr	r0, [pc, #120]	@ (20c5ec <rt_test_012_012_execute+0xfc>)
  20c572:	f7ff fa85 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(sizeof(condition_variable_t));
  20c576:	2008      	movs	r0, #8
  20c578:	f7ff fa72 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" bytes");
  20c57c:	4816      	ldr	r0, [pc, #88]	@ (20c5d8 <rt_test_012_012_execute+0xe8>)
  20c57e:	f7ff fa8f 	bl	20baa0 <test_println.lto_priv.1>
#endif
  }
  test_end_step(6);

  /* [12.12.7] The size of an event source is printed.*/
  test_set_step(7);
  20c582:	4b13      	ldr	r3, [pc, #76]	@ (20c5d0 <rt_test_012_012_execute+0xe0>)
  20c584:	2207      	movs	r2, #7
  20c586:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
  20c588:	4819      	ldr	r0, [pc, #100]	@ (20c5f0 <rt_test_012_012_execute+0x100>)
  20c58a:	f7ff fa79 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(sizeof(event_source_t));
  20c58e:	2004      	movs	r0, #4
  20c590:	f7ff fa66 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" bytes");
  20c594:	4810      	ldr	r0, [pc, #64]	@ (20c5d8 <rt_test_012_012_execute+0xe8>)
  20c596:	f7ff fa83 	bl	20baa0 <test_println.lto_priv.1>
#endif
  }
  test_end_step(7);

  /* [12.12.8] The size of an event listener is printed.*/
  test_set_step(8);
  20c59a:	4b0d      	ldr	r3, [pc, #52]	@ (20c5d0 <rt_test_012_012_execute+0xe0>)
  20c59c:	2208      	movs	r2, #8
  20c59e:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
  20c5a0:	4814      	ldr	r0, [pc, #80]	@ (20c5f4 <rt_test_012_012_execute+0x104>)
  20c5a2:	f7ff fa6d 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(sizeof(event_listener_t));
  20c5a6:	2014      	movs	r0, #20
  20c5a8:	f7ff fa5a 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" bytes");
  20c5ac:	480a      	ldr	r0, [pc, #40]	@ (20c5d8 <rt_test_012_012_execute+0xe8>)
  20c5ae:	f7ff fa77 	bl	20baa0 <test_println.lto_priv.1>
#endif
  }
  test_end_step(8);

  /* [12.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
  20c5b2:	4b07      	ldr	r3, [pc, #28]	@ (20c5d0 <rt_test_012_012_execute+0xe0>)
  20c5b4:	2209      	movs	r2, #9
  20c5b6:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
  20c5b8:	480f      	ldr	r0, [pc, #60]	@ (20c5f8 <rt_test_012_012_execute+0x108>)
  20c5ba:	f7ff fa61 	bl	20ba80 <test_print.lto_priv.1>
    test_printn(sizeof(mailbox_t));
  20c5be:	2028      	movs	r0, #40	@ 0x28
  20c5c0:	f7ff fa4e 	bl	20ba60 <test_printn.lto_priv.1>
    test_println(" bytes");
  20c5c4:	4804      	ldr	r0, [pc, #16]	@ (20c5d8 <rt_test_012_012_execute+0xe8>)
  20c5c6:	f7ff fa6b 	bl	20baa0 <test_println.lto_priv.1>
#endif
  }
  test_end_step(9);
}
  20c5ca:	bf00      	nop
  20c5cc:	bd08      	pop	{r3, pc}
  20c5ce:	bf00      	nop
  20c5d0:	20000bb4 	.word	0x20000bb4
  20c5d4:	08011a90 	.word	0x08011a90
  20c5d8:	08011aa0 	.word	0x08011aa0
  20c5dc:	08011aa8 	.word	0x08011aa8
  20c5e0:	08011ab8 	.word	0x08011ab8
  20c5e4:	08011ac8 	.word	0x08011ac8
  20c5e8:	08011ad8 	.word	0x08011ad8
  20c5ec:	08011ae8 	.word	0x08011ae8
  20c5f0:	08011af8 	.word	0x08011af8
  20c5f4:	08011b08 	.word	0x08011b08
  20c5f8:	08011b18 	.word	0x08011b18
  20c5fc:	00000000 	.word	0x00000000

0020c600 <test_printn.lto_priv.2>:
static inline void test_printn(uint32_t n) {
  20c600:	b500      	push	{lr}
  20c602:	b083      	sub	sp, #12
  20c604:	9001      	str	r0, [sp, #4]
  test_printf("%u", n);
  20c606:	9901      	ldr	r1, [sp, #4]
  20c608:	4803      	ldr	r0, [pc, #12]	@ (20c618 <test_printn.lto_priv.2+0x18>)
  20c60a:	f7fb fb81 	bl	207d10 <test_printf>
}
  20c60e:	bf00      	nop
  20c610:	b003      	add	sp, #12
  20c612:	f85d fb04 	ldr.w	pc, [sp], #4
  20c616:	bf00      	nop
  20c618:	08010dbc 	.word	0x08010dbc
  20c61c:	00000000 	.word	0x00000000

0020c620 <test_print.lto_priv.2>:
static inline void test_print(const char *msgp) {
  20c620:	b500      	push	{lr}
  20c622:	b083      	sub	sp, #12
  20c624:	9001      	str	r0, [sp, #4]
  test_printf("%s", msgp);
  20c626:	9901      	ldr	r1, [sp, #4]
  20c628:	4803      	ldr	r0, [pc, #12]	@ (20c638 <test_print.lto_priv.2+0x18>)
  20c62a:	f7fb fb71 	bl	207d10 <test_printf>
}
  20c62e:	bf00      	nop
  20c630:	b003      	add	sp, #12
  20c632:	f85d fb04 	ldr.w	pc, [sp], #4
  20c636:	bf00      	nop
  20c638:	08010dc0 	.word	0x08010dc0
  20c63c:	00000000 	.word	0x00000000

0020c640 <test_println.lto_priv.2>:
static inline void test_println(const char *msgp) {
  20c640:	b500      	push	{lr}
  20c642:	b083      	sub	sp, #12
  20c644:	9001      	str	r0, [sp, #4]
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
  20c646:	9901      	ldr	r1, [sp, #4]
  20c648:	4803      	ldr	r0, [pc, #12]	@ (20c658 <test_println.lto_priv.2+0x18>)
  20c64a:	f7fb fb61 	bl	207d10 <test_printf>
}
  20c64e:	bf00      	nop
  20c650:	b003      	add	sp, #12
  20c652:	f85d fb04 	ldr.w	pc, [sp], #4
  20c656:	bf00      	nop
  20c658:	08010bb4 	.word	0x08010bb4
  20c65c:	00000000 	.word	0x00000000

0020c660 <oslib_test_001_001_execute>:
 * <h2>Test Steps</h2>
 * - [1.1.1] Prints the version string.
 * .
 */

static void oslib_test_001_001_execute(void) {
  20c660:	b508      	push	{r3, lr}

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
  20c662:	4b1c      	ldr	r3, [pc, #112]	@ (20c6d4 <oslib_test_001_001_execute+0x74>)
  20c664:	2201      	movs	r2, #1
  20c666:	601a      	str	r2, [r3, #0]
  {
#if defined(PORT_ARCHITECTURE_NAME)
    test_print("--- Architecture:                       ");
  20c668:	481b      	ldr	r0, [pc, #108]	@ (20c6d8 <oslib_test_001_001_execute+0x78>)
  20c66a:	f7ff ffd9 	bl	20c620 <test_print.lto_priv.2>
    test_println(PORT_ARCHITECTURE_NAME);
  20c66e:	481b      	ldr	r0, [pc, #108]	@ (20c6dc <oslib_test_001_001_execute+0x7c>)
  20c670:	f7ff ffe6 	bl	20c640 <test_println.lto_priv.2>
#endif
#if defined(PORT_CORE_VARIANT_NAME)
    test_print("--- Core Variant:                       ");
  20c674:	481a      	ldr	r0, [pc, #104]	@ (20c6e0 <oslib_test_001_001_execute+0x80>)
  20c676:	f7ff ffd3 	bl	20c620 <test_print.lto_priv.2>
    test_println(PORT_CORE_VARIANT_NAME);
  20c67a:	481a      	ldr	r0, [pc, #104]	@ (20c6e4 <oslib_test_001_001_execute+0x84>)
  20c67c:	f7ff ffe0 	bl	20c640 <test_println.lto_priv.2>
#endif
#if defined(PORT_COMPILER_NAME)
    test_print("--- Compiler:                           ");
  20c680:	4819      	ldr	r0, [pc, #100]	@ (20c6e8 <oslib_test_001_001_execute+0x88>)
  20c682:	f7ff ffcd 	bl	20c620 <test_print.lto_priv.2>
    test_println(PORT_COMPILER_NAME);
  20c686:	4819      	ldr	r0, [pc, #100]	@ (20c6ec <oslib_test_001_001_execute+0x8c>)
  20c688:	f7ff ffda 	bl	20c640 <test_println.lto_priv.2>
#endif
#if defined(PORT_INFO)
    test_print("--- Port Info:                          ");
  20c68c:	4818      	ldr	r0, [pc, #96]	@ (20c6f0 <oslib_test_001_001_execute+0x90>)
  20c68e:	f7ff ffc7 	bl	20c620 <test_print.lto_priv.2>
    test_println(PORT_INFO);
  20c692:	4818      	ldr	r0, [pc, #96]	@ (20c6f4 <oslib_test_001_001_execute+0x94>)
  20c694:	f7ff ffd4 	bl	20c640 <test_println.lto_priv.2>
#endif
#if defined(PORT_NATURAL_ALIGN)
    test_print("--- Natural alignment:                  ");
  20c698:	4817      	ldr	r0, [pc, #92]	@ (20c6f8 <oslib_test_001_001_execute+0x98>)
  20c69a:	f7ff ffc1 	bl	20c620 <test_print.lto_priv.2>
    test_printn(PORT_NATURAL_ALIGN);
  20c69e:	2004      	movs	r0, #4
  20c6a0:	f7ff ffae 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c6a4:	4815      	ldr	r0, [pc, #84]	@ (20c6fc <oslib_test_001_001_execute+0x9c>)
  20c6a6:	f7ff ffcb 	bl	20c640 <test_println.lto_priv.2>
#endif
#if defined(PORT_STACK_ALIGN)
    test_print("--- Stack alignment:                    ");
  20c6aa:	4815      	ldr	r0, [pc, #84]	@ (20c700 <oslib_test_001_001_execute+0xa0>)
  20c6ac:	f7ff ffb8 	bl	20c620 <test_print.lto_priv.2>
    test_printn(PORT_STACK_ALIGN);
  20c6b0:	2020      	movs	r0, #32
  20c6b2:	f7ff ffa5 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c6b6:	4811      	ldr	r0, [pc, #68]	@ (20c6fc <oslib_test_001_001_execute+0x9c>)
  20c6b8:	f7ff ffc2 	bl	20c640 <test_println.lto_priv.2>
#endif
#if defined(PORT_WORKING_AREA_ALIGN)
    test_print("--- Working area alignment:             ");
  20c6bc:	4811      	ldr	r0, [pc, #68]	@ (20c704 <oslib_test_001_001_execute+0xa4>)
  20c6be:	f7ff ffaf 	bl	20c620 <test_print.lto_priv.2>
    test_printn(PORT_WORKING_AREA_ALIGN);
  20c6c2:	2020      	movs	r0, #32
  20c6c4:	f7ff ff9c 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c6c8:	480c      	ldr	r0, [pc, #48]	@ (20c6fc <oslib_test_001_001_execute+0x9c>)
  20c6ca:	f7ff ffb9 	bl	20c640 <test_println.lto_priv.2>
#endif
  }
  test_end_step(1);
}
  20c6ce:	bf00      	nop
  20c6d0:	bd08      	pop	{r3, pc}
  20c6d2:	bf00      	nop
  20c6d4:	20000bb4 	.word	0x20000bb4
  20c6d8:	08010dc4 	.word	0x08010dc4
  20c6dc:	08010df0 	.word	0x08010df0
  20c6e0:	08010dfc 	.word	0x08010dfc
  20c6e4:	08010e28 	.word	0x08010e28
  20c6e8:	08010e34 	.word	0x08010e34
  20c6ec:	08010e60 	.word	0x08010e60
  20c6f0:	08010e74 	.word	0x08010e74
  20c6f4:	08010ea0 	.word	0x08010ea0
  20c6f8:	08010eb8 	.word	0x08010eb8
  20c6fc:	08010bcc 	.word	0x08010bcc
  20c700:	08010ee4 	.word	0x08010ee4
  20c704:	08010f10 	.word	0x08010f10
	...

0020c710 <oslib_test_001_002_execute>:
 * <h2>Test Steps</h2>
 * - [1.2.1] Prints the version string.
 * .
 */

static void oslib_test_001_002_execute(void) {
  20c710:	b508      	push	{r3, lr}

  /* [1.2.1] Prints the version string.*/
  test_set_step(1);
  20c712:	4b19      	ldr	r3, [pc, #100]	@ (20c778 <oslib_test_001_002_execute+0x68>)
  20c714:	2201      	movs	r2, #1
  20c716:	601a      	str	r2, [r3, #0]
  {
    test_println("--- Product:                            ChibiOS/LIB");
  20c718:	4818      	ldr	r0, [pc, #96]	@ (20c77c <oslib_test_001_002_execute+0x6c>)
  20c71a:	f7ff ff91 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- Stable Flag:                        ");
  20c71e:	4818      	ldr	r0, [pc, #96]	@ (20c780 <oslib_test_001_002_execute+0x70>)
  20c720:	f7ff ff7e 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_OSLIB_STABLE);
  20c724:	2000      	movs	r0, #0
  20c726:	f7ff ff6b 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c72a:	4816      	ldr	r0, [pc, #88]	@ (20c784 <oslib_test_001_002_execute+0x74>)
  20c72c:	f7ff ff88 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- Version String:                     ");
  20c730:	4815      	ldr	r0, [pc, #84]	@ (20c788 <oslib_test_001_002_execute+0x78>)
  20c732:	f7ff ff75 	bl	20c620 <test_print.lto_priv.2>
    test_println(CH_OSLIB_VERSION);
  20c736:	4815      	ldr	r0, [pc, #84]	@ (20c78c <oslib_test_001_002_execute+0x7c>)
  20c738:	f7ff ff82 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- Major Number:                       ");
  20c73c:	4814      	ldr	r0, [pc, #80]	@ (20c790 <oslib_test_001_002_execute+0x80>)
  20c73e:	f7ff ff6f 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_OSLIB_MAJOR);
  20c742:	2001      	movs	r0, #1
  20c744:	f7ff ff5c 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c748:	480e      	ldr	r0, [pc, #56]	@ (20c784 <oslib_test_001_002_execute+0x74>)
  20c74a:	f7ff ff79 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- Minor Number:                       ");
  20c74e:	4811      	ldr	r0, [pc, #68]	@ (20c794 <oslib_test_001_002_execute+0x84>)
  20c750:	f7ff ff66 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_OSLIB_MINOR);
  20c754:	2004      	movs	r0, #4
  20c756:	f7ff ff53 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c75a:	480a      	ldr	r0, [pc, #40]	@ (20c784 <oslib_test_001_002_execute+0x74>)
  20c75c:	f7ff ff70 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- Patch Number:                       ");
  20c760:	480d      	ldr	r0, [pc, #52]	@ (20c798 <oslib_test_001_002_execute+0x88>)
  20c762:	f7ff ff5d 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_OSLIB_PATCH);
  20c766:	2000      	movs	r0, #0
  20c768:	f7ff ff4a 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c76c:	4805      	ldr	r0, [pc, #20]	@ (20c784 <oslib_test_001_002_execute+0x74>)
  20c76e:	f7ff ff67 	bl	20c640 <test_println.lto_priv.2>
  }
  test_end_step(1);
}
  20c772:	bf00      	nop
  20c774:	bd08      	pop	{r3, pc}
  20c776:	bf00      	nop
  20c778:	20000bb4 	.word	0x20000bb4
  20c77c:	08011b28 	.word	0x08011b28
  20c780:	08010f70 	.word	0x08010f70
  20c784:	08010bcc 	.word	0x08010bcc
  20c788:	08010f9c 	.word	0x08010f9c
  20c78c:	08011b5c 	.word	0x08011b5c
  20c790:	08010fd0 	.word	0x08010fd0
  20c794:	08010ffc 	.word	0x08010ffc
  20c798:	08011028 	.word	0x08011028
  20c79c:	00000000 	.word	0x00000000

0020c7a0 <oslib_test_001_003_execute>:
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void oslib_test_001_003_execute(void) {
  20c7a0:	b508      	push	{r3, lr}

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
  20c7a2:	4b53      	ldr	r3, [pc, #332]	@ (20c8f0 <oslib_test_001_003_execute+0x150>)
  20c7a4:	2201      	movs	r2, #1
  20c7a6:	601a      	str	r2, [r3, #0]
  {
    test_print("--- CH_CFG_USE_MAILBOXES:               ");
  20c7a8:	4852      	ldr	r0, [pc, #328]	@ (20c8f4 <oslib_test_001_003_execute+0x154>)
  20c7aa:	f7ff ff39 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_USE_MAILBOXES);
  20c7ae:	2001      	movs	r0, #1
  20c7b0:	f7ff ff26 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c7b4:	4850      	ldr	r0, [pc, #320]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c7b6:	f7ff ff43 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_USE_MEMCHECKS:               ");
  20c7ba:	4850      	ldr	r0, [pc, #320]	@ (20c8fc <oslib_test_001_003_execute+0x15c>)
  20c7bc:	f7ff ff30 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_USE_MEMCHECKS);
  20c7c0:	2001      	movs	r0, #1
  20c7c2:	f7ff ff1d 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c7c6:	484c      	ldr	r0, [pc, #304]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c7c8:	f7ff ff3a 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_USE_MEMCORE:                 ");
  20c7cc:	484c      	ldr	r0, [pc, #304]	@ (20c900 <oslib_test_001_003_execute+0x160>)
  20c7ce:	f7ff ff27 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_USE_MEMCORE);
  20c7d2:	2001      	movs	r0, #1
  20c7d4:	f7ff ff14 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c7d8:	4847      	ldr	r0, [pc, #284]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c7da:	f7ff ff31 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_MEMCORE_SIZE:                ");
  20c7de:	4849      	ldr	r0, [pc, #292]	@ (20c904 <oslib_test_001_003_execute+0x164>)
  20c7e0:	f7ff ff1e 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_MEMCORE_SIZE);
  20c7e4:	2000      	movs	r0, #0
  20c7e6:	f7ff ff0b 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c7ea:	4843      	ldr	r0, [pc, #268]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c7ec:	f7ff ff28 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_USE_HEAP:                    ");
  20c7f0:	4845      	ldr	r0, [pc, #276]	@ (20c908 <oslib_test_001_003_execute+0x168>)
  20c7f2:	f7ff ff15 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_USE_HEAP);
  20c7f6:	2001      	movs	r0, #1
  20c7f8:	f7ff ff02 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c7fc:	483e      	ldr	r0, [pc, #248]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c7fe:	f7ff ff1f 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_USE_MEMPOOLS:                ");
  20c802:	4842      	ldr	r0, [pc, #264]	@ (20c90c <oslib_test_001_003_execute+0x16c>)
  20c804:	f7ff ff0c 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_USE_MEMPOOLS);
  20c808:	2001      	movs	r0, #1
  20c80a:	f7ff fef9 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c80e:	483a      	ldr	r0, [pc, #232]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c810:	f7ff ff16 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_USE_OBJ_FIFOS:               ");
  20c814:	483e      	ldr	r0, [pc, #248]	@ (20c910 <oslib_test_001_003_execute+0x170>)
  20c816:	f7ff ff03 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_USE_OBJ_FIFOS);
  20c81a:	2001      	movs	r0, #1
  20c81c:	f7ff fef0 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c820:	4835      	ldr	r0, [pc, #212]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c822:	f7ff ff0d 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_USE_PIPES:                   ");
  20c826:	483b      	ldr	r0, [pc, #236]	@ (20c914 <oslib_test_001_003_execute+0x174>)
  20c828:	f7ff fefa 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_USE_PIPES);
  20c82c:	2001      	movs	r0, #1
  20c82e:	f7ff fee7 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c832:	4831      	ldr	r0, [pc, #196]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c834:	f7ff ff04 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_USE_OBJ_CACHES:              ");
  20c838:	4837      	ldr	r0, [pc, #220]	@ (20c918 <oslib_test_001_003_execute+0x178>)
  20c83a:	f7ff fef1 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_USE_OBJ_CACHES);
  20c83e:	2001      	movs	r0, #1
  20c840:	f7ff fede 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c844:	482c      	ldr	r0, [pc, #176]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c846:	f7ff fefb 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_USE_DELEGATES:               ");
  20c84a:	4834      	ldr	r0, [pc, #208]	@ (20c91c <oslib_test_001_003_execute+0x17c>)
  20c84c:	f7ff fee8 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_USE_DELEGATES);
  20c850:	2001      	movs	r0, #1
  20c852:	f7ff fed5 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c856:	4828      	ldr	r0, [pc, #160]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c858:	f7ff fef2 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_USE_FACTORY:                 ");
  20c85c:	4830      	ldr	r0, [pc, #192]	@ (20c920 <oslib_test_001_003_execute+0x180>)
  20c85e:	f7ff fedf 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_USE_FACTORY);
  20c862:	2001      	movs	r0, #1
  20c864:	f7ff fecc 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c868:	4823      	ldr	r0, [pc, #140]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c86a:	f7ff fee9 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_FACTORY_MAX_NAMES_LENGTH:    ");
  20c86e:	482d      	ldr	r0, [pc, #180]	@ (20c924 <oslib_test_001_003_execute+0x184>)
  20c870:	f7ff fed6 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_FACTORY_MAX_NAMES_LENGTH);
  20c874:	2008      	movs	r0, #8
  20c876:	f7ff fec3 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c87a:	481f      	ldr	r0, [pc, #124]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c87c:	f7ff fee0 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_FACTORY_OBJECTS_REGISTRY:    ");
  20c880:	4829      	ldr	r0, [pc, #164]	@ (20c928 <oslib_test_001_003_execute+0x188>)
  20c882:	f7ff fecd 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_FACTORY_OBJECTS_REGISTRY);
  20c886:	2001      	movs	r0, #1
  20c888:	f7ff feba 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c88c:	481a      	ldr	r0, [pc, #104]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c88e:	f7ff fed7 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_FACTORY_GENERIC_BUFFERS:     ");
  20c892:	4826      	ldr	r0, [pc, #152]	@ (20c92c <oslib_test_001_003_execute+0x18c>)
  20c894:	f7ff fec4 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_FACTORY_GENERIC_BUFFERS);
  20c898:	2001      	movs	r0, #1
  20c89a:	f7ff feb1 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c89e:	4816      	ldr	r0, [pc, #88]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c8a0:	f7ff fece 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_FACTORY_SEMAPHORES:          ");
  20c8a4:	4822      	ldr	r0, [pc, #136]	@ (20c930 <oslib_test_001_003_execute+0x190>)
  20c8a6:	f7ff febb 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_FACTORY_SEMAPHORES);
  20c8aa:	2001      	movs	r0, #1
  20c8ac:	f7ff fea8 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c8b0:	4811      	ldr	r0, [pc, #68]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c8b2:	f7ff fec5 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_FACTORY_MAILBOXES:           ");
  20c8b6:	481f      	ldr	r0, [pc, #124]	@ (20c934 <oslib_test_001_003_execute+0x194>)
  20c8b8:	f7ff feb2 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_FACTORY_MAILBOXES);
  20c8bc:	2001      	movs	r0, #1
  20c8be:	f7ff fe9f 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c8c2:	480d      	ldr	r0, [pc, #52]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c8c4:	f7ff febc 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_FACTORY_OBJ_FIFOS:           ");
  20c8c8:	481b      	ldr	r0, [pc, #108]	@ (20c938 <oslib_test_001_003_execute+0x198>)
  20c8ca:	f7ff fea9 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_FACTORY_OBJ_FIFOS);
  20c8ce:	2001      	movs	r0, #1
  20c8d0:	f7ff fe96 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c8d4:	4808      	ldr	r0, [pc, #32]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c8d6:	f7ff feb3 	bl	20c640 <test_println.lto_priv.2>
    test_print("--- CH_CFG_FACTORY_PIPES:               ");
  20c8da:	4818      	ldr	r0, [pc, #96]	@ (20c93c <oslib_test_001_003_execute+0x19c>)
  20c8dc:	f7ff fea0 	bl	20c620 <test_print.lto_priv.2>
    test_printn(CH_CFG_FACTORY_PIPES);
  20c8e0:	2001      	movs	r0, #1
  20c8e2:	f7ff fe8d 	bl	20c600 <test_printn.lto_priv.2>
    test_println("");
  20c8e6:	4804      	ldr	r0, [pc, #16]	@ (20c8f8 <oslib_test_001_003_execute+0x158>)
  20c8e8:	f7ff feaa 	bl	20c640 <test_println.lto_priv.2>
  }
  test_end_step(1);
}
  20c8ec:	bf00      	nop
  20c8ee:	bd08      	pop	{r3, pc}
  20c8f0:	20000bb4 	.word	0x20000bb4
  20c8f4:	08011b64 	.word	0x08011b64
  20c8f8:	08010bcc 	.word	0x08010bcc
  20c8fc:	08011b90 	.word	0x08011b90
  20c900:	08011bbc 	.word	0x08011bbc
  20c904:	08011be8 	.word	0x08011be8
  20c908:	08011c14 	.word	0x08011c14
  20c90c:	08011c40 	.word	0x08011c40
  20c910:	08011c6c 	.word	0x08011c6c
  20c914:	08011c98 	.word	0x08011c98
  20c918:	08011cc4 	.word	0x08011cc4
  20c91c:	08011cf0 	.word	0x08011cf0
  20c920:	08011d1c 	.word	0x08011d1c
  20c924:	08011d48 	.word	0x08011d48
  20c928:	08011d74 	.word	0x08011d74
  20c92c:	08011da0 	.word	0x08011da0
  20c930:	08011dcc 	.word	0x08011dcc
  20c934:	08011df8 	.word	0x08011df8
  20c938:	08011e24 	.word	0x08011e24
  20c93c:	08011e50 	.word	0x08011e50

0020c940 <chSysLock.lto_priv.28>:
static inline void chSysLock(void) {
  20c940:	b082      	sub	sp, #8
  20c942:	2330      	movs	r3, #48	@ 0x30
  20c944:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20c946:	9b01      	ldr	r3, [sp, #4]
  20c948:	f383 8811 	msr	BASEPRI, r3
}
  20c94c:	bf00      	nop
}
  20c94e:	bf00      	nop
}
  20c950:	bf00      	nop
  20c952:	b002      	add	sp, #8
  20c954:	4770      	bx	lr
  20c956:	bf00      	nop
	...

0020c960 <chSysUnlock.lto_priv.28>:
static inline void chSysUnlock(void) {
  20c960:	b082      	sub	sp, #8
  20c962:	2300      	movs	r3, #0
  20c964:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20c966:	9b01      	ldr	r3, [sp, #4]
  20c968:	f383 8811 	msr	BASEPRI, r3
}
  20c96c:	bf00      	nop
}
  20c96e:	bf00      	nop
}
  20c970:	bf00      	nop
  20c972:	b002      	add	sp, #8
  20c974:	4770      	bx	lr
  20c976:	bf00      	nop
	...

0020c980 <chMBGetSizeI.lto_priv.1>:
static inline size_t chMBGetSizeI(const mailbox_t *mbp) {
  20c980:	b082      	sub	sp, #8
  20c982:	9001      	str	r0, [sp, #4]
  return (size_t)(mbp->top - mbp->buffer);
  20c984:	9b01      	ldr	r3, [sp, #4]
  20c986:	685a      	ldr	r2, [r3, #4]
  20c988:	9b01      	ldr	r3, [sp, #4]
  20c98a:	681b      	ldr	r3, [r3, #0]
  20c98c:	1ad3      	subs	r3, r2, r3
  20c98e:	109b      	asrs	r3, r3, #2
}
  20c990:	4618      	mov	r0, r3
  20c992:	b002      	add	sp, #8
  20c994:	4770      	bx	lr
  20c996:	bf00      	nop
	...

0020c9a0 <chMBGetUsedCountI.lto_priv.1>:
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {
  20c9a0:	b082      	sub	sp, #8
  20c9a2:	9001      	str	r0, [sp, #4]
  return mbp->cnt;
  20c9a4:	9b01      	ldr	r3, [sp, #4]
  20c9a6:	691b      	ldr	r3, [r3, #16]
}
  20c9a8:	4618      	mov	r0, r3
  20c9aa:	b002      	add	sp, #8
  20c9ac:	4770      	bx	lr
  20c9ae:	bf00      	nop

0020c9b0 <chMBGetFreeCountI.lto_priv.1>:
static inline size_t chMBGetFreeCountI(const mailbox_t *mbp) {
  20c9b0:	b510      	push	{r4, lr}
  20c9b2:	b082      	sub	sp, #8
  20c9b4:	9001      	str	r0, [sp, #4]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  20c9b6:	9801      	ldr	r0, [sp, #4]
  20c9b8:	f7ff ffe2 	bl	20c980 <chMBGetSizeI.lto_priv.1>
  20c9bc:	4604      	mov	r4, r0
  20c9be:	9801      	ldr	r0, [sp, #4]
  20c9c0:	f7ff ffee 	bl	20c9a0 <chMBGetUsedCountI.lto_priv.1>
  20c9c4:	4603      	mov	r3, r0
  20c9c6:	1ae3      	subs	r3, r4, r3
}
  20c9c8:	4618      	mov	r0, r3
  20c9ca:	b002      	add	sp, #8
  20c9cc:	bd10      	pop	{r4, pc}
  20c9ce:	bf00      	nop

0020c9d0 <chMBResumeX>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {
  20c9d0:	b082      	sub	sp, #8
  20c9d2:	9001      	str	r0, [sp, #4]

  mbp->reset = false;
  20c9d4:	9b01      	ldr	r3, [sp, #4]
  20c9d6:	2200      	movs	r2, #0
  20c9d8:	751a      	strb	r2, [r3, #20]
}
  20c9da:	bf00      	nop
  20c9dc:	b002      	add	sp, #8
  20c9de:	4770      	bx	lr

0020c9e0 <osalSysLock.lto_priv.5>:
static inline void osalSysLock(void) {
  20c9e0:	b508      	push	{r3, lr}
  chSysLock();
  20c9e2:	f7ff ffad 	bl	20c940 <chSysLock.lto_priv.28>
}
  20c9e6:	bf00      	nop
  20c9e8:	bd08      	pop	{r3, pc}
  20c9ea:	bf00      	nop
  20c9ec:	0000      	movs	r0, r0
	...

0020c9f0 <osalSysUnlock.lto_priv.5>:
static inline void osalSysUnlock(void) {
  20c9f0:	b508      	push	{r3, lr}
  chSysUnlock();
  20c9f2:	f7ff ffb5 	bl	20c960 <chSysUnlock.lto_priv.28>
}
  20c9f6:	bf00      	nop
  20c9f8:	bd08      	pop	{r3, pc}
  20c9fa:	bf00      	nop
  20c9fc:	0000      	movs	r0, r0
	...

0020ca00 <oslib_test_002_001_setup>:
 * - [2.1.8] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void oslib_test_002_001_setup(void) {
  20ca00:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
  20ca02:	2204      	movs	r2, #4
  20ca04:	4902      	ldr	r1, [pc, #8]	@ (20ca10 <oslib_test_002_001_setup+0x10>)
  20ca06:	4803      	ldr	r0, [pc, #12]	@ (20ca14 <oslib_test_002_001_setup+0x14>)
  20ca08:	f7f8 fa8a 	bl	204f20 <chMBObjectInit>
}
  20ca0c:	bf00      	nop
  20ca0e:	bd08      	pop	{r3, pc}
  20ca10:	200019a4 	.word	0x200019a4
  20ca14:	20020030 	.word	0x20020030
	...

0020ca20 <oslib_test_002_001_teardown>:

static void oslib_test_002_001_teardown(void) {
  20ca20:	b508      	push	{r3, lr}
  chMBReset(&mb1);
  20ca22:	4802      	ldr	r0, [pc, #8]	@ (20ca2c <oslib_test_002_001_teardown+0xc>)
  20ca24:	f7f8 faa4 	bl	204f70 <chMBReset>
}
  20ca28:	bf00      	nop
  20ca2a:	bd08      	pop	{r3, pc}
  20ca2c:	20020030 	.word	0x20020030

0020ca30 <oslib_test_002_001_execute>:

static void oslib_test_002_001_execute(void) {
  20ca30:	b500      	push	{lr}
  20ca32:	b085      	sub	sp, #20
  msg_t msg1, msg2;
  unsigned i;

  /* [2.1.1] Testing the mailbox size.*/
  test_set_step(1);
  20ca34:	4ba5      	ldr	r3, [pc, #660]	@ (20cccc <oslib_test_002_001_execute+0x29c>)
  20ca36:	2201      	movs	r2, #1
  20ca38:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  20ca3a:	f7ff ffd1 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20ca3e:	48a4      	ldr	r0, [pc, #656]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20ca40:	f7ff ffb6 	bl	20c9b0 <chMBGetFreeCountI.lto_priv.1>
  20ca44:	4603      	mov	r3, r0
  20ca46:	2b04      	cmp	r3, #4
  20ca48:	bf0c      	ite	eq
  20ca4a:	2301      	moveq	r3, #1
  20ca4c:	2300      	movne	r3, #0
  20ca4e:	b2db      	uxtb	r3, r3
  20ca50:	49a0      	ldr	r1, [pc, #640]	@ (20ccd4 <oslib_test_002_001_execute+0x2a4>)
  20ca52:	4618      	mov	r0, r3
  20ca54:	f7fa fe04 	bl	207660 <__test_assert>
  20ca58:	4603      	mov	r3, r0
  20ca5a:	2b00      	cmp	r3, #0
  20ca5c:	d002      	beq.n	20ca64 <oslib_test_002_001_execute+0x34>
  20ca5e:	f7ff ffc7 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20ca62:	e1f1      	b.n	20ce48 <oslib_test_002_001_execute+0x418>
  20ca64:	f7ff ffc4 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  }
  test_end_step(1);

  /* [2.1.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
  20ca68:	4b98      	ldr	r3, [pc, #608]	@ (20cccc <oslib_test_002_001_execute+0x29c>)
  20ca6a:	2202      	movs	r2, #2
  20ca6c:	601a      	str	r2, [r3, #0]
  {
    chMBReset(&mb1);
  20ca6e:	4898      	ldr	r0, [pc, #608]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20ca70:	f7f8 fa7e 	bl	204f70 <chMBReset>
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  20ca74:	f7ff ffb4 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20ca78:	4895      	ldr	r0, [pc, #596]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20ca7a:	f7ff ff99 	bl	20c9b0 <chMBGetFreeCountI.lto_priv.1>
  20ca7e:	4603      	mov	r3, r0
  20ca80:	2b04      	cmp	r3, #4
  20ca82:	bf0c      	ite	eq
  20ca84:	2301      	moveq	r3, #1
  20ca86:	2300      	movne	r3, #0
  20ca88:	b2db      	uxtb	r3, r3
  20ca8a:	4993      	ldr	r1, [pc, #588]	@ (20ccd8 <oslib_test_002_001_execute+0x2a8>)
  20ca8c:	4618      	mov	r0, r3
  20ca8e:	f7fa fde7 	bl	207660 <__test_assert>
  20ca92:	4603      	mov	r3, r0
  20ca94:	2b00      	cmp	r3, #0
  20ca96:	d002      	beq.n	20ca9e <oslib_test_002_001_execute+0x6e>
  20ca98:	f7ff ffaa 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20ca9c:	e1d4      	b.n	20ce48 <oslib_test_002_001_execute+0x418>
  20ca9e:	f7ff ffa7 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
  20caa2:	f7ff ff9d 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20caa6:	488a      	ldr	r0, [pc, #552]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20caa8:	f7ff ff7a 	bl	20c9a0 <chMBGetUsedCountI.lto_priv.1>
  20caac:	4603      	mov	r3, r0
  20caae:	2b00      	cmp	r3, #0
  20cab0:	bf0c      	ite	eq
  20cab2:	2301      	moveq	r3, #1
  20cab4:	2300      	movne	r3, #0
  20cab6:	b2db      	uxtb	r3, r3
  20cab8:	4988      	ldr	r1, [pc, #544]	@ (20ccdc <oslib_test_002_001_execute+0x2ac>)
  20caba:	4618      	mov	r0, r3
  20cabc:	f7fa fdd0 	bl	207660 <__test_assert>
  20cac0:	4603      	mov	r3, r0
  20cac2:	2b00      	cmp	r3, #0
  20cac4:	d002      	beq.n	20cacc <oslib_test_002_001_execute+0x9c>
  20cac6:	f7ff ff93 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20caca:	e1bd      	b.n	20ce48 <oslib_test_002_001_execute+0x418>
  20cacc:	f7ff ff90 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
  20cad0:	f7ff ff86 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cad4:	4b7e      	ldr	r3, [pc, #504]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cad6:	681a      	ldr	r2, [r3, #0]
  20cad8:	4b7d      	ldr	r3, [pc, #500]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cada:	689b      	ldr	r3, [r3, #8]
  20cadc:	429a      	cmp	r2, r3
  20cade:	bf0c      	ite	eq
  20cae0:	2301      	moveq	r3, #1
  20cae2:	2300      	movne	r3, #0
  20cae4:	b2db      	uxtb	r3, r3
  20cae6:	497e      	ldr	r1, [pc, #504]	@ (20cce0 <oslib_test_002_001_execute+0x2b0>)
  20cae8:	4618      	mov	r0, r3
  20caea:	f7fa fdb9 	bl	207660 <__test_assert>
  20caee:	4603      	mov	r3, r0
  20caf0:	2b00      	cmp	r3, #0
  20caf2:	d002      	beq.n	20cafa <oslib_test_002_001_execute+0xca>
  20caf4:	f7ff ff7c 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20caf8:	e1a6      	b.n	20ce48 <oslib_test_002_001_execute+0x418>
  20cafa:	f7ff ff79 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  20cafe:	f7ff ff6f 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cb02:	4b73      	ldr	r3, [pc, #460]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cb04:	681a      	ldr	r2, [r3, #0]
  20cb06:	4b72      	ldr	r3, [pc, #456]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cb08:	68db      	ldr	r3, [r3, #12]
  20cb0a:	429a      	cmp	r2, r3
  20cb0c:	bf0c      	ite	eq
  20cb0e:	2301      	moveq	r3, #1
  20cb10:	2300      	movne	r3, #0
  20cb12:	b2db      	uxtb	r3, r3
  20cb14:	4973      	ldr	r1, [pc, #460]	@ (20cce4 <oslib_test_002_001_execute+0x2b4>)
  20cb16:	4618      	mov	r0, r3
  20cb18:	f7fa fda2 	bl	207660 <__test_assert>
  20cb1c:	4603      	mov	r3, r0
  20cb1e:	2b00      	cmp	r3, #0
  20cb20:	d002      	beq.n	20cb28 <oslib_test_002_001_execute+0xf8>
  20cb22:	f7ff ff65 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20cb26:	e18f      	b.n	20ce48 <oslib_test_002_001_execute+0x418>
  20cb28:	f7ff ff62 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  }
  test_end_step(2);

  /* [2.1.3] Testing the behavior of API when the mailbox is in reset
     state then return in active state.*/
  test_set_step(3);
  20cb2c:	4b67      	ldr	r3, [pc, #412]	@ (20cccc <oslib_test_002_001_execute+0x29c>)
  20cb2e:	2203      	movs	r2, #3
  20cb30:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
  20cb32:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20cb36:	2100      	movs	r1, #0
  20cb38:	4865      	ldr	r0, [pc, #404]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cb3a:	f7f8 fa51 	bl	204fe0 <chMBPostTimeout>
  20cb3e:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_RESET, "not in reset state");
  20cb40:	9b02      	ldr	r3, [sp, #8]
  20cb42:	f113 0f02 	cmn.w	r3, #2
  20cb46:	bf0c      	ite	eq
  20cb48:	2301      	moveq	r3, #1
  20cb4a:	2300      	movne	r3, #0
  20cb4c:	b2db      	uxtb	r3, r3
  20cb4e:	4966      	ldr	r1, [pc, #408]	@ (20cce8 <oslib_test_002_001_execute+0x2b8>)
  20cb50:	4618      	mov	r0, r3
  20cb52:	f7fa fd85 	bl	207660 <__test_assert>
  20cb56:	4603      	mov	r3, r0
  20cb58:	2b00      	cmp	r3, #0
  20cb5a:	f040 8175 	bne.w	20ce48 <oslib_test_002_001_execute+0x418>
    msg1 = chMBPostAheadTimeout(&mb1, (msg_t)0, TIME_INFINITE);
  20cb5e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20cb62:	2100      	movs	r1, #0
  20cb64:	485a      	ldr	r0, [pc, #360]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cb66:	f7f8 fad3 	bl	205110 <chMBPostAheadTimeout>
  20cb6a:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_RESET, "not in reset state");
  20cb6c:	9b02      	ldr	r3, [sp, #8]
  20cb6e:	f113 0f02 	cmn.w	r3, #2
  20cb72:	bf0c      	ite	eq
  20cb74:	2301      	moveq	r3, #1
  20cb76:	2300      	movne	r3, #0
  20cb78:	b2db      	uxtb	r3, r3
  20cb7a:	495b      	ldr	r1, [pc, #364]	@ (20cce8 <oslib_test_002_001_execute+0x2b8>)
  20cb7c:	4618      	mov	r0, r3
  20cb7e:	f7fa fd6f 	bl	207660 <__test_assert>
  20cb82:	4603      	mov	r3, r0
  20cb84:	2b00      	cmp	r3, #0
  20cb86:	f040 815f 	bne.w	20ce48 <oslib_test_002_001_execute+0x418>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
  20cb8a:	ab01      	add	r3, sp, #4
  20cb8c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20cb90:	4619      	mov	r1, r3
  20cb92:	484f      	ldr	r0, [pc, #316]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cb94:	f7f8 fb54 	bl	205240 <chMBFetchTimeout>
  20cb98:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_RESET, "not in reset state");
  20cb9a:	9b02      	ldr	r3, [sp, #8]
  20cb9c:	f113 0f02 	cmn.w	r3, #2
  20cba0:	bf0c      	ite	eq
  20cba2:	2301      	moveq	r3, #1
  20cba4:	2300      	movne	r3, #0
  20cba6:	b2db      	uxtb	r3, r3
  20cba8:	494f      	ldr	r1, [pc, #316]	@ (20cce8 <oslib_test_002_001_execute+0x2b8>)
  20cbaa:	4618      	mov	r0, r3
  20cbac:	f7fa fd58 	bl	207660 <__test_assert>
  20cbb0:	4603      	mov	r3, r0
  20cbb2:	2b00      	cmp	r3, #0
  20cbb4:	f040 8148 	bne.w	20ce48 <oslib_test_002_001_execute+0x418>
    chMBResumeX(&mb1);
  20cbb8:	4845      	ldr	r0, [pc, #276]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cbba:	f7ff ff09 	bl	20c9d0 <chMBResumeX>
  }
  test_end_step(3);

  /* [2.1.4] Filling the mailbox using chMBPostTimeout() and
     chMBPostAheadTimeout() once, no errors expected.*/
  test_set_step(4);
  20cbbe:	4b43      	ldr	r3, [pc, #268]	@ (20cccc <oslib_test_002_001_execute+0x29c>)
  20cbc0:	2204      	movs	r2, #4
  20cbc2:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
  20cbc4:	2300      	movs	r3, #0
  20cbc6:	9303      	str	r3, [sp, #12]
  20cbc8:	e019      	b.n	20cbfe <oslib_test_002_001_execute+0x1ce>
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  20cbca:	9b03      	ldr	r3, [sp, #12]
  20cbcc:	3342      	adds	r3, #66	@ 0x42
  20cbce:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20cbd2:	4619      	mov	r1, r3
  20cbd4:	483e      	ldr	r0, [pc, #248]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cbd6:	f7f8 fa03 	bl	204fe0 <chMBPostTimeout>
  20cbda:	9002      	str	r0, [sp, #8]
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20cbdc:	9b02      	ldr	r3, [sp, #8]
  20cbde:	2b00      	cmp	r3, #0
  20cbe0:	bf0c      	ite	eq
  20cbe2:	2301      	moveq	r3, #1
  20cbe4:	2300      	movne	r3, #0
  20cbe6:	b2db      	uxtb	r3, r3
  20cbe8:	4940      	ldr	r1, [pc, #256]	@ (20ccec <oslib_test_002_001_execute+0x2bc>)
  20cbea:	4618      	mov	r0, r3
  20cbec:	f7fa fd38 	bl	207660 <__test_assert>
  20cbf0:	4603      	mov	r3, r0
  20cbf2:	2b00      	cmp	r3, #0
  20cbf4:	f040 8128 	bne.w	20ce48 <oslib_test_002_001_execute+0x418>
    for (i = 0; i < MB_SIZE - 1; i++) {
  20cbf8:	9b03      	ldr	r3, [sp, #12]
  20cbfa:	3301      	adds	r3, #1
  20cbfc:	9303      	str	r3, [sp, #12]
  20cbfe:	9b03      	ldr	r3, [sp, #12]
  20cc00:	2b02      	cmp	r3, #2
  20cc02:	d9e2      	bls.n	20cbca <oslib_test_002_001_execute+0x19a>
    }
    msg1 = chMBPostAheadTimeout(&mb1, 'A', TIME_INFINITE);
  20cc04:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20cc08:	2141      	movs	r1, #65	@ 0x41
  20cc0a:	4831      	ldr	r0, [pc, #196]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cc0c:	f7f8 fa80 	bl	205110 <chMBPostAheadTimeout>
  20cc10:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20cc12:	9b02      	ldr	r3, [sp, #8]
  20cc14:	2b00      	cmp	r3, #0
  20cc16:	bf0c      	ite	eq
  20cc18:	2301      	moveq	r3, #1
  20cc1a:	2300      	movne	r3, #0
  20cc1c:	b2db      	uxtb	r3, r3
  20cc1e:	4933      	ldr	r1, [pc, #204]	@ (20ccec <oslib_test_002_001_execute+0x2bc>)
  20cc20:	4618      	mov	r0, r3
  20cc22:	f7fa fd1d 	bl	207660 <__test_assert>
  20cc26:	4603      	mov	r3, r0
  20cc28:	2b00      	cmp	r3, #0
  20cc2a:	f040 810d 	bne.w	20ce48 <oslib_test_002_001_execute+0x418>
  }
  test_end_step(4);

  /* [2.1.5] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(5);
  20cc2e:	4b27      	ldr	r3, [pc, #156]	@ (20cccc <oslib_test_002_001_execute+0x29c>)
  20cc30:	2205      	movs	r2, #5
  20cc32:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
  20cc34:	f7ff fed4 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cc38:	4825      	ldr	r0, [pc, #148]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cc3a:	f7ff feb9 	bl	20c9b0 <chMBGetFreeCountI.lto_priv.1>
  20cc3e:	4603      	mov	r3, r0
  20cc40:	2b00      	cmp	r3, #0
  20cc42:	bf0c      	ite	eq
  20cc44:	2301      	moveq	r3, #1
  20cc46:	2300      	movne	r3, #0
  20cc48:	b2db      	uxtb	r3, r3
  20cc4a:	4929      	ldr	r1, [pc, #164]	@ (20ccf0 <oslib_test_002_001_execute+0x2c0>)
  20cc4c:	4618      	mov	r0, r3
  20cc4e:	f7fa fd07 	bl	207660 <__test_assert>
  20cc52:	4603      	mov	r3, r0
  20cc54:	2b00      	cmp	r3, #0
  20cc56:	d002      	beq.n	20cc5e <oslib_test_002_001_execute+0x22e>
  20cc58:	f7ff feca 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20cc5c:	e0f4      	b.n	20ce48 <oslib_test_002_001_execute+0x418>
  20cc5e:	f7ff fec7 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
  20cc62:	f7ff febd 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cc66:	481a      	ldr	r0, [pc, #104]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cc68:	f7ff fe9a 	bl	20c9a0 <chMBGetUsedCountI.lto_priv.1>
  20cc6c:	4603      	mov	r3, r0
  20cc6e:	2b04      	cmp	r3, #4
  20cc70:	bf0c      	ite	eq
  20cc72:	2301      	moveq	r3, #1
  20cc74:	2300      	movne	r3, #0
  20cc76:	b2db      	uxtb	r3, r3
  20cc78:	491e      	ldr	r1, [pc, #120]	@ (20ccf4 <oslib_test_002_001_execute+0x2c4>)
  20cc7a:	4618      	mov	r0, r3
  20cc7c:	f7fa fcf0 	bl	207660 <__test_assert>
  20cc80:	4603      	mov	r3, r0
  20cc82:	2b00      	cmp	r3, #0
  20cc84:	d002      	beq.n	20cc8c <oslib_test_002_001_execute+0x25c>
  20cc86:	f7ff feb3 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20cc8a:	e0dd      	b.n	20ce48 <oslib_test_002_001_execute+0x418>
  20cc8c:	f7ff feb0 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
  20cc90:	f7ff fea6 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cc94:	4b0e      	ldr	r3, [pc, #56]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cc96:	68da      	ldr	r2, [r3, #12]
  20cc98:	4b0d      	ldr	r3, [pc, #52]	@ (20ccd0 <oslib_test_002_001_execute+0x2a0>)
  20cc9a:	689b      	ldr	r3, [r3, #8]
  20cc9c:	429a      	cmp	r2, r3
  20cc9e:	bf0c      	ite	eq
  20cca0:	2301      	moveq	r3, #1
  20cca2:	2300      	movne	r3, #0
  20cca4:	b2db      	uxtb	r3, r3
  20cca6:	4914      	ldr	r1, [pc, #80]	@ (20ccf8 <oslib_test_002_001_execute+0x2c8>)
  20cca8:	4618      	mov	r0, r3
  20ccaa:	f7fa fcd9 	bl	207660 <__test_assert>
  20ccae:	4603      	mov	r3, r0
  20ccb0:	2b00      	cmp	r3, #0
  20ccb2:	d002      	beq.n	20ccba <oslib_test_002_001_execute+0x28a>
  20ccb4:	f7ff fe9c 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20ccb8:	e0c6      	b.n	20ce48 <oslib_test_002_001_execute+0x418>
  20ccba:	f7ff fe99 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  }
  test_end_step(5);

  /* [2.1.6] Emptying the mailbox using chMBFetchTimeout(), no errors
     expected.*/
  test_set_step(6);
  20ccbe:	4b03      	ldr	r3, [pc, #12]	@ (20cccc <oslib_test_002_001_execute+0x29c>)
  20ccc0:	2206      	movs	r2, #6
  20ccc2:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
  20ccc4:	2300      	movs	r3, #0
  20ccc6:	9303      	str	r3, [sp, #12]
  20ccc8:	e036      	b.n	20cd38 <oslib_test_002_001_execute+0x308>
  20ccca:	bf00      	nop
  20cccc:	20000bb4 	.word	0x20000bb4
  20ccd0:	20020030 	.word	0x20020030
  20ccd4:	08011e7c 	.word	0x08011e7c
  20ccd8:	08011e88 	.word	0x08011e88
  20ccdc:	08011e94 	.word	0x08011e94
  20cce0:	08011ea0 	.word	0x08011ea0
  20cce4:	08011ec4 	.word	0x08011ec4
  20cce8:	08011ee8 	.word	0x08011ee8
  20ccec:	080117d0 	.word	0x080117d0
  20ccf0:	08011efc 	.word	0x08011efc
  20ccf4:	08011f08 	.word	0x08011f08
  20ccf8:	08011f14 	.word	0x08011f14
      msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
  20ccfc:	ab01      	add	r3, sp, #4
  20ccfe:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20cd02:	4619      	mov	r1, r3
  20cd04:	4852      	ldr	r0, [pc, #328]	@ (20ce50 <oslib_test_002_001_execute+0x420>)
  20cd06:	f7f8 fa9b 	bl	205240 <chMBFetchTimeout>
  20cd0a:	9002      	str	r0, [sp, #8]
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20cd0c:	9b02      	ldr	r3, [sp, #8]
  20cd0e:	2b00      	cmp	r3, #0
  20cd10:	bf0c      	ite	eq
  20cd12:	2301      	moveq	r3, #1
  20cd14:	2300      	movne	r3, #0
  20cd16:	b2db      	uxtb	r3, r3
  20cd18:	494e      	ldr	r1, [pc, #312]	@ (20ce54 <oslib_test_002_001_execute+0x424>)
  20cd1a:	4618      	mov	r0, r3
  20cd1c:	f7fa fca0 	bl	207660 <__test_assert>
  20cd20:	4603      	mov	r3, r0
  20cd22:	2b00      	cmp	r3, #0
  20cd24:	f040 8090 	bne.w	20ce48 <oslib_test_002_001_execute+0x418>
      test_emit_token(msg2);
  20cd28:	9b01      	ldr	r3, [sp, #4]
  20cd2a:	b2db      	uxtb	r3, r3
  20cd2c:	4618      	mov	r0, r3
  20cd2e:	f7fa fcf7 	bl	207720 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
  20cd32:	9b03      	ldr	r3, [sp, #12]
  20cd34:	3301      	adds	r3, #1
  20cd36:	9303      	str	r3, [sp, #12]
  20cd38:	9b03      	ldr	r3, [sp, #12]
  20cd3a:	2b03      	cmp	r3, #3
  20cd3c:	d9de      	bls.n	20ccfc <oslib_test_002_001_execute+0x2cc>
    }
    test_assert_sequence("ABCD", "wrong get sequence");
  20cd3e:	4946      	ldr	r1, [pc, #280]	@ (20ce58 <oslib_test_002_001_execute+0x428>)
  20cd40:	4846      	ldr	r0, [pc, #280]	@ (20ce5c <oslib_test_002_001_execute+0x42c>)
  20cd42:	f7fa fca5 	bl	207690 <__test_assert_sequence>
  20cd46:	4603      	mov	r3, r0
  20cd48:	2b00      	cmp	r3, #0
  20cd4a:	d17d      	bne.n	20ce48 <oslib_test_002_001_execute+0x418>
  }
  test_end_step(6);

  /* [2.1.7] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(7);
  20cd4c:	4b44      	ldr	r3, [pc, #272]	@ (20ce60 <oslib_test_002_001_execute+0x430>)
  20cd4e:	2207      	movs	r2, #7
  20cd50:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  20cd52:	9b03      	ldr	r3, [sp, #12]
  20cd54:	3342      	adds	r3, #66	@ 0x42
  20cd56:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20cd5a:	4619      	mov	r1, r3
  20cd5c:	483c      	ldr	r0, [pc, #240]	@ (20ce50 <oslib_test_002_001_execute+0x420>)
  20cd5e:	f7f8 f93f 	bl	204fe0 <chMBPostTimeout>
  20cd62:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20cd64:	9b02      	ldr	r3, [sp, #8]
  20cd66:	2b00      	cmp	r3, #0
  20cd68:	bf0c      	ite	eq
  20cd6a:	2301      	moveq	r3, #1
  20cd6c:	2300      	movne	r3, #0
  20cd6e:	b2db      	uxtb	r3, r3
  20cd70:	4938      	ldr	r1, [pc, #224]	@ (20ce54 <oslib_test_002_001_execute+0x424>)
  20cd72:	4618      	mov	r0, r3
  20cd74:	f7fa fc74 	bl	207660 <__test_assert>
  20cd78:	4603      	mov	r3, r0
  20cd7a:	2b00      	cmp	r3, #0
  20cd7c:	d164      	bne.n	20ce48 <oslib_test_002_001_execute+0x418>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
  20cd7e:	ab01      	add	r3, sp, #4
  20cd80:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20cd84:	4619      	mov	r1, r3
  20cd86:	4832      	ldr	r0, [pc, #200]	@ (20ce50 <oslib_test_002_001_execute+0x420>)
  20cd88:	f7f8 fa5a 	bl	205240 <chMBFetchTimeout>
  20cd8c:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20cd8e:	9b02      	ldr	r3, [sp, #8]
  20cd90:	2b00      	cmp	r3, #0
  20cd92:	bf0c      	ite	eq
  20cd94:	2301      	moveq	r3, #1
  20cd96:	2300      	movne	r3, #0
  20cd98:	b2db      	uxtb	r3, r3
  20cd9a:	492e      	ldr	r1, [pc, #184]	@ (20ce54 <oslib_test_002_001_execute+0x424>)
  20cd9c:	4618      	mov	r0, r3
  20cd9e:	f7fa fc5f 	bl	207660 <__test_assert>
  20cda2:	4603      	mov	r3, r0
  20cda4:	2b00      	cmp	r3, #0
  20cda6:	d14f      	bne.n	20ce48 <oslib_test_002_001_execute+0x418>
  }
  test_end_step(7);

  /* [2.1.8] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(8);
  20cda8:	4b2d      	ldr	r3, [pc, #180]	@ (20ce60 <oslib_test_002_001_execute+0x430>)
  20cdaa:	2208      	movs	r2, #8
  20cdac:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  20cdae:	f7ff fe17 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cdb2:	4827      	ldr	r0, [pc, #156]	@ (20ce50 <oslib_test_002_001_execute+0x420>)
  20cdb4:	f7ff fdfc 	bl	20c9b0 <chMBGetFreeCountI.lto_priv.1>
  20cdb8:	4603      	mov	r3, r0
  20cdba:	2b04      	cmp	r3, #4
  20cdbc:	bf0c      	ite	eq
  20cdbe:	2301      	moveq	r3, #1
  20cdc0:	2300      	movne	r3, #0
  20cdc2:	b2db      	uxtb	r3, r3
  20cdc4:	4927      	ldr	r1, [pc, #156]	@ (20ce64 <oslib_test_002_001_execute+0x434>)
  20cdc6:	4618      	mov	r0, r3
  20cdc8:	f7fa fc4a 	bl	207660 <__test_assert>
  20cdcc:	4603      	mov	r3, r0
  20cdce:	2b00      	cmp	r3, #0
  20cdd0:	d002      	beq.n	20cdd8 <oslib_test_002_001_execute+0x3a8>
  20cdd2:	f7ff fe0d 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20cdd6:	e037      	b.n	20ce48 <oslib_test_002_001_execute+0x418>
  20cdd8:	f7ff fe0a 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
  20cddc:	f7ff fe00 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cde0:	481b      	ldr	r0, [pc, #108]	@ (20ce50 <oslib_test_002_001_execute+0x420>)
  20cde2:	f7ff fddd 	bl	20c9a0 <chMBGetUsedCountI.lto_priv.1>
  20cde6:	4603      	mov	r3, r0
  20cde8:	2b00      	cmp	r3, #0
  20cdea:	bf0c      	ite	eq
  20cdec:	2301      	moveq	r3, #1
  20cdee:	2300      	movne	r3, #0
  20cdf0:	b2db      	uxtb	r3, r3
  20cdf2:	491d      	ldr	r1, [pc, #116]	@ (20ce68 <oslib_test_002_001_execute+0x438>)
  20cdf4:	4618      	mov	r0, r3
  20cdf6:	f7fa fc33 	bl	207660 <__test_assert>
  20cdfa:	4603      	mov	r3, r0
  20cdfc:	2b00      	cmp	r3, #0
  20cdfe:	d002      	beq.n	20ce06 <oslib_test_002_001_execute+0x3d6>
  20ce00:	f7ff fdf6 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20ce04:	e020      	b.n	20ce48 <oslib_test_002_001_execute+0x418>
  20ce06:	f7ff fdf3 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
  20ce0a:	4b11      	ldr	r3, [pc, #68]	@ (20ce50 <oslib_test_002_001_execute+0x420>)
  20ce0c:	681a      	ldr	r2, [r3, #0]
  20ce0e:	4b10      	ldr	r3, [pc, #64]	@ (20ce50 <oslib_test_002_001_execute+0x420>)
  20ce10:	689b      	ldr	r3, [r3, #8]
  20ce12:	429a      	cmp	r2, r3
  20ce14:	bf0c      	ite	eq
  20ce16:	2301      	moveq	r3, #1
  20ce18:	2300      	movne	r3, #0
  20ce1a:	b2db      	uxtb	r3, r3
  20ce1c:	4913      	ldr	r1, [pc, #76]	@ (20ce6c <oslib_test_002_001_execute+0x43c>)
  20ce1e:	4618      	mov	r0, r3
  20ce20:	f7fa fc1e 	bl	207660 <__test_assert>
  20ce24:	4603      	mov	r3, r0
  20ce26:	2b00      	cmp	r3, #0
  20ce28:	d10e      	bne.n	20ce48 <oslib_test_002_001_execute+0x418>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  20ce2a:	4b09      	ldr	r3, [pc, #36]	@ (20ce50 <oslib_test_002_001_execute+0x420>)
  20ce2c:	681a      	ldr	r2, [r3, #0]
  20ce2e:	4b08      	ldr	r3, [pc, #32]	@ (20ce50 <oslib_test_002_001_execute+0x420>)
  20ce30:	68db      	ldr	r3, [r3, #12]
  20ce32:	429a      	cmp	r2, r3
  20ce34:	bf0c      	ite	eq
  20ce36:	2301      	moveq	r3, #1
  20ce38:	2300      	movne	r3, #0
  20ce3a:	b2db      	uxtb	r3, r3
  20ce3c:	490c      	ldr	r1, [pc, #48]	@ (20ce70 <oslib_test_002_001_execute+0x440>)
  20ce3e:	4618      	mov	r0, r3
  20ce40:	f7fa fc0e 	bl	207660 <__test_assert>
  20ce44:	4603      	mov	r3, r0
  20ce46:	2b00      	cmp	r3, #0
  }
  test_end_step(8);
}
  20ce48:	b005      	add	sp, #20
  20ce4a:	f85d fb04 	ldr.w	pc, [sp], #4
  20ce4e:	bf00      	nop
  20ce50:	20020030 	.word	0x20020030
  20ce54:	080117d0 	.word	0x080117d0
  20ce58:	08011f2c 	.word	0x08011f2c
  20ce5c:	080118a0 	.word	0x080118a0
  20ce60:	20000bb4 	.word	0x20000bb4
  20ce64:	08011e88 	.word	0x08011e88
  20ce68:	08011e94 	.word	0x08011e94
  20ce6c:	08011ea0 	.word	0x08011ea0
  20ce70:	08011ec4 	.word	0x08011ec4
	...

0020ce80 <oslib_test_002_002_setup>:
 * - [2.2.7] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void oslib_test_002_002_setup(void) {
  20ce80:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
  20ce82:	2204      	movs	r2, #4
  20ce84:	4902      	ldr	r1, [pc, #8]	@ (20ce90 <oslib_test_002_002_setup+0x10>)
  20ce86:	4803      	ldr	r0, [pc, #12]	@ (20ce94 <oslib_test_002_002_setup+0x14>)
  20ce88:	f7f8 f84a 	bl	204f20 <chMBObjectInit>
}
  20ce8c:	bf00      	nop
  20ce8e:	bd08      	pop	{r3, pc}
  20ce90:	200019a4 	.word	0x200019a4
  20ce94:	20020030 	.word	0x20020030
	...

0020cea0 <oslib_test_002_002_teardown>:

static void oslib_test_002_002_teardown(void) {
  20cea0:	b508      	push	{r3, lr}
  chMBReset(&mb1);
  20cea2:	4802      	ldr	r0, [pc, #8]	@ (20ceac <oslib_test_002_002_teardown+0xc>)
  20cea4:	f7f8 f864 	bl	204f70 <chMBReset>
}
  20cea8:	bf00      	nop
  20ceaa:	bd08      	pop	{r3, pc}
  20ceac:	20020030 	.word	0x20020030

0020ceb0 <oslib_test_002_002_execute>:

static void oslib_test_002_002_execute(void) {
  20ceb0:	b500      	push	{lr}
  20ceb2:	b085      	sub	sp, #20
  msg_t msg1, msg2;
  unsigned i;

  /* [2.2.1] Testing the mailbox size.*/
  test_set_step(1);
  20ceb4:	4b86      	ldr	r3, [pc, #536]	@ (20d0d0 <oslib_test_002_002_execute+0x220>)
  20ceb6:	2201      	movs	r2, #1
  20ceb8:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  20ceba:	f7ff fd91 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cebe:	4885      	ldr	r0, [pc, #532]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20cec0:	f7ff fd76 	bl	20c9b0 <chMBGetFreeCountI.lto_priv.1>
  20cec4:	4603      	mov	r3, r0
  20cec6:	2b04      	cmp	r3, #4
  20cec8:	bf0c      	ite	eq
  20ceca:	2301      	moveq	r3, #1
  20cecc:	2300      	movne	r3, #0
  20cece:	b2db      	uxtb	r3, r3
  20ced0:	4981      	ldr	r1, [pc, #516]	@ (20d0d8 <oslib_test_002_002_execute+0x228>)
  20ced2:	4618      	mov	r0, r3
  20ced4:	f7fa fbc4 	bl	207660 <__test_assert>
  20ced8:	4603      	mov	r3, r0
  20ceda:	2b00      	cmp	r3, #0
  20cedc:	d002      	beq.n	20cee4 <oslib_test_002_002_execute+0x34>
  20cede:	f7ff fd87 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20cee2:	e1b3      	b.n	20d24c <oslib_test_002_002_execute+0x39c>
  20cee4:	f7ff fd84 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  }
  test_end_step(1);

  /* [2.2.2] Resetting the mailbox, conditions are checked, no errors
     expected. The mailbox is then returned in active state.*/
  test_set_step(2);
  20cee8:	4b79      	ldr	r3, [pc, #484]	@ (20d0d0 <oslib_test_002_002_execute+0x220>)
  20ceea:	2202      	movs	r2, #2
  20ceec:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
  20ceee:	f7ff fd27 	bl	20c940 <chSysLock.lto_priv.28>
    chMBResetI(&mb1);
  20cef2:	4878      	ldr	r0, [pc, #480]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20cef4:	f7f8 f84c 	bl	204f90 <chMBResetI>
    chSysUnlock();
  20cef8:	f7ff fd32 	bl	20c960 <chSysUnlock.lto_priv.28>
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  20cefc:	f7ff fd70 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cf00:	4874      	ldr	r0, [pc, #464]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20cf02:	f7ff fd55 	bl	20c9b0 <chMBGetFreeCountI.lto_priv.1>
  20cf06:	4603      	mov	r3, r0
  20cf08:	2b04      	cmp	r3, #4
  20cf0a:	bf0c      	ite	eq
  20cf0c:	2301      	moveq	r3, #1
  20cf0e:	2300      	movne	r3, #0
  20cf10:	b2db      	uxtb	r3, r3
  20cf12:	4972      	ldr	r1, [pc, #456]	@ (20d0dc <oslib_test_002_002_execute+0x22c>)
  20cf14:	4618      	mov	r0, r3
  20cf16:	f7fa fba3 	bl	207660 <__test_assert>
  20cf1a:	4603      	mov	r3, r0
  20cf1c:	2b00      	cmp	r3, #0
  20cf1e:	d002      	beq.n	20cf26 <oslib_test_002_002_execute+0x76>
  20cf20:	f7ff fd66 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20cf24:	e192      	b.n	20d24c <oslib_test_002_002_execute+0x39c>
  20cf26:	f7ff fd63 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
  20cf2a:	f7ff fd59 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cf2e:	4869      	ldr	r0, [pc, #420]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20cf30:	f7ff fd36 	bl	20c9a0 <chMBGetUsedCountI.lto_priv.1>
  20cf34:	4603      	mov	r3, r0
  20cf36:	2b00      	cmp	r3, #0
  20cf38:	bf0c      	ite	eq
  20cf3a:	2301      	moveq	r3, #1
  20cf3c:	2300      	movne	r3, #0
  20cf3e:	b2db      	uxtb	r3, r3
  20cf40:	4967      	ldr	r1, [pc, #412]	@ (20d0e0 <oslib_test_002_002_execute+0x230>)
  20cf42:	4618      	mov	r0, r3
  20cf44:	f7fa fb8c 	bl	207660 <__test_assert>
  20cf48:	4603      	mov	r3, r0
  20cf4a:	2b00      	cmp	r3, #0
  20cf4c:	d002      	beq.n	20cf54 <oslib_test_002_002_execute+0xa4>
  20cf4e:	f7ff fd4f 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20cf52:	e17b      	b.n	20d24c <oslib_test_002_002_execute+0x39c>
  20cf54:	f7ff fd4c 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
  20cf58:	f7ff fd42 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cf5c:	4b5d      	ldr	r3, [pc, #372]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20cf5e:	681a      	ldr	r2, [r3, #0]
  20cf60:	4b5c      	ldr	r3, [pc, #368]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20cf62:	689b      	ldr	r3, [r3, #8]
  20cf64:	429a      	cmp	r2, r3
  20cf66:	bf0c      	ite	eq
  20cf68:	2301      	moveq	r3, #1
  20cf6a:	2300      	movne	r3, #0
  20cf6c:	b2db      	uxtb	r3, r3
  20cf6e:	495d      	ldr	r1, [pc, #372]	@ (20d0e4 <oslib_test_002_002_execute+0x234>)
  20cf70:	4618      	mov	r0, r3
  20cf72:	f7fa fb75 	bl	207660 <__test_assert>
  20cf76:	4603      	mov	r3, r0
  20cf78:	2b00      	cmp	r3, #0
  20cf7a:	d002      	beq.n	20cf82 <oslib_test_002_002_execute+0xd2>
  20cf7c:	f7ff fd38 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20cf80:	e164      	b.n	20d24c <oslib_test_002_002_execute+0x39c>
  20cf82:	f7ff fd35 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  20cf86:	f7ff fd2b 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20cf8a:	4b52      	ldr	r3, [pc, #328]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20cf8c:	681a      	ldr	r2, [r3, #0]
  20cf8e:	4b51      	ldr	r3, [pc, #324]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20cf90:	68db      	ldr	r3, [r3, #12]
  20cf92:	429a      	cmp	r2, r3
  20cf94:	bf0c      	ite	eq
  20cf96:	2301      	moveq	r3, #1
  20cf98:	2300      	movne	r3, #0
  20cf9a:	b2db      	uxtb	r3, r3
  20cf9c:	4952      	ldr	r1, [pc, #328]	@ (20d0e8 <oslib_test_002_002_execute+0x238>)
  20cf9e:	4618      	mov	r0, r3
  20cfa0:	f7fa fb5e 	bl	207660 <__test_assert>
  20cfa4:	4603      	mov	r3, r0
  20cfa6:	2b00      	cmp	r3, #0
  20cfa8:	d002      	beq.n	20cfb0 <oslib_test_002_002_execute+0x100>
  20cfaa:	f7ff fd21 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20cfae:	e14d      	b.n	20d24c <oslib_test_002_002_execute+0x39c>
  20cfb0:	f7ff fd1e 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    chMBResumeX(&mb1);
  20cfb4:	4847      	ldr	r0, [pc, #284]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20cfb6:	f7ff fd0b 	bl	20c9d0 <chMBResumeX>
  }
  test_end_step(2);

  /* [2.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
  20cfba:	4b45      	ldr	r3, [pc, #276]	@ (20d0d0 <oslib_test_002_002_execute+0x220>)
  20cfbc:	2203      	movs	r2, #3
  20cfbe:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
  20cfc0:	2300      	movs	r3, #0
  20cfc2:	9303      	str	r3, [sp, #12]
  20cfc4:	e01b      	b.n	20cffe <oslib_test_002_002_execute+0x14e>
      chSysLock();
  20cfc6:	f7ff fcbb 	bl	20c940 <chSysLock.lto_priv.28>
      msg1 = chMBPostI(&mb1, 'B' + i);
  20cfca:	9b03      	ldr	r3, [sp, #12]
  20cfcc:	3342      	adds	r3, #66	@ 0x42
  20cfce:	4619      	mov	r1, r3
  20cfd0:	4840      	ldr	r0, [pc, #256]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20cfd2:	f7f8 f865 	bl	2050a0 <chMBPostI>
  20cfd6:	9002      	str	r0, [sp, #8]
      chSysUnlock();
  20cfd8:	f7ff fcc2 	bl	20c960 <chSysUnlock.lto_priv.28>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20cfdc:	9b02      	ldr	r3, [sp, #8]
  20cfde:	2b00      	cmp	r3, #0
  20cfe0:	bf0c      	ite	eq
  20cfe2:	2301      	moveq	r3, #1
  20cfe4:	2300      	movne	r3, #0
  20cfe6:	b2db      	uxtb	r3, r3
  20cfe8:	4940      	ldr	r1, [pc, #256]	@ (20d0ec <oslib_test_002_002_execute+0x23c>)
  20cfea:	4618      	mov	r0, r3
  20cfec:	f7fa fb38 	bl	207660 <__test_assert>
  20cff0:	4603      	mov	r3, r0
  20cff2:	2b00      	cmp	r3, #0
  20cff4:	f040 812a 	bne.w	20d24c <oslib_test_002_002_execute+0x39c>
    for (i = 0; i < MB_SIZE - 1; i++) {
  20cff8:	9b03      	ldr	r3, [sp, #12]
  20cffa:	3301      	adds	r3, #1
  20cffc:	9303      	str	r3, [sp, #12]
  20cffe:	9b03      	ldr	r3, [sp, #12]
  20d000:	2b02      	cmp	r3, #2
  20d002:	d9e0      	bls.n	20cfc6 <oslib_test_002_002_execute+0x116>
    }
    chSysLock();
  20d004:	f7ff fc9c 	bl	20c940 <chSysLock.lto_priv.28>
    msg1 = chMBPostAheadI(&mb1, 'A');
  20d008:	2141      	movs	r1, #65	@ 0x41
  20d00a:	4832      	ldr	r0, [pc, #200]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20d00c:	f7f8 f8e0 	bl	2051d0 <chMBPostAheadI>
  20d010:	9002      	str	r0, [sp, #8]
    chSysUnlock();
  20d012:	f7ff fca5 	bl	20c960 <chSysUnlock.lto_priv.28>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20d016:	9b02      	ldr	r3, [sp, #8]
  20d018:	2b00      	cmp	r3, #0
  20d01a:	bf0c      	ite	eq
  20d01c:	2301      	moveq	r3, #1
  20d01e:	2300      	movne	r3, #0
  20d020:	b2db      	uxtb	r3, r3
  20d022:	4932      	ldr	r1, [pc, #200]	@ (20d0ec <oslib_test_002_002_execute+0x23c>)
  20d024:	4618      	mov	r0, r3
  20d026:	f7fa fb1b 	bl	207660 <__test_assert>
  20d02a:	4603      	mov	r3, r0
  20d02c:	2b00      	cmp	r3, #0
  20d02e:	f040 810d 	bne.w	20d24c <oslib_test_002_002_execute+0x39c>
  }
  test_end_step(3);

  /* [2.2.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
  20d032:	4b27      	ldr	r3, [pc, #156]	@ (20d0d0 <oslib_test_002_002_execute+0x220>)
  20d034:	2204      	movs	r2, #4
  20d036:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
  20d038:	f7ff fcd2 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20d03c:	4825      	ldr	r0, [pc, #148]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20d03e:	f7ff fcb7 	bl	20c9b0 <chMBGetFreeCountI.lto_priv.1>
  20d042:	4603      	mov	r3, r0
  20d044:	2b00      	cmp	r3, #0
  20d046:	bf0c      	ite	eq
  20d048:	2301      	moveq	r3, #1
  20d04a:	2300      	movne	r3, #0
  20d04c:	b2db      	uxtb	r3, r3
  20d04e:	4928      	ldr	r1, [pc, #160]	@ (20d0f0 <oslib_test_002_002_execute+0x240>)
  20d050:	4618      	mov	r0, r3
  20d052:	f7fa fb05 	bl	207660 <__test_assert>
  20d056:	4603      	mov	r3, r0
  20d058:	2b00      	cmp	r3, #0
  20d05a:	d002      	beq.n	20d062 <oslib_test_002_002_execute+0x1b2>
  20d05c:	f7ff fcc8 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20d060:	e0f4      	b.n	20d24c <oslib_test_002_002_execute+0x39c>
  20d062:	f7ff fcc5 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
  20d066:	f7ff fcbb 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20d06a:	481a      	ldr	r0, [pc, #104]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20d06c:	f7ff fc98 	bl	20c9a0 <chMBGetUsedCountI.lto_priv.1>
  20d070:	4603      	mov	r3, r0
  20d072:	2b04      	cmp	r3, #4
  20d074:	bf0c      	ite	eq
  20d076:	2301      	moveq	r3, #1
  20d078:	2300      	movne	r3, #0
  20d07a:	b2db      	uxtb	r3, r3
  20d07c:	491d      	ldr	r1, [pc, #116]	@ (20d0f4 <oslib_test_002_002_execute+0x244>)
  20d07e:	4618      	mov	r0, r3
  20d080:	f7fa faee 	bl	207660 <__test_assert>
  20d084:	4603      	mov	r3, r0
  20d086:	2b00      	cmp	r3, #0
  20d088:	d002      	beq.n	20d090 <oslib_test_002_002_execute+0x1e0>
  20d08a:	f7ff fcb1 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20d08e:	e0dd      	b.n	20d24c <oslib_test_002_002_execute+0x39c>
  20d090:	f7ff fcae 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
  20d094:	f7ff fca4 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20d098:	4b0e      	ldr	r3, [pc, #56]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20d09a:	68da      	ldr	r2, [r3, #12]
  20d09c:	4b0d      	ldr	r3, [pc, #52]	@ (20d0d4 <oslib_test_002_002_execute+0x224>)
  20d09e:	689b      	ldr	r3, [r3, #8]
  20d0a0:	429a      	cmp	r2, r3
  20d0a2:	bf0c      	ite	eq
  20d0a4:	2301      	moveq	r3, #1
  20d0a6:	2300      	movne	r3, #0
  20d0a8:	b2db      	uxtb	r3, r3
  20d0aa:	4913      	ldr	r1, [pc, #76]	@ (20d0f8 <oslib_test_002_002_execute+0x248>)
  20d0ac:	4618      	mov	r0, r3
  20d0ae:	f7fa fad7 	bl	207660 <__test_assert>
  20d0b2:	4603      	mov	r3, r0
  20d0b4:	2b00      	cmp	r3, #0
  20d0b6:	d002      	beq.n	20d0be <oslib_test_002_002_execute+0x20e>
  20d0b8:	f7ff fc9a 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20d0bc:	e0c6      	b.n	20d24c <oslib_test_002_002_execute+0x39c>
  20d0be:	f7ff fc97 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  }
  test_end_step(4);

  /* [2.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
  20d0c2:	4b03      	ldr	r3, [pc, #12]	@ (20d0d0 <oslib_test_002_002_execute+0x220>)
  20d0c4:	2205      	movs	r2, #5
  20d0c6:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
  20d0c8:	2300      	movs	r3, #0
  20d0ca:	9303      	str	r3, [sp, #12]
  20d0cc:	e036      	b.n	20d13c <oslib_test_002_002_execute+0x28c>
  20d0ce:	bf00      	nop
  20d0d0:	20000bb4 	.word	0x20000bb4
  20d0d4:	20020030 	.word	0x20020030
  20d0d8:	08011e7c 	.word	0x08011e7c
  20d0dc:	08011e88 	.word	0x08011e88
  20d0e0:	08011e94 	.word	0x08011e94
  20d0e4:	08011ea0 	.word	0x08011ea0
  20d0e8:	08011ec4 	.word	0x08011ec4
  20d0ec:	080117d0 	.word	0x080117d0
  20d0f0:	08011efc 	.word	0x08011efc
  20d0f4:	08011f08 	.word	0x08011f08
  20d0f8:	08011f14 	.word	0x08011f14
      chSysLock();
  20d0fc:	f7ff fc20 	bl	20c940 <chSysLock.lto_priv.28>
      msg1 = chMBFetchI(&mb1, &msg2);
  20d100:	ab01      	add	r3, sp, #4
  20d102:	4619      	mov	r1, r3
  20d104:	4853      	ldr	r0, [pc, #332]	@ (20d254 <oslib_test_002_002_execute+0x3a4>)
  20d106:	f7f8 f8fb 	bl	205300 <chMBFetchI>
  20d10a:	9002      	str	r0, [sp, #8]
      chSysUnlock();
  20d10c:	f7ff fc28 	bl	20c960 <chSysUnlock.lto_priv.28>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20d110:	9b02      	ldr	r3, [sp, #8]
  20d112:	2b00      	cmp	r3, #0
  20d114:	bf0c      	ite	eq
  20d116:	2301      	moveq	r3, #1
  20d118:	2300      	movne	r3, #0
  20d11a:	b2db      	uxtb	r3, r3
  20d11c:	494e      	ldr	r1, [pc, #312]	@ (20d258 <oslib_test_002_002_execute+0x3a8>)
  20d11e:	4618      	mov	r0, r3
  20d120:	f7fa fa9e 	bl	207660 <__test_assert>
  20d124:	4603      	mov	r3, r0
  20d126:	2b00      	cmp	r3, #0
  20d128:	f040 8090 	bne.w	20d24c <oslib_test_002_002_execute+0x39c>
      test_emit_token(msg2);
  20d12c:	9b01      	ldr	r3, [sp, #4]
  20d12e:	b2db      	uxtb	r3, r3
  20d130:	4618      	mov	r0, r3
  20d132:	f7fa faf5 	bl	207720 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
  20d136:	9b03      	ldr	r3, [sp, #12]
  20d138:	3301      	adds	r3, #1
  20d13a:	9303      	str	r3, [sp, #12]
  20d13c:	9b03      	ldr	r3, [sp, #12]
  20d13e:	2b03      	cmp	r3, #3
  20d140:	d9dc      	bls.n	20d0fc <oslib_test_002_002_execute+0x24c>
    }
    test_assert_sequence("ABCD", "wrong get sequence");
  20d142:	4946      	ldr	r1, [pc, #280]	@ (20d25c <oslib_test_002_002_execute+0x3ac>)
  20d144:	4846      	ldr	r0, [pc, #280]	@ (20d260 <oslib_test_002_002_execute+0x3b0>)
  20d146:	f7fa faa3 	bl	207690 <__test_assert_sequence>
  20d14a:	4603      	mov	r3, r0
  20d14c:	2b00      	cmp	r3, #0
  20d14e:	d17d      	bne.n	20d24c <oslib_test_002_002_execute+0x39c>
  }
  test_end_step(5);

  /* [2.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
  20d150:	4b44      	ldr	r3, [pc, #272]	@ (20d264 <oslib_test_002_002_execute+0x3b4>)
  20d152:	2206      	movs	r2, #6
  20d154:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  20d156:	9b03      	ldr	r3, [sp, #12]
  20d158:	3342      	adds	r3, #66	@ 0x42
  20d15a:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20d15e:	4619      	mov	r1, r3
  20d160:	483c      	ldr	r0, [pc, #240]	@ (20d254 <oslib_test_002_002_execute+0x3a4>)
  20d162:	f7f7 ff3d 	bl	204fe0 <chMBPostTimeout>
  20d166:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20d168:	9b02      	ldr	r3, [sp, #8]
  20d16a:	2b00      	cmp	r3, #0
  20d16c:	bf0c      	ite	eq
  20d16e:	2301      	moveq	r3, #1
  20d170:	2300      	movne	r3, #0
  20d172:	b2db      	uxtb	r3, r3
  20d174:	4938      	ldr	r1, [pc, #224]	@ (20d258 <oslib_test_002_002_execute+0x3a8>)
  20d176:	4618      	mov	r0, r3
  20d178:	f7fa fa72 	bl	207660 <__test_assert>
  20d17c:	4603      	mov	r3, r0
  20d17e:	2b00      	cmp	r3, #0
  20d180:	d164      	bne.n	20d24c <oslib_test_002_002_execute+0x39c>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
  20d182:	ab01      	add	r3, sp, #4
  20d184:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20d188:	4619      	mov	r1, r3
  20d18a:	4832      	ldr	r0, [pc, #200]	@ (20d254 <oslib_test_002_002_execute+0x3a4>)
  20d18c:	f7f8 f858 	bl	205240 <chMBFetchTimeout>
  20d190:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20d192:	9b02      	ldr	r3, [sp, #8]
  20d194:	2b00      	cmp	r3, #0
  20d196:	bf0c      	ite	eq
  20d198:	2301      	moveq	r3, #1
  20d19a:	2300      	movne	r3, #0
  20d19c:	b2db      	uxtb	r3, r3
  20d19e:	492e      	ldr	r1, [pc, #184]	@ (20d258 <oslib_test_002_002_execute+0x3a8>)
  20d1a0:	4618      	mov	r0, r3
  20d1a2:	f7fa fa5d 	bl	207660 <__test_assert>
  20d1a6:	4603      	mov	r3, r0
  20d1a8:	2b00      	cmp	r3, #0
  20d1aa:	d14f      	bne.n	20d24c <oslib_test_002_002_execute+0x39c>
  }
  test_end_step(6);

  /* [2.2.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
  20d1ac:	4b2d      	ldr	r3, [pc, #180]	@ (20d264 <oslib_test_002_002_execute+0x3b4>)
  20d1ae:	2207      	movs	r2, #7
  20d1b0:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  20d1b2:	f7ff fc15 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20d1b6:	4827      	ldr	r0, [pc, #156]	@ (20d254 <oslib_test_002_002_execute+0x3a4>)
  20d1b8:	f7ff fbfa 	bl	20c9b0 <chMBGetFreeCountI.lto_priv.1>
  20d1bc:	4603      	mov	r3, r0
  20d1be:	2b04      	cmp	r3, #4
  20d1c0:	bf0c      	ite	eq
  20d1c2:	2301      	moveq	r3, #1
  20d1c4:	2300      	movne	r3, #0
  20d1c6:	b2db      	uxtb	r3, r3
  20d1c8:	4927      	ldr	r1, [pc, #156]	@ (20d268 <oslib_test_002_002_execute+0x3b8>)
  20d1ca:	4618      	mov	r0, r3
  20d1cc:	f7fa fa48 	bl	207660 <__test_assert>
  20d1d0:	4603      	mov	r3, r0
  20d1d2:	2b00      	cmp	r3, #0
  20d1d4:	d002      	beq.n	20d1dc <oslib_test_002_002_execute+0x32c>
  20d1d6:	f7ff fc0b 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20d1da:	e037      	b.n	20d24c <oslib_test_002_002_execute+0x39c>
  20d1dc:	f7ff fc08 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
  20d1e0:	f7ff fbfe 	bl	20c9e0 <osalSysLock.lto_priv.5>
  20d1e4:	481b      	ldr	r0, [pc, #108]	@ (20d254 <oslib_test_002_002_execute+0x3a4>)
  20d1e6:	f7ff fbdb 	bl	20c9a0 <chMBGetUsedCountI.lto_priv.1>
  20d1ea:	4603      	mov	r3, r0
  20d1ec:	2b00      	cmp	r3, #0
  20d1ee:	bf0c      	ite	eq
  20d1f0:	2301      	moveq	r3, #1
  20d1f2:	2300      	movne	r3, #0
  20d1f4:	b2db      	uxtb	r3, r3
  20d1f6:	491d      	ldr	r1, [pc, #116]	@ (20d26c <oslib_test_002_002_execute+0x3bc>)
  20d1f8:	4618      	mov	r0, r3
  20d1fa:	f7fa fa31 	bl	207660 <__test_assert>
  20d1fe:	4603      	mov	r3, r0
  20d200:	2b00      	cmp	r3, #0
  20d202:	d002      	beq.n	20d20a <oslib_test_002_002_execute+0x35a>
  20d204:	f7ff fbf4 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
  20d208:	e020      	b.n	20d24c <oslib_test_002_002_execute+0x39c>
  20d20a:	f7ff fbf1 	bl	20c9f0 <osalSysUnlock.lto_priv.5>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
  20d20e:	4b11      	ldr	r3, [pc, #68]	@ (20d254 <oslib_test_002_002_execute+0x3a4>)
  20d210:	681a      	ldr	r2, [r3, #0]
  20d212:	4b10      	ldr	r3, [pc, #64]	@ (20d254 <oslib_test_002_002_execute+0x3a4>)
  20d214:	689b      	ldr	r3, [r3, #8]
  20d216:	429a      	cmp	r2, r3
  20d218:	bf0c      	ite	eq
  20d21a:	2301      	moveq	r3, #1
  20d21c:	2300      	movne	r3, #0
  20d21e:	b2db      	uxtb	r3, r3
  20d220:	4913      	ldr	r1, [pc, #76]	@ (20d270 <oslib_test_002_002_execute+0x3c0>)
  20d222:	4618      	mov	r0, r3
  20d224:	f7fa fa1c 	bl	207660 <__test_assert>
  20d228:	4603      	mov	r3, r0
  20d22a:	2b00      	cmp	r3, #0
  20d22c:	d10e      	bne.n	20d24c <oslib_test_002_002_execute+0x39c>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  20d22e:	4b09      	ldr	r3, [pc, #36]	@ (20d254 <oslib_test_002_002_execute+0x3a4>)
  20d230:	681a      	ldr	r2, [r3, #0]
  20d232:	4b08      	ldr	r3, [pc, #32]	@ (20d254 <oslib_test_002_002_execute+0x3a4>)
  20d234:	68db      	ldr	r3, [r3, #12]
  20d236:	429a      	cmp	r2, r3
  20d238:	bf0c      	ite	eq
  20d23a:	2301      	moveq	r3, #1
  20d23c:	2300      	movne	r3, #0
  20d23e:	b2db      	uxtb	r3, r3
  20d240:	490c      	ldr	r1, [pc, #48]	@ (20d274 <oslib_test_002_002_execute+0x3c4>)
  20d242:	4618      	mov	r0, r3
  20d244:	f7fa fa0c 	bl	207660 <__test_assert>
  20d248:	4603      	mov	r3, r0
  20d24a:	2b00      	cmp	r3, #0
  }
  test_end_step(7);
}
  20d24c:	b005      	add	sp, #20
  20d24e:	f85d fb04 	ldr.w	pc, [sp], #4
  20d252:	bf00      	nop
  20d254:	20020030 	.word	0x20020030
  20d258:	080117d0 	.word	0x080117d0
  20d25c:	08011f2c 	.word	0x08011f2c
  20d260:	080118a0 	.word	0x080118a0
  20d264:	20000bb4 	.word	0x20000bb4
  20d268:	08011e88 	.word	0x08011e88
  20d26c:	08011e94 	.word	0x08011e94
  20d270:	08011ea0 	.word	0x08011ea0
  20d274:	08011ec4 	.word	0x08011ec4
	...

0020d280 <oslib_test_002_003_setup>:
 *   active state.
 * - [2.3.4] Testing chMBFetchTimeout() and chMBFetchI() timeout.
 * .
 */

static void oslib_test_002_003_setup(void) {
  20d280:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
  20d282:	2204      	movs	r2, #4
  20d284:	4902      	ldr	r1, [pc, #8]	@ (20d290 <oslib_test_002_003_setup+0x10>)
  20d286:	4803      	ldr	r0, [pc, #12]	@ (20d294 <oslib_test_002_003_setup+0x14>)
  20d288:	f7f7 fe4a 	bl	204f20 <chMBObjectInit>
}
  20d28c:	bf00      	nop
  20d28e:	bd08      	pop	{r3, pc}
  20d290:	200019a4 	.word	0x200019a4
  20d294:	20020030 	.word	0x20020030
	...

0020d2a0 <oslib_test_002_003_teardown>:

static void oslib_test_002_003_teardown(void) {
  20d2a0:	b508      	push	{r3, lr}
  chMBReset(&mb1);
  20d2a2:	4802      	ldr	r0, [pc, #8]	@ (20d2ac <oslib_test_002_003_teardown+0xc>)
  20d2a4:	f7f7 fe64 	bl	204f70 <chMBReset>
}
  20d2a8:	bf00      	nop
  20d2aa:	bd08      	pop	{r3, pc}
  20d2ac:	20020030 	.word	0x20020030

0020d2b0 <oslib_test_002_003_execute>:

static void oslib_test_002_003_execute(void) {
  20d2b0:	b500      	push	{lr}
  20d2b2:	b085      	sub	sp, #20
  msg_t msg1, msg2;
  unsigned i;

  /* [2.3.1] Filling the mailbox.*/
  test_set_step(1);
  20d2b4:	4b5b      	ldr	r3, [pc, #364]	@ (20d424 <oslib_test_002_003_execute+0x174>)
  20d2b6:	2201      	movs	r2, #1
  20d2b8:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
  20d2ba:	2300      	movs	r3, #0
  20d2bc:	9303      	str	r3, [sp, #12]
  20d2be:	e019      	b.n	20d2f4 <oslib_test_002_003_execute+0x44>
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  20d2c0:	9b03      	ldr	r3, [sp, #12]
  20d2c2:	3342      	adds	r3, #66	@ 0x42
  20d2c4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20d2c8:	4619      	mov	r1, r3
  20d2ca:	4857      	ldr	r0, [pc, #348]	@ (20d428 <oslib_test_002_003_execute+0x178>)
  20d2cc:	f7f7 fe88 	bl	204fe0 <chMBPostTimeout>
  20d2d0:	9002      	str	r0, [sp, #8]
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20d2d2:	9b02      	ldr	r3, [sp, #8]
  20d2d4:	2b00      	cmp	r3, #0
  20d2d6:	bf0c      	ite	eq
  20d2d8:	2301      	moveq	r3, #1
  20d2da:	2300      	movne	r3, #0
  20d2dc:	b2db      	uxtb	r3, r3
  20d2de:	4953      	ldr	r1, [pc, #332]	@ (20d42c <oslib_test_002_003_execute+0x17c>)
  20d2e0:	4618      	mov	r0, r3
  20d2e2:	f7fa f9bd 	bl	207660 <__test_assert>
  20d2e6:	4603      	mov	r3, r0
  20d2e8:	2b00      	cmp	r3, #0
  20d2ea:	f040 8097 	bne.w	20d41c <oslib_test_002_003_execute+0x16c>
    for (i = 0; i < MB_SIZE; i++) {
  20d2ee:	9b03      	ldr	r3, [sp, #12]
  20d2f0:	3301      	adds	r3, #1
  20d2f2:	9303      	str	r3, [sp, #12]
  20d2f4:	9b03      	ldr	r3, [sp, #12]
  20d2f6:	2b03      	cmp	r3, #3
  20d2f8:	d9e2      	bls.n	20d2c0 <oslib_test_002_003_execute+0x10>
  }
  test_end_step(1);

  /* [2.3.2] Testing chMBPostTimeout(), chMBPostI(),
     chMBPostAheadTimeout() and chMBPostAheadI() timeout.*/
  test_set_step(2);
  20d2fa:	4b4a      	ldr	r3, [pc, #296]	@ (20d424 <oslib_test_002_003_execute+0x174>)
  20d2fc:	2202      	movs	r2, #2
  20d2fe:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
  20d300:	2201      	movs	r2, #1
  20d302:	2158      	movs	r1, #88	@ 0x58
  20d304:	4848      	ldr	r0, [pc, #288]	@ (20d428 <oslib_test_002_003_execute+0x178>)
  20d306:	f7f7 fe6b 	bl	204fe0 <chMBPostTimeout>
  20d30a:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  20d30c:	9b02      	ldr	r3, [sp, #8]
  20d30e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  20d312:	bf0c      	ite	eq
  20d314:	2301      	moveq	r3, #1
  20d316:	2300      	movne	r3, #0
  20d318:	b2db      	uxtb	r3, r3
  20d31a:	4944      	ldr	r1, [pc, #272]	@ (20d42c <oslib_test_002_003_execute+0x17c>)
  20d31c:	4618      	mov	r0, r3
  20d31e:	f7fa f99f 	bl	207660 <__test_assert>
  20d322:	4603      	mov	r3, r0
  20d324:	2b00      	cmp	r3, #0
  20d326:	d179      	bne.n	20d41c <oslib_test_002_003_execute+0x16c>
    chSysLock();
  20d328:	f7ff fb0a 	bl	20c940 <chSysLock.lto_priv.28>
    msg1 = chMBPostI(&mb1, 'X');
  20d32c:	2158      	movs	r1, #88	@ 0x58
  20d32e:	483e      	ldr	r0, [pc, #248]	@ (20d428 <oslib_test_002_003_execute+0x178>)
  20d330:	f7f7 feb6 	bl	2050a0 <chMBPostI>
  20d334:	9002      	str	r0, [sp, #8]
    chSysUnlock();
  20d336:	f7ff fb13 	bl	20c960 <chSysUnlock.lto_priv.28>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  20d33a:	9b02      	ldr	r3, [sp, #8]
  20d33c:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  20d340:	bf0c      	ite	eq
  20d342:	2301      	moveq	r3, #1
  20d344:	2300      	movne	r3, #0
  20d346:	b2db      	uxtb	r3, r3
  20d348:	4938      	ldr	r1, [pc, #224]	@ (20d42c <oslib_test_002_003_execute+0x17c>)
  20d34a:	4618      	mov	r0, r3
  20d34c:	f7fa f988 	bl	207660 <__test_assert>
  20d350:	4603      	mov	r3, r0
  20d352:	2b00      	cmp	r3, #0
  20d354:	d162      	bne.n	20d41c <oslib_test_002_003_execute+0x16c>
    msg1 = chMBPostAheadTimeout(&mb1, 'X', 1);
  20d356:	2201      	movs	r2, #1
  20d358:	2158      	movs	r1, #88	@ 0x58
  20d35a:	4833      	ldr	r0, [pc, #204]	@ (20d428 <oslib_test_002_003_execute+0x178>)
  20d35c:	f7f7 fed8 	bl	205110 <chMBPostAheadTimeout>
  20d360:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  20d362:	9b02      	ldr	r3, [sp, #8]
  20d364:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  20d368:	bf0c      	ite	eq
  20d36a:	2301      	moveq	r3, #1
  20d36c:	2300      	movne	r3, #0
  20d36e:	b2db      	uxtb	r3, r3
  20d370:	492e      	ldr	r1, [pc, #184]	@ (20d42c <oslib_test_002_003_execute+0x17c>)
  20d372:	4618      	mov	r0, r3
  20d374:	f7fa f974 	bl	207660 <__test_assert>
  20d378:	4603      	mov	r3, r0
  20d37a:	2b00      	cmp	r3, #0
  20d37c:	d14e      	bne.n	20d41c <oslib_test_002_003_execute+0x16c>
    chSysLock();
  20d37e:	f7ff fadf 	bl	20c940 <chSysLock.lto_priv.28>
    msg1 = chMBPostAheadI(&mb1, 'X');
  20d382:	2158      	movs	r1, #88	@ 0x58
  20d384:	4828      	ldr	r0, [pc, #160]	@ (20d428 <oslib_test_002_003_execute+0x178>)
  20d386:	f7f7 ff23 	bl	2051d0 <chMBPostAheadI>
  20d38a:	9002      	str	r0, [sp, #8]
    chSysUnlock();
  20d38c:	f7ff fae8 	bl	20c960 <chSysUnlock.lto_priv.28>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  20d390:	9b02      	ldr	r3, [sp, #8]
  20d392:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  20d396:	bf0c      	ite	eq
  20d398:	2301      	moveq	r3, #1
  20d39a:	2300      	movne	r3, #0
  20d39c:	b2db      	uxtb	r3, r3
  20d39e:	4923      	ldr	r1, [pc, #140]	@ (20d42c <oslib_test_002_003_execute+0x17c>)
  20d3a0:	4618      	mov	r0, r3
  20d3a2:	f7fa f95d 	bl	207660 <__test_assert>
  20d3a6:	4603      	mov	r3, r0
  20d3a8:	2b00      	cmp	r3, #0
  20d3aa:	d137      	bne.n	20d41c <oslib_test_002_003_execute+0x16c>
  }
  test_end_step(2);

  /* [2.3.3] Resetting the mailbox. The mailbox is then returned in
     active state.*/
  test_set_step(3);
  20d3ac:	4b1d      	ldr	r3, [pc, #116]	@ (20d424 <oslib_test_002_003_execute+0x174>)
  20d3ae:	2203      	movs	r2, #3
  20d3b0:	601a      	str	r2, [r3, #0]
  {
    chMBReset(&mb1);
  20d3b2:	481d      	ldr	r0, [pc, #116]	@ (20d428 <oslib_test_002_003_execute+0x178>)
  20d3b4:	f7f7 fddc 	bl	204f70 <chMBReset>
    chMBResumeX(&mb1);
  20d3b8:	481b      	ldr	r0, [pc, #108]	@ (20d428 <oslib_test_002_003_execute+0x178>)
  20d3ba:	f7ff fb09 	bl	20c9d0 <chMBResumeX>
  }
  test_end_step(3);

  /* [2.3.4] Testing chMBFetchTimeout() and chMBFetchI() timeout.*/
  test_set_step(4);
  20d3be:	4b19      	ldr	r3, [pc, #100]	@ (20d424 <oslib_test_002_003_execute+0x174>)
  20d3c0:	2204      	movs	r2, #4
  20d3c2:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
  20d3c4:	ab01      	add	r3, sp, #4
  20d3c6:	2201      	movs	r2, #1
  20d3c8:	4619      	mov	r1, r3
  20d3ca:	4817      	ldr	r0, [pc, #92]	@ (20d428 <oslib_test_002_003_execute+0x178>)
  20d3cc:	f7f7 ff38 	bl	205240 <chMBFetchTimeout>
  20d3d0:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  20d3d2:	9b02      	ldr	r3, [sp, #8]
  20d3d4:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  20d3d8:	bf0c      	ite	eq
  20d3da:	2301      	moveq	r3, #1
  20d3dc:	2300      	movne	r3, #0
  20d3de:	b2db      	uxtb	r3, r3
  20d3e0:	4912      	ldr	r1, [pc, #72]	@ (20d42c <oslib_test_002_003_execute+0x17c>)
  20d3e2:	4618      	mov	r0, r3
  20d3e4:	f7fa f93c 	bl	207660 <__test_assert>
  20d3e8:	4603      	mov	r3, r0
  20d3ea:	2b00      	cmp	r3, #0
  20d3ec:	d116      	bne.n	20d41c <oslib_test_002_003_execute+0x16c>
    chSysLock();
  20d3ee:	f7ff faa7 	bl	20c940 <chSysLock.lto_priv.28>
    msg1 = chMBFetchI(&mb1, &msg2);
  20d3f2:	ab01      	add	r3, sp, #4
  20d3f4:	4619      	mov	r1, r3
  20d3f6:	480c      	ldr	r0, [pc, #48]	@ (20d428 <oslib_test_002_003_execute+0x178>)
  20d3f8:	f7f7 ff82 	bl	205300 <chMBFetchI>
  20d3fc:	9002      	str	r0, [sp, #8]
    chSysUnlock();
  20d3fe:	f7ff faaf 	bl	20c960 <chSysUnlock.lto_priv.28>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  20d402:	9b02      	ldr	r3, [sp, #8]
  20d404:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
  20d408:	bf0c      	ite	eq
  20d40a:	2301      	moveq	r3, #1
  20d40c:	2300      	movne	r3, #0
  20d40e:	b2db      	uxtb	r3, r3
  20d410:	4906      	ldr	r1, [pc, #24]	@ (20d42c <oslib_test_002_003_execute+0x17c>)
  20d412:	4618      	mov	r0, r3
  20d414:	f7fa f924 	bl	207660 <__test_assert>
  20d418:	4603      	mov	r3, r0
  20d41a:	2b00      	cmp	r3, #0
  }
  test_end_step(4);
}
  20d41c:	b005      	add	sp, #20
  20d41e:	f85d fb04 	ldr.w	pc, [sp], #4
  20d422:	bf00      	nop
  20d424:	20000bb4 	.word	0x20000bb4
  20d428:	20020030 	.word	0x20020030
  20d42c:	080117d0 	.word	0x080117d0

0020d430 <chPipeResume>:
 *
 * @param[in] pp        the pointer to an initialized @p pipe_t object
 *
 * @api
 */
static inline void chPipeResume(pipe_t *pp) {
  20d430:	b082      	sub	sp, #8
  20d432:	9001      	str	r0, [sp, #4]

  pp->reset = false;
  20d434:	9b01      	ldr	r3, [sp, #4]
  20d436:	2200      	movs	r2, #0
  20d438:	751a      	strb	r2, [r3, #20]
}
  20d43a:	bf00      	nop
  20d43c:	b002      	add	sp, #8
  20d43e:	4770      	bx	lr

0020d440 <oslib_test_003_001_setup>:
 * - [3.1.13] Write wrapping buffer boundary.
 * - [3.1.14] Read wrapping buffer boundary.
 * .
 */

static void oslib_test_003_001_setup(void) {
  20d440:	b508      	push	{r3, lr}
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE);
  20d442:	2210      	movs	r2, #16
  20d444:	4902      	ldr	r1, [pc, #8]	@ (20d450 <oslib_test_003_001_setup+0x10>)
  20d446:	4803      	ldr	r0, [pc, #12]	@ (20d454 <oslib_test_003_001_setup+0x14>)
  20d448:	f7f8 fd32 	bl	205eb0 <chPipeObjectInit>
}
  20d44c:	bf00      	nop
  20d44e:	bd08      	pop	{r3, pc}
  20d450:	200019b4 	.word	0x200019b4
  20d454:	20020058 	.word	0x20020058
	...

0020d460 <oslib_test_003_001_execute>:

static void oslib_test_003_001_execute(void) {
  20d460:	b500      	push	{lr}
  20d462:	b0a5      	sub	sp, #148	@ 0x94

  /* [3.1.1] Resetting pipe.*/
  test_set_step(1);
  20d464:	4b89      	ldr	r3, [pc, #548]	@ (20d68c <oslib_test_003_001_execute+0x22c>)
  20d466:	2201      	movs	r2, #1
  20d468:	601a      	str	r2, [r3, #0]
  {
    chPipeReset(&pipe1);
  20d46a:	4889      	ldr	r0, [pc, #548]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d46c:	f7f8 fd58 	bl	205f20 <chPipeReset>

    test_assert((pipe1.rdptr == pipe1.buffer) &&
  20d470:	4b87      	ldr	r3, [pc, #540]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d472:	68da      	ldr	r2, [r3, #12]
  20d474:	4b86      	ldr	r3, [pc, #536]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d476:	681b      	ldr	r3, [r3, #0]
  20d478:	429a      	cmp	r2, r3
  20d47a:	d10b      	bne.n	20d494 <oslib_test_003_001_execute+0x34>
  20d47c:	4b84      	ldr	r3, [pc, #528]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d47e:	689a      	ldr	r2, [r3, #8]
  20d480:	4b83      	ldr	r3, [pc, #524]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d482:	681b      	ldr	r3, [r3, #0]
  20d484:	429a      	cmp	r2, r3
  20d486:	d105      	bne.n	20d494 <oslib_test_003_001_execute+0x34>
  20d488:	4b81      	ldr	r3, [pc, #516]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d48a:	691b      	ldr	r3, [r3, #16]
  20d48c:	2b00      	cmp	r3, #0
  20d48e:	d101      	bne.n	20d494 <oslib_test_003_001_execute+0x34>
  20d490:	2301      	movs	r3, #1
  20d492:	e000      	b.n	20d496 <oslib_test_003_001_execute+0x36>
  20d494:	2300      	movs	r3, #0
  20d496:	f003 0301 	and.w	r3, r3, #1
  20d49a:	b2db      	uxtb	r3, r3
  20d49c:	497d      	ldr	r1, [pc, #500]	@ (20d694 <oslib_test_003_001_execute+0x234>)
  20d49e:	4618      	mov	r0, r3
  20d4a0:	f7fa f8de 	bl	207660 <__test_assert>
  20d4a4:	4603      	mov	r3, r0
  20d4a6:	2b00      	cmp	r3, #0
  20d4a8:	f040 8321 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                "invalid pipe state");
  }
  test_end_step(1);

  /* [3.1.2] Writing data, must fail.*/
  test_set_step(2);
  20d4ac:	4b77      	ldr	r3, [pc, #476]	@ (20d68c <oslib_test_003_001_execute+0x22c>)
  20d4ae:	2202      	movs	r2, #2
  20d4b0:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
  20d4b2:	2300      	movs	r3, #0
  20d4b4:	2210      	movs	r2, #16
  20d4b6:	4978      	ldr	r1, [pc, #480]	@ (20d698 <oslib_test_003_001_execute+0x238>)
  20d4b8:	4875      	ldr	r0, [pc, #468]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d4ba:	f7f8 fd69 	bl	205f90 <chPipeWriteTimeout>
  20d4be:	9023      	str	r0, [sp, #140]	@ 0x8c
    test_assert(n == 0, "not reset");
  20d4c0:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
  20d4c2:	2b00      	cmp	r3, #0
  20d4c4:	bf0c      	ite	eq
  20d4c6:	2301      	moveq	r3, #1
  20d4c8:	2300      	movne	r3, #0
  20d4ca:	b2db      	uxtb	r3, r3
  20d4cc:	4973      	ldr	r1, [pc, #460]	@ (20d69c <oslib_test_003_001_execute+0x23c>)
  20d4ce:	4618      	mov	r0, r3
  20d4d0:	f7fa f8c6 	bl	207660 <__test_assert>
  20d4d4:	4603      	mov	r3, r0
  20d4d6:	2b00      	cmp	r3, #0
  20d4d8:	f040 8309 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
  20d4dc:	4b6c      	ldr	r3, [pc, #432]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d4de:	68da      	ldr	r2, [r3, #12]
  20d4e0:	4b6b      	ldr	r3, [pc, #428]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d4e2:	681b      	ldr	r3, [r3, #0]
  20d4e4:	429a      	cmp	r2, r3
  20d4e6:	d10b      	bne.n	20d500 <oslib_test_003_001_execute+0xa0>
  20d4e8:	4b69      	ldr	r3, [pc, #420]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d4ea:	689a      	ldr	r2, [r3, #8]
  20d4ec:	4b68      	ldr	r3, [pc, #416]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d4ee:	681b      	ldr	r3, [r3, #0]
  20d4f0:	429a      	cmp	r2, r3
  20d4f2:	d105      	bne.n	20d500 <oslib_test_003_001_execute+0xa0>
  20d4f4:	4b66      	ldr	r3, [pc, #408]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d4f6:	691b      	ldr	r3, [r3, #16]
  20d4f8:	2b00      	cmp	r3, #0
  20d4fa:	d101      	bne.n	20d500 <oslib_test_003_001_execute+0xa0>
  20d4fc:	2301      	movs	r3, #1
  20d4fe:	e000      	b.n	20d502 <oslib_test_003_001_execute+0xa2>
  20d500:	2300      	movs	r3, #0
  20d502:	f003 0301 	and.w	r3, r3, #1
  20d506:	b2db      	uxtb	r3, r3
  20d508:	4962      	ldr	r1, [pc, #392]	@ (20d694 <oslib_test_003_001_execute+0x234>)
  20d50a:	4618      	mov	r0, r3
  20d50c:	f7fa f8a8 	bl	207660 <__test_assert>
  20d510:	4603      	mov	r3, r0
  20d512:	2b00      	cmp	r3, #0
  20d514:	f040 82eb 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                "invalid pipe state");
  }
  test_end_step(2);

  /* [3.1.3] Reading data, must fail.*/
  test_set_step(3);
  20d518:	4b5c      	ldr	r3, [pc, #368]	@ (20d68c <oslib_test_003_001_execute+0x22c>)
  20d51a:	2203      	movs	r2, #3
  20d51c:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
  20d51e:	4669      	mov	r1, sp
  20d520:	2300      	movs	r3, #0
  20d522:	2210      	movs	r2, #16
  20d524:	485a      	ldr	r0, [pc, #360]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d526:	f7f8 fd83 	bl	206030 <chPipeReadTimeout>
  20d52a:	9022      	str	r0, [sp, #136]	@ 0x88
    test_assert(n == 0, "not reset");
  20d52c:	9b22      	ldr	r3, [sp, #136]	@ 0x88
  20d52e:	2b00      	cmp	r3, #0
  20d530:	bf0c      	ite	eq
  20d532:	2301      	moveq	r3, #1
  20d534:	2300      	movne	r3, #0
  20d536:	b2db      	uxtb	r3, r3
  20d538:	4958      	ldr	r1, [pc, #352]	@ (20d69c <oslib_test_003_001_execute+0x23c>)
  20d53a:	4618      	mov	r0, r3
  20d53c:	f7fa f890 	bl	207660 <__test_assert>
  20d540:	4603      	mov	r3, r0
  20d542:	2b00      	cmp	r3, #0
  20d544:	f040 82d3 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
  20d548:	4b51      	ldr	r3, [pc, #324]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d54a:	68da      	ldr	r2, [r3, #12]
  20d54c:	4b50      	ldr	r3, [pc, #320]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d54e:	681b      	ldr	r3, [r3, #0]
  20d550:	429a      	cmp	r2, r3
  20d552:	d10b      	bne.n	20d56c <oslib_test_003_001_execute+0x10c>
  20d554:	4b4e      	ldr	r3, [pc, #312]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d556:	689a      	ldr	r2, [r3, #8]
  20d558:	4b4d      	ldr	r3, [pc, #308]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d55a:	681b      	ldr	r3, [r3, #0]
  20d55c:	429a      	cmp	r2, r3
  20d55e:	d105      	bne.n	20d56c <oslib_test_003_001_execute+0x10c>
  20d560:	4b4b      	ldr	r3, [pc, #300]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d562:	691b      	ldr	r3, [r3, #16]
  20d564:	2b00      	cmp	r3, #0
  20d566:	d101      	bne.n	20d56c <oslib_test_003_001_execute+0x10c>
  20d568:	2301      	movs	r3, #1
  20d56a:	e000      	b.n	20d56e <oslib_test_003_001_execute+0x10e>
  20d56c:	2300      	movs	r3, #0
  20d56e:	f003 0301 	and.w	r3, r3, #1
  20d572:	b2db      	uxtb	r3, r3
  20d574:	4947      	ldr	r1, [pc, #284]	@ (20d694 <oslib_test_003_001_execute+0x234>)
  20d576:	4618      	mov	r0, r3
  20d578:	f7fa f872 	bl	207660 <__test_assert>
  20d57c:	4603      	mov	r3, r0
  20d57e:	2b00      	cmp	r3, #0
  20d580:	f040 82b5 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                "invalid pipe state");
  }
  test_end_step(3);

  /* [3.1.4] Reactivating pipe.*/
  test_set_step(4);
  20d584:	4b41      	ldr	r3, [pc, #260]	@ (20d68c <oslib_test_003_001_execute+0x22c>)
  20d586:	2204      	movs	r2, #4
  20d588:	601a      	str	r2, [r3, #0]
  {
    chPipeResume(&pipe1);
  20d58a:	4841      	ldr	r0, [pc, #260]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d58c:	f7ff ff50 	bl	20d430 <chPipeResume>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
  20d590:	4b3f      	ldr	r3, [pc, #252]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d592:	68da      	ldr	r2, [r3, #12]
  20d594:	4b3e      	ldr	r3, [pc, #248]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d596:	681b      	ldr	r3, [r3, #0]
  20d598:	429a      	cmp	r2, r3
  20d59a:	d10b      	bne.n	20d5b4 <oslib_test_003_001_execute+0x154>
  20d59c:	4b3c      	ldr	r3, [pc, #240]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d59e:	689a      	ldr	r2, [r3, #8]
  20d5a0:	4b3b      	ldr	r3, [pc, #236]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d5a2:	681b      	ldr	r3, [r3, #0]
  20d5a4:	429a      	cmp	r2, r3
  20d5a6:	d105      	bne.n	20d5b4 <oslib_test_003_001_execute+0x154>
  20d5a8:	4b39      	ldr	r3, [pc, #228]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d5aa:	691b      	ldr	r3, [r3, #16]
  20d5ac:	2b00      	cmp	r3, #0
  20d5ae:	d101      	bne.n	20d5b4 <oslib_test_003_001_execute+0x154>
  20d5b0:	2301      	movs	r3, #1
  20d5b2:	e000      	b.n	20d5b6 <oslib_test_003_001_execute+0x156>
  20d5b4:	2300      	movs	r3, #0
  20d5b6:	f003 0301 	and.w	r3, r3, #1
  20d5ba:	b2db      	uxtb	r3, r3
  20d5bc:	4935      	ldr	r1, [pc, #212]	@ (20d694 <oslib_test_003_001_execute+0x234>)
  20d5be:	4618      	mov	r0, r3
  20d5c0:	f7fa f84e 	bl	207660 <__test_assert>
  20d5c4:	4603      	mov	r3, r0
  20d5c6:	2b00      	cmp	r3, #0
  20d5c8:	f040 8291 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                "invalid pipe state");
  }
  test_end_step(4);

  /* [3.1.5] Filling whole pipe.*/
  test_set_step(5);
  20d5cc:	4b2f      	ldr	r3, [pc, #188]	@ (20d68c <oslib_test_003_001_execute+0x22c>)
  20d5ce:	2205      	movs	r2, #5
  20d5d0:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
  20d5d2:	2300      	movs	r3, #0
  20d5d4:	2210      	movs	r2, #16
  20d5d6:	4930      	ldr	r1, [pc, #192]	@ (20d698 <oslib_test_003_001_execute+0x238>)
  20d5d8:	482d      	ldr	r0, [pc, #180]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d5da:	f7f8 fcd9 	bl	205f90 <chPipeWriteTimeout>
  20d5de:	9021      	str	r0, [sp, #132]	@ 0x84
    test_assert(n == PIPE_SIZE, "wrong size");
  20d5e0:	9b21      	ldr	r3, [sp, #132]	@ 0x84
  20d5e2:	2b10      	cmp	r3, #16
  20d5e4:	bf0c      	ite	eq
  20d5e6:	2301      	moveq	r3, #1
  20d5e8:	2300      	movne	r3, #0
  20d5ea:	b2db      	uxtb	r3, r3
  20d5ec:	492c      	ldr	r1, [pc, #176]	@ (20d6a0 <oslib_test_003_001_execute+0x240>)
  20d5ee:	4618      	mov	r0, r3
  20d5f0:	f7fa f836 	bl	207660 <__test_assert>
  20d5f4:	4603      	mov	r3, r0
  20d5f6:	2b00      	cmp	r3, #0
  20d5f8:	f040 8279 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
  20d5fc:	4b24      	ldr	r3, [pc, #144]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d5fe:	68da      	ldr	r2, [r3, #12]
  20d600:	4b23      	ldr	r3, [pc, #140]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d602:	681b      	ldr	r3, [r3, #0]
  20d604:	429a      	cmp	r2, r3
  20d606:	d10b      	bne.n	20d620 <oslib_test_003_001_execute+0x1c0>
  20d608:	4b21      	ldr	r3, [pc, #132]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d60a:	689a      	ldr	r2, [r3, #8]
  20d60c:	4b20      	ldr	r3, [pc, #128]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d60e:	681b      	ldr	r3, [r3, #0]
  20d610:	429a      	cmp	r2, r3
  20d612:	d105      	bne.n	20d620 <oslib_test_003_001_execute+0x1c0>
  20d614:	4b1e      	ldr	r3, [pc, #120]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d616:	691b      	ldr	r3, [r3, #16]
  20d618:	2b10      	cmp	r3, #16
  20d61a:	d101      	bne.n	20d620 <oslib_test_003_001_execute+0x1c0>
  20d61c:	2301      	movs	r3, #1
  20d61e:	e000      	b.n	20d622 <oslib_test_003_001_execute+0x1c2>
  20d620:	2300      	movs	r3, #0
  20d622:	f003 0301 	and.w	r3, r3, #1
  20d626:	b2db      	uxtb	r3, r3
  20d628:	491a      	ldr	r1, [pc, #104]	@ (20d694 <oslib_test_003_001_execute+0x234>)
  20d62a:	4618      	mov	r0, r3
  20d62c:	f7fa f818 	bl	207660 <__test_assert>
  20d630:	4603      	mov	r3, r0
  20d632:	2b00      	cmp	r3, #0
  20d634:	f040 825b 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                "invalid pipe state");
  }
  test_end_step(5);

  /* [3.1.6] Emptying pipe.*/
  test_set_step(6);
  20d638:	4b14      	ldr	r3, [pc, #80]	@ (20d68c <oslib_test_003_001_execute+0x22c>)
  20d63a:	2206      	movs	r2, #6
  20d63c:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
  20d63e:	a904      	add	r1, sp, #16
  20d640:	2300      	movs	r3, #0
  20d642:	2210      	movs	r2, #16
  20d644:	4812      	ldr	r0, [pc, #72]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d646:	f7f8 fcf3 	bl	206030 <chPipeReadTimeout>
  20d64a:	9020      	str	r0, [sp, #128]	@ 0x80
    test_assert(n == PIPE_SIZE, "wrong size");
  20d64c:	9b20      	ldr	r3, [sp, #128]	@ 0x80
  20d64e:	2b10      	cmp	r3, #16
  20d650:	bf0c      	ite	eq
  20d652:	2301      	moveq	r3, #1
  20d654:	2300      	movne	r3, #0
  20d656:	b2db      	uxtb	r3, r3
  20d658:	4911      	ldr	r1, [pc, #68]	@ (20d6a0 <oslib_test_003_001_execute+0x240>)
  20d65a:	4618      	mov	r0, r3
  20d65c:	f7fa f800 	bl	207660 <__test_assert>
  20d660:	4603      	mov	r3, r0
  20d662:	2b00      	cmp	r3, #0
  20d664:	f040 8243 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
  20d668:	4b09      	ldr	r3, [pc, #36]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d66a:	68da      	ldr	r2, [r3, #12]
  20d66c:	4b08      	ldr	r3, [pc, #32]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d66e:	681b      	ldr	r3, [r3, #0]
  20d670:	429a      	cmp	r2, r3
  20d672:	d117      	bne.n	20d6a4 <oslib_test_003_001_execute+0x244>
  20d674:	4b06      	ldr	r3, [pc, #24]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d676:	689a      	ldr	r2, [r3, #8]
  20d678:	4b05      	ldr	r3, [pc, #20]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d67a:	681b      	ldr	r3, [r3, #0]
  20d67c:	429a      	cmp	r2, r3
  20d67e:	d111      	bne.n	20d6a4 <oslib_test_003_001_execute+0x244>
  20d680:	4b03      	ldr	r3, [pc, #12]	@ (20d690 <oslib_test_003_001_execute+0x230>)
  20d682:	691b      	ldr	r3, [r3, #16]
  20d684:	2b00      	cmp	r3, #0
  20d686:	d10d      	bne.n	20d6a4 <oslib_test_003_001_execute+0x244>
  20d688:	2301      	movs	r3, #1
  20d68a:	e00c      	b.n	20d6a6 <oslib_test_003_001_execute+0x246>
  20d68c:	20000bb4 	.word	0x20000bb4
  20d690:	20020058 	.word	0x20020058
  20d694:	08011f40 	.word	0x08011f40
  20d698:	08012750 	.word	0x08012750
  20d69c:	08011f54 	.word	0x08011f54
  20d6a0:	08011e7c 	.word	0x08011e7c
  20d6a4:	2300      	movs	r3, #0
  20d6a6:	f003 0301 	and.w	r3, r3, #1
  20d6aa:	b2db      	uxtb	r3, r3
  20d6ac:	497d      	ldr	r1, [pc, #500]	@ (20d8a4 <oslib_test_003_001_execute+0x444>)
  20d6ae:	4618      	mov	r0, r3
  20d6b0:	f7f9 ffd6 	bl	207660 <__test_assert>
  20d6b4:	4603      	mov	r3, r0
  20d6b6:	2b00      	cmp	r3, #0
  20d6b8:	f040 8219 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == 0),
                "invalid pipe state");
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
  20d6bc:	ab04      	add	r3, sp, #16
  20d6be:	2210      	movs	r2, #16
  20d6c0:	4619      	mov	r1, r3
  20d6c2:	4879      	ldr	r0, [pc, #484]	@ (20d8a8 <oslib_test_003_001_execute+0x448>)
  20d6c4:	f7f2 fee0 	bl	200488 <memcmp>
  20d6c8:	4603      	mov	r3, r0
  20d6ca:	2b00      	cmp	r3, #0
  20d6cc:	bf0c      	ite	eq
  20d6ce:	2301      	moveq	r3, #1
  20d6d0:	2300      	movne	r3, #0
  20d6d2:	b2db      	uxtb	r3, r3
  20d6d4:	4975      	ldr	r1, [pc, #468]	@ (20d8ac <oslib_test_003_001_execute+0x44c>)
  20d6d6:	4618      	mov	r0, r3
  20d6d8:	f7f9 ffc2 	bl	207660 <__test_assert>
  20d6dc:	4603      	mov	r3, r0
  20d6de:	2b00      	cmp	r3, #0
  20d6e0:	f040 8205 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
  }
  test_end_step(6);

  /* [3.1.7] Small write.*/
  test_set_step(7);
  20d6e4:	4b72      	ldr	r3, [pc, #456]	@ (20d8b0 <oslib_test_003_001_execute+0x450>)
  20d6e6:	2207      	movs	r2, #7
  20d6e8:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 4, TIME_IMMEDIATE);
  20d6ea:	2300      	movs	r3, #0
  20d6ec:	2204      	movs	r2, #4
  20d6ee:	496e      	ldr	r1, [pc, #440]	@ (20d8a8 <oslib_test_003_001_execute+0x448>)
  20d6f0:	4870      	ldr	r0, [pc, #448]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d6f2:	f7f8 fc4d 	bl	205f90 <chPipeWriteTimeout>
  20d6f6:	901f      	str	r0, [sp, #124]	@ 0x7c
    test_assert(n == 4, "wrong size");
  20d6f8:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
  20d6fa:	2b04      	cmp	r3, #4
  20d6fc:	bf0c      	ite	eq
  20d6fe:	2301      	moveq	r3, #1
  20d700:	2300      	movne	r3, #0
  20d702:	b2db      	uxtb	r3, r3
  20d704:	496c      	ldr	r1, [pc, #432]	@ (20d8b8 <oslib_test_003_001_execute+0x458>)
  20d706:	4618      	mov	r0, r3
  20d708:	f7f9 ffaa 	bl	207660 <__test_assert>
  20d70c:	4603      	mov	r3, r0
  20d70e:	2b00      	cmp	r3, #0
  20d710:	f040 81ed 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
  20d714:	4b67      	ldr	r3, [pc, #412]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d716:	68da      	ldr	r2, [r3, #12]
  20d718:	4b66      	ldr	r3, [pc, #408]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d71a:	689b      	ldr	r3, [r3, #8]
  20d71c:	429a      	cmp	r2, r3
  20d71e:	d00b      	beq.n	20d738 <oslib_test_003_001_execute+0x2d8>
  20d720:	4b64      	ldr	r3, [pc, #400]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d722:	68da      	ldr	r2, [r3, #12]
  20d724:	4b63      	ldr	r3, [pc, #396]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d726:	681b      	ldr	r3, [r3, #0]
  20d728:	429a      	cmp	r2, r3
  20d72a:	d105      	bne.n	20d738 <oslib_test_003_001_execute+0x2d8>
  20d72c:	4b61      	ldr	r3, [pc, #388]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d72e:	691b      	ldr	r3, [r3, #16]
  20d730:	2b04      	cmp	r3, #4
  20d732:	d101      	bne.n	20d738 <oslib_test_003_001_execute+0x2d8>
  20d734:	2301      	movs	r3, #1
  20d736:	e000      	b.n	20d73a <oslib_test_003_001_execute+0x2da>
  20d738:	2300      	movs	r3, #0
  20d73a:	f003 0301 	and.w	r3, r3, #1
  20d73e:	b2db      	uxtb	r3, r3
  20d740:	4958      	ldr	r1, [pc, #352]	@ (20d8a4 <oslib_test_003_001_execute+0x444>)
  20d742:	4618      	mov	r0, r3
  20d744:	f7f9 ff8c 	bl	207660 <__test_assert>
  20d748:	4603      	mov	r3, r0
  20d74a:	2b00      	cmp	r3, #0
  20d74c:	f040 81cf 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                "invalid pipe state");
  }
  test_end_step(7);

  /* [3.1.8] Filling remaining space.*/
  test_set_step(8);
  20d750:	4b57      	ldr	r3, [pc, #348]	@ (20d8b0 <oslib_test_003_001_execute+0x450>)
  20d752:	2208      	movs	r2, #8
  20d754:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE - 4, TIME_IMMEDIATE);
  20d756:	2300      	movs	r3, #0
  20d758:	220c      	movs	r2, #12
  20d75a:	4953      	ldr	r1, [pc, #332]	@ (20d8a8 <oslib_test_003_001_execute+0x448>)
  20d75c:	4855      	ldr	r0, [pc, #340]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d75e:	f7f8 fc17 	bl	205f90 <chPipeWriteTimeout>
  20d762:	901e      	str	r0, [sp, #120]	@ 0x78
    test_assert(n == PIPE_SIZE - 4, "wrong size");
  20d764:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
  20d766:	2b0c      	cmp	r3, #12
  20d768:	bf0c      	ite	eq
  20d76a:	2301      	moveq	r3, #1
  20d76c:	2300      	movne	r3, #0
  20d76e:	b2db      	uxtb	r3, r3
  20d770:	4951      	ldr	r1, [pc, #324]	@ (20d8b8 <oslib_test_003_001_execute+0x458>)
  20d772:	4618      	mov	r0, r3
  20d774:	f7f9 ff74 	bl	207660 <__test_assert>
  20d778:	4603      	mov	r3, r0
  20d77a:	2b00      	cmp	r3, #0
  20d77c:	f040 81b7 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
  20d780:	4b4c      	ldr	r3, [pc, #304]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d782:	68da      	ldr	r2, [r3, #12]
  20d784:	4b4b      	ldr	r3, [pc, #300]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d786:	681b      	ldr	r3, [r3, #0]
  20d788:	429a      	cmp	r2, r3
  20d78a:	d10b      	bne.n	20d7a4 <oslib_test_003_001_execute+0x344>
  20d78c:	4b49      	ldr	r3, [pc, #292]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d78e:	689a      	ldr	r2, [r3, #8]
  20d790:	4b48      	ldr	r3, [pc, #288]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d792:	681b      	ldr	r3, [r3, #0]
  20d794:	429a      	cmp	r2, r3
  20d796:	d105      	bne.n	20d7a4 <oslib_test_003_001_execute+0x344>
  20d798:	4b46      	ldr	r3, [pc, #280]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d79a:	691b      	ldr	r3, [r3, #16]
  20d79c:	2b10      	cmp	r3, #16
  20d79e:	d101      	bne.n	20d7a4 <oslib_test_003_001_execute+0x344>
  20d7a0:	2301      	movs	r3, #1
  20d7a2:	e000      	b.n	20d7a6 <oslib_test_003_001_execute+0x346>
  20d7a4:	2300      	movs	r3, #0
  20d7a6:	f003 0301 	and.w	r3, r3, #1
  20d7aa:	b2db      	uxtb	r3, r3
  20d7ac:	493d      	ldr	r1, [pc, #244]	@ (20d8a4 <oslib_test_003_001_execute+0x444>)
  20d7ae:	4618      	mov	r0, r3
  20d7b0:	f7f9 ff56 	bl	207660 <__test_assert>
  20d7b4:	4603      	mov	r3, r0
  20d7b6:	2b00      	cmp	r3, #0
  20d7b8:	f040 8199 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                "invalid pipe state");
  }
  test_end_step(8);

  /* [3.1.9] Small Read.*/
  test_set_step(9);
  20d7bc:	4b3c      	ldr	r3, [pc, #240]	@ (20d8b0 <oslib_test_003_001_execute+0x450>)
  20d7be:	2209      	movs	r2, #9
  20d7c0:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, 4, TIME_IMMEDIATE);
  20d7c2:	a908      	add	r1, sp, #32
  20d7c4:	2300      	movs	r3, #0
  20d7c6:	2204      	movs	r2, #4
  20d7c8:	483a      	ldr	r0, [pc, #232]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d7ca:	f7f8 fc31 	bl	206030 <chPipeReadTimeout>
  20d7ce:	901d      	str	r0, [sp, #116]	@ 0x74
    test_assert(n == 4, "wrong size");
  20d7d0:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
  20d7d2:	2b04      	cmp	r3, #4
  20d7d4:	bf0c      	ite	eq
  20d7d6:	2301      	moveq	r3, #1
  20d7d8:	2300      	movne	r3, #0
  20d7da:	b2db      	uxtb	r3, r3
  20d7dc:	4936      	ldr	r1, [pc, #216]	@ (20d8b8 <oslib_test_003_001_execute+0x458>)
  20d7de:	4618      	mov	r0, r3
  20d7e0:	f7f9 ff3e 	bl	207660 <__test_assert>
  20d7e4:	4603      	mov	r3, r0
  20d7e6:	2b00      	cmp	r3, #0
  20d7e8:	f040 8181 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr != pipe1.buffer) &&
  20d7ec:	4b31      	ldr	r3, [pc, #196]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d7ee:	68da      	ldr	r2, [r3, #12]
  20d7f0:	4b30      	ldr	r3, [pc, #192]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d7f2:	681b      	ldr	r3, [r3, #0]
  20d7f4:	429a      	cmp	r2, r3
  20d7f6:	d00b      	beq.n	20d810 <oslib_test_003_001_execute+0x3b0>
  20d7f8:	4b2e      	ldr	r3, [pc, #184]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d7fa:	689a      	ldr	r2, [r3, #8]
  20d7fc:	4b2d      	ldr	r3, [pc, #180]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d7fe:	681b      	ldr	r3, [r3, #0]
  20d800:	429a      	cmp	r2, r3
  20d802:	d105      	bne.n	20d810 <oslib_test_003_001_execute+0x3b0>
  20d804:	4b2b      	ldr	r3, [pc, #172]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d806:	691b      	ldr	r3, [r3, #16]
  20d808:	2b0c      	cmp	r3, #12
  20d80a:	d101      	bne.n	20d810 <oslib_test_003_001_execute+0x3b0>
  20d80c:	2301      	movs	r3, #1
  20d80e:	e000      	b.n	20d812 <oslib_test_003_001_execute+0x3b2>
  20d810:	2300      	movs	r3, #0
  20d812:	f003 0301 	and.w	r3, r3, #1
  20d816:	b2db      	uxtb	r3, r3
  20d818:	4922      	ldr	r1, [pc, #136]	@ (20d8a4 <oslib_test_003_001_execute+0x444>)
  20d81a:	4618      	mov	r0, r3
  20d81c:	f7f9 ff20 	bl	207660 <__test_assert>
  20d820:	4603      	mov	r3, r0
  20d822:	2b00      	cmp	r3, #0
  20d824:	f040 8163 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == PIPE_SIZE - 4),
                "invalid pipe state");
    test_assert(memcmp(pipe_pattern, buf, 4) == 0, "content mismatch");
  20d828:	ab08      	add	r3, sp, #32
  20d82a:	2204      	movs	r2, #4
  20d82c:	4619      	mov	r1, r3
  20d82e:	481e      	ldr	r0, [pc, #120]	@ (20d8a8 <oslib_test_003_001_execute+0x448>)
  20d830:	f7f2 fe2a 	bl	200488 <memcmp>
  20d834:	4603      	mov	r3, r0
  20d836:	2b00      	cmp	r3, #0
  20d838:	bf0c      	ite	eq
  20d83a:	2301      	moveq	r3, #1
  20d83c:	2300      	movne	r3, #0
  20d83e:	b2db      	uxtb	r3, r3
  20d840:	491a      	ldr	r1, [pc, #104]	@ (20d8ac <oslib_test_003_001_execute+0x44c>)
  20d842:	4618      	mov	r0, r3
  20d844:	f7f9 ff0c 	bl	207660 <__test_assert>
  20d848:	4603      	mov	r3, r0
  20d84a:	2b00      	cmp	r3, #0
  20d84c:	f040 814f 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
  }
  test_end_step(9);

  /* [3.1.10] Reading remaining data.*/
  test_set_step(10);
  20d850:	4b17      	ldr	r3, [pc, #92]	@ (20d8b0 <oslib_test_003_001_execute+0x450>)
  20d852:	220a      	movs	r2, #10
  20d854:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE - 4, TIME_IMMEDIATE);
  20d856:	a90c      	add	r1, sp, #48	@ 0x30
  20d858:	2300      	movs	r3, #0
  20d85a:	220c      	movs	r2, #12
  20d85c:	4815      	ldr	r0, [pc, #84]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d85e:	f7f8 fbe7 	bl	206030 <chPipeReadTimeout>
  20d862:	901c      	str	r0, [sp, #112]	@ 0x70
    test_assert(n == PIPE_SIZE - 4, "wrong size");
  20d864:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
  20d866:	2b0c      	cmp	r3, #12
  20d868:	bf0c      	ite	eq
  20d86a:	2301      	moveq	r3, #1
  20d86c:	2300      	movne	r3, #0
  20d86e:	b2db      	uxtb	r3, r3
  20d870:	4911      	ldr	r1, [pc, #68]	@ (20d8b8 <oslib_test_003_001_execute+0x458>)
  20d872:	4618      	mov	r0, r3
  20d874:	f7f9 fef4 	bl	207660 <__test_assert>
  20d878:	4603      	mov	r3, r0
  20d87a:	2b00      	cmp	r3, #0
  20d87c:	f040 8137 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
  20d880:	4b0c      	ldr	r3, [pc, #48]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d882:	68da      	ldr	r2, [r3, #12]
  20d884:	4b0b      	ldr	r3, [pc, #44]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d886:	681b      	ldr	r3, [r3, #0]
  20d888:	429a      	cmp	r2, r3
  20d88a:	d117      	bne.n	20d8bc <oslib_test_003_001_execute+0x45c>
  20d88c:	4b09      	ldr	r3, [pc, #36]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d88e:	689a      	ldr	r2, [r3, #8]
  20d890:	4b08      	ldr	r3, [pc, #32]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d892:	681b      	ldr	r3, [r3, #0]
  20d894:	429a      	cmp	r2, r3
  20d896:	d111      	bne.n	20d8bc <oslib_test_003_001_execute+0x45c>
  20d898:	4b06      	ldr	r3, [pc, #24]	@ (20d8b4 <oslib_test_003_001_execute+0x454>)
  20d89a:	691b      	ldr	r3, [r3, #16]
  20d89c:	2b00      	cmp	r3, #0
  20d89e:	d10d      	bne.n	20d8bc <oslib_test_003_001_execute+0x45c>
  20d8a0:	2301      	movs	r3, #1
  20d8a2:	e00c      	b.n	20d8be <oslib_test_003_001_execute+0x45e>
  20d8a4:	08011f40 	.word	0x08011f40
  20d8a8:	08012750 	.word	0x08012750
  20d8ac:	08011f60 	.word	0x08011f60
  20d8b0:	20000bb4 	.word	0x20000bb4
  20d8b4:	20020058 	.word	0x20020058
  20d8b8:	08011e7c 	.word	0x08011e7c
  20d8bc:	2300      	movs	r3, #0
  20d8be:	f003 0301 	and.w	r3, r3, #1
  20d8c2:	b2db      	uxtb	r3, r3
  20d8c4:	498b      	ldr	r1, [pc, #556]	@ (20daf4 <oslib_test_003_001_execute+0x694>)
  20d8c6:	4618      	mov	r0, r3
  20d8c8:	f7f9 feca 	bl	207660 <__test_assert>
  20d8cc:	4603      	mov	r3, r0
  20d8ce:	2b00      	cmp	r3, #0
  20d8d0:	f040 810d 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == 0),
                "invalid pipe state");
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE - 4) == 0, "content mismatch");
  20d8d4:	ab0c      	add	r3, sp, #48	@ 0x30
  20d8d6:	220c      	movs	r2, #12
  20d8d8:	4619      	mov	r1, r3
  20d8da:	4887      	ldr	r0, [pc, #540]	@ (20daf8 <oslib_test_003_001_execute+0x698>)
  20d8dc:	f7f2 fdd4 	bl	200488 <memcmp>
  20d8e0:	4603      	mov	r3, r0
  20d8e2:	2b00      	cmp	r3, #0
  20d8e4:	bf0c      	ite	eq
  20d8e6:	2301      	moveq	r3, #1
  20d8e8:	2300      	movne	r3, #0
  20d8ea:	b2db      	uxtb	r3, r3
  20d8ec:	4983      	ldr	r1, [pc, #524]	@ (20dafc <oslib_test_003_001_execute+0x69c>)
  20d8ee:	4618      	mov	r0, r3
  20d8f0:	f7f9 feb6 	bl	207660 <__test_assert>
  20d8f4:	4603      	mov	r3, r0
  20d8f6:	2b00      	cmp	r3, #0
  20d8f8:	f040 80f9 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
  }
  test_end_step(10);

  /* [3.1.11] Small Write.*/
  test_set_step(11);
  20d8fc:	4b80      	ldr	r3, [pc, #512]	@ (20db00 <oslib_test_003_001_execute+0x6a0>)
  20d8fe:	220b      	movs	r2, #11
  20d900:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 5, TIME_IMMEDIATE);
  20d902:	2300      	movs	r3, #0
  20d904:	2205      	movs	r2, #5
  20d906:	497c      	ldr	r1, [pc, #496]	@ (20daf8 <oslib_test_003_001_execute+0x698>)
  20d908:	487e      	ldr	r0, [pc, #504]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d90a:	f7f8 fb41 	bl	205f90 <chPipeWriteTimeout>
  20d90e:	901b      	str	r0, [sp, #108]	@ 0x6c
    test_assert(n == 5, "wrong size");
  20d910:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
  20d912:	2b05      	cmp	r3, #5
  20d914:	bf0c      	ite	eq
  20d916:	2301      	moveq	r3, #1
  20d918:	2300      	movne	r3, #0
  20d91a:	b2db      	uxtb	r3, r3
  20d91c:	497a      	ldr	r1, [pc, #488]	@ (20db08 <oslib_test_003_001_execute+0x6a8>)
  20d91e:	4618      	mov	r0, r3
  20d920:	f7f9 fe9e 	bl	207660 <__test_assert>
  20d924:	4603      	mov	r3, r0
  20d926:	2b00      	cmp	r3, #0
  20d928:	f040 80e1 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
  20d92c:	4b75      	ldr	r3, [pc, #468]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d92e:	68da      	ldr	r2, [r3, #12]
  20d930:	4b74      	ldr	r3, [pc, #464]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d932:	689b      	ldr	r3, [r3, #8]
  20d934:	429a      	cmp	r2, r3
  20d936:	d00b      	beq.n	20d950 <oslib_test_003_001_execute+0x4f0>
  20d938:	4b72      	ldr	r3, [pc, #456]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d93a:	68da      	ldr	r2, [r3, #12]
  20d93c:	4b71      	ldr	r3, [pc, #452]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d93e:	681b      	ldr	r3, [r3, #0]
  20d940:	429a      	cmp	r2, r3
  20d942:	d105      	bne.n	20d950 <oslib_test_003_001_execute+0x4f0>
  20d944:	4b6f      	ldr	r3, [pc, #444]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d946:	691b      	ldr	r3, [r3, #16]
  20d948:	2b05      	cmp	r3, #5
  20d94a:	d101      	bne.n	20d950 <oslib_test_003_001_execute+0x4f0>
  20d94c:	2301      	movs	r3, #1
  20d94e:	e000      	b.n	20d952 <oslib_test_003_001_execute+0x4f2>
  20d950:	2300      	movs	r3, #0
  20d952:	f003 0301 	and.w	r3, r3, #1
  20d956:	b2db      	uxtb	r3, r3
  20d958:	4966      	ldr	r1, [pc, #408]	@ (20daf4 <oslib_test_003_001_execute+0x694>)
  20d95a:	4618      	mov	r0, r3
  20d95c:	f7f9 fe80 	bl	207660 <__test_assert>
  20d960:	4603      	mov	r3, r0
  20d962:	2b00      	cmp	r3, #0
  20d964:	f040 80c3 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                "invalid pipe state");
  }
  test_end_step(11);

  /* [3.1.12] Small Read.*/
  test_set_step(12);
  20d968:	4b65      	ldr	r3, [pc, #404]	@ (20db00 <oslib_test_003_001_execute+0x6a0>)
  20d96a:	220c      	movs	r2, #12
  20d96c:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, 5, TIME_IMMEDIATE);
  20d96e:	a910      	add	r1, sp, #64	@ 0x40
  20d970:	2300      	movs	r3, #0
  20d972:	2205      	movs	r2, #5
  20d974:	4863      	ldr	r0, [pc, #396]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d976:	f7f8 fb5b 	bl	206030 <chPipeReadTimeout>
  20d97a:	901a      	str	r0, [sp, #104]	@ 0x68
    test_assert(n == 5, "wrong size");
  20d97c:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
  20d97e:	2b05      	cmp	r3, #5
  20d980:	bf0c      	ite	eq
  20d982:	2301      	moveq	r3, #1
  20d984:	2300      	movne	r3, #0
  20d986:	b2db      	uxtb	r3, r3
  20d988:	495f      	ldr	r1, [pc, #380]	@ (20db08 <oslib_test_003_001_execute+0x6a8>)
  20d98a:	4618      	mov	r0, r3
  20d98c:	f7f9 fe68 	bl	207660 <__test_assert>
  20d990:	4603      	mov	r3, r0
  20d992:	2b00      	cmp	r3, #0
  20d994:	f040 80ab 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
  20d998:	4b5a      	ldr	r3, [pc, #360]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d99a:	68da      	ldr	r2, [r3, #12]
  20d99c:	4b59      	ldr	r3, [pc, #356]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d99e:	689b      	ldr	r3, [r3, #8]
  20d9a0:	429a      	cmp	r2, r3
  20d9a2:	d10b      	bne.n	20d9bc <oslib_test_003_001_execute+0x55c>
  20d9a4:	4b57      	ldr	r3, [pc, #348]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d9a6:	689a      	ldr	r2, [r3, #8]
  20d9a8:	4b56      	ldr	r3, [pc, #344]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d9aa:	681b      	ldr	r3, [r3, #0]
  20d9ac:	429a      	cmp	r2, r3
  20d9ae:	d005      	beq.n	20d9bc <oslib_test_003_001_execute+0x55c>
  20d9b0:	4b54      	ldr	r3, [pc, #336]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20d9b2:	691b      	ldr	r3, [r3, #16]
  20d9b4:	2b00      	cmp	r3, #0
  20d9b6:	d101      	bne.n	20d9bc <oslib_test_003_001_execute+0x55c>
  20d9b8:	2301      	movs	r3, #1
  20d9ba:	e000      	b.n	20d9be <oslib_test_003_001_execute+0x55e>
  20d9bc:	2300      	movs	r3, #0
  20d9be:	f003 0301 	and.w	r3, r3, #1
  20d9c2:	b2db      	uxtb	r3, r3
  20d9c4:	494b      	ldr	r1, [pc, #300]	@ (20daf4 <oslib_test_003_001_execute+0x694>)
  20d9c6:	4618      	mov	r0, r3
  20d9c8:	f7f9 fe4a 	bl	207660 <__test_assert>
  20d9cc:	4603      	mov	r3, r0
  20d9ce:	2b00      	cmp	r3, #0
  20d9d0:	f040 808d 	bne.w	20daee <oslib_test_003_001_execute+0x68e>
                (pipe1.wrptr != pipe1.buffer) &&
                (pipe1.cnt == 0),
                "invalid pipe state");
    test_assert(memcmp(pipe_pattern, buf, 5) == 0, "content mismatch");
  20d9d4:	ab10      	add	r3, sp, #64	@ 0x40
  20d9d6:	2205      	movs	r2, #5
  20d9d8:	4619      	mov	r1, r3
  20d9da:	4847      	ldr	r0, [pc, #284]	@ (20daf8 <oslib_test_003_001_execute+0x698>)
  20d9dc:	f7f2 fd54 	bl	200488 <memcmp>
  20d9e0:	4603      	mov	r3, r0
  20d9e2:	2b00      	cmp	r3, #0
  20d9e4:	bf0c      	ite	eq
  20d9e6:	2301      	moveq	r3, #1
  20d9e8:	2300      	movne	r3, #0
  20d9ea:	b2db      	uxtb	r3, r3
  20d9ec:	4943      	ldr	r1, [pc, #268]	@ (20dafc <oslib_test_003_001_execute+0x69c>)
  20d9ee:	4618      	mov	r0, r3
  20d9f0:	f7f9 fe36 	bl	207660 <__test_assert>
  20d9f4:	4603      	mov	r3, r0
  20d9f6:	2b00      	cmp	r3, #0
  20d9f8:	d179      	bne.n	20daee <oslib_test_003_001_execute+0x68e>
  }
  test_end_step(12);

  /* [3.1.13] Write wrapping buffer boundary.*/
  test_set_step(13);
  20d9fa:	4b41      	ldr	r3, [pc, #260]	@ (20db00 <oslib_test_003_001_execute+0x6a0>)
  20d9fc:	220d      	movs	r2, #13
  20d9fe:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
  20da00:	2300      	movs	r3, #0
  20da02:	2210      	movs	r2, #16
  20da04:	493c      	ldr	r1, [pc, #240]	@ (20daf8 <oslib_test_003_001_execute+0x698>)
  20da06:	483f      	ldr	r0, [pc, #252]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20da08:	f7f8 fac2 	bl	205f90 <chPipeWriteTimeout>
  20da0c:	9019      	str	r0, [sp, #100]	@ 0x64
    test_assert(n == PIPE_SIZE, "wrong size");
  20da0e:	9b19      	ldr	r3, [sp, #100]	@ 0x64
  20da10:	2b10      	cmp	r3, #16
  20da12:	bf0c      	ite	eq
  20da14:	2301      	moveq	r3, #1
  20da16:	2300      	movne	r3, #0
  20da18:	b2db      	uxtb	r3, r3
  20da1a:	493b      	ldr	r1, [pc, #236]	@ (20db08 <oslib_test_003_001_execute+0x6a8>)
  20da1c:	4618      	mov	r0, r3
  20da1e:	f7f9 fe1f 	bl	207660 <__test_assert>
  20da22:	4603      	mov	r3, r0
  20da24:	2b00      	cmp	r3, #0
  20da26:	d162      	bne.n	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
  20da28:	4b36      	ldr	r3, [pc, #216]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20da2a:	68da      	ldr	r2, [r3, #12]
  20da2c:	4b35      	ldr	r3, [pc, #212]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20da2e:	689b      	ldr	r3, [r3, #8]
  20da30:	429a      	cmp	r2, r3
  20da32:	d10b      	bne.n	20da4c <oslib_test_003_001_execute+0x5ec>
  20da34:	4b33      	ldr	r3, [pc, #204]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20da36:	689a      	ldr	r2, [r3, #8]
  20da38:	4b32      	ldr	r3, [pc, #200]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20da3a:	681b      	ldr	r3, [r3, #0]
  20da3c:	429a      	cmp	r2, r3
  20da3e:	d005      	beq.n	20da4c <oslib_test_003_001_execute+0x5ec>
  20da40:	4b30      	ldr	r3, [pc, #192]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20da42:	691b      	ldr	r3, [r3, #16]
  20da44:	2b10      	cmp	r3, #16
  20da46:	d101      	bne.n	20da4c <oslib_test_003_001_execute+0x5ec>
  20da48:	2301      	movs	r3, #1
  20da4a:	e000      	b.n	20da4e <oslib_test_003_001_execute+0x5ee>
  20da4c:	2300      	movs	r3, #0
  20da4e:	f003 0301 	and.w	r3, r3, #1
  20da52:	b2db      	uxtb	r3, r3
  20da54:	4927      	ldr	r1, [pc, #156]	@ (20daf4 <oslib_test_003_001_execute+0x694>)
  20da56:	4618      	mov	r0, r3
  20da58:	f7f9 fe02 	bl	207660 <__test_assert>
  20da5c:	4603      	mov	r3, r0
  20da5e:	2b00      	cmp	r3, #0
  20da60:	d145      	bne.n	20daee <oslib_test_003_001_execute+0x68e>
                "invalid pipe state");
  }
  test_end_step(13);

  /* [3.1.14] Read wrapping buffer boundary.*/
  test_set_step(14);
  20da62:	4b27      	ldr	r3, [pc, #156]	@ (20db00 <oslib_test_003_001_execute+0x6a0>)
  20da64:	220e      	movs	r2, #14
  20da66:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
  20da68:	a914      	add	r1, sp, #80	@ 0x50
  20da6a:	2300      	movs	r3, #0
  20da6c:	2210      	movs	r2, #16
  20da6e:	4825      	ldr	r0, [pc, #148]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20da70:	f7f8 fade 	bl	206030 <chPipeReadTimeout>
  20da74:	9018      	str	r0, [sp, #96]	@ 0x60
    test_assert(n == PIPE_SIZE, "wrong size");
  20da76:	9b18      	ldr	r3, [sp, #96]	@ 0x60
  20da78:	2b10      	cmp	r3, #16
  20da7a:	bf0c      	ite	eq
  20da7c:	2301      	moveq	r3, #1
  20da7e:	2300      	movne	r3, #0
  20da80:	b2db      	uxtb	r3, r3
  20da82:	4921      	ldr	r1, [pc, #132]	@ (20db08 <oslib_test_003_001_execute+0x6a8>)
  20da84:	4618      	mov	r0, r3
  20da86:	f7f9 fdeb 	bl	207660 <__test_assert>
  20da8a:	4603      	mov	r3, r0
  20da8c:	2b00      	cmp	r3, #0
  20da8e:	d12e      	bne.n	20daee <oslib_test_003_001_execute+0x68e>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
  20da90:	4b1c      	ldr	r3, [pc, #112]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20da92:	68da      	ldr	r2, [r3, #12]
  20da94:	4b1b      	ldr	r3, [pc, #108]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20da96:	689b      	ldr	r3, [r3, #8]
  20da98:	429a      	cmp	r2, r3
  20da9a:	d10b      	bne.n	20dab4 <oslib_test_003_001_execute+0x654>
  20da9c:	4b19      	ldr	r3, [pc, #100]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20da9e:	689a      	ldr	r2, [r3, #8]
  20daa0:	4b18      	ldr	r3, [pc, #96]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20daa2:	681b      	ldr	r3, [r3, #0]
  20daa4:	429a      	cmp	r2, r3
  20daa6:	d005      	beq.n	20dab4 <oslib_test_003_001_execute+0x654>
  20daa8:	4b16      	ldr	r3, [pc, #88]	@ (20db04 <oslib_test_003_001_execute+0x6a4>)
  20daaa:	691b      	ldr	r3, [r3, #16]
  20daac:	2b00      	cmp	r3, #0
  20daae:	d101      	bne.n	20dab4 <oslib_test_003_001_execute+0x654>
  20dab0:	2301      	movs	r3, #1
  20dab2:	e000      	b.n	20dab6 <oslib_test_003_001_execute+0x656>
  20dab4:	2300      	movs	r3, #0
  20dab6:	f003 0301 	and.w	r3, r3, #1
  20daba:	b2db      	uxtb	r3, r3
  20dabc:	490d      	ldr	r1, [pc, #52]	@ (20daf4 <oslib_test_003_001_execute+0x694>)
  20dabe:	4618      	mov	r0, r3
  20dac0:	f7f9 fdce 	bl	207660 <__test_assert>
  20dac4:	4603      	mov	r3, r0
  20dac6:	2b00      	cmp	r3, #0
  20dac8:	d111      	bne.n	20daee <oslib_test_003_001_execute+0x68e>
                (pipe1.wrptr != pipe1.buffer) &&
                (pipe1.cnt == 0),
                "invalid pipe state");
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
  20daca:	ab14      	add	r3, sp, #80	@ 0x50
  20dacc:	2210      	movs	r2, #16
  20dace:	4619      	mov	r1, r3
  20dad0:	4809      	ldr	r0, [pc, #36]	@ (20daf8 <oslib_test_003_001_execute+0x698>)
  20dad2:	f7f2 fcd9 	bl	200488 <memcmp>
  20dad6:	4603      	mov	r3, r0
  20dad8:	2b00      	cmp	r3, #0
  20dada:	bf0c      	ite	eq
  20dadc:	2301      	moveq	r3, #1
  20dade:	2300      	movne	r3, #0
  20dae0:	b2db      	uxtb	r3, r3
  20dae2:	4906      	ldr	r1, [pc, #24]	@ (20dafc <oslib_test_003_001_execute+0x69c>)
  20dae4:	4618      	mov	r0, r3
  20dae6:	f7f9 fdbb 	bl	207660 <__test_assert>
  20daea:	4603      	mov	r3, r0
  20daec:	2b00      	cmp	r3, #0
  }
  test_end_step(14);
}
  20daee:	b025      	add	sp, #148	@ 0x94
  20daf0:	f85d fb04 	ldr.w	pc, [sp], #4
  20daf4:	08011f40 	.word	0x08011f40
  20daf8:	08012750 	.word	0x08012750
  20dafc:	08011f60 	.word	0x08011f60
  20db00:	20000bb4 	.word	0x20000bb4
  20db04:	20020058 	.word	0x20020058
  20db08:	08011e7c 	.word	0x08011e7c
  20db0c:	00000000 	.word	0x00000000

0020db10 <oslib_test_003_002_setup>:
 * - [3.2.1] Reading while pipe is empty.
 * - [3.2.2] Writing a string larger than pipe buffer.
 * .
 */

static void oslib_test_003_002_setup(void) {
  20db10:	b508      	push	{r3, lr}
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE / 2);
  20db12:	2208      	movs	r2, #8
  20db14:	4902      	ldr	r1, [pc, #8]	@ (20db20 <oslib_test_003_002_setup+0x10>)
  20db16:	4803      	ldr	r0, [pc, #12]	@ (20db24 <oslib_test_003_002_setup+0x14>)
  20db18:	f7f8 f9ca 	bl	205eb0 <chPipeObjectInit>
}
  20db1c:	bf00      	nop
  20db1e:	bd08      	pop	{r3, pc}
  20db20:	200019b4 	.word	0x200019b4
  20db24:	20020058 	.word	0x20020058
	...

0020db30 <oslib_test_003_002_execute>:

static void oslib_test_003_002_execute(void) {
  20db30:	b500      	push	{lr}
  20db32:	b087      	sub	sp, #28

  /* [3.2.1] Reading while pipe is empty.*/
  test_set_step(1);
  20db34:	4b34      	ldr	r3, [pc, #208]	@ (20dc08 <oslib_test_003_002_execute+0xd8>)
  20db36:	2201      	movs	r2, #1
  20db38:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
  20db3a:	4669      	mov	r1, sp
  20db3c:	2300      	movs	r3, #0
  20db3e:	2210      	movs	r2, #16
  20db40:	4832      	ldr	r0, [pc, #200]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20db42:	f7f8 fa75 	bl	206030 <chPipeReadTimeout>
  20db46:	9005      	str	r0, [sp, #20]
    test_assert(n == 0, "wrong size");
  20db48:	9b05      	ldr	r3, [sp, #20]
  20db4a:	2b00      	cmp	r3, #0
  20db4c:	bf0c      	ite	eq
  20db4e:	2301      	moveq	r3, #1
  20db50:	2300      	movne	r3, #0
  20db52:	b2db      	uxtb	r3, r3
  20db54:	492e      	ldr	r1, [pc, #184]	@ (20dc10 <oslib_test_003_002_execute+0xe0>)
  20db56:	4618      	mov	r0, r3
  20db58:	f7f9 fd82 	bl	207660 <__test_assert>
  20db5c:	4603      	mov	r3, r0
  20db5e:	2b00      	cmp	r3, #0
  20db60:	d14f      	bne.n	20dc02 <oslib_test_003_002_execute+0xd2>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
  20db62:	4b2a      	ldr	r3, [pc, #168]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20db64:	68da      	ldr	r2, [r3, #12]
  20db66:	4b29      	ldr	r3, [pc, #164]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20db68:	681b      	ldr	r3, [r3, #0]
  20db6a:	429a      	cmp	r2, r3
  20db6c:	d10b      	bne.n	20db86 <oslib_test_003_002_execute+0x56>
  20db6e:	4b27      	ldr	r3, [pc, #156]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20db70:	689a      	ldr	r2, [r3, #8]
  20db72:	4b26      	ldr	r3, [pc, #152]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20db74:	681b      	ldr	r3, [r3, #0]
  20db76:	429a      	cmp	r2, r3
  20db78:	d105      	bne.n	20db86 <oslib_test_003_002_execute+0x56>
  20db7a:	4b24      	ldr	r3, [pc, #144]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20db7c:	691b      	ldr	r3, [r3, #16]
  20db7e:	2b00      	cmp	r3, #0
  20db80:	d101      	bne.n	20db86 <oslib_test_003_002_execute+0x56>
  20db82:	2301      	movs	r3, #1
  20db84:	e000      	b.n	20db88 <oslib_test_003_002_execute+0x58>
  20db86:	2300      	movs	r3, #0
  20db88:	f003 0301 	and.w	r3, r3, #1
  20db8c:	b2db      	uxtb	r3, r3
  20db8e:	4921      	ldr	r1, [pc, #132]	@ (20dc14 <oslib_test_003_002_execute+0xe4>)
  20db90:	4618      	mov	r0, r3
  20db92:	f7f9 fd65 	bl	207660 <__test_assert>
  20db96:	4603      	mov	r3, r0
  20db98:	2b00      	cmp	r3, #0
  20db9a:	d132      	bne.n	20dc02 <oslib_test_003_002_execute+0xd2>
                "invalid pipe state");
  }
  test_end_step(1);

  /* [3.2.2] Writing a string larger than pipe buffer.*/
  test_set_step(2);
  20db9c:	4b1a      	ldr	r3, [pc, #104]	@ (20dc08 <oslib_test_003_002_execute+0xd8>)
  20db9e:	2202      	movs	r2, #2
  20dba0:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
  20dba2:	2300      	movs	r3, #0
  20dba4:	2210      	movs	r2, #16
  20dba6:	491c      	ldr	r1, [pc, #112]	@ (20dc18 <oslib_test_003_002_execute+0xe8>)
  20dba8:	4818      	ldr	r0, [pc, #96]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20dbaa:	f7f8 f9f1 	bl	205f90 <chPipeWriteTimeout>
  20dbae:	9004      	str	r0, [sp, #16]
    test_assert(n == PIPE_SIZE / 2, "wrong size");
  20dbb0:	9b04      	ldr	r3, [sp, #16]
  20dbb2:	2b08      	cmp	r3, #8
  20dbb4:	bf0c      	ite	eq
  20dbb6:	2301      	moveq	r3, #1
  20dbb8:	2300      	movne	r3, #0
  20dbba:	b2db      	uxtb	r3, r3
  20dbbc:	4914      	ldr	r1, [pc, #80]	@ (20dc10 <oslib_test_003_002_execute+0xe0>)
  20dbbe:	4618      	mov	r0, r3
  20dbc0:	f7f9 fd4e 	bl	207660 <__test_assert>
  20dbc4:	4603      	mov	r3, r0
  20dbc6:	2b00      	cmp	r3, #0
  20dbc8:	d11b      	bne.n	20dc02 <oslib_test_003_002_execute+0xd2>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
  20dbca:	4b10      	ldr	r3, [pc, #64]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20dbcc:	68da      	ldr	r2, [r3, #12]
  20dbce:	4b0f      	ldr	r3, [pc, #60]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20dbd0:	689b      	ldr	r3, [r3, #8]
  20dbd2:	429a      	cmp	r2, r3
  20dbd4:	d10b      	bne.n	20dbee <oslib_test_003_002_execute+0xbe>
  20dbd6:	4b0d      	ldr	r3, [pc, #52]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20dbd8:	689a      	ldr	r2, [r3, #8]
  20dbda:	4b0c      	ldr	r3, [pc, #48]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20dbdc:	681b      	ldr	r3, [r3, #0]
  20dbde:	429a      	cmp	r2, r3
  20dbe0:	d105      	bne.n	20dbee <oslib_test_003_002_execute+0xbe>
  20dbe2:	4b0a      	ldr	r3, [pc, #40]	@ (20dc0c <oslib_test_003_002_execute+0xdc>)
  20dbe4:	691b      	ldr	r3, [r3, #16]
  20dbe6:	2b08      	cmp	r3, #8
  20dbe8:	d101      	bne.n	20dbee <oslib_test_003_002_execute+0xbe>
  20dbea:	2301      	movs	r3, #1
  20dbec:	e000      	b.n	20dbf0 <oslib_test_003_002_execute+0xc0>
  20dbee:	2300      	movs	r3, #0
  20dbf0:	f003 0301 	and.w	r3, r3, #1
  20dbf4:	b2db      	uxtb	r3, r3
  20dbf6:	4907      	ldr	r1, [pc, #28]	@ (20dc14 <oslib_test_003_002_execute+0xe4>)
  20dbf8:	4618      	mov	r0, r3
  20dbfa:	f7f9 fd31 	bl	207660 <__test_assert>
  20dbfe:	4603      	mov	r3, r0
  20dc00:	2b00      	cmp	r3, #0
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == PIPE_SIZE / 2),
                "invalid pipe state");
  }
  test_end_step(2);
}
  20dc02:	b007      	add	sp, #28
  20dc04:	f85d fb04 	ldr.w	pc, [sp], #4
  20dc08:	20000bb4 	.word	0x20000bb4
  20dc0c:	20020058 	.word	0x20020058
  20dc10:	08011e7c 	.word	0x08011e7c
  20dc14:	08011f40 	.word	0x08011f40
  20dc18:	08012750 	.word	0x08012750
  20dc1c:	00000000 	.word	0x00000000

0020dc20 <chThdGetSelfX.lto_priv.14>:
  return __sch_get_currthread();
  20dc20:	4b01      	ldr	r3, [pc, #4]	@ (20dc28 <chThdGetSelfX.lto_priv.14+0x8>)
  20dc22:	68db      	ldr	r3, [r3, #12]
}
  20dc24:	4618      	mov	r0, r3
  20dc26:	4770      	bx	lr
  20dc28:	20000890 	.word	0x20000890
  20dc2c:	00000000 	.word	0x00000000

0020dc30 <chThdGetPriorityX.lto_priv.8>:
static inline tprio_t chThdGetPriorityX(void) {
  20dc30:	b508      	push	{r3, lr}
  return chThdGetSelfX()->hdr.pqueue.prio;
  20dc32:	f7ff fff5 	bl	20dc20 <chThdGetSelfX.lto_priv.14>
  20dc36:	4603      	mov	r3, r0
  20dc38:	689b      	ldr	r3, [r3, #8]
}
  20dc3a:	4618      	mov	r0, r3
  20dc3c:	bd08      	pop	{r3, pc}
  20dc3e:	bf00      	nop

0020dc40 <chGuardedPoolObjectInit.lto_priv.0>:
                                           size_t size) {
  20dc40:	b500      	push	{lr}
  20dc42:	b083      	sub	sp, #12
  20dc44:	9001      	str	r0, [sp, #4]
  20dc46:	9100      	str	r1, [sp, #0]
  chGuardedPoolObjectInitAligned(gmp, size, PORT_NATURAL_ALIGN);
  20dc48:	2204      	movs	r2, #4
  20dc4a:	9900      	ldr	r1, [sp, #0]
  20dc4c:	9801      	ldr	r0, [sp, #4]
  20dc4e:	f7f7 ff7f 	bl	205b50 <chGuardedPoolObjectInitAligned>
}
  20dc52:	bf00      	nop
  20dc54:	b003      	add	sp, #12
  20dc56:	f85d fb04 	ldr.w	pc, [sp], #4
  20dc5a:	bf00      	nop
  20dc5c:	0000      	movs	r0, r0
	...

0020dc60 <chJobObjectInit>:
 * @init
 */
static inline void chJobObjectInit(jobs_queue_t *jqp,
                                   size_t jobsn,
                                   job_descriptor_t *jobsbuf,
                                   msg_t *msgbuf) {
  20dc60:	b500      	push	{lr}
  20dc62:	b085      	sub	sp, #20
  20dc64:	9003      	str	r0, [sp, #12]
  20dc66:	9102      	str	r1, [sp, #8]
  20dc68:	9201      	str	r2, [sp, #4]
  20dc6a:	9300      	str	r3, [sp, #0]

  chDbgCheck((jobsn > 0U) && (jobsbuf != NULL) && (msgbuf != NULL));

  chGuardedPoolObjectInit(&jqp->free, sizeof (job_descriptor_t));
  20dc6c:	9b03      	ldr	r3, [sp, #12]
  20dc6e:	2108      	movs	r1, #8
  20dc70:	4618      	mov	r0, r3
  20dc72:	f7ff ffe5 	bl	20dc40 <chGuardedPoolObjectInit.lto_priv.0>
  chGuardedPoolLoadArray(&jqp->free, (void *)jobsbuf, jobsn);
  20dc76:	9b03      	ldr	r3, [sp, #12]
  20dc78:	9a02      	ldr	r2, [sp, #8]
  20dc7a:	9901      	ldr	r1, [sp, #4]
  20dc7c:	4618      	mov	r0, r3
  20dc7e:	f7f7 ff7f 	bl	205b80 <chGuardedPoolLoadArray>
  chMBObjectInit(&jqp->mbx, msgbuf, jobsn);
  20dc82:	9b03      	ldr	r3, [sp, #12]
  20dc84:	331c      	adds	r3, #28
  20dc86:	9a02      	ldr	r2, [sp, #8]
  20dc88:	9900      	ldr	r1, [sp, #0]
  20dc8a:	4618      	mov	r0, r3
  20dc8c:	f7f7 f948 	bl	204f20 <chMBObjectInit>
}
  20dc90:	bf00      	nop
  20dc92:	b005      	add	sp, #20
  20dc94:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0020dca0 <chJobGet>:
 * @param[in] jqp       pointer to a @p jobs_queue_t object
 * @return              The pointer to the allocated job object.
 *
 * @api
 */
static inline job_descriptor_t *chJobGet(jobs_queue_t *jqp) {
  20dca0:	b500      	push	{lr}
  20dca2:	b083      	sub	sp, #12
  20dca4:	9001      	str	r0, [sp, #4]

  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
  20dca6:	9b01      	ldr	r3, [sp, #4]
  20dca8:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
  20dcac:	4618      	mov	r0, r3
  20dcae:	f7f7 ffa7 	bl	205c00 <chGuardedPoolAllocTimeout>
  20dcb2:	4603      	mov	r3, r0
}
  20dcb4:	4618      	mov	r0, r3
  20dcb6:	b003      	add	sp, #12
  20dcb8:	f85d fb04 	ldr.w	pc, [sp], #4
  20dcbc:	0000      	movs	r0, r0
	...

0020dcc0 <chJobPost>:
 * @param[in] jqp       pointer to a @p jobs_queue_t object
 * @param[in] jp        pointer to the job object to be posted
 *
 * @api
 */
static inline void chJobPost(jobs_queue_t *jqp, job_descriptor_t *jp) {
  20dcc0:	b500      	push	{lr}
  20dcc2:	b085      	sub	sp, #20
  20dcc4:	9001      	str	r0, [sp, #4]
  20dcc6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
  20dcc8:	9b01      	ldr	r3, [sp, #4]
  20dcca:	331c      	adds	r3, #28
  20dccc:	9900      	ldr	r1, [sp, #0]
  20dcce:	2200      	movs	r2, #0
  20dcd0:	4618      	mov	r0, r3
  20dcd2:	f7f7 f985 	bl	204fe0 <chMBPostTimeout>
  20dcd6:	9003      	str	r0, [sp, #12]
  chDbgAssert(msg == MSG_OK, "post failed");
}
  20dcd8:	bf00      	nop
  20dcda:	b005      	add	sp, #20
  20dcdc:	f85d fb04 	ldr.w	pc, [sp], #4

0020dce0 <chJobDispatch>:
 * @return              The function outcome.
 * @retval MSG_OK       if a job has been executed.
 * @retval MSG_RESET    if the internal mailbox has been reset.
 * @retval MSG_JOB_NULL if a @p JOB_NULL has been received.
 */
static inline msg_t chJobDispatch(jobs_queue_t *jqp) {
  20dce0:	b500      	push	{lr}
  20dce2:	b087      	sub	sp, #28
  20dce4:	9001      	str	r0, [sp, #4]
  msg_t msg, jmsg;

  /* Waiting for a job.*/
  msg = chMBFetchTimeout(&jqp->mbx, &jmsg, TIME_INFINITE);
  20dce6:	9b01      	ldr	r3, [sp, #4]
  20dce8:	331c      	adds	r3, #28
  20dcea:	a903      	add	r1, sp, #12
  20dcec:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
  20dcf0:	4618      	mov	r0, r3
  20dcf2:	f7f7 faa5 	bl	205240 <chMBFetchTimeout>
  20dcf6:	9005      	str	r0, [sp, #20]
  if (msg == MSG_OK) {
  20dcf8:	9b05      	ldr	r3, [sp, #20]
  20dcfa:	2b00      	cmp	r3, #0
  20dcfc:	d114      	bne.n	20dd28 <chJobDispatch+0x48>
    job_descriptor_t *jp = (job_descriptor_t *)jmsg;
  20dcfe:	9b03      	ldr	r3, [sp, #12]
  20dd00:	9304      	str	r3, [sp, #16]

    chDbgAssert(jp != NULL, "is NULL");

    if (jp->jobfunc != NULL) {
  20dd02:	9b04      	ldr	r3, [sp, #16]
  20dd04:	681b      	ldr	r3, [r3, #0]
  20dd06:	2b00      	cmp	r3, #0
  20dd08:	d00b      	beq.n	20dd22 <chJobDispatch+0x42>

      /* Invoking the job function.*/
      jp->jobfunc(jp->jobarg);
  20dd0a:	9b04      	ldr	r3, [sp, #16]
  20dd0c:	681b      	ldr	r3, [r3, #0]
  20dd0e:	9a04      	ldr	r2, [sp, #16]
  20dd10:	6852      	ldr	r2, [r2, #4]
  20dd12:	4610      	mov	r0, r2
  20dd14:	4798      	blx	r3

      /* Returning the job descriptor object.*/
      chGuardedPoolFree(&jqp->free, (void *)jp);
  20dd16:	9b01      	ldr	r3, [sp, #4]
  20dd18:	9904      	ldr	r1, [sp, #16]
  20dd1a:	4618      	mov	r0, r3
  20dd1c:	f7f7 ff88 	bl	205c30 <chGuardedPoolFree>
  20dd20:	e002      	b.n	20dd28 <chJobDispatch+0x48>
    }
    else {
      msg = MSG_JOB_NULL;
  20dd22:	f06f 0301 	mvn.w	r3, #1
  20dd26:	9305      	str	r3, [sp, #20]
    }
  }

  return msg;
  20dd28:	9b05      	ldr	r3, [sp, #20]
}
  20dd2a:	4618      	mov	r0, r3
  20dd2c:	b007      	add	sp, #28
  20dd2e:	f85d fb04 	ldr.w	pc, [sp], #4
  20dd32:	bf00      	nop
	...

0020dd40 <job_slow>:

static jobs_queue_t jq;
static job_descriptor_t jobs[JOBS_QUEUE_SIZE];
static msg_t msg_queue[JOBS_QUEUE_SIZE];

static void job_slow(void *arg) {
  20dd40:	b500      	push	{lr}
  20dd42:	b083      	sub	sp, #12
  20dd44:	9001      	str	r0, [sp, #4]

  test_emit_token((int)arg);
  20dd46:	9b01      	ldr	r3, [sp, #4]
  20dd48:	b2db      	uxtb	r3, r3
  20dd4a:	4618      	mov	r0, r3
  20dd4c:	f7f9 fce8 	bl	207720 <test_emit_token>
  chThdSleepMilliseconds(10);
  20dd50:	2064      	movs	r0, #100	@ 0x64
  20dd52:	f7f5 fc4d 	bl	2035f0 <chThdSleep>
}
  20dd56:	bf00      	nop
  20dd58:	b003      	add	sp, #12
  20dd5a:	f85d fb04 	ldr.w	pc, [sp], #4
  20dd5e:	bf00      	nop

0020dd60 <Thread1.lto_priv.0>:

static THD_WORKING_AREA(wa1Thread1, 256);
static THD_WORKING_AREA(wa2Thread1, 256);
static THD_FUNCTION(Thread1, arg) {
  20dd60:	b500      	push	{lr}
  20dd62:	b085      	sub	sp, #20
  20dd64:	9001      	str	r0, [sp, #4]
  msg_t msg;

  (void)arg;

  do {
    msg = chJobDispatch(&jq);
  20dd66:	4806      	ldr	r0, [pc, #24]	@ (20dd80 <Thread1.lto_priv.0+0x20>)
  20dd68:	f7ff ffba 	bl	20dce0 <chJobDispatch>
  20dd6c:	9003      	str	r0, [sp, #12]
  } while (msg == MSG_OK);
  20dd6e:	9b03      	ldr	r3, [sp, #12]
  20dd70:	2b00      	cmp	r3, #0
  20dd72:	d0f8      	beq.n	20dd66 <Thread1.lto_priv.0+0x6>
}
  20dd74:	bf00      	nop
  20dd76:	bf00      	nop
  20dd78:	b005      	add	sp, #20
  20dd7a:	f85d fb04 	ldr.w	pc, [sp], #4
  20dd7e:	bf00      	nop
  20dd80:	200019c4 	.word	0x200019c4
	...

0020dd90 <oslib_test_004_001_execute>:
 * - [4.1.3] Sending jobs with various timings.
 * - [4.1.4] Sending two null jobs to make threads exit.
 * .
 */

static void oslib_test_004_001_execute(void) {
  20dd90:	b500      	push	{lr}
  20dd92:	b095      	sub	sp, #84	@ 0x54
  thread_t *tp1, *tp2;

  /* [4.1.1] Initializing the Jobs Queue object.*/
  test_set_step(1);
  20dd94:	4b45      	ldr	r3, [pc, #276]	@ (20deac <oslib_test_004_001_execute+0x11c>)
  20dd96:	2201      	movs	r2, #1
  20dd98:	601a      	str	r2, [r3, #0]
  {
    chJobObjectInit(&jq, JOBS_QUEUE_SIZE, jobs, msg_queue);
  20dd9a:	4b45      	ldr	r3, [pc, #276]	@ (20deb0 <oslib_test_004_001_execute+0x120>)
  20dd9c:	4a45      	ldr	r2, [pc, #276]	@ (20deb4 <oslib_test_004_001_execute+0x124>)
  20dd9e:	2104      	movs	r1, #4
  20dda0:	4845      	ldr	r0, [pc, #276]	@ (20deb8 <oslib_test_004_001_execute+0x128>)
  20dda2:	f7ff ff5d 	bl	20dc60 <chJobObjectInit>
  }
  test_end_step(1);

  /* [4.1.2] Starting the dispatcher threads.*/
  test_set_step(2);
  20dda6:	4b41      	ldr	r3, [pc, #260]	@ (20deac <oslib_test_004_001_execute+0x11c>)
  20dda8:	2202      	movs	r2, #2
  20ddaa:	601a      	str	r2, [r3, #0]
  {
    thread_descriptor_t td1 = {
  20ddac:	ab08      	add	r3, sp, #32
  20ddae:	2200      	movs	r2, #0
  20ddb0:	601a      	str	r2, [r3, #0]
  20ddb2:	605a      	str	r2, [r3, #4]
  20ddb4:	609a      	str	r2, [r3, #8]
  20ddb6:	60da      	str	r2, [r3, #12]
  20ddb8:	611a      	str	r2, [r3, #16]
  20ddba:	615a      	str	r2, [r3, #20]
  20ddbc:	619a      	str	r2, [r3, #24]
  20ddbe:	4b3f      	ldr	r3, [pc, #252]	@ (20debc <oslib_test_004_001_execute+0x12c>)
  20ddc0:	9308      	str	r3, [sp, #32]
  20ddc2:	4b3f      	ldr	r3, [pc, #252]	@ (20dec0 <oslib_test_004_001_execute+0x130>)
  20ddc4:	9309      	str	r3, [sp, #36]	@ 0x24
      .name  = "dispatcher1",
      .wbase = wa1Thread1,
      .wend  = THD_WORKING_AREA_END(wa1Thread1),
  20ddc6:	4b3f      	ldr	r3, [pc, #252]	@ (20dec4 <oslib_test_004_001_execute+0x134>)
    thread_descriptor_t td1 = {
  20ddc8:	930a      	str	r3, [sp, #40]	@ 0x28
      .prio  = chThdGetPriorityX() - 1,
  20ddca:	f7ff ff31 	bl	20dc30 <chThdGetPriorityX.lto_priv.8>
  20ddce:	4603      	mov	r3, r0
  20ddd0:	3b01      	subs	r3, #1
    thread_descriptor_t td1 = {
  20ddd2:	930b      	str	r3, [sp, #44]	@ 0x2c
  20ddd4:	4b3c      	ldr	r3, [pc, #240]	@ (20dec8 <oslib_test_004_001_execute+0x138>)
  20ddd6:	930c      	str	r3, [sp, #48]	@ 0x30
      .funcp = Thread1,
      .arg   = NULL
    };
    tp1 = chThdCreate(&td1);
  20ddd8:	ab08      	add	r3, sp, #32
  20ddda:	4618      	mov	r0, r3
  20dddc:	f7f5 fab8 	bl	203350 <chThdCreate>
  20dde0:	9012      	str	r0, [sp, #72]	@ 0x48

    thread_descriptor_t td2 = {
  20dde2:	ab01      	add	r3, sp, #4
  20dde4:	2200      	movs	r2, #0
  20dde6:	601a      	str	r2, [r3, #0]
  20dde8:	605a      	str	r2, [r3, #4]
  20ddea:	609a      	str	r2, [r3, #8]
  20ddec:	60da      	str	r2, [r3, #12]
  20ddee:	611a      	str	r2, [r3, #16]
  20ddf0:	615a      	str	r2, [r3, #20]
  20ddf2:	619a      	str	r2, [r3, #24]
  20ddf4:	4b35      	ldr	r3, [pc, #212]	@ (20decc <oslib_test_004_001_execute+0x13c>)
  20ddf6:	9301      	str	r3, [sp, #4]
  20ddf8:	4b35      	ldr	r3, [pc, #212]	@ (20ded0 <oslib_test_004_001_execute+0x140>)
  20ddfa:	9302      	str	r3, [sp, #8]
      .name  = "dispatcher2",
      .wbase = wa2Thread1,
      .wend  = THD_WORKING_AREA_END(wa2Thread1),
  20ddfc:	4b35      	ldr	r3, [pc, #212]	@ (20ded4 <oslib_test_004_001_execute+0x144>)
    thread_descriptor_t td2 = {
  20ddfe:	9303      	str	r3, [sp, #12]
      .prio  = chThdGetPriorityX() - 2,
  20de00:	f7ff ff16 	bl	20dc30 <chThdGetPriorityX.lto_priv.8>
  20de04:	4603      	mov	r3, r0
  20de06:	3b02      	subs	r3, #2
    thread_descriptor_t td2 = {
  20de08:	9304      	str	r3, [sp, #16]
  20de0a:	4b2f      	ldr	r3, [pc, #188]	@ (20dec8 <oslib_test_004_001_execute+0x138>)
  20de0c:	9305      	str	r3, [sp, #20]
      .funcp = Thread1,
      .arg   = NULL
    };
    tp2 = chThdCreate(&td2);
  20de0e:	ab01      	add	r3, sp, #4
  20de10:	4618      	mov	r0, r3
  20de12:	f7f5 fa9d 	bl	203350 <chThdCreate>
  20de16:	9011      	str	r0, [sp, #68]	@ 0x44
  }
  test_end_step(2);

  /* [4.1.3] Sending jobs with various timings.*/
  test_set_step(3);
  20de18:	4b24      	ldr	r3, [pc, #144]	@ (20deac <oslib_test_004_001_execute+0x11c>)
  20de1a:	2203      	movs	r2, #3
  20de1c:	601a      	str	r2, [r3, #0]
  {
    unsigned i;
    job_descriptor_t *jdp;

    for (i = 0; i < 8; i++) {
  20de1e:	2300      	movs	r3, #0
  20de20:	9313      	str	r3, [sp, #76]	@ 0x4c
  20de22:	e012      	b.n	20de4a <oslib_test_004_001_execute+0xba>
      jdp = chJobGet(&jq);
  20de24:	4824      	ldr	r0, [pc, #144]	@ (20deb8 <oslib_test_004_001_execute+0x128>)
  20de26:	f7ff ff3b 	bl	20dca0 <chJobGet>
  20de2a:	900f      	str	r0, [sp, #60]	@ 0x3c
      jdp->jobfunc = job_slow;
  20de2c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  20de2e:	4a2a      	ldr	r2, [pc, #168]	@ (20ded8 <oslib_test_004_001_execute+0x148>)
  20de30:	601a      	str	r2, [r3, #0]
      jdp->jobarg  = (void *)('a' + i);
  20de32:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
  20de34:	3361      	adds	r3, #97	@ 0x61
  20de36:	461a      	mov	r2, r3
  20de38:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  20de3a:	605a      	str	r2, [r3, #4]
      chJobPost(&jq, jdp);
  20de3c:	990f      	ldr	r1, [sp, #60]	@ 0x3c
  20de3e:	481e      	ldr	r0, [pc, #120]	@ (20deb8 <oslib_test_004_001_execute+0x128>)
  20de40:	f7ff ff3e 	bl	20dcc0 <chJobPost>
    for (i = 0; i < 8; i++) {
  20de44:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
  20de46:	3301      	adds	r3, #1
  20de48:	9313      	str	r3, [sp, #76]	@ 0x4c
  20de4a:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
  20de4c:	2b07      	cmp	r3, #7
  20de4e:	d9e9      	bls.n	20de24 <oslib_test_004_001_execute+0x94>
    }
  }
  test_end_step(3);

  /* [4.1.4] Sending two null jobs to make threads exit.*/
  test_set_step(4);
  20de50:	4b16      	ldr	r3, [pc, #88]	@ (20deac <oslib_test_004_001_execute+0x11c>)
  20de52:	2204      	movs	r2, #4
  20de54:	601a      	str	r2, [r3, #0]
  {
    job_descriptor_t *jdp;

    jdp = chJobGet(&jq);
  20de56:	4818      	ldr	r0, [pc, #96]	@ (20deb8 <oslib_test_004_001_execute+0x128>)
  20de58:	f7ff ff22 	bl	20dca0 <chJobGet>
  20de5c:	9010      	str	r0, [sp, #64]	@ 0x40
    jdp->jobfunc = NULL;
  20de5e:	9b10      	ldr	r3, [sp, #64]	@ 0x40
  20de60:	2200      	movs	r2, #0
  20de62:	601a      	str	r2, [r3, #0]
    jdp->jobarg  = NULL;
  20de64:	9b10      	ldr	r3, [sp, #64]	@ 0x40
  20de66:	2200      	movs	r2, #0
  20de68:	605a      	str	r2, [r3, #4]
    chJobPost(&jq, jdp);
  20de6a:	9910      	ldr	r1, [sp, #64]	@ 0x40
  20de6c:	4812      	ldr	r0, [pc, #72]	@ (20deb8 <oslib_test_004_001_execute+0x128>)
  20de6e:	f7ff ff27 	bl	20dcc0 <chJobPost>
    jdp = chJobGet(&jq);
  20de72:	4811      	ldr	r0, [pc, #68]	@ (20deb8 <oslib_test_004_001_execute+0x128>)
  20de74:	f7ff ff14 	bl	20dca0 <chJobGet>
  20de78:	9010      	str	r0, [sp, #64]	@ 0x40
    jdp->jobfunc = NULL;
  20de7a:	9b10      	ldr	r3, [sp, #64]	@ 0x40
  20de7c:	2200      	movs	r2, #0
  20de7e:	601a      	str	r2, [r3, #0]
    jdp->jobarg  = NULL;
  20de80:	9b10      	ldr	r3, [sp, #64]	@ 0x40
  20de82:	2200      	movs	r2, #0
  20de84:	605a      	str	r2, [r3, #4]
    chJobPost(&jq, jdp);
  20de86:	9910      	ldr	r1, [sp, #64]	@ 0x40
  20de88:	480b      	ldr	r0, [pc, #44]	@ (20deb8 <oslib_test_004_001_execute+0x128>)
  20de8a:	f7ff ff19 	bl	20dcc0 <chJobPost>
    (void) chThdWait(tp1);
  20de8e:	9812      	ldr	r0, [sp, #72]	@ 0x48
  20de90:	f7f5 fb46 	bl	203520 <chThdWait>
    (void) chThdWait(tp2);
  20de94:	9811      	ldr	r0, [sp, #68]	@ 0x44
  20de96:	f7f5 fb43 	bl	203520 <chThdWait>
    test_assert_sequence("abcdefgh", "unexpected tokens");
  20de9a:	4910      	ldr	r1, [pc, #64]	@ (20dedc <oslib_test_004_001_execute+0x14c>)
  20de9c:	4810      	ldr	r0, [pc, #64]	@ (20dee0 <oslib_test_004_001_execute+0x150>)
  20de9e:	f7f9 fbf7 	bl	207690 <__test_assert_sequence>
  20dea2:	4603      	mov	r3, r0
  20dea4:	2b00      	cmp	r3, #0
  }
  test_end_step(4);
}
  20dea6:	b015      	add	sp, #84	@ 0x54
  20dea8:	f85d fb04 	ldr.w	pc, [sp], #4
  20deac:	20000bb4 	.word	0x20000bb4
  20deb0:	20001a28 	.word	0x20001a28
  20deb4:	20001a08 	.word	0x20001a08
  20deb8:	200019c4 	.word	0x200019c4
  20debc:	08011f74 	.word	0x08011f74
  20dec0:	20001a40 	.word	0x20001a40
  20dec4:	20001d20 	.word	0x20001d20
  20dec8:	0020dd61 	.word	0x0020dd61
  20decc:	08011f80 	.word	0x08011f80
  20ded0:	20001d20 	.word	0x20001d20
  20ded4:	20002000 	.word	0x20002000
  20ded8:	0020dd41 	.word	0x0020dd41
  20dedc:	08011f8c 	.word	0x08011f8c
  20dee0:	08011fa0 	.word	0x08011fa0
	...

0020def0 <chThdGetSelfX.lto_priv.15>:
  return __sch_get_currthread();
  20def0:	4b01      	ldr	r3, [pc, #4]	@ (20def8 <chThdGetSelfX.lto_priv.15+0x8>)
  20def2:	68db      	ldr	r3, [r3, #12]
}
  20def4:	4618      	mov	r0, r3
  20def6:	4770      	bx	lr
  20def8:	20000890 	.word	0x20000890
  20defc:	00000000 	.word	0x00000000

0020df00 <chThdGetPriorityX.lto_priv.9>:
static inline tprio_t chThdGetPriorityX(void) {
  20df00:	b508      	push	{r3, lr}
  return chThdGetSelfX()->hdr.pqueue.prio;
  20df02:	f7ff fff5 	bl	20def0 <chThdGetSelfX.lto_priv.15>
  20df06:	4603      	mov	r3, r0
  20df08:	689b      	ldr	r3, [r3, #8]
}
  20df0a:	4618      	mov	r0, r3
  20df0c:	bd08      	pop	{r3, pc}
  20df0e:	bf00      	nop

0020df10 <chDelegateCallDirect0>:
 *
 * @param[in] tp        pointer to the delegate thread
 * @param[in] func      pointer to the function to be called
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect0(thread_t *tp, delegate_fn0_t func) {
  20df10:	b500      	push	{lr}
  20df12:	b083      	sub	sp, #12
  20df14:	9001      	str	r0, [sp, #4]
  20df16:	9100      	str	r1, [sp, #0]

  return chDelegateCallVeneer(tp, __ch_delegate_fn0, func);
  20df18:	9a00      	ldr	r2, [sp, #0]
  20df1a:	4904      	ldr	r1, [pc, #16]	@ (20df2c <chDelegateCallDirect0+0x1c>)
  20df1c:	9801      	ldr	r0, [sp, #4]
  20df1e:	f7f8 fc27 	bl	206770 <chDelegateCallVeneer>
  20df22:	4603      	mov	r3, r0
}
  20df24:	4618      	mov	r0, r3
  20df26:	b003      	add	sp, #12
  20df28:	f85d fb04 	ldr.w	pc, [sp], #4
  20df2c:	002065f1 	.word	0x002065f1

0020df30 <chDelegateCallDirect1>:
 * @param[in] func      pointer to the function to be called
 * @param[in] p1        parameter 1 passed as a @p msg_t
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect1(thread_t *tp, delegate_fn1_t func,
                                          msg_t p1) {
  20df30:	b500      	push	{lr}
  20df32:	b085      	sub	sp, #20
  20df34:	9003      	str	r0, [sp, #12]
  20df36:	9102      	str	r1, [sp, #8]
  20df38:	9201      	str	r2, [sp, #4]

  return chDelegateCallVeneer(tp, __ch_delegate_fn1, func, p1);
  20df3a:	9b01      	ldr	r3, [sp, #4]
  20df3c:	9a02      	ldr	r2, [sp, #8]
  20df3e:	4904      	ldr	r1, [pc, #16]	@ (20df50 <chDelegateCallDirect1+0x20>)
  20df40:	9803      	ldr	r0, [sp, #12]
  20df42:	f7f8 fc15 	bl	206770 <chDelegateCallVeneer>
  20df46:	4603      	mov	r3, r0
}
  20df48:	4618      	mov	r0, r3
  20df4a:	b005      	add	sp, #20
  20df4c:	f85d fb04 	ldr.w	pc, [sp], #4
  20df50:	00206621 	.word	0x00206621
	...

0020df60 <chDelegateCallDirect2>:
 * @param[in] p1        parameter 1 passed as a @p msg_t
 * @param[in] p2        parameter 2 passed as a @p msg_t
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect2(thread_t *tp, delegate_fn2_t func,
                                          msg_t p1, msg_t p2) {
  20df60:	b500      	push	{lr}
  20df62:	b087      	sub	sp, #28
  20df64:	9005      	str	r0, [sp, #20]
  20df66:	9104      	str	r1, [sp, #16]
  20df68:	9203      	str	r2, [sp, #12]
  20df6a:	9302      	str	r3, [sp, #8]

  return chDelegateCallVeneer(tp, __ch_delegate_fn2, func, p1, p2);
  20df6c:	9b02      	ldr	r3, [sp, #8]
  20df6e:	9300      	str	r3, [sp, #0]
  20df70:	9b03      	ldr	r3, [sp, #12]
  20df72:	9a04      	ldr	r2, [sp, #16]
  20df74:	4904      	ldr	r1, [pc, #16]	@ (20df88 <chDelegateCallDirect2+0x28>)
  20df76:	9805      	ldr	r0, [sp, #20]
  20df78:	f7f8 fbfa 	bl	206770 <chDelegateCallVeneer>
  20df7c:	4603      	mov	r3, r0
}
  20df7e:	4618      	mov	r0, r3
  20df80:	b007      	add	sp, #28
  20df82:	f85d fb04 	ldr.w	pc, [sp], #4
  20df86:	bf00      	nop
  20df88:	00206661 	.word	0x00206661
  20df8c:	00000000 	.word	0x00000000

0020df90 <chDelegateCallDirect3>:
 * @param[in] p2        parameter 2 passed as a @p msg_t
 * @param[in] p3        parameter 3 passed as a @p msg_t
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect3(thread_t *tp, delegate_fn3_t func,
                                          msg_t p1, msg_t p2, msg_t p3) {
  20df90:	b500      	push	{lr}
  20df92:	b087      	sub	sp, #28
  20df94:	9005      	str	r0, [sp, #20]
  20df96:	9104      	str	r1, [sp, #16]
  20df98:	9203      	str	r2, [sp, #12]
  20df9a:	9302      	str	r3, [sp, #8]

  return chDelegateCallVeneer(tp, __ch_delegate_fn3, func, p1, p2, p3);
  20df9c:	9b08      	ldr	r3, [sp, #32]
  20df9e:	9301      	str	r3, [sp, #4]
  20dfa0:	9b02      	ldr	r3, [sp, #8]
  20dfa2:	9300      	str	r3, [sp, #0]
  20dfa4:	9b03      	ldr	r3, [sp, #12]
  20dfa6:	9a04      	ldr	r2, [sp, #16]
  20dfa8:	4904      	ldr	r1, [pc, #16]	@ (20dfbc <chDelegateCallDirect3+0x2c>)
  20dfaa:	9805      	ldr	r0, [sp, #20]
  20dfac:	f7f8 fbe0 	bl	206770 <chDelegateCallVeneer>
  20dfb0:	4603      	mov	r3, r0
}
  20dfb2:	4618      	mov	r0, r3
  20dfb4:	b007      	add	sp, #28
  20dfb6:	f85d fb04 	ldr.w	pc, [sp], #4
  20dfba:	bf00      	nop
  20dfbc:	002066b1 	.word	0x002066b1

0020dfc0 <chDelegateCallDirect4>:
 * @param[in] p4        parameter 4 passed as a @p msg_t
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect4(thread_t *tp, delegate_fn4_t func,
                                          msg_t p1, msg_t p2, msg_t p3,
                                          msg_t p4) {
  20dfc0:	b500      	push	{lr}
  20dfc2:	b089      	sub	sp, #36	@ 0x24
  20dfc4:	9007      	str	r0, [sp, #28]
  20dfc6:	9106      	str	r1, [sp, #24]
  20dfc8:	9205      	str	r2, [sp, #20]
  20dfca:	9304      	str	r3, [sp, #16]

  return chDelegateCallVeneer(tp, __ch_delegate_fn4, func, p1, p2, p3, p4);
  20dfcc:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  20dfce:	9302      	str	r3, [sp, #8]
  20dfd0:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20dfd2:	9301      	str	r3, [sp, #4]
  20dfd4:	9b04      	ldr	r3, [sp, #16]
  20dfd6:	9300      	str	r3, [sp, #0]
  20dfd8:	9b05      	ldr	r3, [sp, #20]
  20dfda:	9a06      	ldr	r2, [sp, #24]
  20dfdc:	4904      	ldr	r1, [pc, #16]	@ (20dff0 <chDelegateCallDirect4+0x30>)
  20dfde:	9807      	ldr	r0, [sp, #28]
  20dfe0:	f7f8 fbc6 	bl	206770 <chDelegateCallVeneer>
  20dfe4:	4603      	mov	r3, r0
}
  20dfe6:	4618      	mov	r0, r3
  20dfe8:	b009      	add	sp, #36	@ 0x24
  20dfea:	f85d fb04 	ldr.w	pc, [sp], #4
  20dfee:	bf00      	nop
  20dff0:	00206711 	.word	0x00206711
	...

0020e000 <dis_func0>:
 * Shared code.
 ****************************************************************************/

static bool exit_flag;

static int dis_func0(void) {
  20e000:	b508      	push	{r3, lr}

  test_emit_token('0');
  20e002:	2030      	movs	r0, #48	@ 0x30
  20e004:	f7f9 fb8c 	bl	207720 <test_emit_token>

  return (msg_t)0x55AA;
  20e008:	f245 53aa 	movw	r3, #21930	@ 0x55aa
}
  20e00c:	4618      	mov	r0, r3
  20e00e:	bd08      	pop	{r3, pc}

0020e010 <dis_func1>:

static msg_t dis_func1(msg_t a) {
  20e010:	b500      	push	{lr}
  20e012:	b083      	sub	sp, #12
  20e014:	9001      	str	r0, [sp, #4]

  test_emit_token((char)a);
  20e016:	9b01      	ldr	r3, [sp, #4]
  20e018:	b2db      	uxtb	r3, r3
  20e01a:	4618      	mov	r0, r3
  20e01c:	f7f9 fb80 	bl	207720 <test_emit_token>

  return (msg_t)a;
  20e020:	9b01      	ldr	r3, [sp, #4]
}
  20e022:	4618      	mov	r0, r3
  20e024:	b003      	add	sp, #12
  20e026:	f85d fb04 	ldr.w	pc, [sp], #4
  20e02a:	bf00      	nop
  20e02c:	0000      	movs	r0, r0
	...

0020e030 <dis_func2>:

static msg_t dis_func2(msg_t a, msg_t b) {
  20e030:	b500      	push	{lr}
  20e032:	b083      	sub	sp, #12
  20e034:	9001      	str	r0, [sp, #4]
  20e036:	9100      	str	r1, [sp, #0]

  test_emit_token((char)a);
  20e038:	9b01      	ldr	r3, [sp, #4]
  20e03a:	b2db      	uxtb	r3, r3
  20e03c:	4618      	mov	r0, r3
  20e03e:	f7f9 fb6f 	bl	207720 <test_emit_token>
  test_emit_token((char)b);
  20e042:	9b00      	ldr	r3, [sp, #0]
  20e044:	b2db      	uxtb	r3, r3
  20e046:	4618      	mov	r0, r3
  20e048:	f7f9 fb6a 	bl	207720 <test_emit_token>

  return (msg_t)a;
  20e04c:	9b01      	ldr	r3, [sp, #4]
}
  20e04e:	4618      	mov	r0, r3
  20e050:	b003      	add	sp, #12
  20e052:	f85d fb04 	ldr.w	pc, [sp], #4
  20e056:	bf00      	nop
	...

0020e060 <dis_func3>:

static msg_t dis_func3(msg_t a, msg_t b, msg_t c) {
  20e060:	b500      	push	{lr}
  20e062:	b085      	sub	sp, #20
  20e064:	9003      	str	r0, [sp, #12]
  20e066:	9102      	str	r1, [sp, #8]
  20e068:	9201      	str	r2, [sp, #4]

  test_emit_token((char)a);
  20e06a:	9b03      	ldr	r3, [sp, #12]
  20e06c:	b2db      	uxtb	r3, r3
  20e06e:	4618      	mov	r0, r3
  20e070:	f7f9 fb56 	bl	207720 <test_emit_token>
  test_emit_token((char)b);
  20e074:	9b02      	ldr	r3, [sp, #8]
  20e076:	b2db      	uxtb	r3, r3
  20e078:	4618      	mov	r0, r3
  20e07a:	f7f9 fb51 	bl	207720 <test_emit_token>
  test_emit_token((char)c);
  20e07e:	9b01      	ldr	r3, [sp, #4]
  20e080:	b2db      	uxtb	r3, r3
  20e082:	4618      	mov	r0, r3
  20e084:	f7f9 fb4c 	bl	207720 <test_emit_token>

  return (msg_t)a;
  20e088:	9b03      	ldr	r3, [sp, #12]
}
  20e08a:	4618      	mov	r0, r3
  20e08c:	b005      	add	sp, #20
  20e08e:	f85d fb04 	ldr.w	pc, [sp], #4
  20e092:	bf00      	nop
	...

0020e0a0 <dis_func4>:

static msg_t dis_func4(msg_t a, msg_t b, msg_t c, msg_t d) {
  20e0a0:	b500      	push	{lr}
  20e0a2:	b085      	sub	sp, #20
  20e0a4:	9003      	str	r0, [sp, #12]
  20e0a6:	9102      	str	r1, [sp, #8]
  20e0a8:	9201      	str	r2, [sp, #4]
  20e0aa:	9300      	str	r3, [sp, #0]

  test_emit_token((char)a);
  20e0ac:	9b03      	ldr	r3, [sp, #12]
  20e0ae:	b2db      	uxtb	r3, r3
  20e0b0:	4618      	mov	r0, r3
  20e0b2:	f7f9 fb35 	bl	207720 <test_emit_token>
  test_emit_token((char)b);
  20e0b6:	9b02      	ldr	r3, [sp, #8]
  20e0b8:	b2db      	uxtb	r3, r3
  20e0ba:	4618      	mov	r0, r3
  20e0bc:	f7f9 fb30 	bl	207720 <test_emit_token>
  test_emit_token((char)c);
  20e0c0:	9b01      	ldr	r3, [sp, #4]
  20e0c2:	b2db      	uxtb	r3, r3
  20e0c4:	4618      	mov	r0, r3
  20e0c6:	f7f9 fb2b 	bl	207720 <test_emit_token>
  test_emit_token((char)d);
  20e0ca:	9b00      	ldr	r3, [sp, #0]
  20e0cc:	b2db      	uxtb	r3, r3
  20e0ce:	4618      	mov	r0, r3
  20e0d0:	f7f9 fb26 	bl	207720 <test_emit_token>

  return (msg_t)a;
  20e0d4:	9b03      	ldr	r3, [sp, #12]
}
  20e0d6:	4618      	mov	r0, r3
  20e0d8:	b005      	add	sp, #20
  20e0da:	f85d fb04 	ldr.w	pc, [sp], #4
  20e0de:	bf00      	nop

0020e0e0 <dis_func_end>:

static int dis_func_end(void) {
  20e0e0:	b508      	push	{r3, lr}

  test_emit_token('Z');
  20e0e2:	205a      	movs	r0, #90	@ 0x5a
  20e0e4:	f7f9 fb1c 	bl	207720 <test_emit_token>
  exit_flag = true;
  20e0e8:	4b03      	ldr	r3, [pc, #12]	@ (20e0f8 <dis_func_end+0x18>)
  20e0ea:	2201      	movs	r2, #1
  20e0ec:	701a      	strb	r2, [r3, #0]

  return (msg_t)0xAA55;
  20e0ee:	f64a 2355 	movw	r3, #43605	@ 0xaa55
}
  20e0f2:	4618      	mov	r0, r3
  20e0f4:	bd08      	pop	{r3, pc}
  20e0f6:	bf00      	nop
  20e0f8:	20002000 	.word	0x20002000
  20e0fc:	00000000 	.word	0x00000000

0020e100 <Thread1.lto_priv.1>:

static THD_WORKING_AREA(waThread1, 256);
static THD_FUNCTION(Thread1, arg) {
  20e100:	b500      	push	{lr}
  20e102:	b083      	sub	sp, #12
  20e104:	9001      	str	r0, [sp, #4]

  (void)arg;

  exit_flag = false;
  20e106:	4b0a      	ldr	r3, [pc, #40]	@ (20e130 <Thread1.lto_priv.1+0x30>)
  20e108:	2200      	movs	r2, #0
  20e10a:	701a      	strb	r2, [r3, #0]
  do {
    chDelegateDispatch();
  20e10c:	f7f8 fb48 	bl	2067a0 <chDelegateDispatch>
  } while (!exit_flag);
  20e110:	4b07      	ldr	r3, [pc, #28]	@ (20e130 <Thread1.lto_priv.1+0x30>)
  20e112:	781b      	ldrb	r3, [r3, #0]
  20e114:	f083 0301 	eor.w	r3, r3, #1
  20e118:	b2db      	uxtb	r3, r3
  20e11a:	2b00      	cmp	r3, #0
  20e11c:	d1f6      	bne.n	20e10c <Thread1.lto_priv.1+0xc>

  chThdExit(0x0FA5);
  20e11e:	f640 70a5 	movw	r0, #4005	@ 0xfa5
  20e122:	f7f5 f9b5 	bl	203490 <chThdExit>
}
  20e126:	bf00      	nop
  20e128:	b003      	add	sp, #12
  20e12a:	f85d fb04 	ldr.w	pc, [sp], #4
  20e12e:	bf00      	nop
  20e130:	20002000 	.word	0x20002000
	...

0020e140 <oslib_test_005_001_execute>:
 *   emitted tokens.
 * - [5.1.3] Waiting for the thread to terminate-.
 * .
 */

static void oslib_test_005_001_execute(void) {
  20e140:	b500      	push	{lr}
  20e142:	b08d      	sub	sp, #52	@ 0x34
  thread_t *tp;

  /* [5.1.1] Starting the dispatcher thread.*/
  test_set_step(1);
  20e144:	4b5e      	ldr	r3, [pc, #376]	@ (20e2c0 <oslib_test_005_001_execute+0x180>)
  20e146:	2201      	movs	r2, #1
  20e148:	601a      	str	r2, [r3, #0]
  {
    thread_descriptor_t td = {
  20e14a:	ab02      	add	r3, sp, #8
  20e14c:	2200      	movs	r2, #0
  20e14e:	601a      	str	r2, [r3, #0]
  20e150:	605a      	str	r2, [r3, #4]
  20e152:	609a      	str	r2, [r3, #8]
  20e154:	60da      	str	r2, [r3, #12]
  20e156:	611a      	str	r2, [r3, #16]
  20e158:	615a      	str	r2, [r3, #20]
  20e15a:	619a      	str	r2, [r3, #24]
  20e15c:	4b59      	ldr	r3, [pc, #356]	@ (20e2c4 <oslib_test_005_001_execute+0x184>)
  20e15e:	9302      	str	r3, [sp, #8]
  20e160:	4b59      	ldr	r3, [pc, #356]	@ (20e2c8 <oslib_test_005_001_execute+0x188>)
  20e162:	9303      	str	r3, [sp, #12]
      .name  = "dispatcher",
      .wbase = waThread1,
      .wend  = THD_WORKING_AREA_END(waThread1),
  20e164:	4b59      	ldr	r3, [pc, #356]	@ (20e2cc <oslib_test_005_001_execute+0x18c>)
    thread_descriptor_t td = {
  20e166:	9304      	str	r3, [sp, #16]
      .prio  = chThdGetPriorityX() + 1,
  20e168:	f7ff feca 	bl	20df00 <chThdGetPriorityX.lto_priv.9>
  20e16c:	4603      	mov	r3, r0
  20e16e:	3301      	adds	r3, #1
    thread_descriptor_t td = {
  20e170:	9305      	str	r3, [sp, #20]
  20e172:	4b57      	ldr	r3, [pc, #348]	@ (20e2d0 <oslib_test_005_001_execute+0x190>)
  20e174:	9306      	str	r3, [sp, #24]
      .funcp = Thread1,
      .arg   = NULL
    };
    tp = chThdCreate(&td);
  20e176:	ab02      	add	r3, sp, #8
  20e178:	4618      	mov	r0, r3
  20e17a:	f7f5 f8e9 	bl	203350 <chThdCreate>
  20e17e:	900b      	str	r0, [sp, #44]	@ 0x2c
  }
  test_end_step(1);

  /* [5.1.2] Calling the default veneers, checking the result and the
     emitted tokens.*/
  test_set_step(2);
  20e180:	4b4f      	ldr	r3, [pc, #316]	@ (20e2c0 <oslib_test_005_001_execute+0x180>)
  20e182:	2202      	movs	r2, #2
  20e184:	601a      	str	r2, [r3, #0]
  {
    int retval;

    retval = chDelegateCallDirect0(tp, (delegate_fn0_t)dis_func0);
  20e186:	4953      	ldr	r1, [pc, #332]	@ (20e2d4 <oslib_test_005_001_execute+0x194>)
  20e188:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  20e18a:	f7ff fec1 	bl	20df10 <chDelegateCallDirect0>
  20e18e:	900a      	str	r0, [sp, #40]	@ 0x28
    test_assert(retval == 0x55AA, "invalid return value");
  20e190:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20e192:	f245 52aa 	movw	r2, #21930	@ 0x55aa
  20e196:	4293      	cmp	r3, r2
  20e198:	bf0c      	ite	eq
  20e19a:	2301      	moveq	r3, #1
  20e19c:	2300      	movne	r3, #0
  20e19e:	b2db      	uxtb	r3, r3
  20e1a0:	494d      	ldr	r1, [pc, #308]	@ (20e2d8 <oslib_test_005_001_execute+0x198>)
  20e1a2:	4618      	mov	r0, r3
  20e1a4:	f7f9 fa5c 	bl	207660 <__test_assert>
  20e1a8:	4603      	mov	r3, r0
  20e1aa:	2b00      	cmp	r3, #0
  20e1ac:	f040 8085 	bne.w	20e2ba <oslib_test_005_001_execute+0x17a>

    retval = chDelegateCallDirect1(tp, (delegate_fn1_t)dis_func1, 'A');
  20e1b0:	2241      	movs	r2, #65	@ 0x41
  20e1b2:	494a      	ldr	r1, [pc, #296]	@ (20e2dc <oslib_test_005_001_execute+0x19c>)
  20e1b4:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  20e1b6:	f7ff febb 	bl	20df30 <chDelegateCallDirect1>
  20e1ba:	900a      	str	r0, [sp, #40]	@ 0x28
    test_assert(retval == (int)'A', "invalid return value");
  20e1bc:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20e1be:	2b41      	cmp	r3, #65	@ 0x41
  20e1c0:	bf0c      	ite	eq
  20e1c2:	2301      	moveq	r3, #1
  20e1c4:	2300      	movne	r3, #0
  20e1c6:	b2db      	uxtb	r3, r3
  20e1c8:	4943      	ldr	r1, [pc, #268]	@ (20e2d8 <oslib_test_005_001_execute+0x198>)
  20e1ca:	4618      	mov	r0, r3
  20e1cc:	f7f9 fa48 	bl	207660 <__test_assert>
  20e1d0:	4603      	mov	r3, r0
  20e1d2:	2b00      	cmp	r3, #0
  20e1d4:	d171      	bne.n	20e2ba <oslib_test_005_001_execute+0x17a>

    retval = chDelegateCallDirect2(tp, (delegate_fn2_t)dis_func2, 'B', 'C');
  20e1d6:	2343      	movs	r3, #67	@ 0x43
  20e1d8:	2242      	movs	r2, #66	@ 0x42
  20e1da:	4941      	ldr	r1, [pc, #260]	@ (20e2e0 <oslib_test_005_001_execute+0x1a0>)
  20e1dc:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  20e1de:	f7ff febf 	bl	20df60 <chDelegateCallDirect2>
  20e1e2:	900a      	str	r0, [sp, #40]	@ 0x28
    test_assert(retval == (int)'B', "invalid return value");
  20e1e4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20e1e6:	2b42      	cmp	r3, #66	@ 0x42
  20e1e8:	bf0c      	ite	eq
  20e1ea:	2301      	moveq	r3, #1
  20e1ec:	2300      	movne	r3, #0
  20e1ee:	b2db      	uxtb	r3, r3
  20e1f0:	4939      	ldr	r1, [pc, #228]	@ (20e2d8 <oslib_test_005_001_execute+0x198>)
  20e1f2:	4618      	mov	r0, r3
  20e1f4:	f7f9 fa34 	bl	207660 <__test_assert>
  20e1f8:	4603      	mov	r3, r0
  20e1fa:	2b00      	cmp	r3, #0
  20e1fc:	d15d      	bne.n	20e2ba <oslib_test_005_001_execute+0x17a>

    retval = chDelegateCallDirect3(tp, (delegate_fn3_t)dis_func3, 'D', 'E', 'F');
  20e1fe:	2346      	movs	r3, #70	@ 0x46
  20e200:	9300      	str	r3, [sp, #0]
  20e202:	2345      	movs	r3, #69	@ 0x45
  20e204:	2244      	movs	r2, #68	@ 0x44
  20e206:	4937      	ldr	r1, [pc, #220]	@ (20e2e4 <oslib_test_005_001_execute+0x1a4>)
  20e208:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  20e20a:	f7ff fec1 	bl	20df90 <chDelegateCallDirect3>
  20e20e:	900a      	str	r0, [sp, #40]	@ 0x28
    test_assert(retval == (int)'D', "invalid return value");
  20e210:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20e212:	2b44      	cmp	r3, #68	@ 0x44
  20e214:	bf0c      	ite	eq
  20e216:	2301      	moveq	r3, #1
  20e218:	2300      	movne	r3, #0
  20e21a:	b2db      	uxtb	r3, r3
  20e21c:	492e      	ldr	r1, [pc, #184]	@ (20e2d8 <oslib_test_005_001_execute+0x198>)
  20e21e:	4618      	mov	r0, r3
  20e220:	f7f9 fa1e 	bl	207660 <__test_assert>
  20e224:	4603      	mov	r3, r0
  20e226:	2b00      	cmp	r3, #0
  20e228:	d147      	bne.n	20e2ba <oslib_test_005_001_execute+0x17a>

    retval = chDelegateCallDirect4(tp, (delegate_fn4_t)dis_func4, 'G', 'H', 'I', 'J');
  20e22a:	234a      	movs	r3, #74	@ 0x4a
  20e22c:	9301      	str	r3, [sp, #4]
  20e22e:	2349      	movs	r3, #73	@ 0x49
  20e230:	9300      	str	r3, [sp, #0]
  20e232:	2348      	movs	r3, #72	@ 0x48
  20e234:	2247      	movs	r2, #71	@ 0x47
  20e236:	492c      	ldr	r1, [pc, #176]	@ (20e2e8 <oslib_test_005_001_execute+0x1a8>)
  20e238:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  20e23a:	f7ff fec1 	bl	20dfc0 <chDelegateCallDirect4>
  20e23e:	900a      	str	r0, [sp, #40]	@ 0x28
    test_assert(retval == (int)'G', "invalid return value");
  20e240:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20e242:	2b47      	cmp	r3, #71	@ 0x47
  20e244:	bf0c      	ite	eq
  20e246:	2301      	moveq	r3, #1
  20e248:	2300      	movne	r3, #0
  20e24a:	b2db      	uxtb	r3, r3
  20e24c:	4922      	ldr	r1, [pc, #136]	@ (20e2d8 <oslib_test_005_001_execute+0x198>)
  20e24e:	4618      	mov	r0, r3
  20e250:	f7f9 fa06 	bl	207660 <__test_assert>
  20e254:	4603      	mov	r3, r0
  20e256:	2b00      	cmp	r3, #0
  20e258:	d12f      	bne.n	20e2ba <oslib_test_005_001_execute+0x17a>

    retval = chDelegateCallDirect0(tp, (delegate_fn0_t)dis_func_end);
  20e25a:	4924      	ldr	r1, [pc, #144]	@ (20e2ec <oslib_test_005_001_execute+0x1ac>)
  20e25c:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  20e25e:	f7ff fe57 	bl	20df10 <chDelegateCallDirect0>
  20e262:	900a      	str	r0, [sp, #40]	@ 0x28
    test_assert(retval == 0xAA55, "invalid return value");
  20e264:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20e266:	f64a 2255 	movw	r2, #43605	@ 0xaa55
  20e26a:	4293      	cmp	r3, r2
  20e26c:	bf0c      	ite	eq
  20e26e:	2301      	moveq	r3, #1
  20e270:	2300      	movne	r3, #0
  20e272:	b2db      	uxtb	r3, r3
  20e274:	4918      	ldr	r1, [pc, #96]	@ (20e2d8 <oslib_test_005_001_execute+0x198>)
  20e276:	4618      	mov	r0, r3
  20e278:	f7f9 f9f2 	bl	207660 <__test_assert>
  20e27c:	4603      	mov	r3, r0
  20e27e:	2b00      	cmp	r3, #0
  20e280:	d11b      	bne.n	20e2ba <oslib_test_005_001_execute+0x17a>

    test_assert_sequence("0ABCDEFGHIJZ", "unexpected tokens");
  20e282:	491b      	ldr	r1, [pc, #108]	@ (20e2f0 <oslib_test_005_001_execute+0x1b0>)
  20e284:	481b      	ldr	r0, [pc, #108]	@ (20e2f4 <oslib_test_005_001_execute+0x1b4>)
  20e286:	f7f9 fa03 	bl	207690 <__test_assert_sequence>
  20e28a:	4603      	mov	r3, r0
  20e28c:	2b00      	cmp	r3, #0
  20e28e:	d114      	bne.n	20e2ba <oslib_test_005_001_execute+0x17a>
  }
  test_end_step(2);

  /* [5.1.3] Waiting for the thread to terminate-.*/
  test_set_step(3);
  20e290:	4b0b      	ldr	r3, [pc, #44]	@ (20e2c0 <oslib_test_005_001_execute+0x180>)
  20e292:	2203      	movs	r2, #3
  20e294:	601a      	str	r2, [r3, #0]
  {
    msg_t msg = chThdWait(tp);
  20e296:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  20e298:	f7f5 f942 	bl	203520 <chThdWait>
  20e29c:	9009      	str	r0, [sp, #36]	@ 0x24
    test_assert(msg == 0x0FA5, "invalid exit code");
  20e29e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  20e2a0:	f640 72a5 	movw	r2, #4005	@ 0xfa5
  20e2a4:	4293      	cmp	r3, r2
  20e2a6:	bf0c      	ite	eq
  20e2a8:	2301      	moveq	r3, #1
  20e2aa:	2300      	movne	r3, #0
  20e2ac:	b2db      	uxtb	r3, r3
  20e2ae:	4912      	ldr	r1, [pc, #72]	@ (20e2f8 <oslib_test_005_001_execute+0x1b8>)
  20e2b0:	4618      	mov	r0, r3
  20e2b2:	f7f9 f9d5 	bl	207660 <__test_assert>
  20e2b6:	4603      	mov	r3, r0
  20e2b8:	2b00      	cmp	r3, #0
  }
  test_end_step(3);
}
  20e2ba:	b00d      	add	sp, #52	@ 0x34
  20e2bc:	f85d fb04 	ldr.w	pc, [sp], #4
  20e2c0:	20000bb4 	.word	0x20000bb4
  20e2c4:	08011fac 	.word	0x08011fac
  20e2c8:	20002020 	.word	0x20002020
  20e2cc:	20002300 	.word	0x20002300
  20e2d0:	0020e101 	.word	0x0020e101
  20e2d4:	0020e001 	.word	0x0020e001
  20e2d8:	08011fb8 	.word	0x08011fb8
  20e2dc:	0020e011 	.word	0x0020e011
  20e2e0:	0020e031 	.word	0x0020e031
  20e2e4:	0020e061 	.word	0x0020e061
  20e2e8:	0020e0a1 	.word	0x0020e0a1
  20e2ec:	0020e0e1 	.word	0x0020e0e1
  20e2f0:	08011f8c 	.word	0x08011f8c
  20e2f4:	08011fd0 	.word	0x08011fd0
  20e2f8:	08011fe0 	.word	0x08011fe0
  20e2fc:	00000000 	.word	0x00000000

0020e300 <chSysLock.lto_priv.29>:
static inline void chSysLock(void) {
  20e300:	b082      	sub	sp, #8
  20e302:	2330      	movs	r3, #48	@ 0x30
  20e304:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20e306:	9b01      	ldr	r3, [sp, #4]
  20e308:	f383 8811 	msr	BASEPRI, r3
}
  20e30c:	bf00      	nop
}
  20e30e:	bf00      	nop
}
  20e310:	bf00      	nop
  20e312:	b002      	add	sp, #8
  20e314:	4770      	bx	lr
  20e316:	bf00      	nop
	...

0020e320 <chSysUnlock.lto_priv.29>:
static inline void chSysUnlock(void) {
  20e320:	b082      	sub	sp, #8
  20e322:	2300      	movs	r3, #0
  20e324:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20e326:	9b01      	ldr	r3, [sp, #4]
  20e328:	f383 8811 	msr	BASEPRI, r3
}
  20e32c:	bf00      	nop
}
  20e32e:	bf00      	nop
}
  20e330:	bf00      	nop
  20e332:	b002      	add	sp, #8
  20e334:	4770      	bx	lr
  20e336:	bf00      	nop
	...

0020e340 <chCacheReleaseObject>:
 * @param[in] objp      pointer to the @p oc_object_t structure
 *
 * @api
 */
static inline void chCacheReleaseObject(objects_cache_t *ocp,
                                        oc_object_t *objp) {
  20e340:	b500      	push	{lr}
  20e342:	b083      	sub	sp, #12
  20e344:	9001      	str	r0, [sp, #4]
  20e346:	9100      	str	r1, [sp, #0]

  chSysLock();
  20e348:	f7ff ffda 	bl	20e300 <chSysLock.lto_priv.29>
  chCacheReleaseObjectI(ocp, objp);
  20e34c:	9900      	ldr	r1, [sp, #0]
  20e34e:	9801      	ldr	r0, [sp, #4]
  20e350:	f7f8 f86e 	bl	206430 <chCacheReleaseObjectI>
  chSchRescheduleS();
  20e354:	f7f4 fc8c 	bl	202c70 <chSchRescheduleS>
  chSysUnlock();
  20e358:	f7ff ffe2 	bl	20e320 <chSysUnlock.lto_priv.29>
}
  20e35c:	bf00      	nop
  20e35e:	b003      	add	sp, #12
  20e360:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0020e370 <obj_read>:
static cached_object_t objects[NUM_OBJECTS];
static objects_cache_t cache1;

static bool obj_read(objects_cache_t *ocp,
                     oc_object_t *objp,
                     bool async) {
  20e370:	b500      	push	{lr}
  20e372:	b085      	sub	sp, #20
  20e374:	9003      	str	r0, [sp, #12]
  20e376:	9102      	str	r1, [sp, #8]
  20e378:	4613      	mov	r3, r2
  20e37a:	f88d 3007 	strb.w	r3, [sp, #7]

  test_emit_token('a' + objp->obj_key);
  20e37e:	9b02      	ldr	r3, [sp, #8]
  20e380:	695b      	ldr	r3, [r3, #20]
  20e382:	b2db      	uxtb	r3, r3
  20e384:	3361      	adds	r3, #97	@ 0x61
  20e386:	b2db      	uxtb	r3, r3
  20e388:	4618      	mov	r0, r3
  20e38a:	f7f9 f9c9 	bl	207720 <test_emit_token>

  objp->obj_flags &= ~OC_FLAG_NOTSYNC;
  20e38e:	9b02      	ldr	r3, [sp, #8]
  20e390:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e392:	f023 0208 	bic.w	r2, r3, #8
  20e396:	9b02      	ldr	r3, [sp, #8]
  20e398:	625a      	str	r2, [r3, #36]	@ 0x24

  if (async) {
  20e39a:	f89d 3007 	ldrb.w	r3, [sp, #7]
  20e39e:	2b00      	cmp	r3, #0
  20e3a0:	d003      	beq.n	20e3aa <obj_read+0x3a>
    chCacheReleaseObject(ocp, objp);
  20e3a2:	9902      	ldr	r1, [sp, #8]
  20e3a4:	9803      	ldr	r0, [sp, #12]
  20e3a6:	f7ff ffcb 	bl	20e340 <chCacheReleaseObject>
  }

  return false;
  20e3aa:	2300      	movs	r3, #0
}
  20e3ac:	4618      	mov	r0, r3
  20e3ae:	b005      	add	sp, #20
  20e3b0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0020e3c0 <obj_write>:

static bool obj_write(objects_cache_t *ocp,
                      oc_object_t *objp,
                      bool async) {
  20e3c0:	b500      	push	{lr}
  20e3c2:	b085      	sub	sp, #20
  20e3c4:	9003      	str	r0, [sp, #12]
  20e3c6:	9102      	str	r1, [sp, #8]
  20e3c8:	4613      	mov	r3, r2
  20e3ca:	f88d 3007 	strb.w	r3, [sp, #7]
  (void)ocp;
  (void)async;

  test_emit_token('A' + objp->obj_key);
  20e3ce:	9b02      	ldr	r3, [sp, #8]
  20e3d0:	695b      	ldr	r3, [r3, #20]
  20e3d2:	b2db      	uxtb	r3, r3
  20e3d4:	3341      	adds	r3, #65	@ 0x41
  20e3d6:	b2db      	uxtb	r3, r3
  20e3d8:	4618      	mov	r0, r3
  20e3da:	f7f9 f9a1 	bl	207720 <test_emit_token>

  return false;
  20e3de:	2300      	movs	r3, #0
}
  20e3e0:	4618      	mov	r0, r3
  20e3e2:	b005      	add	sp, #20
  20e3e4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0020e3f0 <oslib_test_006_001_execute>:
 * - [6.1.5] Checking cached objects.
 * - [6.1.6] Checking non-cached objects.
 * .
 */

static void oslib_test_006_001_execute(void) {
  20e3f0:	b500      	push	{lr}
  20e3f2:	b091      	sub	sp, #68	@ 0x44

  /* [6.1.1] Cache initialization.*/
  test_set_step(1);
  20e3f4:	4b6a      	ldr	r3, [pc, #424]	@ (20e5a0 <oslib_test_006_001_execute+0x1b0>)
  20e3f6:	2201      	movs	r2, #1
  20e3f8:	601a      	str	r2, [r3, #0]
  {
    chCacheObjectInit(&cache1,
  20e3fa:	4b6a      	ldr	r3, [pc, #424]	@ (20e5a4 <oslib_test_006_001_execute+0x1b4>)
  20e3fc:	9303      	str	r3, [sp, #12]
  20e3fe:	4b6a      	ldr	r3, [pc, #424]	@ (20e5a8 <oslib_test_006_001_execute+0x1b8>)
  20e400:	9302      	str	r3, [sp, #8]
  20e402:	4b6a      	ldr	r3, [pc, #424]	@ (20e5ac <oslib_test_006_001_execute+0x1bc>)
  20e404:	9301      	str	r3, [sp, #4]
  20e406:	233c      	movs	r3, #60	@ 0x3c
  20e408:	9300      	str	r3, [sp, #0]
  20e40a:	2304      	movs	r3, #4
  20e40c:	4a68      	ldr	r2, [pc, #416]	@ (20e5b0 <oslib_test_006_001_execute+0x1c0>)
  20e40e:	2108      	movs	r1, #8
  20e410:	4868      	ldr	r0, [pc, #416]	@ (20e5b4 <oslib_test_006_001_execute+0x1c4>)
  20e412:	f7f7 ff25 	bl	206260 <chCacheObjectInit>
                      obj_write);
  }
  test_end_step(1);

  /* [6.1.2] Getting and releasing objects without initialization.*/
  test_set_step(2);
  20e416:	4b62      	ldr	r3, [pc, #392]	@ (20e5a0 <oslib_test_006_001_execute+0x1b0>)
  20e418:	2202      	movs	r2, #2
  20e41a:	601a      	str	r2, [r3, #0]
  {
    uint32_t i;

    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
  20e41c:	2300      	movs	r3, #0
  20e41e:	930f      	str	r3, [sp, #60]	@ 0x3c
  20e420:	e02e      	b.n	20e480 <oslib_test_006_001_execute+0x90>
      oc_object_t * objp = chCacheGetObject(&cache1, NULL, i);
  20e422:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
  20e424:	2100      	movs	r1, #0
  20e426:	4863      	ldr	r0, [pc, #396]	@ (20e5b4 <oslib_test_006_001_execute+0x1c4>)
  20e428:	f7f7 ff9a 	bl	206360 <chCacheGetObject>
  20e42c:	9004      	str	r0, [sp, #16]

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
  20e42e:	9b04      	ldr	r3, [sp, #16]
  20e430:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e432:	f003 0302 	and.w	r3, r3, #2
  20e436:	2b00      	cmp	r3, #0
  20e438:	bf14      	ite	ne
  20e43a:	2301      	movne	r3, #1
  20e43c:	2300      	moveq	r3, #0
  20e43e:	b2db      	uxtb	r3, r3
  20e440:	495d      	ldr	r1, [pc, #372]	@ (20e5b8 <oslib_test_006_001_execute+0x1c8>)
  20e442:	4618      	mov	r0, r3
  20e444:	f7f9 f90c 	bl	207660 <__test_assert>
  20e448:	4603      	mov	r3, r0
  20e44a:	2b00      	cmp	r3, #0
  20e44c:	f040 81bb 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "should not be in sync");
  20e450:	9b04      	ldr	r3, [sp, #16]
  20e452:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e454:	f003 0308 	and.w	r3, r3, #8
  20e458:	2b00      	cmp	r3, #0
  20e45a:	bf14      	ite	ne
  20e45c:	2301      	movne	r3, #1
  20e45e:	2300      	moveq	r3, #0
  20e460:	b2db      	uxtb	r3, r3
  20e462:	4956      	ldr	r1, [pc, #344]	@ (20e5bc <oslib_test_006_001_execute+0x1cc>)
  20e464:	4618      	mov	r0, r3
  20e466:	f7f9 f8fb 	bl	207660 <__test_assert>
  20e46a:	4603      	mov	r3, r0
  20e46c:	2b00      	cmp	r3, #0
  20e46e:	f040 81aa 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>

      chCacheReleaseObject(&cache1, objp);
  20e472:	9904      	ldr	r1, [sp, #16]
  20e474:	484f      	ldr	r0, [pc, #316]	@ (20e5b4 <oslib_test_006_001_execute+0x1c4>)
  20e476:	f7ff ff63 	bl	20e340 <chCacheReleaseObject>
    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
  20e47a:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  20e47c:	3301      	adds	r3, #1
  20e47e:	930f      	str	r3, [sp, #60]	@ 0x3c
  20e480:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
  20e482:	2b07      	cmp	r3, #7
  20e484:	d9cd      	bls.n	20e422 <oslib_test_006_001_execute+0x32>
    }

    test_assert_sequence("", "unexpected tokens");
  20e486:	494e      	ldr	r1, [pc, #312]	@ (20e5c0 <oslib_test_006_001_execute+0x1d0>)
  20e488:	484e      	ldr	r0, [pc, #312]	@ (20e5c4 <oslib_test_006_001_execute+0x1d4>)
  20e48a:	f7f9 f901 	bl	207690 <__test_assert_sequence>
  20e48e:	4603      	mov	r3, r0
  20e490:	2b00      	cmp	r3, #0
  20e492:	f040 8198 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>
  }
  test_end_step(2);

  /* [6.1.3] Getting and releasing objects with synchronous
     initialization.*/
  test_set_step(3);
  20e496:	4b42      	ldr	r3, [pc, #264]	@ (20e5a0 <oslib_test_006_001_execute+0x1b0>)
  20e498:	2203      	movs	r2, #3
  20e49a:	601a      	str	r2, [r3, #0]
  {
    uint32_t i;
    bool error;

    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
  20e49c:	2300      	movs	r3, #0
  20e49e:	930e      	str	r3, [sp, #56]	@ 0x38
  20e4a0:	e06d      	b.n	20e57e <oslib_test_006_001_execute+0x18e>
      oc_object_t *objp = chCacheGetObject(&cache1, NULL, i);
  20e4a2:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
  20e4a4:	2100      	movs	r1, #0
  20e4a6:	4843      	ldr	r0, [pc, #268]	@ (20e5b4 <oslib_test_006_001_execute+0x1c4>)
  20e4a8:	f7f7 ff5a 	bl	206360 <chCacheGetObject>
  20e4ac:	9006      	str	r0, [sp, #24]

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
  20e4ae:	9b06      	ldr	r3, [sp, #24]
  20e4b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e4b2:	f003 0302 	and.w	r3, r3, #2
  20e4b6:	2b00      	cmp	r3, #0
  20e4b8:	bf14      	ite	ne
  20e4ba:	2301      	movne	r3, #1
  20e4bc:	2300      	moveq	r3, #0
  20e4be:	b2db      	uxtb	r3, r3
  20e4c0:	493d      	ldr	r1, [pc, #244]	@ (20e5b8 <oslib_test_006_001_execute+0x1c8>)
  20e4c2:	4618      	mov	r0, r3
  20e4c4:	f7f9 f8cc 	bl	207660 <__test_assert>
  20e4c8:	4603      	mov	r3, r0
  20e4ca:	2b00      	cmp	r3, #0
  20e4cc:	f040 817b 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
  20e4d0:	9b06      	ldr	r3, [sp, #24]
  20e4d2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e4d4:	f003 0308 	and.w	r3, r3, #8
  20e4d8:	2b00      	cmp	r3, #0
  20e4da:	bf14      	ite	ne
  20e4dc:	2301      	movne	r3, #1
  20e4de:	2300      	moveq	r3, #0
  20e4e0:	b2db      	uxtb	r3, r3
  20e4e2:	4939      	ldr	r1, [pc, #228]	@ (20e5c8 <oslib_test_006_001_execute+0x1d8>)
  20e4e4:	4618      	mov	r0, r3
  20e4e6:	f7f9 f8bb 	bl	207660 <__test_assert>
  20e4ea:	4603      	mov	r3, r0
  20e4ec:	2b00      	cmp	r3, #0
  20e4ee:	f040 816a 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>

      error = chCacheReadObject(&cache1, objp, false);
  20e4f2:	2200      	movs	r2, #0
  20e4f4:	9906      	ldr	r1, [sp, #24]
  20e4f6:	482f      	ldr	r0, [pc, #188]	@ (20e5b4 <oslib_test_006_001_execute+0x1c4>)
  20e4f8:	f7f8 f822 	bl	206540 <chCacheReadObject>
  20e4fc:	4603      	mov	r3, r0
  20e4fe:	f88d 3017 	strb.w	r3, [sp, #23]

      test_assert(error == false, "returned error");
  20e502:	f89d 3017 	ldrb.w	r3, [sp, #23]
  20e506:	2b00      	cmp	r3, #0
  20e508:	bf14      	ite	ne
  20e50a:	2301      	movne	r3, #1
  20e50c:	2300      	moveq	r3, #0
  20e50e:	b2db      	uxtb	r3, r3
  20e510:	f083 0301 	eor.w	r3, r3, #1
  20e514:	b2db      	uxtb	r3, r3
  20e516:	f003 0301 	and.w	r3, r3, #1
  20e51a:	b2db      	uxtb	r3, r3
  20e51c:	492b      	ldr	r1, [pc, #172]	@ (20e5cc <oslib_test_006_001_execute+0x1dc>)
  20e51e:	4618      	mov	r0, r3
  20e520:	f7f9 f89e 	bl	207660 <__test_assert>
  20e524:	4603      	mov	r3, r0
  20e526:	2b00      	cmp	r3, #0
  20e528:	f040 814d 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
  20e52c:	9b06      	ldr	r3, [sp, #24]
  20e52e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e530:	f003 0302 	and.w	r3, r3, #2
  20e534:	2b00      	cmp	r3, #0
  20e536:	bf14      	ite	ne
  20e538:	2301      	movne	r3, #1
  20e53a:	2300      	moveq	r3, #0
  20e53c:	b2db      	uxtb	r3, r3
  20e53e:	491e      	ldr	r1, [pc, #120]	@ (20e5b8 <oslib_test_006_001_execute+0x1c8>)
  20e540:	4618      	mov	r0, r3
  20e542:	f7f9 f88d 	bl	207660 <__test_assert>
  20e546:	4603      	mov	r3, r0
  20e548:	2b00      	cmp	r3, #0
  20e54a:	f040 813c 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
  20e54e:	9b06      	ldr	r3, [sp, #24]
  20e550:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e552:	f003 0308 	and.w	r3, r3, #8
  20e556:	2b00      	cmp	r3, #0
  20e558:	bf0c      	ite	eq
  20e55a:	2301      	moveq	r3, #1
  20e55c:	2300      	movne	r3, #0
  20e55e:	b2db      	uxtb	r3, r3
  20e560:	491b      	ldr	r1, [pc, #108]	@ (20e5d0 <oslib_test_006_001_execute+0x1e0>)
  20e562:	4618      	mov	r0, r3
  20e564:	f7f9 f87c 	bl	207660 <__test_assert>
  20e568:	4603      	mov	r3, r0
  20e56a:	2b00      	cmp	r3, #0
  20e56c:	f040 812b 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>

      chCacheReleaseObject(&cache1, objp);
  20e570:	9906      	ldr	r1, [sp, #24]
  20e572:	4810      	ldr	r0, [pc, #64]	@ (20e5b4 <oslib_test_006_001_execute+0x1c4>)
  20e574:	f7ff fee4 	bl	20e340 <chCacheReleaseObject>
    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
  20e578:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  20e57a:	3301      	adds	r3, #1
  20e57c:	930e      	str	r3, [sp, #56]	@ 0x38
  20e57e:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  20e580:	2b07      	cmp	r3, #7
  20e582:	d98e      	bls.n	20e4a2 <oslib_test_006_001_execute+0xb2>
    }

    test_assert_sequence("abcdefgh", "unexpected tokens");
  20e584:	490e      	ldr	r1, [pc, #56]	@ (20e5c0 <oslib_test_006_001_execute+0x1d0>)
  20e586:	4813      	ldr	r0, [pc, #76]	@ (20e5d4 <oslib_test_006_001_execute+0x1e4>)
  20e588:	f7f9 f882 	bl	207690 <__test_assert_sequence>
  20e58c:	4603      	mov	r3, r0
  20e58e:	2b00      	cmp	r3, #0
  20e590:	f040 8119 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>
  }
  test_end_step(3);

  /* [6.1.4] Getting and releasing objects with asynchronous
     initialization.*/
  test_set_step(4);
  20e594:	4b02      	ldr	r3, [pc, #8]	@ (20e5a0 <oslib_test_006_001_execute+0x1b0>)
  20e596:	2204      	movs	r2, #4
  20e598:	601a      	str	r2, [r3, #0]
  {
    uint32_t i;
    bool error;

    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
  20e59a:	2300      	movs	r3, #0
  20e59c:	930d      	str	r3, [sp, #52]	@ 0x34
  20e59e:	e08f      	b.n	20e6c0 <oslib_test_006_001_execute+0x2d0>
  20e5a0:	20000bb4 	.word	0x20000bb4
  20e5a4:	0020e3c1 	.word	0x0020e3c1
  20e5a8:	0020e371 	.word	0x0020e371
  20e5ac:	20002340 	.word	0x20002340
  20e5b0:	20002300 	.word	0x20002300
  20e5b4:	20002430 	.word	0x20002430
  20e5b8:	08011ff4 	.word	0x08011ff4
  20e5bc:	08012000 	.word	0x08012000
  20e5c0:	08011f8c 	.word	0x08011f8c
  20e5c4:	08010bcc 	.word	0x08010bcc
  20e5c8:	0801202c 	.word	0x0801202c
  20e5cc:	08012018 	.word	0x08012018
  20e5d0:	08012028 	.word	0x08012028
  20e5d4:	08011fa0 	.word	0x08011fa0
      oc_object_t *objp = chCacheGetObject(&cache1, NULL, i);
  20e5d8:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
  20e5da:	2100      	movs	r1, #0
  20e5dc:	487b      	ldr	r0, [pc, #492]	@ (20e7cc <oslib_test_006_001_execute+0x3dc>)
  20e5de:	f7f7 febf 	bl	206360 <chCacheGetObject>
  20e5e2:	9008      	str	r0, [sp, #32]

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
  20e5e4:	9b08      	ldr	r3, [sp, #32]
  20e5e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e5e8:	f003 0302 	and.w	r3, r3, #2
  20e5ec:	2b00      	cmp	r3, #0
  20e5ee:	bf14      	ite	ne
  20e5f0:	2301      	movne	r3, #1
  20e5f2:	2300      	moveq	r3, #0
  20e5f4:	b2db      	uxtb	r3, r3
  20e5f6:	4976      	ldr	r1, [pc, #472]	@ (20e7d0 <oslib_test_006_001_execute+0x3e0>)
  20e5f8:	4618      	mov	r0, r3
  20e5fa:	f7f9 f831 	bl	207660 <__test_assert>
  20e5fe:	4603      	mov	r3, r0
  20e600:	2b00      	cmp	r3, #0
  20e602:	f040 80e0 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
  20e606:	9b08      	ldr	r3, [sp, #32]
  20e608:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e60a:	f003 0308 	and.w	r3, r3, #8
  20e60e:	2b00      	cmp	r3, #0
  20e610:	bf14      	ite	ne
  20e612:	2301      	movne	r3, #1
  20e614:	2300      	moveq	r3, #0
  20e616:	b2db      	uxtb	r3, r3
  20e618:	496e      	ldr	r1, [pc, #440]	@ (20e7d4 <oslib_test_006_001_execute+0x3e4>)
  20e61a:	4618      	mov	r0, r3
  20e61c:	f7f9 f820 	bl	207660 <__test_assert>
  20e620:	4603      	mov	r3, r0
  20e622:	2b00      	cmp	r3, #0
  20e624:	f040 80cf 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>

      error = chCacheReadObject(&cache1, objp, true);
  20e628:	2201      	movs	r2, #1
  20e62a:	9908      	ldr	r1, [sp, #32]
  20e62c:	4867      	ldr	r0, [pc, #412]	@ (20e7cc <oslib_test_006_001_execute+0x3dc>)
  20e62e:	f7f7 ff87 	bl	206540 <chCacheReadObject>
  20e632:	4603      	mov	r3, r0
  20e634:	f88d 301f 	strb.w	r3, [sp, #31]

      test_assert(error == false, "returned error");
  20e638:	f89d 301f 	ldrb.w	r3, [sp, #31]
  20e63c:	2b00      	cmp	r3, #0
  20e63e:	bf14      	ite	ne
  20e640:	2301      	movne	r3, #1
  20e642:	2300      	moveq	r3, #0
  20e644:	b2db      	uxtb	r3, r3
  20e646:	f083 0301 	eor.w	r3, r3, #1
  20e64a:	b2db      	uxtb	r3, r3
  20e64c:	f003 0301 	and.w	r3, r3, #1
  20e650:	b2db      	uxtb	r3, r3
  20e652:	4961      	ldr	r1, [pc, #388]	@ (20e7d8 <oslib_test_006_001_execute+0x3e8>)
  20e654:	4618      	mov	r0, r3
  20e656:	f7f9 f803 	bl	207660 <__test_assert>
  20e65a:	4603      	mov	r3, r0
  20e65c:	2b00      	cmp	r3, #0
  20e65e:	f040 80b2 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>

      objp = chCacheGetObject(&cache1, NULL, i);
  20e662:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
  20e664:	2100      	movs	r1, #0
  20e666:	4859      	ldr	r0, [pc, #356]	@ (20e7cc <oslib_test_006_001_execute+0x3dc>)
  20e668:	f7f7 fe7a 	bl	206360 <chCacheGetObject>
  20e66c:	9008      	str	r0, [sp, #32]

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
  20e66e:	9b08      	ldr	r3, [sp, #32]
  20e670:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e672:	f003 0302 	and.w	r3, r3, #2
  20e676:	2b00      	cmp	r3, #0
  20e678:	bf14      	ite	ne
  20e67a:	2301      	movne	r3, #1
  20e67c:	2300      	moveq	r3, #0
  20e67e:	b2db      	uxtb	r3, r3
  20e680:	4953      	ldr	r1, [pc, #332]	@ (20e7d0 <oslib_test_006_001_execute+0x3e0>)
  20e682:	4618      	mov	r0, r3
  20e684:	f7f8 ffec 	bl	207660 <__test_assert>
  20e688:	4603      	mov	r3, r0
  20e68a:	2b00      	cmp	r3, #0
  20e68c:	f040 809b 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
  20e690:	9b08      	ldr	r3, [sp, #32]
  20e692:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e694:	f003 0308 	and.w	r3, r3, #8
  20e698:	2b00      	cmp	r3, #0
  20e69a:	bf0c      	ite	eq
  20e69c:	2301      	moveq	r3, #1
  20e69e:	2300      	movne	r3, #0
  20e6a0:	b2db      	uxtb	r3, r3
  20e6a2:	494e      	ldr	r1, [pc, #312]	@ (20e7dc <oslib_test_006_001_execute+0x3ec>)
  20e6a4:	4618      	mov	r0, r3
  20e6a6:	f7f8 ffdb 	bl	207660 <__test_assert>
  20e6aa:	4603      	mov	r3, r0
  20e6ac:	2b00      	cmp	r3, #0
  20e6ae:	f040 808a 	bne.w	20e7c6 <oslib_test_006_001_execute+0x3d6>

      chCacheReleaseObject(&cache1, objp);
  20e6b2:	9908      	ldr	r1, [sp, #32]
  20e6b4:	4845      	ldr	r0, [pc, #276]	@ (20e7cc <oslib_test_006_001_execute+0x3dc>)
  20e6b6:	f7ff fe43 	bl	20e340 <chCacheReleaseObject>
    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
  20e6ba:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  20e6bc:	3301      	adds	r3, #1
  20e6be:	930d      	str	r3, [sp, #52]	@ 0x34
  20e6c0:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  20e6c2:	2b07      	cmp	r3, #7
  20e6c4:	d988      	bls.n	20e5d8 <oslib_test_006_001_execute+0x1e8>
    }

    test_assert_sequence("abcdefgh", "unexpected tokens");
  20e6c6:	4946      	ldr	r1, [pc, #280]	@ (20e7e0 <oslib_test_006_001_execute+0x3f0>)
  20e6c8:	4846      	ldr	r0, [pc, #280]	@ (20e7e4 <oslib_test_006_001_execute+0x3f4>)
  20e6ca:	f7f8 ffe1 	bl	207690 <__test_assert_sequence>
  20e6ce:	4603      	mov	r3, r0
  20e6d0:	2b00      	cmp	r3, #0
  20e6d2:	d178      	bne.n	20e7c6 <oslib_test_006_001_execute+0x3d6>
  }
  test_end_step(4);

  /* [6.1.5] Checking cached objects.*/
  test_set_step(5);
  20e6d4:	4b44      	ldr	r3, [pc, #272]	@ (20e7e8 <oslib_test_006_001_execute+0x3f8>)
  20e6d6:	2205      	movs	r2, #5
  20e6d8:	601a      	str	r2, [r3, #0]
  {
    uint32_t i;

    for (i = NUM_OBJECTS; i < (NUM_OBJECTS * 2); i++) {
  20e6da:	2304      	movs	r3, #4
  20e6dc:	930c      	str	r3, [sp, #48]	@ 0x30
  20e6de:	e02c      	b.n	20e73a <oslib_test_006_001_execute+0x34a>
      oc_object_t *objp = chCacheGetObject(&cache1, NULL, i);
  20e6e0:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
  20e6e2:	2100      	movs	r1, #0
  20e6e4:	4839      	ldr	r0, [pc, #228]	@ (20e7cc <oslib_test_006_001_execute+0x3dc>)
  20e6e6:	f7f7 fe3b 	bl	206360 <chCacheGetObject>
  20e6ea:	9009      	str	r0, [sp, #36]	@ 0x24

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
  20e6ec:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  20e6ee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e6f0:	f003 0302 	and.w	r3, r3, #2
  20e6f4:	2b00      	cmp	r3, #0
  20e6f6:	bf14      	ite	ne
  20e6f8:	2301      	movne	r3, #1
  20e6fa:	2300      	moveq	r3, #0
  20e6fc:	b2db      	uxtb	r3, r3
  20e6fe:	4934      	ldr	r1, [pc, #208]	@ (20e7d0 <oslib_test_006_001_execute+0x3e0>)
  20e700:	4618      	mov	r0, r3
  20e702:	f7f8 ffad 	bl	207660 <__test_assert>
  20e706:	4603      	mov	r3, r0
  20e708:	2b00      	cmp	r3, #0
  20e70a:	d15c      	bne.n	20e7c6 <oslib_test_006_001_execute+0x3d6>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
  20e70c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  20e70e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e710:	f003 0308 	and.w	r3, r3, #8
  20e714:	2b00      	cmp	r3, #0
  20e716:	bf0c      	ite	eq
  20e718:	2301      	moveq	r3, #1
  20e71a:	2300      	movne	r3, #0
  20e71c:	b2db      	uxtb	r3, r3
  20e71e:	492f      	ldr	r1, [pc, #188]	@ (20e7dc <oslib_test_006_001_execute+0x3ec>)
  20e720:	4618      	mov	r0, r3
  20e722:	f7f8 ff9d 	bl	207660 <__test_assert>
  20e726:	4603      	mov	r3, r0
  20e728:	2b00      	cmp	r3, #0
  20e72a:	d14c      	bne.n	20e7c6 <oslib_test_006_001_execute+0x3d6>

      chCacheReleaseObject(&cache1, objp);
  20e72c:	9909      	ldr	r1, [sp, #36]	@ 0x24
  20e72e:	4827      	ldr	r0, [pc, #156]	@ (20e7cc <oslib_test_006_001_execute+0x3dc>)
  20e730:	f7ff fe06 	bl	20e340 <chCacheReleaseObject>
    for (i = NUM_OBJECTS; i < (NUM_OBJECTS * 2); i++) {
  20e734:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
  20e736:	3301      	adds	r3, #1
  20e738:	930c      	str	r3, [sp, #48]	@ 0x30
  20e73a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
  20e73c:	2b07      	cmp	r3, #7
  20e73e:	d9cf      	bls.n	20e6e0 <oslib_test_006_001_execute+0x2f0>
    }

    test_assert_sequence("", "unexpected tokens");
  20e740:	4927      	ldr	r1, [pc, #156]	@ (20e7e0 <oslib_test_006_001_execute+0x3f0>)
  20e742:	482a      	ldr	r0, [pc, #168]	@ (20e7ec <oslib_test_006_001_execute+0x3fc>)
  20e744:	f7f8 ffa4 	bl	207690 <__test_assert_sequence>
  20e748:	4603      	mov	r3, r0
  20e74a:	2b00      	cmp	r3, #0
  20e74c:	d13b      	bne.n	20e7c6 <oslib_test_006_001_execute+0x3d6>
  }
  test_end_step(5);

  /* [6.1.6] Checking non-cached objects.*/
  test_set_step(6);
  20e74e:	4b26      	ldr	r3, [pc, #152]	@ (20e7e8 <oslib_test_006_001_execute+0x3f8>)
  20e750:	2206      	movs	r2, #6
  20e752:	601a      	str	r2, [r3, #0]
  {
    uint32_t i;

    for (i = 0; i < NUM_OBJECTS; i++) {
  20e754:	2300      	movs	r3, #0
  20e756:	930b      	str	r3, [sp, #44]	@ 0x2c
  20e758:	e02c      	b.n	20e7b4 <oslib_test_006_001_execute+0x3c4>
      oc_object_t *objp = chCacheGetObject(&cache1, NULL, i);
  20e75a:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
  20e75c:	2100      	movs	r1, #0
  20e75e:	481b      	ldr	r0, [pc, #108]	@ (20e7cc <oslib_test_006_001_execute+0x3dc>)
  20e760:	f7f7 fdfe 	bl	206360 <chCacheGetObject>
  20e764:	900a      	str	r0, [sp, #40]	@ 0x28

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
  20e766:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20e768:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e76a:	f003 0302 	and.w	r3, r3, #2
  20e76e:	2b00      	cmp	r3, #0
  20e770:	bf14      	ite	ne
  20e772:	2301      	movne	r3, #1
  20e774:	2300      	moveq	r3, #0
  20e776:	b2db      	uxtb	r3, r3
  20e778:	4915      	ldr	r1, [pc, #84]	@ (20e7d0 <oslib_test_006_001_execute+0x3e0>)
  20e77a:	4618      	mov	r0, r3
  20e77c:	f7f8 ff70 	bl	207660 <__test_assert>
  20e780:	4603      	mov	r3, r0
  20e782:	2b00      	cmp	r3, #0
  20e784:	d11f      	bne.n	20e7c6 <oslib_test_006_001_execute+0x3d6>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
  20e786:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  20e788:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  20e78a:	f003 0308 	and.w	r3, r3, #8
  20e78e:	2b00      	cmp	r3, #0
  20e790:	bf14      	ite	ne
  20e792:	2301      	movne	r3, #1
  20e794:	2300      	moveq	r3, #0
  20e796:	b2db      	uxtb	r3, r3
  20e798:	490e      	ldr	r1, [pc, #56]	@ (20e7d4 <oslib_test_006_001_execute+0x3e4>)
  20e79a:	4618      	mov	r0, r3
  20e79c:	f7f8 ff60 	bl	207660 <__test_assert>
  20e7a0:	4603      	mov	r3, r0
  20e7a2:	2b00      	cmp	r3, #0
  20e7a4:	d10f      	bne.n	20e7c6 <oslib_test_006_001_execute+0x3d6>

      chCacheReleaseObject(&cache1, objp);
  20e7a6:	990a      	ldr	r1, [sp, #40]	@ 0x28
  20e7a8:	4808      	ldr	r0, [pc, #32]	@ (20e7cc <oslib_test_006_001_execute+0x3dc>)
  20e7aa:	f7ff fdc9 	bl	20e340 <chCacheReleaseObject>
    for (i = 0; i < NUM_OBJECTS; i++) {
  20e7ae:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  20e7b0:	3301      	adds	r3, #1
  20e7b2:	930b      	str	r3, [sp, #44]	@ 0x2c
  20e7b4:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  20e7b6:	2b03      	cmp	r3, #3
  20e7b8:	d9cf      	bls.n	20e75a <oslib_test_006_001_execute+0x36a>
    }

    test_assert_sequence("", "unexpected tokens");
  20e7ba:	4909      	ldr	r1, [pc, #36]	@ (20e7e0 <oslib_test_006_001_execute+0x3f0>)
  20e7bc:	480b      	ldr	r0, [pc, #44]	@ (20e7ec <oslib_test_006_001_execute+0x3fc>)
  20e7be:	f7f8 ff67 	bl	207690 <__test_assert_sequence>
  20e7c2:	4603      	mov	r3, r0
  20e7c4:	2b00      	cmp	r3, #0
  }
  test_end_step(6);
}
  20e7c6:	b011      	add	sp, #68	@ 0x44
  20e7c8:	f85d fb04 	ldr.w	pc, [sp], #4
  20e7cc:	20002430 	.word	0x20002430
  20e7d0:	08011ff4 	.word	0x08011ff4
  20e7d4:	0801202c 	.word	0x0801202c
  20e7d8:	08012018 	.word	0x08012018
  20e7dc:	08012028 	.word	0x08012028
  20e7e0:	08011f8c 	.word	0x08011f8c
  20e7e4:	08011fa0 	.word	0x08011fa0
  20e7e8:	20000bb4 	.word	0x20000bb4
  20e7ec:	08010bcc 	.word	0x08010bcc

0020e7f0 <chPoolObjectInit.lto_priv.2>:
                                    memgetfunc_t provider) {
  20e7f0:	b500      	push	{lr}
  20e7f2:	b085      	sub	sp, #20
  20e7f4:	9003      	str	r0, [sp, #12]
  20e7f6:	9102      	str	r1, [sp, #8]
  20e7f8:	9201      	str	r2, [sp, #4]
  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
  20e7fa:	9b01      	ldr	r3, [sp, #4]
  20e7fc:	2204      	movs	r2, #4
  20e7fe:	9902      	ldr	r1, [sp, #8]
  20e800:	9803      	ldr	r0, [sp, #12]
  20e802:	f7f7 f915 	bl	205a30 <chPoolObjectInitAligned>
}
  20e806:	bf00      	nop
  20e808:	b005      	add	sp, #20
  20e80a:	f85d fb04 	ldr.w	pc, [sp], #4
  20e80e:	bf00      	nop

0020e810 <chGuardedPoolObjectInit.lto_priv.1>:
                                           size_t size) {
  20e810:	b500      	push	{lr}
  20e812:	b083      	sub	sp, #12
  20e814:	9001      	str	r0, [sp, #4]
  20e816:	9100      	str	r1, [sp, #0]
  chGuardedPoolObjectInitAligned(gmp, size, PORT_NATURAL_ALIGN);
  20e818:	2204      	movs	r2, #4
  20e81a:	9900      	ldr	r1, [sp, #0]
  20e81c:	9801      	ldr	r0, [sp, #4]
  20e81e:	f7f7 f997 	bl	205b50 <chGuardedPoolObjectInitAligned>
}
  20e822:	bf00      	nop
  20e824:	b003      	add	sp, #12
  20e826:	f85d fb04 	ldr.w	pc, [sp], #4
  20e82a:	bf00      	nop
  20e82c:	0000      	movs	r0, r0
	...

0020e830 <null_provider>:

#if CH_CFG_USE_SEMAPHORES
static GUARDEDMEMORYPOOL_DECL(gmp1, sizeof (uint32_t), PORT_NATURAL_ALIGN);
#endif

static void *null_provider(size_t size, unsigned align) {
  20e830:	b082      	sub	sp, #8
  20e832:	9001      	str	r0, [sp, #4]
  20e834:	9100      	str	r1, [sp, #0]

  (void)size;
  (void)align;

  return NULL;
  20e836:	2300      	movs	r3, #0
}
  20e838:	4618      	mov	r0, r3
  20e83a:	b002      	add	sp, #8
  20e83c:	4770      	bx	lr
  20e83e:	bf00      	nop

0020e840 <oslib_test_007_001_setup>:
 * - [7.1.7] Covering the case where a provider is unable to return
 *   more memory.
 * .
 */

static void oslib_test_007_001_setup(void) {
  20e840:	b508      	push	{r3, lr}
  chPoolObjectInit(&mp1, sizeof (uint32_t), NULL);
  20e842:	2200      	movs	r2, #0
  20e844:	2104      	movs	r1, #4
  20e846:	4802      	ldr	r0, [pc, #8]	@ (20e850 <oslib_test_007_001_setup+0x10>)
  20e848:	f7ff ffd2 	bl	20e7f0 <chPoolObjectInit.lto_priv.2>
}
  20e84c:	bf00      	nop
  20e84e:	bd08      	pop	{r3, pc}
  20e850:	200200a8 	.word	0x200200a8
	...

0020e860 <oslib_test_007_001_execute>:

static void oslib_test_007_001_execute(void) {
  20e860:	b500      	push	{lr}
  20e862:	b083      	sub	sp, #12
  unsigned i;

  /* [7.1.1] Adding the objects to the pool using chPoolLoadArray().*/
  test_set_step(1);
  20e864:	4b49      	ldr	r3, [pc, #292]	@ (20e98c <oslib_test_007_001_execute+0x12c>)
  20e866:	2201      	movs	r2, #1
  20e868:	601a      	str	r2, [r3, #0]
  {
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
  20e86a:	2204      	movs	r2, #4
  20e86c:	4948      	ldr	r1, [pc, #288]	@ (20e990 <oslib_test_007_001_execute+0x130>)
  20e86e:	4849      	ldr	r0, [pc, #292]	@ (20e994 <oslib_test_007_001_execute+0x134>)
  20e870:	f7f7 f8f6 	bl	205a60 <chPoolLoadArray>
  }
  test_end_step(1);

  /* [7.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
  20e874:	4b45      	ldr	r3, [pc, #276]	@ (20e98c <oslib_test_007_001_execute+0x12c>)
  20e876:	2202      	movs	r2, #2
  20e878:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20e87a:	2300      	movs	r3, #0
  20e87c:	9301      	str	r3, [sp, #4]
  20e87e:	e012      	b.n	20e8a6 <oslib_test_007_001_execute+0x46>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  20e880:	4844      	ldr	r0, [pc, #272]	@ (20e994 <oslib_test_007_001_execute+0x134>)
  20e882:	f7f7 f935 	bl	205af0 <chPoolAlloc>
  20e886:	4603      	mov	r3, r0
  20e888:	2b00      	cmp	r3, #0
  20e88a:	bf14      	ite	ne
  20e88c:	2301      	movne	r3, #1
  20e88e:	2300      	moveq	r3, #0
  20e890:	b2db      	uxtb	r3, r3
  20e892:	4941      	ldr	r1, [pc, #260]	@ (20e998 <oslib_test_007_001_execute+0x138>)
  20e894:	4618      	mov	r0, r3
  20e896:	f7f8 fee3 	bl	207660 <__test_assert>
  20e89a:	4603      	mov	r3, r0
  20e89c:	2b00      	cmp	r3, #0
  20e89e:	d172      	bne.n	20e986 <oslib_test_007_001_execute+0x126>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20e8a0:	9b01      	ldr	r3, [sp, #4]
  20e8a2:	3301      	adds	r3, #1
  20e8a4:	9301      	str	r3, [sp, #4]
  20e8a6:	9b01      	ldr	r3, [sp, #4]
  20e8a8:	2b03      	cmp	r3, #3
  20e8aa:	d9e9      	bls.n	20e880 <oslib_test_007_001_execute+0x20>
  }
  test_end_step(2);

  /* [7.1.3] Now must be empty.*/
  test_set_step(3);
  20e8ac:	4b37      	ldr	r3, [pc, #220]	@ (20e98c <oslib_test_007_001_execute+0x12c>)
  20e8ae:	2203      	movs	r2, #3
  20e8b0:	601a      	str	r2, [r3, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
  20e8b2:	4838      	ldr	r0, [pc, #224]	@ (20e994 <oslib_test_007_001_execute+0x134>)
  20e8b4:	f7f7 f91c 	bl	205af0 <chPoolAlloc>
  20e8b8:	4603      	mov	r3, r0
  20e8ba:	2b00      	cmp	r3, #0
  20e8bc:	bf0c      	ite	eq
  20e8be:	2301      	moveq	r3, #1
  20e8c0:	2300      	movne	r3, #0
  20e8c2:	b2db      	uxtb	r3, r3
  20e8c4:	4935      	ldr	r1, [pc, #212]	@ (20e99c <oslib_test_007_001_execute+0x13c>)
  20e8c6:	4618      	mov	r0, r3
  20e8c8:	f7f8 feca 	bl	207660 <__test_assert>
  20e8cc:	4603      	mov	r3, r0
  20e8ce:	2b00      	cmp	r3, #0
  20e8d0:	d159      	bne.n	20e986 <oslib_test_007_001_execute+0x126>
  }
  test_end_step(3);

  /* [7.1.4] Adding the objects to the pool using chPoolFree().*/
  test_set_step(4);
  20e8d2:	4b2e      	ldr	r3, [pc, #184]	@ (20e98c <oslib_test_007_001_execute+0x12c>)
  20e8d4:	2204      	movs	r2, #4
  20e8d6:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20e8d8:	2300      	movs	r3, #0
  20e8da:	9301      	str	r3, [sp, #4]
  20e8dc:	e00a      	b.n	20e8f4 <oslib_test_007_001_execute+0x94>
      chPoolFree(&mp1, &objects[i]);
  20e8de:	9b01      	ldr	r3, [sp, #4]
  20e8e0:	009b      	lsls	r3, r3, #2
  20e8e2:	4a2b      	ldr	r2, [pc, #172]	@ (20e990 <oslib_test_007_001_execute+0x130>)
  20e8e4:	4413      	add	r3, r2
  20e8e6:	4619      	mov	r1, r3
  20e8e8:	482a      	ldr	r0, [pc, #168]	@ (20e994 <oslib_test_007_001_execute+0x134>)
  20e8ea:	f7f7 f921 	bl	205b30 <chPoolFree>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20e8ee:	9b01      	ldr	r3, [sp, #4]
  20e8f0:	3301      	adds	r3, #1
  20e8f2:	9301      	str	r3, [sp, #4]
  20e8f4:	9b01      	ldr	r3, [sp, #4]
  20e8f6:	2b03      	cmp	r3, #3
  20e8f8:	d9f1      	bls.n	20e8de <oslib_test_007_001_execute+0x7e>
  }
  test_end_step(4);

  /* [7.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
  20e8fa:	4b24      	ldr	r3, [pc, #144]	@ (20e98c <oslib_test_007_001_execute+0x12c>)
  20e8fc:	2205      	movs	r2, #5
  20e8fe:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20e900:	2300      	movs	r3, #0
  20e902:	9301      	str	r3, [sp, #4]
  20e904:	e012      	b.n	20e92c <oslib_test_007_001_execute+0xcc>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  20e906:	4823      	ldr	r0, [pc, #140]	@ (20e994 <oslib_test_007_001_execute+0x134>)
  20e908:	f7f7 f8f2 	bl	205af0 <chPoolAlloc>
  20e90c:	4603      	mov	r3, r0
  20e90e:	2b00      	cmp	r3, #0
  20e910:	bf14      	ite	ne
  20e912:	2301      	movne	r3, #1
  20e914:	2300      	moveq	r3, #0
  20e916:	b2db      	uxtb	r3, r3
  20e918:	491f      	ldr	r1, [pc, #124]	@ (20e998 <oslib_test_007_001_execute+0x138>)
  20e91a:	4618      	mov	r0, r3
  20e91c:	f7f8 fea0 	bl	207660 <__test_assert>
  20e920:	4603      	mov	r3, r0
  20e922:	2b00      	cmp	r3, #0
  20e924:	d12f      	bne.n	20e986 <oslib_test_007_001_execute+0x126>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20e926:	9b01      	ldr	r3, [sp, #4]
  20e928:	3301      	adds	r3, #1
  20e92a:	9301      	str	r3, [sp, #4]
  20e92c:	9b01      	ldr	r3, [sp, #4]
  20e92e:	2b03      	cmp	r3, #3
  20e930:	d9e9      	bls.n	20e906 <oslib_test_007_001_execute+0xa6>
  }
  test_end_step(5);

  /* [7.1.6] Now must be empty again.*/
  test_set_step(6);
  20e932:	4b16      	ldr	r3, [pc, #88]	@ (20e98c <oslib_test_007_001_execute+0x12c>)
  20e934:	2206      	movs	r2, #6
  20e936:	601a      	str	r2, [r3, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
  20e938:	4816      	ldr	r0, [pc, #88]	@ (20e994 <oslib_test_007_001_execute+0x134>)
  20e93a:	f7f7 f8d9 	bl	205af0 <chPoolAlloc>
  20e93e:	4603      	mov	r3, r0
  20e940:	2b00      	cmp	r3, #0
  20e942:	bf0c      	ite	eq
  20e944:	2301      	moveq	r3, #1
  20e946:	2300      	movne	r3, #0
  20e948:	b2db      	uxtb	r3, r3
  20e94a:	4914      	ldr	r1, [pc, #80]	@ (20e99c <oslib_test_007_001_execute+0x13c>)
  20e94c:	4618      	mov	r0, r3
  20e94e:	f7f8 fe87 	bl	207660 <__test_assert>
  20e952:	4603      	mov	r3, r0
  20e954:	2b00      	cmp	r3, #0
  20e956:	d116      	bne.n	20e986 <oslib_test_007_001_execute+0x126>
  }
  test_end_step(6);

  /* [7.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
  20e958:	4b0c      	ldr	r3, [pc, #48]	@ (20e98c <oslib_test_007_001_execute+0x12c>)
  20e95a:	2207      	movs	r2, #7
  20e95c:	601a      	str	r2, [r3, #0]
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
  20e95e:	4a10      	ldr	r2, [pc, #64]	@ (20e9a0 <oslib_test_007_001_execute+0x140>)
  20e960:	2104      	movs	r1, #4
  20e962:	480c      	ldr	r0, [pc, #48]	@ (20e994 <oslib_test_007_001_execute+0x134>)
  20e964:	f7ff ff44 	bl	20e7f0 <chPoolObjectInit.lto_priv.2>
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
  20e968:	480a      	ldr	r0, [pc, #40]	@ (20e994 <oslib_test_007_001_execute+0x134>)
  20e96a:	f7f7 f8c1 	bl	205af0 <chPoolAlloc>
  20e96e:	4603      	mov	r3, r0
  20e970:	2b00      	cmp	r3, #0
  20e972:	bf0c      	ite	eq
  20e974:	2301      	moveq	r3, #1
  20e976:	2300      	movne	r3, #0
  20e978:	b2db      	uxtb	r3, r3
  20e97a:	490a      	ldr	r1, [pc, #40]	@ (20e9a4 <oslib_test_007_001_execute+0x144>)
  20e97c:	4618      	mov	r0, r3
  20e97e:	f7f8 fe6f 	bl	207660 <__test_assert>
  20e982:	4603      	mov	r3, r0
  20e984:	2b00      	cmp	r3, #0
  }
  test_end_step(7);
}
  20e986:	b003      	add	sp, #12
  20e988:	f85d fb04 	ldr.w	pc, [sp], #4
  20e98c:	20000bb4 	.word	0x20000bb4
  20e990:	20002474 	.word	0x20002474
  20e994:	200200a8 	.word	0x200200a8
  20e998:	08012034 	.word	0x08012034
  20e99c:	08012040 	.word	0x08012040
  20e9a0:	0020e831 	.word	0x0020e831
  20e9a4:	08012050 	.word	0x08012050
	...

0020e9b0 <oslib_test_007_002_setup>:
 * - [7.2.5] Emptying the pool using chGuardedPoolAllocTimeout() again.
 * - [7.2.6] Now must be empty again.
 * .
 */

static void oslib_test_007_002_setup(void) {
  20e9b0:	b508      	push	{r3, lr}
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
  20e9b2:	2104      	movs	r1, #4
  20e9b4:	4802      	ldr	r0, [pc, #8]	@ (20e9c0 <oslib_test_007_002_setup+0x10>)
  20e9b6:	f7ff ff2b 	bl	20e810 <chGuardedPoolObjectInit.lto_priv.1>
}
  20e9ba:	bf00      	nop
  20e9bc:	bd08      	pop	{r3, pc}
  20e9be:	bf00      	nop
  20e9c0:	200200b8 	.word	0x200200b8
	...

0020e9d0 <oslib_test_007_002_execute>:

static void oslib_test_007_002_execute(void) {
  20e9d0:	b500      	push	{lr}
  20e9d2:	b083      	sub	sp, #12
  unsigned i;

  /* [7.2.1] Adding the objects to the pool using
     chGuardedPoolLoadArray().*/
  test_set_step(1);
  20e9d4:	4b3f      	ldr	r3, [pc, #252]	@ (20ead4 <oslib_test_007_002_execute+0x104>)
  20e9d6:	2201      	movs	r2, #1
  20e9d8:	601a      	str	r2, [r3, #0]
  {
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
  20e9da:	2204      	movs	r2, #4
  20e9dc:	493e      	ldr	r1, [pc, #248]	@ (20ead8 <oslib_test_007_002_execute+0x108>)
  20e9de:	483f      	ldr	r0, [pc, #252]	@ (20eadc <oslib_test_007_002_execute+0x10c>)
  20e9e0:	f7f7 f8ce 	bl	205b80 <chGuardedPoolLoadArray>
  }
  test_end_step(1);

  /* [7.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
  20e9e4:	4b3b      	ldr	r3, [pc, #236]	@ (20ead4 <oslib_test_007_002_execute+0x104>)
  20e9e6:	2202      	movs	r2, #2
  20e9e8:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20e9ea:	2300      	movs	r3, #0
  20e9ec:	9301      	str	r3, [sp, #4]
  20e9ee:	e013      	b.n	20ea18 <oslib_test_007_002_execute+0x48>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  20e9f0:	2100      	movs	r1, #0
  20e9f2:	483a      	ldr	r0, [pc, #232]	@ (20eadc <oslib_test_007_002_execute+0x10c>)
  20e9f4:	f7f7 f904 	bl	205c00 <chGuardedPoolAllocTimeout>
  20e9f8:	4603      	mov	r3, r0
  20e9fa:	2b00      	cmp	r3, #0
  20e9fc:	bf14      	ite	ne
  20e9fe:	2301      	movne	r3, #1
  20ea00:	2300      	moveq	r3, #0
  20ea02:	b2db      	uxtb	r3, r3
  20ea04:	4936      	ldr	r1, [pc, #216]	@ (20eae0 <oslib_test_007_002_execute+0x110>)
  20ea06:	4618      	mov	r0, r3
  20ea08:	f7f8 fe2a 	bl	207660 <__test_assert>
  20ea0c:	4603      	mov	r3, r0
  20ea0e:	2b00      	cmp	r3, #0
  20ea10:	d15d      	bne.n	20eace <oslib_test_007_002_execute+0xfe>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20ea12:	9b01      	ldr	r3, [sp, #4]
  20ea14:	3301      	adds	r3, #1
  20ea16:	9301      	str	r3, [sp, #4]
  20ea18:	9b01      	ldr	r3, [sp, #4]
  20ea1a:	2b03      	cmp	r3, #3
  20ea1c:	d9e8      	bls.n	20e9f0 <oslib_test_007_002_execute+0x20>
  }
  test_end_step(2);

  /* [7.2.3] Now must be empty.*/
  test_set_step(3);
  20ea1e:	4b2d      	ldr	r3, [pc, #180]	@ (20ead4 <oslib_test_007_002_execute+0x104>)
  20ea20:	2203      	movs	r2, #3
  20ea22:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
  20ea24:	2100      	movs	r1, #0
  20ea26:	482d      	ldr	r0, [pc, #180]	@ (20eadc <oslib_test_007_002_execute+0x10c>)
  20ea28:	f7f7 f8ea 	bl	205c00 <chGuardedPoolAllocTimeout>
  20ea2c:	4603      	mov	r3, r0
  20ea2e:	2b00      	cmp	r3, #0
  20ea30:	bf0c      	ite	eq
  20ea32:	2301      	moveq	r3, #1
  20ea34:	2300      	movne	r3, #0
  20ea36:	b2db      	uxtb	r3, r3
  20ea38:	492a      	ldr	r1, [pc, #168]	@ (20eae4 <oslib_test_007_002_execute+0x114>)
  20ea3a:	4618      	mov	r0, r3
  20ea3c:	f7f8 fe10 	bl	207660 <__test_assert>
  20ea40:	4603      	mov	r3, r0
  20ea42:	2b00      	cmp	r3, #0
  20ea44:	d143      	bne.n	20eace <oslib_test_007_002_execute+0xfe>
  }
  test_end_step(3);

  /* [7.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
  20ea46:	4b23      	ldr	r3, [pc, #140]	@ (20ead4 <oslib_test_007_002_execute+0x104>)
  20ea48:	2204      	movs	r2, #4
  20ea4a:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20ea4c:	2300      	movs	r3, #0
  20ea4e:	9301      	str	r3, [sp, #4]
  20ea50:	e00a      	b.n	20ea68 <oslib_test_007_002_execute+0x98>
      chGuardedPoolFree(&gmp1, &objects[i]);
  20ea52:	9b01      	ldr	r3, [sp, #4]
  20ea54:	009b      	lsls	r3, r3, #2
  20ea56:	4a20      	ldr	r2, [pc, #128]	@ (20ead8 <oslib_test_007_002_execute+0x108>)
  20ea58:	4413      	add	r3, r2
  20ea5a:	4619      	mov	r1, r3
  20ea5c:	481f      	ldr	r0, [pc, #124]	@ (20eadc <oslib_test_007_002_execute+0x10c>)
  20ea5e:	f7f7 f8e7 	bl	205c30 <chGuardedPoolFree>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20ea62:	9b01      	ldr	r3, [sp, #4]
  20ea64:	3301      	adds	r3, #1
  20ea66:	9301      	str	r3, [sp, #4]
  20ea68:	9b01      	ldr	r3, [sp, #4]
  20ea6a:	2b03      	cmp	r3, #3
  20ea6c:	d9f1      	bls.n	20ea52 <oslib_test_007_002_execute+0x82>
  }
  test_end_step(4);

  /* [7.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
  20ea6e:	4b19      	ldr	r3, [pc, #100]	@ (20ead4 <oslib_test_007_002_execute+0x104>)
  20ea70:	2205      	movs	r2, #5
  20ea72:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20ea74:	2300      	movs	r3, #0
  20ea76:	9301      	str	r3, [sp, #4]
  20ea78:	e013      	b.n	20eaa2 <oslib_test_007_002_execute+0xd2>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  20ea7a:	2100      	movs	r1, #0
  20ea7c:	4817      	ldr	r0, [pc, #92]	@ (20eadc <oslib_test_007_002_execute+0x10c>)
  20ea7e:	f7f7 f8bf 	bl	205c00 <chGuardedPoolAllocTimeout>
  20ea82:	4603      	mov	r3, r0
  20ea84:	2b00      	cmp	r3, #0
  20ea86:	bf14      	ite	ne
  20ea88:	2301      	movne	r3, #1
  20ea8a:	2300      	moveq	r3, #0
  20ea8c:	b2db      	uxtb	r3, r3
  20ea8e:	4914      	ldr	r1, [pc, #80]	@ (20eae0 <oslib_test_007_002_execute+0x110>)
  20ea90:	4618      	mov	r0, r3
  20ea92:	f7f8 fde5 	bl	207660 <__test_assert>
  20ea96:	4603      	mov	r3, r0
  20ea98:	2b00      	cmp	r3, #0
  20ea9a:	d118      	bne.n	20eace <oslib_test_007_002_execute+0xfe>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  20ea9c:	9b01      	ldr	r3, [sp, #4]
  20ea9e:	3301      	adds	r3, #1
  20eaa0:	9301      	str	r3, [sp, #4]
  20eaa2:	9b01      	ldr	r3, [sp, #4]
  20eaa4:	2b03      	cmp	r3, #3
  20eaa6:	d9e8      	bls.n	20ea7a <oslib_test_007_002_execute+0xaa>
  }
  test_end_step(5);

  /* [7.2.6] Now must be empty again.*/
  test_set_step(6);
  20eaa8:	4b0a      	ldr	r3, [pc, #40]	@ (20ead4 <oslib_test_007_002_execute+0x104>)
  20eaaa:	2206      	movs	r2, #6
  20eaac:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
  20eaae:	2100      	movs	r1, #0
  20eab0:	480a      	ldr	r0, [pc, #40]	@ (20eadc <oslib_test_007_002_execute+0x10c>)
  20eab2:	f7f7 f8a5 	bl	205c00 <chGuardedPoolAllocTimeout>
  20eab6:	4603      	mov	r3, r0
  20eab8:	2b00      	cmp	r3, #0
  20eaba:	bf0c      	ite	eq
  20eabc:	2301      	moveq	r3, #1
  20eabe:	2300      	movne	r3, #0
  20eac0:	b2db      	uxtb	r3, r3
  20eac2:	4908      	ldr	r1, [pc, #32]	@ (20eae4 <oslib_test_007_002_execute+0x114>)
  20eac4:	4618      	mov	r0, r3
  20eac6:	f7f8 fdcb 	bl	207660 <__test_assert>
  20eaca:	4603      	mov	r3, r0
  20eacc:	2b00      	cmp	r3, #0
  }
  test_end_step(6);
}
  20eace:	b003      	add	sp, #12
  20ead0:	f85d fb04 	ldr.w	pc, [sp], #4
  20ead4:	20000bb4 	.word	0x20000bb4
  20ead8:	20002474 	.word	0x20002474
  20eadc:	200200b8 	.word	0x200200b8
  20eae0:	08012034 	.word	0x08012034
  20eae4:	08012040 	.word	0x08012040
	...

0020eaf0 <oslib_test_007_003_setup>:
 * - [7.3.1] Trying to allocate with 100mS timeout, must fail because
 *   the pool is empty.
 * .
 */

static void oslib_test_007_003_setup(void) {
  20eaf0:	b508      	push	{r3, lr}
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
  20eaf2:	2104      	movs	r1, #4
  20eaf4:	4802      	ldr	r0, [pc, #8]	@ (20eb00 <oslib_test_007_003_setup+0x10>)
  20eaf6:	f7ff fe8b 	bl	20e810 <chGuardedPoolObjectInit.lto_priv.1>
}
  20eafa:	bf00      	nop
  20eafc:	bd08      	pop	{r3, pc}
  20eafe:	bf00      	nop
  20eb00:	200200b8 	.word	0x200200b8
	...

0020eb10 <oslib_test_007_003_execute>:

static void oslib_test_007_003_execute(void) {
  20eb10:	b508      	push	{r3, lr}

  /* [7.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
  20eb12:	4b0a      	ldr	r3, [pc, #40]	@ (20eb3c <oslib_test_007_003_execute+0x2c>)
  20eb14:	2201      	movs	r2, #1
  20eb16:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
  20eb18:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
  20eb1c:	4808      	ldr	r0, [pc, #32]	@ (20eb40 <oslib_test_007_003_execute+0x30>)
  20eb1e:	f7f7 f86f 	bl	205c00 <chGuardedPoolAllocTimeout>
  20eb22:	4603      	mov	r3, r0
  20eb24:	2b00      	cmp	r3, #0
  20eb26:	bf0c      	ite	eq
  20eb28:	2301      	moveq	r3, #1
  20eb2a:	2300      	movne	r3, #0
  20eb2c:	b2db      	uxtb	r3, r3
  20eb2e:	4905      	ldr	r1, [pc, #20]	@ (20eb44 <oslib_test_007_003_execute+0x34>)
  20eb30:	4618      	mov	r0, r3
  20eb32:	f7f8 fd95 	bl	207660 <__test_assert>
  20eb36:	4603      	mov	r3, r0
  20eb38:	2b00      	cmp	r3, #0
  }
  test_end_step(1);
}
  20eb3a:	bd08      	pop	{r3, pc}
  20eb3c:	20000bb4 	.word	0x20000bb4
  20eb40:	200200b8 	.word	0x200200b8
  20eb44:	08012040 	.word	0x08012040
	...

0020eb50 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
  20eb50:	b500      	push	{lr}
  20eb52:	b083      	sub	sp, #12
  20eb54:	9001      	str	r0, [sp, #4]
  20eb56:	9100      	str	r1, [sp, #0]

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
  20eb58:	2208      	movs	r2, #8
  20eb5a:	9900      	ldr	r1, [sp, #0]
  20eb5c:	9801      	ldr	r0, [sp, #4]
  20eb5e:	f7f6 fd17 	bl	205590 <chHeapAllocAligned>
  20eb62:	4603      	mov	r3, r0
}
  20eb64:	4618      	mov	r0, r3
  20eb66:	b003      	add	sp, #12
  20eb68:	f85d fb04 	ldr.w	pc, [sp], #4
  20eb6c:	0000      	movs	r0, r0
	...

0020eb70 <oslib_test_008_001_setup>:
 *   same than the one registered at beginning, finally, integrity is
 *   checked.
 * .
 */

static void oslib_test_008_001_setup(void) {
  20eb70:	b508      	push	{r3, lr}
  chHeapObjectInit(&test_heap, test_heap_buffer, sizeof(test_heap_buffer));
  20eb72:	2280      	movs	r2, #128	@ 0x80
  20eb74:	4902      	ldr	r1, [pc, #8]	@ (20eb80 <oslib_test_008_001_setup+0x10>)
  20eb76:	4803      	ldr	r0, [pc, #12]	@ (20eb84 <oslib_test_008_001_setup+0x14>)
  20eb78:	f7f6 fcd2 	bl	205520 <chHeapObjectInit>
}
  20eb7c:	bf00      	nop
  20eb7e:	bd08      	pop	{r3, pc}
  20eb80:	200024a8 	.word	0x200024a8
  20eb84:	20002484 	.word	0x20002484
	...

0020eb90 <oslib_test_008_001_execute>:

static void oslib_test_008_001_execute(void) {
  20eb90:	b500      	push	{lr}
  20eb92:	b089      	sub	sp, #36	@ 0x24
  size_t n, sz;

  /* [8.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present, finally, integrity is
     checked.*/
  test_set_step(1);
  20eb94:	4bb1      	ldr	r3, [pc, #708]	@ (20ee5c <oslib_test_008_001_execute+0x2cc>)
  20eb96:	2201      	movs	r2, #1
  20eb98:	601a      	str	r2, [r3, #0]
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
  20eb9a:	ab03      	add	r3, sp, #12
  20eb9c:	2200      	movs	r2, #0
  20eb9e:	4619      	mov	r1, r3
  20eba0:	48af      	ldr	r0, [pc, #700]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20eba2:	f7f6 fe35 	bl	205810 <chHeapStatus>
  20eba6:	4603      	mov	r3, r0
  20eba8:	2b01      	cmp	r3, #1
  20ebaa:	bf0c      	ite	eq
  20ebac:	2301      	moveq	r3, #1
  20ebae:	2300      	movne	r3, #0
  20ebb0:	b2db      	uxtb	r3, r3
  20ebb2:	49ac      	ldr	r1, [pc, #688]	@ (20ee64 <oslib_test_008_001_execute+0x2d4>)
  20ebb4:	4618      	mov	r0, r3
  20ebb6:	f7f8 fd53 	bl	207660 <__test_assert>
  20ebba:	4603      	mov	r3, r0
  20ebbc:	2b00      	cmp	r3, #0
  20ebbe:	f040 82b2 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(!chHeapIntegrityCheck(&test_heap), "integrity failure");
  20ebc2:	48a7      	ldr	r0, [pc, #668]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ebc4:	f7f6 fe74 	bl	2058b0 <chHeapIntegrityCheck>
  20ebc8:	4603      	mov	r3, r0
  20ebca:	2b00      	cmp	r3, #0
  20ebcc:	bf14      	ite	ne
  20ebce:	2301      	movne	r3, #1
  20ebd0:	2300      	moveq	r3, #0
  20ebd2:	b2db      	uxtb	r3, r3
  20ebd4:	f083 0301 	eor.w	r3, r3, #1
  20ebd8:	b2db      	uxtb	r3, r3
  20ebda:	f003 0301 	and.w	r3, r3, #1
  20ebde:	b2db      	uxtb	r3, r3
  20ebe0:	49a1      	ldr	r1, [pc, #644]	@ (20ee68 <oslib_test_008_001_execute+0x2d8>)
  20ebe2:	4618      	mov	r0, r3
  20ebe4:	f7f8 fd3c 	bl	207660 <__test_assert>
  20ebe8:	4603      	mov	r3, r0
  20ebea:	2b00      	cmp	r3, #0
  20ebec:	f040 829b 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
  }
  test_end_step(1);

  /* [8.1.2] Trying to allocate an block bigger than available space,
     an error is expected, finally, integrity is checked.*/
  test_set_step(2);
  20ebf0:	4b9a      	ldr	r3, [pc, #616]	@ (20ee5c <oslib_test_008_001_execute+0x2cc>)
  20ebf2:	2202      	movs	r2, #2
  20ebf4:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, sizeof test_heap_buffer * 2);
  20ebf6:	f44f 7180 	mov.w	r1, #256	@ 0x100
  20ebfa:	4899      	ldr	r0, [pc, #612]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ebfc:	f7ff ffa8 	bl	20eb50 <chHeapAlloc>
  20ec00:	9007      	str	r0, [sp, #28]
    test_assert(p1 == NULL, "allocation not failed");
  20ec02:	9b07      	ldr	r3, [sp, #28]
  20ec04:	2b00      	cmp	r3, #0
  20ec06:	bf0c      	ite	eq
  20ec08:	2301      	moveq	r3, #1
  20ec0a:	2300      	movne	r3, #0
  20ec0c:	b2db      	uxtb	r3, r3
  20ec0e:	4997      	ldr	r1, [pc, #604]	@ (20ee6c <oslib_test_008_001_execute+0x2dc>)
  20ec10:	4618      	mov	r0, r3
  20ec12:	f7f8 fd25 	bl	207660 <__test_assert>
  20ec16:	4603      	mov	r3, r0
  20ec18:	2b00      	cmp	r3, #0
  20ec1a:	f040 8284 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(!chHeapIntegrityCheck(&test_heap), "integrity failure");
  20ec1e:	4890      	ldr	r0, [pc, #576]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ec20:	f7f6 fe46 	bl	2058b0 <chHeapIntegrityCheck>
  20ec24:	4603      	mov	r3, r0
  20ec26:	2b00      	cmp	r3, #0
  20ec28:	bf14      	ite	ne
  20ec2a:	2301      	movne	r3, #1
  20ec2c:	2300      	moveq	r3, #0
  20ec2e:	b2db      	uxtb	r3, r3
  20ec30:	f083 0301 	eor.w	r3, r3, #1
  20ec34:	b2db      	uxtb	r3, r3
  20ec36:	f003 0301 	and.w	r3, r3, #1
  20ec3a:	b2db      	uxtb	r3, r3
  20ec3c:	498a      	ldr	r1, [pc, #552]	@ (20ee68 <oslib_test_008_001_execute+0x2d8>)
  20ec3e:	4618      	mov	r0, r3
  20ec40:	f7f8 fd0e 	bl	207660 <__test_assert>
  20ec44:	4603      	mov	r3, r0
  20ec46:	2b00      	cmp	r3, #0
  20ec48:	f040 826d 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
  test_end_step(2);

  /* [8.1.3] Single block allocation using chHeapAlloc() then the block
     is freed using chHeapFree(), must not fail, finally, integrity is
     checked.*/
  test_set_step(3);
  20ec4c:	4b83      	ldr	r3, [pc, #524]	@ (20ee5c <oslib_test_008_001_execute+0x2cc>)
  20ec4e:	2203      	movs	r2, #3
  20ec50:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20ec52:	2110      	movs	r1, #16
  20ec54:	4882      	ldr	r0, [pc, #520]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ec56:	f7ff ff7b 	bl	20eb50 <chHeapAlloc>
  20ec5a:	9007      	str	r0, [sp, #28]
    test_assert(p1 != NULL, "allocation failed");
  20ec5c:	9b07      	ldr	r3, [sp, #28]
  20ec5e:	2b00      	cmp	r3, #0
  20ec60:	bf14      	ite	ne
  20ec62:	2301      	movne	r3, #1
  20ec64:	2300      	moveq	r3, #0
  20ec66:	b2db      	uxtb	r3, r3
  20ec68:	4981      	ldr	r1, [pc, #516]	@ (20ee70 <oslib_test_008_001_execute+0x2e0>)
  20ec6a:	4618      	mov	r0, r3
  20ec6c:	f7f8 fcf8 	bl	207660 <__test_assert>
  20ec70:	4603      	mov	r3, r0
  20ec72:	2b00      	cmp	r3, #0
  20ec74:	f040 8257 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    chHeapFree(p1);
  20ec78:	9807      	ldr	r0, [sp, #28]
  20ec7a:	f7f6 fd59 	bl	205730 <chHeapFree>
    test_assert(!chHeapIntegrityCheck(&test_heap), "integrity failure");
  20ec7e:	4878      	ldr	r0, [pc, #480]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ec80:	f7f6 fe16 	bl	2058b0 <chHeapIntegrityCheck>
  20ec84:	4603      	mov	r3, r0
  20ec86:	2b00      	cmp	r3, #0
  20ec88:	bf14      	ite	ne
  20ec8a:	2301      	movne	r3, #1
  20ec8c:	2300      	moveq	r3, #0
  20ec8e:	b2db      	uxtb	r3, r3
  20ec90:	f083 0301 	eor.w	r3, r3, #1
  20ec94:	b2db      	uxtb	r3, r3
  20ec96:	f003 0301 	and.w	r3, r3, #1
  20ec9a:	b2db      	uxtb	r3, r3
  20ec9c:	4972      	ldr	r1, [pc, #456]	@ (20ee68 <oslib_test_008_001_execute+0x2d8>)
  20ec9e:	4618      	mov	r0, r3
  20eca0:	f7f8 fcde 	bl	207660 <__test_assert>
  20eca4:	4603      	mov	r3, r0
  20eca6:	2b00      	cmp	r3, #0
  20eca8:	f040 823d 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
  test_end_step(3);

  /* [8.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size, finally, integrity
     is checked.*/
  test_set_step(4);
  20ecac:	4b6b      	ldr	r3, [pc, #428]	@ (20ee5c <oslib_test_008_001_execute+0x2cc>)
  20ecae:	2204      	movs	r2, #4
  20ecb0:	601a      	str	r2, [r3, #0]
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
  20ecb2:	aa01      	add	r2, sp, #4
  20ecb4:	ab02      	add	r3, sp, #8
  20ecb6:	4619      	mov	r1, r3
  20ecb8:	4869      	ldr	r0, [pc, #420]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ecba:	f7f6 fda9 	bl	205810 <chHeapStatus>
  20ecbe:	4603      	mov	r3, r0
  20ecc0:	9304      	str	r3, [sp, #16]
    test_assert(n == 1, "missing free block");
  20ecc2:	9b04      	ldr	r3, [sp, #16]
  20ecc4:	2b01      	cmp	r3, #1
  20ecc6:	bf0c      	ite	eq
  20ecc8:	2301      	moveq	r3, #1
  20ecca:	2300      	movne	r3, #0
  20eccc:	b2db      	uxtb	r3, r3
  20ecce:	4969      	ldr	r1, [pc, #420]	@ (20ee74 <oslib_test_008_001_execute+0x2e4>)
  20ecd0:	4618      	mov	r0, r3
  20ecd2:	f7f8 fcc5 	bl	207660 <__test_assert>
  20ecd6:	4603      	mov	r3, r0
  20ecd8:	2b00      	cmp	r3, #0
  20ecda:	f040 8224 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
  20ecde:	9b02      	ldr	r3, [sp, #8]
  20ece0:	2b0f      	cmp	r3, #15
  20ece2:	bf8c      	ite	hi
  20ece4:	2301      	movhi	r3, #1
  20ece6:	2300      	movls	r3, #0
  20ece8:	b2db      	uxtb	r3, r3
  20ecea:	4963      	ldr	r1, [pc, #396]	@ (20ee78 <oslib_test_008_001_execute+0x2e8>)
  20ecec:	4618      	mov	r0, r3
  20ecee:	f7f8 fcb7 	bl	207660 <__test_assert>
  20ecf2:	4603      	mov	r3, r0
  20ecf4:	2b00      	cmp	r3, #0
  20ecf6:	f040 8216 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(total_size == largest_size, "unexpected heap state");
  20ecfa:	9a02      	ldr	r2, [sp, #8]
  20ecfc:	9b01      	ldr	r3, [sp, #4]
  20ecfe:	429a      	cmp	r2, r3
  20ed00:	bf0c      	ite	eq
  20ed02:	2301      	moveq	r3, #1
  20ed04:	2300      	movne	r3, #0
  20ed06:	b2db      	uxtb	r3, r3
  20ed08:	495b      	ldr	r1, [pc, #364]	@ (20ee78 <oslib_test_008_001_execute+0x2e8>)
  20ed0a:	4618      	mov	r0, r3
  20ed0c:	f7f8 fca8 	bl	207660 <__test_assert>
  20ed10:	4603      	mov	r3, r0
  20ed12:	2b00      	cmp	r3, #0
  20ed14:	f040 8207 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(!chHeapIntegrityCheck(&test_heap), "integrity failure");
  20ed18:	4851      	ldr	r0, [pc, #324]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ed1a:	f7f6 fdc9 	bl	2058b0 <chHeapIntegrityCheck>
  20ed1e:	4603      	mov	r3, r0
  20ed20:	2b00      	cmp	r3, #0
  20ed22:	bf14      	ite	ne
  20ed24:	2301      	movne	r3, #1
  20ed26:	2300      	moveq	r3, #0
  20ed28:	b2db      	uxtb	r3, r3
  20ed2a:	f083 0301 	eor.w	r3, r3, #1
  20ed2e:	b2db      	uxtb	r3, r3
  20ed30:	f003 0301 	and.w	r3, r3, #1
  20ed34:	b2db      	uxtb	r3, r3
  20ed36:	494c      	ldr	r1, [pc, #304]	@ (20ee68 <oslib_test_008_001_execute+0x2d8>)
  20ed38:	4618      	mov	r0, r3
  20ed3a:	f7f8 fc91 	bl	207660 <__test_assert>
  20ed3e:	4603      	mov	r3, r0
  20ed40:	2b00      	cmp	r3, #0
  20ed42:	f040 81f0 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
  }
  test_end_step(4);

  /* [8.1.5] Allocating then freeing in the same order, finally,
     integrity is checked.*/
  test_set_step(5);
  20ed46:	4b45      	ldr	r3, [pc, #276]	@ (20ee5c <oslib_test_008_001_execute+0x2cc>)
  20ed48:	2205      	movs	r2, #5
  20ed4a:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20ed4c:	2110      	movs	r1, #16
  20ed4e:	4844      	ldr	r0, [pc, #272]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ed50:	f7ff fefe 	bl	20eb50 <chHeapAlloc>
  20ed54:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20ed56:	2110      	movs	r1, #16
  20ed58:	4841      	ldr	r0, [pc, #260]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ed5a:	f7ff fef9 	bl	20eb50 <chHeapAlloc>
  20ed5e:	9006      	str	r0, [sp, #24]
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20ed60:	2110      	movs	r1, #16
  20ed62:	483f      	ldr	r0, [pc, #252]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ed64:	f7ff fef4 	bl	20eb50 <chHeapAlloc>
  20ed68:	9005      	str	r0, [sp, #20]
    chHeapFree(p1);                                 /* Does not merge.*/
  20ed6a:	9807      	ldr	r0, [sp, #28]
  20ed6c:	f7f6 fce0 	bl	205730 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
  20ed70:	9806      	ldr	r0, [sp, #24]
  20ed72:	f7f6 fcdd 	bl	205730 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
  20ed76:	9805      	ldr	r0, [sp, #20]
  20ed78:	f7f6 fcda 	bl	205730 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  20ed7c:	ab04      	add	r3, sp, #16
  20ed7e:	2200      	movs	r2, #0
  20ed80:	4619      	mov	r1, r3
  20ed82:	4837      	ldr	r0, [pc, #220]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ed84:	f7f6 fd44 	bl	205810 <chHeapStatus>
  20ed88:	4603      	mov	r3, r0
  20ed8a:	2b01      	cmp	r3, #1
  20ed8c:	bf0c      	ite	eq
  20ed8e:	2301      	moveq	r3, #1
  20ed90:	2300      	movne	r3, #0
  20ed92:	b2db      	uxtb	r3, r3
  20ed94:	4933      	ldr	r1, [pc, #204]	@ (20ee64 <oslib_test_008_001_execute+0x2d4>)
  20ed96:	4618      	mov	r0, r3
  20ed98:	f7f8 fc62 	bl	207660 <__test_assert>
  20ed9c:	4603      	mov	r3, r0
  20ed9e:	2b00      	cmp	r3, #0
  20eda0:	f040 81c1 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(!chHeapIntegrityCheck(&test_heap), "integrity failure");
  20eda4:	482e      	ldr	r0, [pc, #184]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20eda6:	f7f6 fd83 	bl	2058b0 <chHeapIntegrityCheck>
  20edaa:	4603      	mov	r3, r0
  20edac:	2b00      	cmp	r3, #0
  20edae:	bf14      	ite	ne
  20edb0:	2301      	movne	r3, #1
  20edb2:	2300      	moveq	r3, #0
  20edb4:	b2db      	uxtb	r3, r3
  20edb6:	f083 0301 	eor.w	r3, r3, #1
  20edba:	b2db      	uxtb	r3, r3
  20edbc:	f003 0301 	and.w	r3, r3, #1
  20edc0:	b2db      	uxtb	r3, r3
  20edc2:	4929      	ldr	r1, [pc, #164]	@ (20ee68 <oslib_test_008_001_execute+0x2d8>)
  20edc4:	4618      	mov	r0, r3
  20edc6:	f7f8 fc4b 	bl	207660 <__test_assert>
  20edca:	4603      	mov	r3, r0
  20edcc:	2b00      	cmp	r3, #0
  20edce:	f040 81aa 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
  }
  test_end_step(5);

  /* [8.1.6] Allocating then freeing in reverse order, finally,
     integrity is checked.*/
  test_set_step(6);
  20edd2:	4b22      	ldr	r3, [pc, #136]	@ (20ee5c <oslib_test_008_001_execute+0x2cc>)
  20edd4:	2206      	movs	r2, #6
  20edd6:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20edd8:	2110      	movs	r1, #16
  20edda:	4821      	ldr	r0, [pc, #132]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20eddc:	f7ff feb8 	bl	20eb50 <chHeapAlloc>
  20ede0:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20ede2:	2110      	movs	r1, #16
  20ede4:	481e      	ldr	r0, [pc, #120]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ede6:	f7ff feb3 	bl	20eb50 <chHeapAlloc>
  20edea:	9006      	str	r0, [sp, #24]
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20edec:	2110      	movs	r1, #16
  20edee:	481c      	ldr	r0, [pc, #112]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20edf0:	f7ff feae 	bl	20eb50 <chHeapAlloc>
  20edf4:	9005      	str	r0, [sp, #20]
    chHeapFree(p3);                                 /* Merges forward.*/
  20edf6:	9805      	ldr	r0, [sp, #20]
  20edf8:	f7f6 fc9a 	bl	205730 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
  20edfc:	9806      	ldr	r0, [sp, #24]
  20edfe:	f7f6 fc97 	bl	205730 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
  20ee02:	9807      	ldr	r0, [sp, #28]
  20ee04:	f7f6 fc94 	bl	205730 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  20ee08:	ab04      	add	r3, sp, #16
  20ee0a:	2200      	movs	r2, #0
  20ee0c:	4619      	mov	r1, r3
  20ee0e:	4814      	ldr	r0, [pc, #80]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ee10:	f7f6 fcfe 	bl	205810 <chHeapStatus>
  20ee14:	4603      	mov	r3, r0
  20ee16:	2b01      	cmp	r3, #1
  20ee18:	bf0c      	ite	eq
  20ee1a:	2301      	moveq	r3, #1
  20ee1c:	2300      	movne	r3, #0
  20ee1e:	b2db      	uxtb	r3, r3
  20ee20:	4910      	ldr	r1, [pc, #64]	@ (20ee64 <oslib_test_008_001_execute+0x2d4>)
  20ee22:	4618      	mov	r0, r3
  20ee24:	f7f8 fc1c 	bl	207660 <__test_assert>
  20ee28:	4603      	mov	r3, r0
  20ee2a:	2b00      	cmp	r3, #0
  20ee2c:	f040 817b 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(!chHeapIntegrityCheck(&test_heap), "integrity failure");
  20ee30:	480b      	ldr	r0, [pc, #44]	@ (20ee60 <oslib_test_008_001_execute+0x2d0>)
  20ee32:	f7f6 fd3d 	bl	2058b0 <chHeapIntegrityCheck>
  20ee36:	4603      	mov	r3, r0
  20ee38:	2b00      	cmp	r3, #0
  20ee3a:	bf14      	ite	ne
  20ee3c:	2301      	movne	r3, #1
  20ee3e:	2300      	moveq	r3, #0
  20ee40:	b2db      	uxtb	r3, r3
  20ee42:	f083 0301 	eor.w	r3, r3, #1
  20ee46:	b2db      	uxtb	r3, r3
  20ee48:	f003 0301 	and.w	r3, r3, #1
  20ee4c:	b2db      	uxtb	r3, r3
  20ee4e:	4906      	ldr	r1, [pc, #24]	@ (20ee68 <oslib_test_008_001_execute+0x2d8>)
  20ee50:	4618      	mov	r0, r3
  20ee52:	f7f8 fc05 	bl	207660 <__test_assert>
  20ee56:	4603      	mov	r3, r0
  20ee58:	2b00      	cmp	r3, #0
  20ee5a:	e00f      	b.n	20ee7c <oslib_test_008_001_execute+0x2ec>
  20ee5c:	20000bb4 	.word	0x20000bb4
  20ee60:	20002484 	.word	0x20002484
  20ee64:	08011934 	.word	0x08011934
  20ee68:	0801206c 	.word	0x0801206c
  20ee6c:	08012080 	.word	0x08012080
  20ee70:	08012098 	.word	0x08012098
  20ee74:	080120ac 	.word	0x080120ac
  20ee78:	080120c0 	.word	0x080120c0
  20ee7c:	f040 8153 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
  test_end_step(6);

  /* [8.1.7] Small fragments handling. Checking the behavior when
     allocating blocks with size not multiple of alignment unit,
     finally, integrity is checked.*/
  test_set_step(7);
  20ee80:	4baa      	ldr	r3, [pc, #680]	@ (20f12c <oslib_test_008_001_execute+0x59c>)
  20ee82:	2207      	movs	r2, #7
  20ee84:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE + 1);
  20ee86:	2111      	movs	r1, #17
  20ee88:	48a9      	ldr	r0, [pc, #676]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20ee8a:	f7ff fe61 	bl	20eb50 <chHeapAlloc>
  20ee8e:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20ee90:	2110      	movs	r1, #16
  20ee92:	48a7      	ldr	r0, [pc, #668]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20ee94:	f7ff fe5c 	bl	20eb50 <chHeapAlloc>
  20ee98:	9006      	str	r0, [sp, #24]
    chHeapFree(p1);
  20ee9a:	9807      	ldr	r0, [sp, #28]
  20ee9c:	f7f6 fc48 	bl	205730 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
  20eea0:	ab04      	add	r3, sp, #16
  20eea2:	2200      	movs	r2, #0
  20eea4:	4619      	mov	r1, r3
  20eea6:	48a2      	ldr	r0, [pc, #648]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20eea8:	f7f6 fcb2 	bl	205810 <chHeapStatus>
  20eeac:	4603      	mov	r3, r0
  20eeae:	2b02      	cmp	r3, #2
  20eeb0:	bf0c      	ite	eq
  20eeb2:	2301      	moveq	r3, #1
  20eeb4:	2300      	movne	r3, #0
  20eeb6:	b2db      	uxtb	r3, r3
  20eeb8:	499e      	ldr	r1, [pc, #632]	@ (20f134 <oslib_test_008_001_execute+0x5a4>)
  20eeba:	4618      	mov	r0, r3
  20eebc:	f7f8 fbd0 	bl	207660 <__test_assert>
  20eec0:	4603      	mov	r3, r0
  20eec2:	2b00      	cmp	r3, #0
  20eec4:	f040 812f 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20eec8:	2110      	movs	r1, #16
  20eeca:	4899      	ldr	r0, [pc, #612]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20eecc:	f7ff fe40 	bl	20eb50 <chHeapAlloc>
  20eed0:	9007      	str	r0, [sp, #28]
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
  20eed2:	ab04      	add	r3, sp, #16
  20eed4:	2200      	movs	r2, #0
  20eed6:	4619      	mov	r1, r3
  20eed8:	4895      	ldr	r0, [pc, #596]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20eeda:	f7f6 fc99 	bl	205810 <chHeapStatus>
  20eede:	4603      	mov	r3, r0
  20eee0:	2b01      	cmp	r3, #1
  20eee2:	d008      	beq.n	20eef6 <oslib_test_008_001_execute+0x366>
  20eee4:	ab04      	add	r3, sp, #16
  20eee6:	2200      	movs	r2, #0
  20eee8:	4619      	mov	r1, r3
  20eeea:	4891      	ldr	r0, [pc, #580]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20eeec:	f7f6 fc90 	bl	205810 <chHeapStatus>
  20eef0:	4603      	mov	r3, r0
  20eef2:	2b02      	cmp	r3, #2
  20eef4:	d101      	bne.n	20eefa <oslib_test_008_001_execute+0x36a>
  20eef6:	2301      	movs	r3, #1
  20eef8:	e000      	b.n	20eefc <oslib_test_008_001_execute+0x36c>
  20eefa:	2300      	movs	r3, #0
  20eefc:	f003 0301 	and.w	r3, r3, #1
  20ef00:	b2db      	uxtb	r3, r3
  20ef02:	498d      	ldr	r1, [pc, #564]	@ (20f138 <oslib_test_008_001_execute+0x5a8>)
  20ef04:	4618      	mov	r0, r3
  20ef06:	f7f8 fbab 	bl	207660 <__test_assert>
  20ef0a:	4603      	mov	r3, r0
  20ef0c:	2b00      	cmp	r3, #0
  20ef0e:	f040 810a 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
                (chHeapStatus(&test_heap, &n, NULL) == 2), "heap fragmented");
    chHeapFree(p2);
  20ef12:	9806      	ldr	r0, [sp, #24]
  20ef14:	f7f6 fc0c 	bl	205730 <chHeapFree>
    chHeapFree(p1);
  20ef18:	9807      	ldr	r0, [sp, #28]
  20ef1a:	f7f6 fc09 	bl	205730 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  20ef1e:	ab04      	add	r3, sp, #16
  20ef20:	2200      	movs	r2, #0
  20ef22:	4619      	mov	r1, r3
  20ef24:	4882      	ldr	r0, [pc, #520]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20ef26:	f7f6 fc73 	bl	205810 <chHeapStatus>
  20ef2a:	4603      	mov	r3, r0
  20ef2c:	2b01      	cmp	r3, #1
  20ef2e:	bf0c      	ite	eq
  20ef30:	2301      	moveq	r3, #1
  20ef32:	2300      	movne	r3, #0
  20ef34:	b2db      	uxtb	r3, r3
  20ef36:	4980      	ldr	r1, [pc, #512]	@ (20f138 <oslib_test_008_001_execute+0x5a8>)
  20ef38:	4618      	mov	r0, r3
  20ef3a:	f7f8 fb91 	bl	207660 <__test_assert>
  20ef3e:	4603      	mov	r3, r0
  20ef40:	2b00      	cmp	r3, #0
  20ef42:	f040 80f0 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(!chHeapIntegrityCheck(&test_heap), "integrity failure");
  20ef46:	487a      	ldr	r0, [pc, #488]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20ef48:	f7f6 fcb2 	bl	2058b0 <chHeapIntegrityCheck>
  20ef4c:	4603      	mov	r3, r0
  20ef4e:	2b00      	cmp	r3, #0
  20ef50:	bf14      	ite	ne
  20ef52:	2301      	movne	r3, #1
  20ef54:	2300      	moveq	r3, #0
  20ef56:	b2db      	uxtb	r3, r3
  20ef58:	f083 0301 	eor.w	r3, r3, #1
  20ef5c:	b2db      	uxtb	r3, r3
  20ef5e:	f003 0301 	and.w	r3, r3, #1
  20ef62:	b2db      	uxtb	r3, r3
  20ef64:	4975      	ldr	r1, [pc, #468]	@ (20f13c <oslib_test_008_001_execute+0x5ac>)
  20ef66:	4618      	mov	r0, r3
  20ef68:	f7f8 fb7a 	bl	207660 <__test_assert>
  20ef6c:	4603      	mov	r3, r0
  20ef6e:	2b00      	cmp	r3, #0
  20ef70:	f040 80d9 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
  test_end_step(7);

  /* [8.1.8] Skipping a fragment, the first fragment in the list is too
     small so the allocator must pick the second one, finally,
     integrity is checked.*/
  test_set_step(8);
  20ef74:	4b6d      	ldr	r3, [pc, #436]	@ (20f12c <oslib_test_008_001_execute+0x59c>)
  20ef76:	2208      	movs	r2, #8
  20ef78:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20ef7a:	2110      	movs	r1, #16
  20ef7c:	486c      	ldr	r0, [pc, #432]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20ef7e:	f7ff fde7 	bl	20eb50 <chHeapAlloc>
  20ef82:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20ef84:	2110      	movs	r1, #16
  20ef86:	486a      	ldr	r0, [pc, #424]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20ef88:	f7ff fde2 	bl	20eb50 <chHeapAlloc>
  20ef8c:	9006      	str	r0, [sp, #24]
    chHeapFree(p1);
  20ef8e:	9807      	ldr	r0, [sp, #28]
  20ef90:	f7f6 fbce 	bl	205730 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
  20ef94:	ab04      	add	r3, sp, #16
  20ef96:	2200      	movs	r2, #0
  20ef98:	4619      	mov	r1, r3
  20ef9a:	4865      	ldr	r0, [pc, #404]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20ef9c:	f7f6 fc38 	bl	205810 <chHeapStatus>
  20efa0:	4603      	mov	r3, r0
  20efa2:	2b02      	cmp	r3, #2
  20efa4:	bf0c      	ite	eq
  20efa6:	2301      	moveq	r3, #1
  20efa8:	2300      	movne	r3, #0
  20efaa:	b2db      	uxtb	r3, r3
  20efac:	4961      	ldr	r1, [pc, #388]	@ (20f134 <oslib_test_008_001_execute+0x5a4>)
  20efae:	4618      	mov	r0, r3
  20efb0:	f7f8 fb56 	bl	207660 <__test_assert>
  20efb4:	4603      	mov	r3, r0
  20efb6:	2b00      	cmp	r3, #0
  20efb8:	f040 80b5 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE * 2); /* Skips first fragment.*/
  20efbc:	2120      	movs	r1, #32
  20efbe:	485c      	ldr	r0, [pc, #368]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20efc0:	f7ff fdc6 	bl	20eb50 <chHeapAlloc>
  20efc4:	9007      	str	r0, [sp, #28]
    chHeapFree(p1);
  20efc6:	9807      	ldr	r0, [sp, #28]
  20efc8:	f7f6 fbb2 	bl	205730 <chHeapFree>
    chHeapFree(p2);
  20efcc:	9806      	ldr	r0, [sp, #24]
  20efce:	f7f6 fbaf 	bl	205730 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  20efd2:	ab04      	add	r3, sp, #16
  20efd4:	2200      	movs	r2, #0
  20efd6:	4619      	mov	r1, r3
  20efd8:	4855      	ldr	r0, [pc, #340]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20efda:	f7f6 fc19 	bl	205810 <chHeapStatus>
  20efde:	4603      	mov	r3, r0
  20efe0:	2b01      	cmp	r3, #1
  20efe2:	bf0c      	ite	eq
  20efe4:	2301      	moveq	r3, #1
  20efe6:	2300      	movne	r3, #0
  20efe8:	b2db      	uxtb	r3, r3
  20efea:	4953      	ldr	r1, [pc, #332]	@ (20f138 <oslib_test_008_001_execute+0x5a8>)
  20efec:	4618      	mov	r0, r3
  20efee:	f7f8 fb37 	bl	207660 <__test_assert>
  20eff2:	4603      	mov	r3, r0
  20eff4:	2b00      	cmp	r3, #0
  20eff6:	f040 8096 	bne.w	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(!chHeapIntegrityCheck(&test_heap), "integrity failure");
  20effa:	484d      	ldr	r0, [pc, #308]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20effc:	f7f6 fc58 	bl	2058b0 <chHeapIntegrityCheck>
  20f000:	4603      	mov	r3, r0
  20f002:	2b00      	cmp	r3, #0
  20f004:	bf14      	ite	ne
  20f006:	2301      	movne	r3, #1
  20f008:	2300      	moveq	r3, #0
  20f00a:	b2db      	uxtb	r3, r3
  20f00c:	f083 0301 	eor.w	r3, r3, #1
  20f010:	b2db      	uxtb	r3, r3
  20f012:	f003 0301 	and.w	r3, r3, #1
  20f016:	b2db      	uxtb	r3, r3
  20f018:	4948      	ldr	r1, [pc, #288]	@ (20f13c <oslib_test_008_001_execute+0x5ac>)
  20f01a:	4618      	mov	r0, r3
  20f01c:	f7f8 fb20 	bl	207660 <__test_assert>
  20f020:	4603      	mov	r3, r0
  20f022:	2b00      	cmp	r3, #0
  20f024:	d17f      	bne.n	20f126 <oslib_test_008_001_execute+0x596>
  }
  test_end_step(8);

  /* [8.1.9] Allocating the whole available space, finally, integrity
     is checked.*/
  test_set_step(9);
  20f026:	4b41      	ldr	r3, [pc, #260]	@ (20f12c <oslib_test_008_001_execute+0x59c>)
  20f028:	2209      	movs	r2, #9
  20f02a:	601a      	str	r2, [r3, #0]
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
  20f02c:	ab04      	add	r3, sp, #16
  20f02e:	2200      	movs	r2, #0
  20f030:	4619      	mov	r1, r3
  20f032:	483f      	ldr	r0, [pc, #252]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20f034:	f7f6 fbec 	bl	205810 <chHeapStatus>
    p1 = chHeapAlloc(&test_heap, n);
  20f038:	9b04      	ldr	r3, [sp, #16]
  20f03a:	4619      	mov	r1, r3
  20f03c:	483c      	ldr	r0, [pc, #240]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20f03e:	f7ff fd87 	bl	20eb50 <chHeapAlloc>
  20f042:	9007      	str	r0, [sp, #28]
    test_assert(p1 != NULL, "allocation failed");
  20f044:	9b07      	ldr	r3, [sp, #28]
  20f046:	2b00      	cmp	r3, #0
  20f048:	bf14      	ite	ne
  20f04a:	2301      	movne	r3, #1
  20f04c:	2300      	moveq	r3, #0
  20f04e:	b2db      	uxtb	r3, r3
  20f050:	493b      	ldr	r1, [pc, #236]	@ (20f140 <oslib_test_008_001_execute+0x5b0>)
  20f052:	4618      	mov	r0, r3
  20f054:	f7f8 fb04 	bl	207660 <__test_assert>
  20f058:	4603      	mov	r3, r0
  20f05a:	2b00      	cmp	r3, #0
  20f05c:	d163      	bne.n	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
  20f05e:	2200      	movs	r2, #0
  20f060:	2100      	movs	r1, #0
  20f062:	4833      	ldr	r0, [pc, #204]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20f064:	f7f6 fbd4 	bl	205810 <chHeapStatus>
  20f068:	4603      	mov	r3, r0
  20f06a:	2b00      	cmp	r3, #0
  20f06c:	bf0c      	ite	eq
  20f06e:	2301      	moveq	r3, #1
  20f070:	2300      	movne	r3, #0
  20f072:	b2db      	uxtb	r3, r3
  20f074:	4933      	ldr	r1, [pc, #204]	@ (20f144 <oslib_test_008_001_execute+0x5b4>)
  20f076:	4618      	mov	r0, r3
  20f078:	f7f8 faf2 	bl	207660 <__test_assert>
  20f07c:	4603      	mov	r3, r0
  20f07e:	2b00      	cmp	r3, #0
  20f080:	d151      	bne.n	20f126 <oslib_test_008_001_execute+0x596>
    chHeapFree(p1);
  20f082:	9807      	ldr	r0, [sp, #28]
  20f084:	f7f6 fb54 	bl	205730 <chHeapFree>
    test_assert(!chHeapIntegrityCheck(&test_heap), "integrity failure");
  20f088:	4829      	ldr	r0, [pc, #164]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20f08a:	f7f6 fc11 	bl	2058b0 <chHeapIntegrityCheck>
  20f08e:	4603      	mov	r3, r0
  20f090:	2b00      	cmp	r3, #0
  20f092:	bf14      	ite	ne
  20f094:	2301      	movne	r3, #1
  20f096:	2300      	moveq	r3, #0
  20f098:	b2db      	uxtb	r3, r3
  20f09a:	f083 0301 	eor.w	r3, r3, #1
  20f09e:	b2db      	uxtb	r3, r3
  20f0a0:	f003 0301 	and.w	r3, r3, #1
  20f0a4:	b2db      	uxtb	r3, r3
  20f0a6:	4925      	ldr	r1, [pc, #148]	@ (20f13c <oslib_test_008_001_execute+0x5ac>)
  20f0a8:	4618      	mov	r0, r3
  20f0aa:	f7f8 fad9 	bl	207660 <__test_assert>
  20f0ae:	4603      	mov	r3, r0
  20f0b0:	2b00      	cmp	r3, #0
  20f0b2:	d138      	bne.n	20f126 <oslib_test_008_001_execute+0x596>
  test_end_step(9);

  /* [8.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning, finally, integrity is
     checked.*/
  test_set_step(10);
  20f0b4:	4b1d      	ldr	r3, [pc, #116]	@ (20f12c <oslib_test_008_001_execute+0x59c>)
  20f0b6:	220a      	movs	r2, #10
  20f0b8:	601a      	str	r2, [r3, #0]
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  20f0ba:	ab04      	add	r3, sp, #16
  20f0bc:	2200      	movs	r2, #0
  20f0be:	4619      	mov	r1, r3
  20f0c0:	481b      	ldr	r0, [pc, #108]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20f0c2:	f7f6 fba5 	bl	205810 <chHeapStatus>
  20f0c6:	4603      	mov	r3, r0
  20f0c8:	2b01      	cmp	r3, #1
  20f0ca:	bf0c      	ite	eq
  20f0cc:	2301      	moveq	r3, #1
  20f0ce:	2300      	movne	r3, #0
  20f0d0:	b2db      	uxtb	r3, r3
  20f0d2:	4919      	ldr	r1, [pc, #100]	@ (20f138 <oslib_test_008_001_execute+0x5a8>)
  20f0d4:	4618      	mov	r0, r3
  20f0d6:	f7f8 fac3 	bl	207660 <__test_assert>
  20f0da:	4603      	mov	r3, r0
  20f0dc:	2b00      	cmp	r3, #0
  20f0de:	d122      	bne.n	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(n == sz, "size changed");
  20f0e0:	9a04      	ldr	r2, [sp, #16]
  20f0e2:	9b03      	ldr	r3, [sp, #12]
  20f0e4:	429a      	cmp	r2, r3
  20f0e6:	bf0c      	ite	eq
  20f0e8:	2301      	moveq	r3, #1
  20f0ea:	2300      	movne	r3, #0
  20f0ec:	b2db      	uxtb	r3, r3
  20f0ee:	4916      	ldr	r1, [pc, #88]	@ (20f148 <oslib_test_008_001_execute+0x5b8>)
  20f0f0:	4618      	mov	r0, r3
  20f0f2:	f7f8 fab5 	bl	207660 <__test_assert>
  20f0f6:	4603      	mov	r3, r0
  20f0f8:	2b00      	cmp	r3, #0
  20f0fa:	d114      	bne.n	20f126 <oslib_test_008_001_execute+0x596>
    test_assert(!chHeapIntegrityCheck(&test_heap), "integrity failure");
  20f0fc:	480c      	ldr	r0, [pc, #48]	@ (20f130 <oslib_test_008_001_execute+0x5a0>)
  20f0fe:	f7f6 fbd7 	bl	2058b0 <chHeapIntegrityCheck>
  20f102:	4603      	mov	r3, r0
  20f104:	2b00      	cmp	r3, #0
  20f106:	bf14      	ite	ne
  20f108:	2301      	movne	r3, #1
  20f10a:	2300      	moveq	r3, #0
  20f10c:	b2db      	uxtb	r3, r3
  20f10e:	f083 0301 	eor.w	r3, r3, #1
  20f112:	b2db      	uxtb	r3, r3
  20f114:	f003 0301 	and.w	r3, r3, #1
  20f118:	b2db      	uxtb	r3, r3
  20f11a:	4908      	ldr	r1, [pc, #32]	@ (20f13c <oslib_test_008_001_execute+0x5ac>)
  20f11c:	4618      	mov	r0, r3
  20f11e:	f7f8 fa9f 	bl	207660 <__test_assert>
  20f122:	4603      	mov	r3, r0
  20f124:	2b00      	cmp	r3, #0
  }
  test_end_step(10);
}
  20f126:	b009      	add	sp, #36	@ 0x24
  20f128:	f85d fb04 	ldr.w	pc, [sp], #4
  20f12c:	20000bb4 	.word	0x20000bb4
  20f130:	20002484 	.word	0x20002484
  20f134:	080120d8 	.word	0x080120d8
  20f138:	08011934 	.word	0x08011934
  20f13c:	0801206c 	.word	0x0801206c
  20f140:	08012098 	.word	0x08012098
  20f144:	08011e88 	.word	0x08011e88
  20f148:	080120e8 	.word	0x080120e8
  20f14c:	00000000 	.word	0x00000000

0020f150 <oslib_test_008_002_execute>:
 *   is freed using chHeapFree(), must not fail.
 * - [8.2.2] Testing allocation failure.
 * .
 */

static void oslib_test_008_002_execute(void) {
  20f150:	b500      	push	{lr}
  20f152:	b085      	sub	sp, #20
  void *p1;
  size_t total_size, largest_size;

  /* [8.2.1] Single block allocation using chHeapAlloc() then the block
     is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
  20f154:	4b1a      	ldr	r3, [pc, #104]	@ (20f1c0 <oslib_test_008_002_execute+0x70>)
  20f156:	2201      	movs	r2, #1
  20f158:	601a      	str	r2, [r3, #0]
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
  20f15a:	aa01      	add	r2, sp, #4
  20f15c:	ab02      	add	r3, sp, #8
  20f15e:	4619      	mov	r1, r3
  20f160:	2000      	movs	r0, #0
  20f162:	f7f6 fb55 	bl	205810 <chHeapStatus>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
  20f166:	2110      	movs	r1, #16
  20f168:	4816      	ldr	r0, [pc, #88]	@ (20f1c4 <oslib_test_008_002_execute+0x74>)
  20f16a:	f7ff fcf1 	bl	20eb50 <chHeapAlloc>
  20f16e:	9003      	str	r0, [sp, #12]
    test_assert(p1 != NULL, "allocation failed");
  20f170:	9b03      	ldr	r3, [sp, #12]
  20f172:	2b00      	cmp	r3, #0
  20f174:	bf14      	ite	ne
  20f176:	2301      	movne	r3, #1
  20f178:	2300      	moveq	r3, #0
  20f17a:	b2db      	uxtb	r3, r3
  20f17c:	4912      	ldr	r1, [pc, #72]	@ (20f1c8 <oslib_test_008_002_execute+0x78>)
  20f17e:	4618      	mov	r0, r3
  20f180:	f7f8 fa6e 	bl	207660 <__test_assert>
  20f184:	4603      	mov	r3, r0
  20f186:	2b00      	cmp	r3, #0
  20f188:	d117      	bne.n	20f1ba <oslib_test_008_002_execute+0x6a>
    chHeapFree(p1);
  20f18a:	9803      	ldr	r0, [sp, #12]
  20f18c:	f7f6 fad0 	bl	205730 <chHeapFree>
  }
  test_end_step(1);

  /* [8.2.2] Testing allocation failure.*/
  test_set_step(2);
  20f190:	4b0b      	ldr	r3, [pc, #44]	@ (20f1c0 <oslib_test_008_002_execute+0x70>)
  20f192:	2202      	movs	r2, #2
  20f194:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
  20f196:	f06f 01ff 	mvn.w	r1, #255	@ 0xff
  20f19a:	2000      	movs	r0, #0
  20f19c:	f7ff fcd8 	bl	20eb50 <chHeapAlloc>
  20f1a0:	9003      	str	r0, [sp, #12]
    test_assert(p1 == NULL, "allocation not failed");
  20f1a2:	9b03      	ldr	r3, [sp, #12]
  20f1a4:	2b00      	cmp	r3, #0
  20f1a6:	bf0c      	ite	eq
  20f1a8:	2301      	moveq	r3, #1
  20f1aa:	2300      	movne	r3, #0
  20f1ac:	b2db      	uxtb	r3, r3
  20f1ae:	4907      	ldr	r1, [pc, #28]	@ (20f1cc <oslib_test_008_002_execute+0x7c>)
  20f1b0:	4618      	mov	r0, r3
  20f1b2:	f7f8 fa55 	bl	207660 <__test_assert>
  20f1b6:	4603      	mov	r3, r0
  20f1b8:	2b00      	cmp	r3, #0
  }
  test_end_step(2);
}
  20f1ba:	b005      	add	sp, #20
  20f1bc:	f85d fb04 	ldr.w	pc, [sp], #4
  20f1c0:	20000bb4 	.word	0x20000bb4
  20f1c4:	20002484 	.word	0x20002484
  20f1c8:	08012098 	.word	0x08012098
  20f1cc:	08012080 	.word	0x08012080

0020f1d0 <chFactoryDuplicateReference>:
 * @param[in] dep       pointer to the element field of the object
 * @return              The duplicated object reference.
 *
 * @api
 */
static inline dyn_element_t *chFactoryDuplicateReference(dyn_element_t *dep) {
  20f1d0:	b082      	sub	sp, #8
  20f1d2:	9001      	str	r0, [sp, #4]

  dep->refs++;
  20f1d4:	9b01      	ldr	r3, [sp, #4]
  20f1d6:	685b      	ldr	r3, [r3, #4]
  20f1d8:	1c5a      	adds	r2, r3, #1
  20f1da:	9b01      	ldr	r3, [sp, #4]
  20f1dc:	605a      	str	r2, [r3, #4]

  return dep;
  20f1de:	9b01      	ldr	r3, [sp, #4]
}
  20f1e0:	4618      	mov	r0, r3
  20f1e2:	b002      	add	sp, #8
  20f1e4:	4770      	bx	lr
  20f1e6:	bf00      	nop
	...

0020f1f0 <oslib_test_009_001_teardown>:
 * - [9.1.6] Retrieving the registered object by name again, must not
 *   exist.
 * .
 */

static void oslib_test_009_001_teardown(void) {
  20f1f0:	b500      	push	{lr}
  20f1f2:	b083      	sub	sp, #12
  registered_object_t *rop;

  rop = chFactoryFindObject("myobj");
  20f1f4:	4809      	ldr	r0, [pc, #36]	@ (20f21c <oslib_test_009_001_teardown+0x2c>)
  20f1f6:	f7f7 fcd3 	bl	206ba0 <chFactoryFindObject>
  20f1fa:	9001      	str	r0, [sp, #4]
  if (rop != NULL) {
  20f1fc:	9b01      	ldr	r3, [sp, #4]
  20f1fe:	2b00      	cmp	r3, #0
  20f200:	d007      	beq.n	20f212 <oslib_test_009_001_teardown+0x22>
    while (rop->element.refs > 0U) {
  20f202:	e002      	b.n	20f20a <oslib_test_009_001_teardown+0x1a>
      chFactoryReleaseObject(rop);
  20f204:	9801      	ldr	r0, [sp, #4]
  20f206:	f7f7 fce3 	bl	206bd0 <chFactoryReleaseObject>
    while (rop->element.refs > 0U) {
  20f20a:	9b01      	ldr	r3, [sp, #4]
  20f20c:	685b      	ldr	r3, [r3, #4]
  20f20e:	2b00      	cmp	r3, #0
  20f210:	d1f8      	bne.n	20f204 <oslib_test_009_001_teardown+0x14>
    }
  }
}
  20f212:	bf00      	nop
  20f214:	b003      	add	sp, #12
  20f216:	f85d fb04 	ldr.w	pc, [sp], #4
  20f21a:	bf00      	nop
  20f21c:	080120f8 	.word	0x080120f8

0020f220 <oslib_test_009_001_execute>:

static void oslib_test_009_001_execute(void) {
  20f220:	b500      	push	{lr}
  20f222:	b085      	sub	sp, #20
  registered_object_t *rop;

  /* [9.1.1] Retrieving a registered object by name, must not exist.*/
  test_set_step(1);
  20f224:	4b79      	ldr	r3, [pc, #484]	@ (20f40c <oslib_test_009_001_execute+0x1ec>)
  20f226:	2201      	movs	r2, #1
  20f228:	601a      	str	r2, [r3, #0]
  {
    rop = chFactoryFindObject("myobj");
  20f22a:	4879      	ldr	r0, [pc, #484]	@ (20f410 <oslib_test_009_001_execute+0x1f0>)
  20f22c:	f7f7 fcb8 	bl	206ba0 <chFactoryFindObject>
  20f230:	9003      	str	r0, [sp, #12]
    test_assert(rop == NULL, "found");
  20f232:	9b03      	ldr	r3, [sp, #12]
  20f234:	2b00      	cmp	r3, #0
  20f236:	bf0c      	ite	eq
  20f238:	2301      	moveq	r3, #1
  20f23a:	2300      	movne	r3, #0
  20f23c:	b2db      	uxtb	r3, r3
  20f23e:	4975      	ldr	r1, [pc, #468]	@ (20f414 <oslib_test_009_001_execute+0x1f4>)
  20f240:	4618      	mov	r0, r3
  20f242:	f7f8 fa0d 	bl	207660 <__test_assert>
  20f246:	4603      	mov	r3, r0
  20f248:	2b00      	cmp	r3, #0
  20f24a:	f040 80dc 	bne.w	20f406 <oslib_test_009_001_execute+0x1e6>
  }
  test_end_step(1);

  /* [9.1.2] Registering an object, it must not exists, must succeed.*/
  test_set_step(2);
  20f24e:	4b6f      	ldr	r3, [pc, #444]	@ (20f40c <oslib_test_009_001_execute+0x1ec>)
  20f250:	2202      	movs	r2, #2
  20f252:	601a      	str	r2, [r3, #0]
  {
    static uint32_t myobj = 0x55aa;

    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
  20f254:	4970      	ldr	r1, [pc, #448]	@ (20f418 <oslib_test_009_001_execute+0x1f8>)
  20f256:	486e      	ldr	r0, [pc, #440]	@ (20f410 <oslib_test_009_001_execute+0x1f0>)
  20f258:	f7f7 fc7a 	bl	206b50 <chFactoryRegisterObject>
  20f25c:	9003      	str	r0, [sp, #12]
    test_assert(rop != NULL, "cannot register");
  20f25e:	9b03      	ldr	r3, [sp, #12]
  20f260:	2b00      	cmp	r3, #0
  20f262:	bf14      	ite	ne
  20f264:	2301      	movne	r3, #1
  20f266:	2300      	moveq	r3, #0
  20f268:	b2db      	uxtb	r3, r3
  20f26a:	496c      	ldr	r1, [pc, #432]	@ (20f41c <oslib_test_009_001_execute+0x1fc>)
  20f26c:	4618      	mov	r0, r3
  20f26e:	f7f8 f9f7 	bl	207660 <__test_assert>
  20f272:	4603      	mov	r3, r0
  20f274:	2b00      	cmp	r3, #0
  20f276:	f040 80c6 	bne.w	20f406 <oslib_test_009_001_execute+0x1e6>
  }
  test_end_step(2);

  /* [9.1.3] Registering an object with the same name, must fail.*/
  test_set_step(3);
  20f27a:	4b64      	ldr	r3, [pc, #400]	@ (20f40c <oslib_test_009_001_execute+0x1ec>)
  20f27c:	2203      	movs	r2, #3
  20f27e:	601a      	str	r2, [r3, #0]
  {
    registered_object_t *rop1;
    static uint32_t myobj = 0x55aa;

    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
  20f280:	4967      	ldr	r1, [pc, #412]	@ (20f420 <oslib_test_009_001_execute+0x200>)
  20f282:	4863      	ldr	r0, [pc, #396]	@ (20f410 <oslib_test_009_001_execute+0x1f0>)
  20f284:	f7f7 fc64 	bl	206b50 <chFactoryRegisterObject>
  20f288:	9002      	str	r0, [sp, #8]
    test_assert(rop1 == NULL, "can register");
  20f28a:	9b02      	ldr	r3, [sp, #8]
  20f28c:	2b00      	cmp	r3, #0
  20f28e:	bf0c      	ite	eq
  20f290:	2301      	moveq	r3, #1
  20f292:	2300      	movne	r3, #0
  20f294:	b2db      	uxtb	r3, r3
  20f296:	4963      	ldr	r1, [pc, #396]	@ (20f424 <oslib_test_009_001_execute+0x204>)
  20f298:	4618      	mov	r0, r3
  20f29a:	f7f8 f9e1 	bl	207660 <__test_assert>
  20f29e:	4603      	mov	r3, r0
  20f2a0:	2b00      	cmp	r3, #0
  20f2a2:	f040 80b0 	bne.w	20f406 <oslib_test_009_001_execute+0x1e6>
  test_end_step(3);

  /* [9.1.4] Retrieving the registered object by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
  20f2a6:	4b59      	ldr	r3, [pc, #356]	@ (20f40c <oslib_test_009_001_execute+0x1ec>)
  20f2a8:	2204      	movs	r2, #4
  20f2aa:	601a      	str	r2, [r3, #0]
  {
    registered_object_t *rop1, *rop2;

    rop1 = chFactoryFindObject("myobj");
  20f2ac:	4858      	ldr	r0, [pc, #352]	@ (20f410 <oslib_test_009_001_execute+0x1f0>)
  20f2ae:	f7f7 fc77 	bl	206ba0 <chFactoryFindObject>
  20f2b2:	9001      	str	r0, [sp, #4]
    test_assert(rop1 != NULL, "not found");
  20f2b4:	9b01      	ldr	r3, [sp, #4]
  20f2b6:	2b00      	cmp	r3, #0
  20f2b8:	bf14      	ite	ne
  20f2ba:	2301      	movne	r3, #1
  20f2bc:	2300      	moveq	r3, #0
  20f2be:	b2db      	uxtb	r3, r3
  20f2c0:	4959      	ldr	r1, [pc, #356]	@ (20f428 <oslib_test_009_001_execute+0x208>)
  20f2c2:	4618      	mov	r0, r3
  20f2c4:	f7f8 f9cc 	bl	207660 <__test_assert>
  20f2c8:	4603      	mov	r3, r0
  20f2ca:	2b00      	cmp	r3, #0
  20f2cc:	f040 809b 	bne.w	20f406 <oslib_test_009_001_execute+0x1e6>
    test_assert(*(uint32_t *)(rop1->objp) == 0x55aa, "object mismatch");
  20f2d0:	9b01      	ldr	r3, [sp, #4]
  20f2d2:	691b      	ldr	r3, [r3, #16]
  20f2d4:	681b      	ldr	r3, [r3, #0]
  20f2d6:	f245 52aa 	movw	r2, #21930	@ 0x55aa
  20f2da:	4293      	cmp	r3, r2
  20f2dc:	bf0c      	ite	eq
  20f2de:	2301      	moveq	r3, #1
  20f2e0:	2300      	movne	r3, #0
  20f2e2:	b2db      	uxtb	r3, r3
  20f2e4:	4951      	ldr	r1, [pc, #324]	@ (20f42c <oslib_test_009_001_execute+0x20c>)
  20f2e6:	4618      	mov	r0, r3
  20f2e8:	f7f8 f9ba 	bl	207660 <__test_assert>
  20f2ec:	4603      	mov	r3, r0
  20f2ee:	2b00      	cmp	r3, #0
  20f2f0:	f040 8089 	bne.w	20f406 <oslib_test_009_001_execute+0x1e6>
    test_assert(rop == rop1, "object reference mismatch");
  20f2f4:	9a03      	ldr	r2, [sp, #12]
  20f2f6:	9b01      	ldr	r3, [sp, #4]
  20f2f8:	429a      	cmp	r2, r3
  20f2fa:	bf0c      	ite	eq
  20f2fc:	2301      	moveq	r3, #1
  20f2fe:	2300      	movne	r3, #0
  20f300:	b2db      	uxtb	r3, r3
  20f302:	494b      	ldr	r1, [pc, #300]	@ (20f430 <oslib_test_009_001_execute+0x210>)
  20f304:	4618      	mov	r0, r3
  20f306:	f7f8 f9ab 	bl	207660 <__test_assert>
  20f30a:	4603      	mov	r3, r0
  20f30c:	2b00      	cmp	r3, #0
  20f30e:	d17a      	bne.n	20f406 <oslib_test_009_001_execute+0x1e6>
    test_assert(rop1->element.refs == 2, "object reference mismatch");
  20f310:	9b01      	ldr	r3, [sp, #4]
  20f312:	685b      	ldr	r3, [r3, #4]
  20f314:	2b02      	cmp	r3, #2
  20f316:	bf0c      	ite	eq
  20f318:	2301      	moveq	r3, #1
  20f31a:	2300      	movne	r3, #0
  20f31c:	b2db      	uxtb	r3, r3
  20f31e:	4944      	ldr	r1, [pc, #272]	@ (20f430 <oslib_test_009_001_execute+0x210>)
  20f320:	4618      	mov	r0, r3
  20f322:	f7f8 f99d 	bl	207660 <__test_assert>
  20f326:	4603      	mov	r3, r0
  20f328:	2b00      	cmp	r3, #0
  20f32a:	d16c      	bne.n	20f406 <oslib_test_009_001_execute+0x1e6>

    rop2 = (registered_object_t *)chFactoryDuplicateReference(&rop1->element);
  20f32c:	9b01      	ldr	r3, [sp, #4]
  20f32e:	4618      	mov	r0, r3
  20f330:	f7ff ff4e 	bl	20f1d0 <chFactoryDuplicateReference>
  20f334:	9000      	str	r0, [sp, #0]
    test_assert(rop1 == rop2, "object reference mismatch");
  20f336:	9a01      	ldr	r2, [sp, #4]
  20f338:	9b00      	ldr	r3, [sp, #0]
  20f33a:	429a      	cmp	r2, r3
  20f33c:	bf0c      	ite	eq
  20f33e:	2301      	moveq	r3, #1
  20f340:	2300      	movne	r3, #0
  20f342:	b2db      	uxtb	r3, r3
  20f344:	493a      	ldr	r1, [pc, #232]	@ (20f430 <oslib_test_009_001_execute+0x210>)
  20f346:	4618      	mov	r0, r3
  20f348:	f7f8 f98a 	bl	207660 <__test_assert>
  20f34c:	4603      	mov	r3, r0
  20f34e:	2b00      	cmp	r3, #0
  20f350:	d159      	bne.n	20f406 <oslib_test_009_001_execute+0x1e6>
    test_assert(*(uint32_t *)(rop2->objp) == 0x55aa, "object mismatch");
  20f352:	9b00      	ldr	r3, [sp, #0]
  20f354:	691b      	ldr	r3, [r3, #16]
  20f356:	681b      	ldr	r3, [r3, #0]
  20f358:	f245 52aa 	movw	r2, #21930	@ 0x55aa
  20f35c:	4293      	cmp	r3, r2
  20f35e:	bf0c      	ite	eq
  20f360:	2301      	moveq	r3, #1
  20f362:	2300      	movne	r3, #0
  20f364:	b2db      	uxtb	r3, r3
  20f366:	4931      	ldr	r1, [pc, #196]	@ (20f42c <oslib_test_009_001_execute+0x20c>)
  20f368:	4618      	mov	r0, r3
  20f36a:	f7f8 f979 	bl	207660 <__test_assert>
  20f36e:	4603      	mov	r3, r0
  20f370:	2b00      	cmp	r3, #0
  20f372:	d148      	bne.n	20f406 <oslib_test_009_001_execute+0x1e6>
    test_assert(rop2->element.refs == 3, "object reference mismatch");
  20f374:	9b00      	ldr	r3, [sp, #0]
  20f376:	685b      	ldr	r3, [r3, #4]
  20f378:	2b03      	cmp	r3, #3
  20f37a:	bf0c      	ite	eq
  20f37c:	2301      	moveq	r3, #1
  20f37e:	2300      	movne	r3, #0
  20f380:	b2db      	uxtb	r3, r3
  20f382:	492b      	ldr	r1, [pc, #172]	@ (20f430 <oslib_test_009_001_execute+0x210>)
  20f384:	4618      	mov	r0, r3
  20f386:	f7f8 f96b 	bl	207660 <__test_assert>
  20f38a:	4603      	mov	r3, r0
  20f38c:	2b00      	cmp	r3, #0
  20f38e:	d13a      	bne.n	20f406 <oslib_test_009_001_execute+0x1e6>

    chFactoryReleaseObject(rop2);
  20f390:	9800      	ldr	r0, [sp, #0]
  20f392:	f7f7 fc1d 	bl	206bd0 <chFactoryReleaseObject>
    test_assert(rop1->element.refs == 2, "references mismatch");
  20f396:	9b01      	ldr	r3, [sp, #4]
  20f398:	685b      	ldr	r3, [r3, #4]
  20f39a:	2b02      	cmp	r3, #2
  20f39c:	bf0c      	ite	eq
  20f39e:	2301      	moveq	r3, #1
  20f3a0:	2300      	movne	r3, #0
  20f3a2:	b2db      	uxtb	r3, r3
  20f3a4:	4923      	ldr	r1, [pc, #140]	@ (20f434 <oslib_test_009_001_execute+0x214>)
  20f3a6:	4618      	mov	r0, r3
  20f3a8:	f7f8 f95a 	bl	207660 <__test_assert>
  20f3ac:	4603      	mov	r3, r0
  20f3ae:	2b00      	cmp	r3, #0
  20f3b0:	d129      	bne.n	20f406 <oslib_test_009_001_execute+0x1e6>

    chFactoryReleaseObject(rop1);
  20f3b2:	9801      	ldr	r0, [sp, #4]
  20f3b4:	f7f7 fc0c 	bl	206bd0 <chFactoryReleaseObject>
    test_assert(rop->element.refs == 1, "references mismatch");
  20f3b8:	9b03      	ldr	r3, [sp, #12]
  20f3ba:	685b      	ldr	r3, [r3, #4]
  20f3bc:	2b01      	cmp	r3, #1
  20f3be:	bf0c      	ite	eq
  20f3c0:	2301      	moveq	r3, #1
  20f3c2:	2300      	movne	r3, #0
  20f3c4:	b2db      	uxtb	r3, r3
  20f3c6:	491b      	ldr	r1, [pc, #108]	@ (20f434 <oslib_test_009_001_execute+0x214>)
  20f3c8:	4618      	mov	r0, r3
  20f3ca:	f7f8 f949 	bl	207660 <__test_assert>
  20f3ce:	4603      	mov	r3, r0
  20f3d0:	2b00      	cmp	r3, #0
  20f3d2:	d118      	bne.n	20f406 <oslib_test_009_001_execute+0x1e6>
  }
  test_end_step(4);

  /* [9.1.5] Releasing the first reference to the object, must not
     trigger an assertion.*/
  test_set_step(5);
  20f3d4:	4b0d      	ldr	r3, [pc, #52]	@ (20f40c <oslib_test_009_001_execute+0x1ec>)
  20f3d6:	2205      	movs	r2, #5
  20f3d8:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleaseObject(rop);
  20f3da:	9803      	ldr	r0, [sp, #12]
  20f3dc:	f7f7 fbf8 	bl	206bd0 <chFactoryReleaseObject>
  }
  test_end_step(5);

  /* [9.1.6] Retrieving the registered object by name again, must not
     exist.*/
  test_set_step(6);
  20f3e0:	4b0a      	ldr	r3, [pc, #40]	@ (20f40c <oslib_test_009_001_execute+0x1ec>)
  20f3e2:	2206      	movs	r2, #6
  20f3e4:	601a      	str	r2, [r3, #0]
  {
    rop = chFactoryFindObject("myobj");
  20f3e6:	480a      	ldr	r0, [pc, #40]	@ (20f410 <oslib_test_009_001_execute+0x1f0>)
  20f3e8:	f7f7 fbda 	bl	206ba0 <chFactoryFindObject>
  20f3ec:	9003      	str	r0, [sp, #12]
    test_assert(rop == NULL, "found");
  20f3ee:	9b03      	ldr	r3, [sp, #12]
  20f3f0:	2b00      	cmp	r3, #0
  20f3f2:	bf0c      	ite	eq
  20f3f4:	2301      	moveq	r3, #1
  20f3f6:	2300      	movne	r3, #0
  20f3f8:	b2db      	uxtb	r3, r3
  20f3fa:	4906      	ldr	r1, [pc, #24]	@ (20f414 <oslib_test_009_001_execute+0x1f4>)
  20f3fc:	4618      	mov	r0, r3
  20f3fe:	f7f8 f92f 	bl	207660 <__test_assert>
  20f402:	4603      	mov	r3, r0
  20f404:	2b00      	cmp	r3, #0
  }
  test_end_step(6);
}
  20f406:	b005      	add	sp, #20
  20f408:	f85d fb04 	ldr.w	pc, [sp], #4
  20f40c:	20000bb4 	.word	0x20000bb4
  20f410:	080120f8 	.word	0x080120f8
  20f414:	08012124 	.word	0x08012124
  20f418:	200200d4 	.word	0x200200d4
  20f41c:	08012100 	.word	0x08012100
  20f420:	200200d8 	.word	0x200200d8
  20f424:	08012110 	.word	0x08012110
  20f428:	08012120 	.word	0x08012120
  20f42c:	0801212c 	.word	0x0801212c
  20f430:	0801213c 	.word	0x0801213c
  20f434:	08012158 	.word	0x08012158
	...

0020f440 <oslib_test_009_002_teardown>:
 * - [9.2.6] Retrieving the dynamic buffer by name again, must not
 *   exist.
 * .
 */

static void oslib_test_009_002_teardown(void) {
  20f440:	b500      	push	{lr}
  20f442:	b083      	sub	sp, #12
  dyn_buffer_t *dbp;

  dbp = chFactoryFindBuffer("mybuf");
  20f444:	4809      	ldr	r0, [pc, #36]	@ (20f46c <oslib_test_009_002_teardown+0x2c>)
  20f446:	f7f7 fc0b 	bl	206c60 <chFactoryFindBuffer>
  20f44a:	9001      	str	r0, [sp, #4]
  if (dbp != NULL) {
  20f44c:	9b01      	ldr	r3, [sp, #4]
  20f44e:	2b00      	cmp	r3, #0
  20f450:	d007      	beq.n	20f462 <oslib_test_009_002_teardown+0x22>
    while (dbp->element.refs > 0U) {
  20f452:	e002      	b.n	20f45a <oslib_test_009_002_teardown+0x1a>
      chFactoryReleaseBuffer(dbp);
  20f454:	9801      	ldr	r0, [sp, #4]
  20f456:	f7f7 fc1b 	bl	206c90 <chFactoryReleaseBuffer>
    while (dbp->element.refs > 0U) {
  20f45a:	9b01      	ldr	r3, [sp, #4]
  20f45c:	685b      	ldr	r3, [r3, #4]
  20f45e:	2b00      	cmp	r3, #0
  20f460:	d1f8      	bne.n	20f454 <oslib_test_009_002_teardown+0x14>
    }
  }
}
  20f462:	bf00      	nop
  20f464:	b003      	add	sp, #12
  20f466:	f85d fb04 	ldr.w	pc, [sp], #4
  20f46a:	bf00      	nop
  20f46c:	0801216c 	.word	0x0801216c

0020f470 <oslib_test_009_002_execute>:

static void oslib_test_009_002_execute(void) {
  20f470:	b500      	push	{lr}
  20f472:	b085      	sub	sp, #20
  dyn_buffer_t *dbp;

  /* [9.2.1] Retrieving a dynamic buffer by name, must not exist.*/
  test_set_step(1);
  20f474:	4b67      	ldr	r3, [pc, #412]	@ (20f614 <oslib_test_009_002_execute+0x1a4>)
  20f476:	2201      	movs	r2, #1
  20f478:	601a      	str	r2, [r3, #0]
  {
    dbp = chFactoryFindBuffer("mybuf");
  20f47a:	4867      	ldr	r0, [pc, #412]	@ (20f618 <oslib_test_009_002_execute+0x1a8>)
  20f47c:	f7f7 fbf0 	bl	206c60 <chFactoryFindBuffer>
  20f480:	9003      	str	r0, [sp, #12]
    test_assert(dbp == NULL, "found");
  20f482:	9b03      	ldr	r3, [sp, #12]
  20f484:	2b00      	cmp	r3, #0
  20f486:	bf0c      	ite	eq
  20f488:	2301      	moveq	r3, #1
  20f48a:	2300      	movne	r3, #0
  20f48c:	b2db      	uxtb	r3, r3
  20f48e:	4963      	ldr	r1, [pc, #396]	@ (20f61c <oslib_test_009_002_execute+0x1ac>)
  20f490:	4618      	mov	r0, r3
  20f492:	f7f8 f8e5 	bl	207660 <__test_assert>
  20f496:	4603      	mov	r3, r0
  20f498:	2b00      	cmp	r3, #0
  20f49a:	f040 80b8 	bne.w	20f60e <oslib_test_009_002_execute+0x19e>
  }
  test_end_step(1);

  /* [9.2.2] Creating a dynamic buffer it must not exists, must
     succeed.*/
  test_set_step(2);
  20f49e:	4b5d      	ldr	r3, [pc, #372]	@ (20f614 <oslib_test_009_002_execute+0x1a4>)
  20f4a0:	2202      	movs	r2, #2
  20f4a2:	601a      	str	r2, [r3, #0]
  {
    dbp = chFactoryCreateBuffer("mybuf", 128U);
  20f4a4:	2180      	movs	r1, #128	@ 0x80
  20f4a6:	485c      	ldr	r0, [pc, #368]	@ (20f618 <oslib_test_009_002_execute+0x1a8>)
  20f4a8:	f7f7 fbb2 	bl	206c10 <chFactoryCreateBuffer>
  20f4ac:	9003      	str	r0, [sp, #12]
    test_assert(dbp != NULL, "cannot create");
  20f4ae:	9b03      	ldr	r3, [sp, #12]
  20f4b0:	2b00      	cmp	r3, #0
  20f4b2:	bf14      	ite	ne
  20f4b4:	2301      	movne	r3, #1
  20f4b6:	2300      	moveq	r3, #0
  20f4b8:	b2db      	uxtb	r3, r3
  20f4ba:	4959      	ldr	r1, [pc, #356]	@ (20f620 <oslib_test_009_002_execute+0x1b0>)
  20f4bc:	4618      	mov	r0, r3
  20f4be:	f7f8 f8cf 	bl	207660 <__test_assert>
  20f4c2:	4603      	mov	r3, r0
  20f4c4:	2b00      	cmp	r3, #0
  20f4c6:	f040 80a2 	bne.w	20f60e <oslib_test_009_002_execute+0x19e>
  }
  test_end_step(2);

  /* [9.2.3] Creating a dynamic buffer with the same name, must fail.*/
  test_set_step(3);
  20f4ca:	4b52      	ldr	r3, [pc, #328]	@ (20f614 <oslib_test_009_002_execute+0x1a4>)
  20f4cc:	2203      	movs	r2, #3
  20f4ce:	601a      	str	r2, [r3, #0]
  {
    dyn_buffer_t *dbp1;

    dbp1 = chFactoryCreateBuffer("mybuf", 128U);
  20f4d0:	2180      	movs	r1, #128	@ 0x80
  20f4d2:	4851      	ldr	r0, [pc, #324]	@ (20f618 <oslib_test_009_002_execute+0x1a8>)
  20f4d4:	f7f7 fb9c 	bl	206c10 <chFactoryCreateBuffer>
  20f4d8:	9002      	str	r0, [sp, #8]
    test_assert(dbp1 == NULL, "can create");
  20f4da:	9b02      	ldr	r3, [sp, #8]
  20f4dc:	2b00      	cmp	r3, #0
  20f4de:	bf0c      	ite	eq
  20f4e0:	2301      	moveq	r3, #1
  20f4e2:	2300      	movne	r3, #0
  20f4e4:	b2db      	uxtb	r3, r3
  20f4e6:	494f      	ldr	r1, [pc, #316]	@ (20f624 <oslib_test_009_002_execute+0x1b4>)
  20f4e8:	4618      	mov	r0, r3
  20f4ea:	f7f8 f8b9 	bl	207660 <__test_assert>
  20f4ee:	4603      	mov	r3, r0
  20f4f0:	2b00      	cmp	r3, #0
  20f4f2:	f040 808c 	bne.w	20f60e <oslib_test_009_002_execute+0x19e>
  test_end_step(3);

  /* [9.2.4] Retrieving the dynamic buffer by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
  20f4f6:	4b47      	ldr	r3, [pc, #284]	@ (20f614 <oslib_test_009_002_execute+0x1a4>)
  20f4f8:	2204      	movs	r2, #4
  20f4fa:	601a      	str	r2, [r3, #0]
  {
    dyn_buffer_t *dbp1, *dbp2;

    dbp1 = chFactoryFindBuffer("mybuf");
  20f4fc:	4846      	ldr	r0, [pc, #280]	@ (20f618 <oslib_test_009_002_execute+0x1a8>)
  20f4fe:	f7f7 fbaf 	bl	206c60 <chFactoryFindBuffer>
  20f502:	9001      	str	r0, [sp, #4]
    test_assert(dbp1 != NULL, "not found");
  20f504:	9b01      	ldr	r3, [sp, #4]
  20f506:	2b00      	cmp	r3, #0
  20f508:	bf14      	ite	ne
  20f50a:	2301      	movne	r3, #1
  20f50c:	2300      	moveq	r3, #0
  20f50e:	b2db      	uxtb	r3, r3
  20f510:	4945      	ldr	r1, [pc, #276]	@ (20f628 <oslib_test_009_002_execute+0x1b8>)
  20f512:	4618      	mov	r0, r3
  20f514:	f7f8 f8a4 	bl	207660 <__test_assert>
  20f518:	4603      	mov	r3, r0
  20f51a:	2b00      	cmp	r3, #0
  20f51c:	d177      	bne.n	20f60e <oslib_test_009_002_execute+0x19e>
    test_assert(dbp == dbp1, "object reference mismatch");
  20f51e:	9a03      	ldr	r2, [sp, #12]
  20f520:	9b01      	ldr	r3, [sp, #4]
  20f522:	429a      	cmp	r2, r3
  20f524:	bf0c      	ite	eq
  20f526:	2301      	moveq	r3, #1
  20f528:	2300      	movne	r3, #0
  20f52a:	b2db      	uxtb	r3, r3
  20f52c:	493f      	ldr	r1, [pc, #252]	@ (20f62c <oslib_test_009_002_execute+0x1bc>)
  20f52e:	4618      	mov	r0, r3
  20f530:	f7f8 f896 	bl	207660 <__test_assert>
  20f534:	4603      	mov	r3, r0
  20f536:	2b00      	cmp	r3, #0
  20f538:	d169      	bne.n	20f60e <oslib_test_009_002_execute+0x19e>
    test_assert(dbp1->element.refs == 2, "object reference mismatch");
  20f53a:	9b01      	ldr	r3, [sp, #4]
  20f53c:	685b      	ldr	r3, [r3, #4]
  20f53e:	2b02      	cmp	r3, #2
  20f540:	bf0c      	ite	eq
  20f542:	2301      	moveq	r3, #1
  20f544:	2300      	movne	r3, #0
  20f546:	b2db      	uxtb	r3, r3
  20f548:	4938      	ldr	r1, [pc, #224]	@ (20f62c <oslib_test_009_002_execute+0x1bc>)
  20f54a:	4618      	mov	r0, r3
  20f54c:	f7f8 f888 	bl	207660 <__test_assert>
  20f550:	4603      	mov	r3, r0
  20f552:	2b00      	cmp	r3, #0
  20f554:	d15b      	bne.n	20f60e <oslib_test_009_002_execute+0x19e>

    dbp2 = (dyn_buffer_t *)chFactoryDuplicateReference(&dbp1->element);
  20f556:	9b01      	ldr	r3, [sp, #4]
  20f558:	4618      	mov	r0, r3
  20f55a:	f7ff fe39 	bl	20f1d0 <chFactoryDuplicateReference>
  20f55e:	9000      	str	r0, [sp, #0]
    test_assert(dbp1 == dbp2, "object reference mismatch");
  20f560:	9a01      	ldr	r2, [sp, #4]
  20f562:	9b00      	ldr	r3, [sp, #0]
  20f564:	429a      	cmp	r2, r3
  20f566:	bf0c      	ite	eq
  20f568:	2301      	moveq	r3, #1
  20f56a:	2300      	movne	r3, #0
  20f56c:	b2db      	uxtb	r3, r3
  20f56e:	492f      	ldr	r1, [pc, #188]	@ (20f62c <oslib_test_009_002_execute+0x1bc>)
  20f570:	4618      	mov	r0, r3
  20f572:	f7f8 f875 	bl	207660 <__test_assert>
  20f576:	4603      	mov	r3, r0
  20f578:	2b00      	cmp	r3, #0
  20f57a:	d148      	bne.n	20f60e <oslib_test_009_002_execute+0x19e>
    test_assert(dbp2->element.refs == 3, "object reference mismatch");
  20f57c:	9b00      	ldr	r3, [sp, #0]
  20f57e:	685b      	ldr	r3, [r3, #4]
  20f580:	2b03      	cmp	r3, #3
  20f582:	bf0c      	ite	eq
  20f584:	2301      	moveq	r3, #1
  20f586:	2300      	movne	r3, #0
  20f588:	b2db      	uxtb	r3, r3
  20f58a:	4928      	ldr	r1, [pc, #160]	@ (20f62c <oslib_test_009_002_execute+0x1bc>)
  20f58c:	4618      	mov	r0, r3
  20f58e:	f7f8 f867 	bl	207660 <__test_assert>
  20f592:	4603      	mov	r3, r0
  20f594:	2b00      	cmp	r3, #0
  20f596:	d13a      	bne.n	20f60e <oslib_test_009_002_execute+0x19e>

    chFactoryReleaseBuffer(dbp2);
  20f598:	9800      	ldr	r0, [sp, #0]
  20f59a:	f7f7 fb79 	bl	206c90 <chFactoryReleaseBuffer>
    test_assert(dbp1->element.refs == 2, "references mismatch");
  20f59e:	9b01      	ldr	r3, [sp, #4]
  20f5a0:	685b      	ldr	r3, [r3, #4]
  20f5a2:	2b02      	cmp	r3, #2
  20f5a4:	bf0c      	ite	eq
  20f5a6:	2301      	moveq	r3, #1
  20f5a8:	2300      	movne	r3, #0
  20f5aa:	b2db      	uxtb	r3, r3
  20f5ac:	4920      	ldr	r1, [pc, #128]	@ (20f630 <oslib_test_009_002_execute+0x1c0>)
  20f5ae:	4618      	mov	r0, r3
  20f5b0:	f7f8 f856 	bl	207660 <__test_assert>
  20f5b4:	4603      	mov	r3, r0
  20f5b6:	2b00      	cmp	r3, #0
  20f5b8:	d129      	bne.n	20f60e <oslib_test_009_002_execute+0x19e>

    chFactoryReleaseBuffer(dbp1);
  20f5ba:	9801      	ldr	r0, [sp, #4]
  20f5bc:	f7f7 fb68 	bl	206c90 <chFactoryReleaseBuffer>
    test_assert(dbp->element.refs == 1, "references mismatch");
  20f5c0:	9b03      	ldr	r3, [sp, #12]
  20f5c2:	685b      	ldr	r3, [r3, #4]
  20f5c4:	2b01      	cmp	r3, #1
  20f5c6:	bf0c      	ite	eq
  20f5c8:	2301      	moveq	r3, #1
  20f5ca:	2300      	movne	r3, #0
  20f5cc:	b2db      	uxtb	r3, r3
  20f5ce:	4918      	ldr	r1, [pc, #96]	@ (20f630 <oslib_test_009_002_execute+0x1c0>)
  20f5d0:	4618      	mov	r0, r3
  20f5d2:	f7f8 f845 	bl	207660 <__test_assert>
  20f5d6:	4603      	mov	r3, r0
  20f5d8:	2b00      	cmp	r3, #0
  20f5da:	d118      	bne.n	20f60e <oslib_test_009_002_execute+0x19e>
  }
  test_end_step(4);

  /* [9.2.5] Releasing the first reference to the dynamic buffer, must
     not trigger an assertion.*/
  test_set_step(5);
  20f5dc:	4b0d      	ldr	r3, [pc, #52]	@ (20f614 <oslib_test_009_002_execute+0x1a4>)
  20f5de:	2205      	movs	r2, #5
  20f5e0:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleaseBuffer(dbp);
  20f5e2:	9803      	ldr	r0, [sp, #12]
  20f5e4:	f7f7 fb54 	bl	206c90 <chFactoryReleaseBuffer>
  }
  test_end_step(5);

  /* [9.2.6] Retrieving the dynamic buffer by name again, must not
     exist.*/
  test_set_step(6);
  20f5e8:	4b0a      	ldr	r3, [pc, #40]	@ (20f614 <oslib_test_009_002_execute+0x1a4>)
  20f5ea:	2206      	movs	r2, #6
  20f5ec:	601a      	str	r2, [r3, #0]
  {
    dbp = chFactoryFindBuffer("mybuf");
  20f5ee:	480a      	ldr	r0, [pc, #40]	@ (20f618 <oslib_test_009_002_execute+0x1a8>)
  20f5f0:	f7f7 fb36 	bl	206c60 <chFactoryFindBuffer>
  20f5f4:	9003      	str	r0, [sp, #12]
    test_assert(dbp == NULL, "found");
  20f5f6:	9b03      	ldr	r3, [sp, #12]
  20f5f8:	2b00      	cmp	r3, #0
  20f5fa:	bf0c      	ite	eq
  20f5fc:	2301      	moveq	r3, #1
  20f5fe:	2300      	movne	r3, #0
  20f600:	b2db      	uxtb	r3, r3
  20f602:	4906      	ldr	r1, [pc, #24]	@ (20f61c <oslib_test_009_002_execute+0x1ac>)
  20f604:	4618      	mov	r0, r3
  20f606:	f7f8 f82b 	bl	207660 <__test_assert>
  20f60a:	4603      	mov	r3, r0
  20f60c:	2b00      	cmp	r3, #0
  }
  test_end_step(6);
}
  20f60e:	b005      	add	sp, #20
  20f610:	f85d fb04 	ldr.w	pc, [sp], #4
  20f614:	20000bb4 	.word	0x20000bb4
  20f618:	0801216c 	.word	0x0801216c
  20f61c:	08012124 	.word	0x08012124
  20f620:	08012174 	.word	0x08012174
  20f624:	08012184 	.word	0x08012184
  20f628:	08012120 	.word	0x08012120
  20f62c:	0801213c 	.word	0x0801213c
  20f630:	08012158 	.word	0x08012158
	...

0020f640 <oslib_test_009_003_teardown>:
 * - [9.3.6] Retrieving the dynamic semaphore by name again, must not
 *   exist.
 * .
 */

static void oslib_test_009_003_teardown(void) {
  20f640:	b500      	push	{lr}
  20f642:	b083      	sub	sp, #12
  dyn_semaphore_t *dsp;

  dsp = chFactoryFindSemaphore("mysem");
  20f644:	4809      	ldr	r0, [pc, #36]	@ (20f66c <oslib_test_009_003_teardown+0x2c>)
  20f646:	f7f7 fb63 	bl	206d10 <chFactoryFindSemaphore>
  20f64a:	9001      	str	r0, [sp, #4]
  if (dsp != NULL) {
  20f64c:	9b01      	ldr	r3, [sp, #4]
  20f64e:	2b00      	cmp	r3, #0
  20f650:	d007      	beq.n	20f662 <oslib_test_009_003_teardown+0x22>
    while (dsp->element.refs > 0U) {
  20f652:	e002      	b.n	20f65a <oslib_test_009_003_teardown+0x1a>
      chFactoryReleaseSemaphore(dsp);
  20f654:	9801      	ldr	r0, [sp, #4]
  20f656:	f7f7 fb73 	bl	206d40 <chFactoryReleaseSemaphore>
    while (dsp->element.refs > 0U) {
  20f65a:	9b01      	ldr	r3, [sp, #4]
  20f65c:	685b      	ldr	r3, [r3, #4]
  20f65e:	2b00      	cmp	r3, #0
  20f660:	d1f8      	bne.n	20f654 <oslib_test_009_003_teardown+0x14>
    }
  }
}
  20f662:	bf00      	nop
  20f664:	b003      	add	sp, #12
  20f666:	f85d fb04 	ldr.w	pc, [sp], #4
  20f66a:	bf00      	nop
  20f66c:	08012190 	.word	0x08012190

0020f670 <oslib_test_009_003_execute>:

static void oslib_test_009_003_execute(void) {
  20f670:	b500      	push	{lr}
  20f672:	b085      	sub	sp, #20
  dyn_semaphore_t *dsp;

  /* [9.3.1] Retrieving a dynamic semaphore by name, must not exist.*/
  test_set_step(1);
  20f674:	4b67      	ldr	r3, [pc, #412]	@ (20f814 <oslib_test_009_003_execute+0x1a4>)
  20f676:	2201      	movs	r2, #1
  20f678:	601a      	str	r2, [r3, #0]
  {
    dsp = chFactoryFindSemaphore("mysem");
  20f67a:	4867      	ldr	r0, [pc, #412]	@ (20f818 <oslib_test_009_003_execute+0x1a8>)
  20f67c:	f7f7 fb48 	bl	206d10 <chFactoryFindSemaphore>
  20f680:	9003      	str	r0, [sp, #12]
    test_assert(dsp == NULL, "found");
  20f682:	9b03      	ldr	r3, [sp, #12]
  20f684:	2b00      	cmp	r3, #0
  20f686:	bf0c      	ite	eq
  20f688:	2301      	moveq	r3, #1
  20f68a:	2300      	movne	r3, #0
  20f68c:	b2db      	uxtb	r3, r3
  20f68e:	4963      	ldr	r1, [pc, #396]	@ (20f81c <oslib_test_009_003_execute+0x1ac>)
  20f690:	4618      	mov	r0, r3
  20f692:	f7f7 ffe5 	bl	207660 <__test_assert>
  20f696:	4603      	mov	r3, r0
  20f698:	2b00      	cmp	r3, #0
  20f69a:	f040 80b8 	bne.w	20f80e <oslib_test_009_003_execute+0x19e>
  }
  test_end_step(1);

  /* [9.3.2] Creating a dynamic semaphore it must not exists, must
     succeed.*/
  test_set_step(2);
  20f69e:	4b5d      	ldr	r3, [pc, #372]	@ (20f814 <oslib_test_009_003_execute+0x1a4>)
  20f6a0:	2202      	movs	r2, #2
  20f6a2:	601a      	str	r2, [r3, #0]
  {
    dsp = chFactoryCreateSemaphore("mysem", 0);
  20f6a4:	2100      	movs	r1, #0
  20f6a6:	485c      	ldr	r0, [pc, #368]	@ (20f818 <oslib_test_009_003_execute+0x1a8>)
  20f6a8:	f7f7 fb0a 	bl	206cc0 <chFactoryCreateSemaphore>
  20f6ac:	9003      	str	r0, [sp, #12]
    test_assert(dsp != NULL, "cannot create");
  20f6ae:	9b03      	ldr	r3, [sp, #12]
  20f6b0:	2b00      	cmp	r3, #0
  20f6b2:	bf14      	ite	ne
  20f6b4:	2301      	movne	r3, #1
  20f6b6:	2300      	moveq	r3, #0
  20f6b8:	b2db      	uxtb	r3, r3
  20f6ba:	4959      	ldr	r1, [pc, #356]	@ (20f820 <oslib_test_009_003_execute+0x1b0>)
  20f6bc:	4618      	mov	r0, r3
  20f6be:	f7f7 ffcf 	bl	207660 <__test_assert>
  20f6c2:	4603      	mov	r3, r0
  20f6c4:	2b00      	cmp	r3, #0
  20f6c6:	f040 80a2 	bne.w	20f80e <oslib_test_009_003_execute+0x19e>
  }
  test_end_step(2);

  /* [9.3.3] Creating a dynamic semaphore with the same name, must
     fail.*/
  test_set_step(3);
  20f6ca:	4b52      	ldr	r3, [pc, #328]	@ (20f814 <oslib_test_009_003_execute+0x1a4>)
  20f6cc:	2203      	movs	r2, #3
  20f6ce:	601a      	str	r2, [r3, #0]
  {
    dyn_semaphore_t *dsp1;

    dsp1 = chFactoryCreateSemaphore("mysem", 0);
  20f6d0:	2100      	movs	r1, #0
  20f6d2:	4851      	ldr	r0, [pc, #324]	@ (20f818 <oslib_test_009_003_execute+0x1a8>)
  20f6d4:	f7f7 faf4 	bl	206cc0 <chFactoryCreateSemaphore>
  20f6d8:	9002      	str	r0, [sp, #8]
    test_assert(dsp1 == NULL, "can create");
  20f6da:	9b02      	ldr	r3, [sp, #8]
  20f6dc:	2b00      	cmp	r3, #0
  20f6de:	bf0c      	ite	eq
  20f6e0:	2301      	moveq	r3, #1
  20f6e2:	2300      	movne	r3, #0
  20f6e4:	b2db      	uxtb	r3, r3
  20f6e6:	494f      	ldr	r1, [pc, #316]	@ (20f824 <oslib_test_009_003_execute+0x1b4>)
  20f6e8:	4618      	mov	r0, r3
  20f6ea:	f7f7 ffb9 	bl	207660 <__test_assert>
  20f6ee:	4603      	mov	r3, r0
  20f6f0:	2b00      	cmp	r3, #0
  20f6f2:	f040 808c 	bne.w	20f80e <oslib_test_009_003_execute+0x19e>
  test_end_step(3);

  /* [9.3.4] Retrieving the dynamic semaphore by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
  20f6f6:	4b47      	ldr	r3, [pc, #284]	@ (20f814 <oslib_test_009_003_execute+0x1a4>)
  20f6f8:	2204      	movs	r2, #4
  20f6fa:	601a      	str	r2, [r3, #0]
  {
    dyn_semaphore_t *dsp1, *dsp2;

    dsp1 = chFactoryFindSemaphore("mysem");
  20f6fc:	4846      	ldr	r0, [pc, #280]	@ (20f818 <oslib_test_009_003_execute+0x1a8>)
  20f6fe:	f7f7 fb07 	bl	206d10 <chFactoryFindSemaphore>
  20f702:	9001      	str	r0, [sp, #4]
    test_assert(dsp1 != NULL, "not found");
  20f704:	9b01      	ldr	r3, [sp, #4]
  20f706:	2b00      	cmp	r3, #0
  20f708:	bf14      	ite	ne
  20f70a:	2301      	movne	r3, #1
  20f70c:	2300      	moveq	r3, #0
  20f70e:	b2db      	uxtb	r3, r3
  20f710:	4945      	ldr	r1, [pc, #276]	@ (20f828 <oslib_test_009_003_execute+0x1b8>)
  20f712:	4618      	mov	r0, r3
  20f714:	f7f7 ffa4 	bl	207660 <__test_assert>
  20f718:	4603      	mov	r3, r0
  20f71a:	2b00      	cmp	r3, #0
  20f71c:	d177      	bne.n	20f80e <oslib_test_009_003_execute+0x19e>
    test_assert(dsp == dsp1, "object reference mismatch");
  20f71e:	9a03      	ldr	r2, [sp, #12]
  20f720:	9b01      	ldr	r3, [sp, #4]
  20f722:	429a      	cmp	r2, r3
  20f724:	bf0c      	ite	eq
  20f726:	2301      	moveq	r3, #1
  20f728:	2300      	movne	r3, #0
  20f72a:	b2db      	uxtb	r3, r3
  20f72c:	493f      	ldr	r1, [pc, #252]	@ (20f82c <oslib_test_009_003_execute+0x1bc>)
  20f72e:	4618      	mov	r0, r3
  20f730:	f7f7 ff96 	bl	207660 <__test_assert>
  20f734:	4603      	mov	r3, r0
  20f736:	2b00      	cmp	r3, #0
  20f738:	d169      	bne.n	20f80e <oslib_test_009_003_execute+0x19e>
    test_assert(dsp1->element.refs == 2, "object reference mismatch");
  20f73a:	9b01      	ldr	r3, [sp, #4]
  20f73c:	685b      	ldr	r3, [r3, #4]
  20f73e:	2b02      	cmp	r3, #2
  20f740:	bf0c      	ite	eq
  20f742:	2301      	moveq	r3, #1
  20f744:	2300      	movne	r3, #0
  20f746:	b2db      	uxtb	r3, r3
  20f748:	4938      	ldr	r1, [pc, #224]	@ (20f82c <oslib_test_009_003_execute+0x1bc>)
  20f74a:	4618      	mov	r0, r3
  20f74c:	f7f7 ff88 	bl	207660 <__test_assert>
  20f750:	4603      	mov	r3, r0
  20f752:	2b00      	cmp	r3, #0
  20f754:	d15b      	bne.n	20f80e <oslib_test_009_003_execute+0x19e>

    dsp2 = (dyn_semaphore_t *)chFactoryDuplicateReference(&dsp1->element);
  20f756:	9b01      	ldr	r3, [sp, #4]
  20f758:	4618      	mov	r0, r3
  20f75a:	f7ff fd39 	bl	20f1d0 <chFactoryDuplicateReference>
  20f75e:	9000      	str	r0, [sp, #0]
    test_assert(dsp1 == dsp2, "object reference mismatch");
  20f760:	9a01      	ldr	r2, [sp, #4]
  20f762:	9b00      	ldr	r3, [sp, #0]
  20f764:	429a      	cmp	r2, r3
  20f766:	bf0c      	ite	eq
  20f768:	2301      	moveq	r3, #1
  20f76a:	2300      	movne	r3, #0
  20f76c:	b2db      	uxtb	r3, r3
  20f76e:	492f      	ldr	r1, [pc, #188]	@ (20f82c <oslib_test_009_003_execute+0x1bc>)
  20f770:	4618      	mov	r0, r3
  20f772:	f7f7 ff75 	bl	207660 <__test_assert>
  20f776:	4603      	mov	r3, r0
  20f778:	2b00      	cmp	r3, #0
  20f77a:	d148      	bne.n	20f80e <oslib_test_009_003_execute+0x19e>
    test_assert(dsp2->element.refs == 3, "object reference mismatch");
  20f77c:	9b00      	ldr	r3, [sp, #0]
  20f77e:	685b      	ldr	r3, [r3, #4]
  20f780:	2b03      	cmp	r3, #3
  20f782:	bf0c      	ite	eq
  20f784:	2301      	moveq	r3, #1
  20f786:	2300      	movne	r3, #0
  20f788:	b2db      	uxtb	r3, r3
  20f78a:	4928      	ldr	r1, [pc, #160]	@ (20f82c <oslib_test_009_003_execute+0x1bc>)
  20f78c:	4618      	mov	r0, r3
  20f78e:	f7f7 ff67 	bl	207660 <__test_assert>
  20f792:	4603      	mov	r3, r0
  20f794:	2b00      	cmp	r3, #0
  20f796:	d13a      	bne.n	20f80e <oslib_test_009_003_execute+0x19e>

    chFactoryReleaseSemaphore(dsp2);
  20f798:	9800      	ldr	r0, [sp, #0]
  20f79a:	f7f7 fad1 	bl	206d40 <chFactoryReleaseSemaphore>
    test_assert(dsp1->element.refs == 2, "references mismatch");
  20f79e:	9b01      	ldr	r3, [sp, #4]
  20f7a0:	685b      	ldr	r3, [r3, #4]
  20f7a2:	2b02      	cmp	r3, #2
  20f7a4:	bf0c      	ite	eq
  20f7a6:	2301      	moveq	r3, #1
  20f7a8:	2300      	movne	r3, #0
  20f7aa:	b2db      	uxtb	r3, r3
  20f7ac:	4920      	ldr	r1, [pc, #128]	@ (20f830 <oslib_test_009_003_execute+0x1c0>)
  20f7ae:	4618      	mov	r0, r3
  20f7b0:	f7f7 ff56 	bl	207660 <__test_assert>
  20f7b4:	4603      	mov	r3, r0
  20f7b6:	2b00      	cmp	r3, #0
  20f7b8:	d129      	bne.n	20f80e <oslib_test_009_003_execute+0x19e>

    chFactoryReleaseSemaphore(dsp1);
  20f7ba:	9801      	ldr	r0, [sp, #4]
  20f7bc:	f7f7 fac0 	bl	206d40 <chFactoryReleaseSemaphore>
    test_assert(dsp->element.refs == 1, "references mismatch");
  20f7c0:	9b03      	ldr	r3, [sp, #12]
  20f7c2:	685b      	ldr	r3, [r3, #4]
  20f7c4:	2b01      	cmp	r3, #1
  20f7c6:	bf0c      	ite	eq
  20f7c8:	2301      	moveq	r3, #1
  20f7ca:	2300      	movne	r3, #0
  20f7cc:	b2db      	uxtb	r3, r3
  20f7ce:	4918      	ldr	r1, [pc, #96]	@ (20f830 <oslib_test_009_003_execute+0x1c0>)
  20f7d0:	4618      	mov	r0, r3
  20f7d2:	f7f7 ff45 	bl	207660 <__test_assert>
  20f7d6:	4603      	mov	r3, r0
  20f7d8:	2b00      	cmp	r3, #0
  20f7da:	d118      	bne.n	20f80e <oslib_test_009_003_execute+0x19e>
  }
  test_end_step(4);

  /* [9.3.5] Releasing the first reference to the dynamic semaphore
     must not trigger an assertion.*/
  test_set_step(5);
  20f7dc:	4b0d      	ldr	r3, [pc, #52]	@ (20f814 <oslib_test_009_003_execute+0x1a4>)
  20f7de:	2205      	movs	r2, #5
  20f7e0:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleaseSemaphore(dsp);
  20f7e2:	9803      	ldr	r0, [sp, #12]
  20f7e4:	f7f7 faac 	bl	206d40 <chFactoryReleaseSemaphore>
  }
  test_end_step(5);

  /* [9.3.6] Retrieving the dynamic semaphore by name again, must not
     exist.*/
  test_set_step(6);
  20f7e8:	4b0a      	ldr	r3, [pc, #40]	@ (20f814 <oslib_test_009_003_execute+0x1a4>)
  20f7ea:	2206      	movs	r2, #6
  20f7ec:	601a      	str	r2, [r3, #0]
  {
    dsp = chFactoryFindSemaphore("mysem");
  20f7ee:	480a      	ldr	r0, [pc, #40]	@ (20f818 <oslib_test_009_003_execute+0x1a8>)
  20f7f0:	f7f7 fa8e 	bl	206d10 <chFactoryFindSemaphore>
  20f7f4:	9003      	str	r0, [sp, #12]
    test_assert(dsp == NULL, "found");
  20f7f6:	9b03      	ldr	r3, [sp, #12]
  20f7f8:	2b00      	cmp	r3, #0
  20f7fa:	bf0c      	ite	eq
  20f7fc:	2301      	moveq	r3, #1
  20f7fe:	2300      	movne	r3, #0
  20f800:	b2db      	uxtb	r3, r3
  20f802:	4906      	ldr	r1, [pc, #24]	@ (20f81c <oslib_test_009_003_execute+0x1ac>)
  20f804:	4618      	mov	r0, r3
  20f806:	f7f7 ff2b 	bl	207660 <__test_assert>
  20f80a:	4603      	mov	r3, r0
  20f80c:	2b00      	cmp	r3, #0
  }
  test_end_step(6);
}
  20f80e:	b005      	add	sp, #20
  20f810:	f85d fb04 	ldr.w	pc, [sp], #4
  20f814:	20000bb4 	.word	0x20000bb4
  20f818:	08012190 	.word	0x08012190
  20f81c:	08012124 	.word	0x08012124
  20f820:	08012174 	.word	0x08012174
  20f824:	08012184 	.word	0x08012184
  20f828:	08012120 	.word	0x08012120
  20f82c:	0801213c 	.word	0x0801213c
  20f830:	08012158 	.word	0x08012158
	...

0020f840 <oslib_test_009_004_teardown>:
 * - [9.4.6] Retrieving the dynamic mailbox by name again, must not
 *   exist.
 * .
 */

static void oslib_test_009_004_teardown(void) {
  20f840:	b500      	push	{lr}
  20f842:	b083      	sub	sp, #12
  dyn_mailbox_t *dmp;

  dmp = chFactoryFindMailbox("mymbx");
  20f844:	4809      	ldr	r0, [pc, #36]	@ (20f86c <oslib_test_009_004_teardown+0x2c>)
  20f846:	f7f7 fac3 	bl	206dd0 <chFactoryFindMailbox>
  20f84a:	9001      	str	r0, [sp, #4]
  if (dmp != NULL) {
  20f84c:	9b01      	ldr	r3, [sp, #4]
  20f84e:	2b00      	cmp	r3, #0
  20f850:	d007      	beq.n	20f862 <oslib_test_009_004_teardown+0x22>
    while (dmp->element.refs > 0U) {
  20f852:	e002      	b.n	20f85a <oslib_test_009_004_teardown+0x1a>
      chFactoryReleaseMailbox(dmp);
  20f854:	9801      	ldr	r0, [sp, #4]
  20f856:	f7f7 fad3 	bl	206e00 <chFactoryReleaseMailbox>
    while (dmp->element.refs > 0U) {
  20f85a:	9b01      	ldr	r3, [sp, #4]
  20f85c:	685b      	ldr	r3, [r3, #4]
  20f85e:	2b00      	cmp	r3, #0
  20f860:	d1f8      	bne.n	20f854 <oslib_test_009_004_teardown+0x14>
    }
  }
}
  20f862:	bf00      	nop
  20f864:	b003      	add	sp, #12
  20f866:	f85d fb04 	ldr.w	pc, [sp], #4
  20f86a:	bf00      	nop
  20f86c:	08012198 	.word	0x08012198

0020f870 <oslib_test_009_004_execute>:

static void oslib_test_009_004_execute(void) {
  20f870:	b500      	push	{lr}
  20f872:	b085      	sub	sp, #20
  dyn_mailbox_t *dmp;

  /* [9.4.1] Retrieving a dynamic mailbox by name, must not exist.*/
  test_set_step(1);
  20f874:	4b67      	ldr	r3, [pc, #412]	@ (20fa14 <oslib_test_009_004_execute+0x1a4>)
  20f876:	2201      	movs	r2, #1
  20f878:	601a      	str	r2, [r3, #0]
  {
    dmp = chFactoryFindMailbox("mymbx");
  20f87a:	4867      	ldr	r0, [pc, #412]	@ (20fa18 <oslib_test_009_004_execute+0x1a8>)
  20f87c:	f7f7 faa8 	bl	206dd0 <chFactoryFindMailbox>
  20f880:	9003      	str	r0, [sp, #12]
    test_assert(dmp == NULL, "found");
  20f882:	9b03      	ldr	r3, [sp, #12]
  20f884:	2b00      	cmp	r3, #0
  20f886:	bf0c      	ite	eq
  20f888:	2301      	moveq	r3, #1
  20f88a:	2300      	movne	r3, #0
  20f88c:	b2db      	uxtb	r3, r3
  20f88e:	4963      	ldr	r1, [pc, #396]	@ (20fa1c <oslib_test_009_004_execute+0x1ac>)
  20f890:	4618      	mov	r0, r3
  20f892:	f7f7 fee5 	bl	207660 <__test_assert>
  20f896:	4603      	mov	r3, r0
  20f898:	2b00      	cmp	r3, #0
  20f89a:	f040 80b8 	bne.w	20fa0e <oslib_test_009_004_execute+0x19e>
  }
  test_end_step(1);

  /* [9.4.2] Creating a dynamic mailbox it must not exists, must
     succeed.*/
  test_set_step(2);
  20f89e:	4b5d      	ldr	r3, [pc, #372]	@ (20fa14 <oslib_test_009_004_execute+0x1a4>)
  20f8a0:	2202      	movs	r2, #2
  20f8a2:	601a      	str	r2, [r3, #0]
  {
    dmp = chFactoryCreateMailbox("mymbx", 16U);
  20f8a4:	2110      	movs	r1, #16
  20f8a6:	485c      	ldr	r0, [pc, #368]	@ (20fa18 <oslib_test_009_004_execute+0x1a8>)
  20f8a8:	f7f7 fa6a 	bl	206d80 <chFactoryCreateMailbox>
  20f8ac:	9003      	str	r0, [sp, #12]
    test_assert(dmp != NULL, "cannot create");
  20f8ae:	9b03      	ldr	r3, [sp, #12]
  20f8b0:	2b00      	cmp	r3, #0
  20f8b2:	bf14      	ite	ne
  20f8b4:	2301      	movne	r3, #1
  20f8b6:	2300      	moveq	r3, #0
  20f8b8:	b2db      	uxtb	r3, r3
  20f8ba:	4959      	ldr	r1, [pc, #356]	@ (20fa20 <oslib_test_009_004_execute+0x1b0>)
  20f8bc:	4618      	mov	r0, r3
  20f8be:	f7f7 fecf 	bl	207660 <__test_assert>
  20f8c2:	4603      	mov	r3, r0
  20f8c4:	2b00      	cmp	r3, #0
  20f8c6:	f040 80a2 	bne.w	20fa0e <oslib_test_009_004_execute+0x19e>
  }
  test_end_step(2);

  /* [9.4.3] Creating a dynamic mailbox with the same name, must
     fail.*/
  test_set_step(3);
  20f8ca:	4b52      	ldr	r3, [pc, #328]	@ (20fa14 <oslib_test_009_004_execute+0x1a4>)
  20f8cc:	2203      	movs	r2, #3
  20f8ce:	601a      	str	r2, [r3, #0]
  {
    dyn_mailbox_t *dmp1;

    dmp1 = chFactoryCreateMailbox("mymbx", 16U);
  20f8d0:	2110      	movs	r1, #16
  20f8d2:	4851      	ldr	r0, [pc, #324]	@ (20fa18 <oslib_test_009_004_execute+0x1a8>)
  20f8d4:	f7f7 fa54 	bl	206d80 <chFactoryCreateMailbox>
  20f8d8:	9002      	str	r0, [sp, #8]
    test_assert(dmp1 == NULL, "can create");
  20f8da:	9b02      	ldr	r3, [sp, #8]
  20f8dc:	2b00      	cmp	r3, #0
  20f8de:	bf0c      	ite	eq
  20f8e0:	2301      	moveq	r3, #1
  20f8e2:	2300      	movne	r3, #0
  20f8e4:	b2db      	uxtb	r3, r3
  20f8e6:	494f      	ldr	r1, [pc, #316]	@ (20fa24 <oslib_test_009_004_execute+0x1b4>)
  20f8e8:	4618      	mov	r0, r3
  20f8ea:	f7f7 feb9 	bl	207660 <__test_assert>
  20f8ee:	4603      	mov	r3, r0
  20f8f0:	2b00      	cmp	r3, #0
  20f8f2:	f040 808c 	bne.w	20fa0e <oslib_test_009_004_execute+0x19e>
  test_end_step(3);

  /* [9.4.4] Retrieving the dynamic mailbox by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
  20f8f6:	4b47      	ldr	r3, [pc, #284]	@ (20fa14 <oslib_test_009_004_execute+0x1a4>)
  20f8f8:	2204      	movs	r2, #4
  20f8fa:	601a      	str	r2, [r3, #0]
  {
    dyn_mailbox_t *dmp1, *dmp2;

    dmp1 = chFactoryFindMailbox("mymbx");
  20f8fc:	4846      	ldr	r0, [pc, #280]	@ (20fa18 <oslib_test_009_004_execute+0x1a8>)
  20f8fe:	f7f7 fa67 	bl	206dd0 <chFactoryFindMailbox>
  20f902:	9001      	str	r0, [sp, #4]
    test_assert(dmp1 != NULL, "not found");
  20f904:	9b01      	ldr	r3, [sp, #4]
  20f906:	2b00      	cmp	r3, #0
  20f908:	bf14      	ite	ne
  20f90a:	2301      	movne	r3, #1
  20f90c:	2300      	moveq	r3, #0
  20f90e:	b2db      	uxtb	r3, r3
  20f910:	4945      	ldr	r1, [pc, #276]	@ (20fa28 <oslib_test_009_004_execute+0x1b8>)
  20f912:	4618      	mov	r0, r3
  20f914:	f7f7 fea4 	bl	207660 <__test_assert>
  20f918:	4603      	mov	r3, r0
  20f91a:	2b00      	cmp	r3, #0
  20f91c:	d177      	bne.n	20fa0e <oslib_test_009_004_execute+0x19e>
    test_assert(dmp == dmp1, "object reference mismatch");
  20f91e:	9a03      	ldr	r2, [sp, #12]
  20f920:	9b01      	ldr	r3, [sp, #4]
  20f922:	429a      	cmp	r2, r3
  20f924:	bf0c      	ite	eq
  20f926:	2301      	moveq	r3, #1
  20f928:	2300      	movne	r3, #0
  20f92a:	b2db      	uxtb	r3, r3
  20f92c:	493f      	ldr	r1, [pc, #252]	@ (20fa2c <oslib_test_009_004_execute+0x1bc>)
  20f92e:	4618      	mov	r0, r3
  20f930:	f7f7 fe96 	bl	207660 <__test_assert>
  20f934:	4603      	mov	r3, r0
  20f936:	2b00      	cmp	r3, #0
  20f938:	d169      	bne.n	20fa0e <oslib_test_009_004_execute+0x19e>
    test_assert(dmp1->element.refs == 2, "object reference mismatch");
  20f93a:	9b01      	ldr	r3, [sp, #4]
  20f93c:	685b      	ldr	r3, [r3, #4]
  20f93e:	2b02      	cmp	r3, #2
  20f940:	bf0c      	ite	eq
  20f942:	2301      	moveq	r3, #1
  20f944:	2300      	movne	r3, #0
  20f946:	b2db      	uxtb	r3, r3
  20f948:	4938      	ldr	r1, [pc, #224]	@ (20fa2c <oslib_test_009_004_execute+0x1bc>)
  20f94a:	4618      	mov	r0, r3
  20f94c:	f7f7 fe88 	bl	207660 <__test_assert>
  20f950:	4603      	mov	r3, r0
  20f952:	2b00      	cmp	r3, #0
  20f954:	d15b      	bne.n	20fa0e <oslib_test_009_004_execute+0x19e>

    dmp2 = (dyn_mailbox_t *)chFactoryDuplicateReference(&dmp1->element);
  20f956:	9b01      	ldr	r3, [sp, #4]
  20f958:	4618      	mov	r0, r3
  20f95a:	f7ff fc39 	bl	20f1d0 <chFactoryDuplicateReference>
  20f95e:	9000      	str	r0, [sp, #0]
    test_assert(dmp1 == dmp2, "object reference mismatch");
  20f960:	9a01      	ldr	r2, [sp, #4]
  20f962:	9b00      	ldr	r3, [sp, #0]
  20f964:	429a      	cmp	r2, r3
  20f966:	bf0c      	ite	eq
  20f968:	2301      	moveq	r3, #1
  20f96a:	2300      	movne	r3, #0
  20f96c:	b2db      	uxtb	r3, r3
  20f96e:	492f      	ldr	r1, [pc, #188]	@ (20fa2c <oslib_test_009_004_execute+0x1bc>)
  20f970:	4618      	mov	r0, r3
  20f972:	f7f7 fe75 	bl	207660 <__test_assert>
  20f976:	4603      	mov	r3, r0
  20f978:	2b00      	cmp	r3, #0
  20f97a:	d148      	bne.n	20fa0e <oslib_test_009_004_execute+0x19e>
    test_assert(dmp2->element.refs == 3, "object reference mismatch");
  20f97c:	9b00      	ldr	r3, [sp, #0]
  20f97e:	685b      	ldr	r3, [r3, #4]
  20f980:	2b03      	cmp	r3, #3
  20f982:	bf0c      	ite	eq
  20f984:	2301      	moveq	r3, #1
  20f986:	2300      	movne	r3, #0
  20f988:	b2db      	uxtb	r3, r3
  20f98a:	4928      	ldr	r1, [pc, #160]	@ (20fa2c <oslib_test_009_004_execute+0x1bc>)
  20f98c:	4618      	mov	r0, r3
  20f98e:	f7f7 fe67 	bl	207660 <__test_assert>
  20f992:	4603      	mov	r3, r0
  20f994:	2b00      	cmp	r3, #0
  20f996:	d13a      	bne.n	20fa0e <oslib_test_009_004_execute+0x19e>

    chFactoryReleaseMailbox(dmp2);
  20f998:	9800      	ldr	r0, [sp, #0]
  20f99a:	f7f7 fa31 	bl	206e00 <chFactoryReleaseMailbox>
    test_assert(dmp1->element.refs == 2, "references mismatch");
  20f99e:	9b01      	ldr	r3, [sp, #4]
  20f9a0:	685b      	ldr	r3, [r3, #4]
  20f9a2:	2b02      	cmp	r3, #2
  20f9a4:	bf0c      	ite	eq
  20f9a6:	2301      	moveq	r3, #1
  20f9a8:	2300      	movne	r3, #0
  20f9aa:	b2db      	uxtb	r3, r3
  20f9ac:	4920      	ldr	r1, [pc, #128]	@ (20fa30 <oslib_test_009_004_execute+0x1c0>)
  20f9ae:	4618      	mov	r0, r3
  20f9b0:	f7f7 fe56 	bl	207660 <__test_assert>
  20f9b4:	4603      	mov	r3, r0
  20f9b6:	2b00      	cmp	r3, #0
  20f9b8:	d129      	bne.n	20fa0e <oslib_test_009_004_execute+0x19e>

    chFactoryReleaseMailbox(dmp1);
  20f9ba:	9801      	ldr	r0, [sp, #4]
  20f9bc:	f7f7 fa20 	bl	206e00 <chFactoryReleaseMailbox>
    test_assert(dmp->element.refs == 1, "references mismatch");
  20f9c0:	9b03      	ldr	r3, [sp, #12]
  20f9c2:	685b      	ldr	r3, [r3, #4]
  20f9c4:	2b01      	cmp	r3, #1
  20f9c6:	bf0c      	ite	eq
  20f9c8:	2301      	moveq	r3, #1
  20f9ca:	2300      	movne	r3, #0
  20f9cc:	b2db      	uxtb	r3, r3
  20f9ce:	4918      	ldr	r1, [pc, #96]	@ (20fa30 <oslib_test_009_004_execute+0x1c0>)
  20f9d0:	4618      	mov	r0, r3
  20f9d2:	f7f7 fe45 	bl	207660 <__test_assert>
  20f9d6:	4603      	mov	r3, r0
  20f9d8:	2b00      	cmp	r3, #0
  20f9da:	d118      	bne.n	20fa0e <oslib_test_009_004_execute+0x19e>
  }
  test_end_step(4);

  /* [9.4.5] Releasing the first reference to the dynamic mailbox must
     not trigger an assertion.*/
  test_set_step(5);
  20f9dc:	4b0d      	ldr	r3, [pc, #52]	@ (20fa14 <oslib_test_009_004_execute+0x1a4>)
  20f9de:	2205      	movs	r2, #5
  20f9e0:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleaseMailbox(dmp);
  20f9e2:	9803      	ldr	r0, [sp, #12]
  20f9e4:	f7f7 fa0c 	bl	206e00 <chFactoryReleaseMailbox>
  }
  test_end_step(5);

  /* [9.4.6] Retrieving the dynamic mailbox by name again, must not
     exist.*/
  test_set_step(6);
  20f9e8:	4b0a      	ldr	r3, [pc, #40]	@ (20fa14 <oslib_test_009_004_execute+0x1a4>)
  20f9ea:	2206      	movs	r2, #6
  20f9ec:	601a      	str	r2, [r3, #0]
  {
    dmp = chFactoryFindMailbox("mymbx");
  20f9ee:	480a      	ldr	r0, [pc, #40]	@ (20fa18 <oslib_test_009_004_execute+0x1a8>)
  20f9f0:	f7f7 f9ee 	bl	206dd0 <chFactoryFindMailbox>
  20f9f4:	9003      	str	r0, [sp, #12]
    test_assert(dmp == NULL, "found");
  20f9f6:	9b03      	ldr	r3, [sp, #12]
  20f9f8:	2b00      	cmp	r3, #0
  20f9fa:	bf0c      	ite	eq
  20f9fc:	2301      	moveq	r3, #1
  20f9fe:	2300      	movne	r3, #0
  20fa00:	b2db      	uxtb	r3, r3
  20fa02:	4906      	ldr	r1, [pc, #24]	@ (20fa1c <oslib_test_009_004_execute+0x1ac>)
  20fa04:	4618      	mov	r0, r3
  20fa06:	f7f7 fe2b 	bl	207660 <__test_assert>
  20fa0a:	4603      	mov	r3, r0
  20fa0c:	2b00      	cmp	r3, #0
  }
  test_end_step(6);
}
  20fa0e:	b005      	add	sp, #20
  20fa10:	f85d fb04 	ldr.w	pc, [sp], #4
  20fa14:	20000bb4 	.word	0x20000bb4
  20fa18:	08012198 	.word	0x08012198
  20fa1c:	08012124 	.word	0x08012124
  20fa20:	08012174 	.word	0x08012174
  20fa24:	08012184 	.word	0x08012184
  20fa28:	08012120 	.word	0x08012120
  20fa2c:	0801213c 	.word	0x0801213c
  20fa30:	08012158 	.word	0x08012158
	...

0020fa40 <oslib_test_009_005_teardown>:
 * - [9.5.6] Retrieving the dynamic objects FIFO by name again, must
 *   not exist.
 * .
 */

static void oslib_test_009_005_teardown(void) {
  20fa40:	b500      	push	{lr}
  20fa42:	b083      	sub	sp, #12
  dyn_objects_fifo_t *dofp;

  dofp = chFactoryFindObjectsFIFO("myfifo");
  20fa44:	4809      	ldr	r0, [pc, #36]	@ (20fa6c <oslib_test_009_005_teardown+0x2c>)
  20fa46:	f7f7 fa43 	bl	206ed0 <chFactoryFindObjectsFIFO>
  20fa4a:	9001      	str	r0, [sp, #4]
  if (dofp != NULL) {
  20fa4c:	9b01      	ldr	r3, [sp, #4]
  20fa4e:	2b00      	cmp	r3, #0
  20fa50:	d007      	beq.n	20fa62 <oslib_test_009_005_teardown+0x22>
    while (dofp->element.refs > 0U) {
  20fa52:	e002      	b.n	20fa5a <oslib_test_009_005_teardown+0x1a>
      chFactoryReleaseObjectsFIFO(dofp);
  20fa54:	9801      	ldr	r0, [sp, #4]
  20fa56:	f7f7 fa53 	bl	206f00 <chFactoryReleaseObjectsFIFO>
    while (dofp->element.refs > 0U) {
  20fa5a:	9b01      	ldr	r3, [sp, #4]
  20fa5c:	685b      	ldr	r3, [r3, #4]
  20fa5e:	2b00      	cmp	r3, #0
  20fa60:	d1f8      	bne.n	20fa54 <oslib_test_009_005_teardown+0x14>
    }
  }
}
  20fa62:	bf00      	nop
  20fa64:	b003      	add	sp, #12
  20fa66:	f85d fb04 	ldr.w	pc, [sp], #4
  20fa6a:	bf00      	nop
  20fa6c:	080121a0 	.word	0x080121a0

0020fa70 <oslib_test_009_005_execute>:

static void oslib_test_009_005_execute(void) {
  20fa70:	b500      	push	{lr}
  20fa72:	b085      	sub	sp, #20
  dyn_objects_fifo_t *dofp;

  /* [9.5.1] Retrieving a dynamic objects FIFO by name, must not
     exist.*/
  test_set_step(1);
  20fa74:	4b69      	ldr	r3, [pc, #420]	@ (20fc1c <oslib_test_009_005_execute+0x1ac>)
  20fa76:	2201      	movs	r2, #1
  20fa78:	601a      	str	r2, [r3, #0]
  {
    dofp = chFactoryFindObjectsFIFO("myfifo");
  20fa7a:	4869      	ldr	r0, [pc, #420]	@ (20fc20 <oslib_test_009_005_execute+0x1b0>)
  20fa7c:	f7f7 fa28 	bl	206ed0 <chFactoryFindObjectsFIFO>
  20fa80:	9003      	str	r0, [sp, #12]
    test_assert(dofp == NULL, "found");
  20fa82:	9b03      	ldr	r3, [sp, #12]
  20fa84:	2b00      	cmp	r3, #0
  20fa86:	bf0c      	ite	eq
  20fa88:	2301      	moveq	r3, #1
  20fa8a:	2300      	movne	r3, #0
  20fa8c:	b2db      	uxtb	r3, r3
  20fa8e:	4965      	ldr	r1, [pc, #404]	@ (20fc24 <oslib_test_009_005_execute+0x1b4>)
  20fa90:	4618      	mov	r0, r3
  20fa92:	f7f7 fde5 	bl	207660 <__test_assert>
  20fa96:	4603      	mov	r3, r0
  20fa98:	2b00      	cmp	r3, #0
  20fa9a:	f040 80bc 	bne.w	20fc16 <oslib_test_009_005_execute+0x1a6>
  }
  test_end_step(1);

  /* [9.5.2] Creating a dynamic objects FIFO it must not exists, must
     succeed.*/
  test_set_step(2);
  20fa9e:	4b5f      	ldr	r3, [pc, #380]	@ (20fc1c <oslib_test_009_005_execute+0x1ac>)
  20faa0:	2202      	movs	r2, #2
  20faa2:	601a      	str	r2, [r3, #0]
  {
    dofp = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
  20faa4:	2304      	movs	r3, #4
  20faa6:	2210      	movs	r2, #16
  20faa8:	2110      	movs	r1, #16
  20faaa:	485d      	ldr	r0, [pc, #372]	@ (20fc20 <oslib_test_009_005_execute+0x1b0>)
  20faac:	f7f7 f9c0 	bl	206e30 <chFactoryCreateObjectsFIFO>
  20fab0:	9003      	str	r0, [sp, #12]
    test_assert(dofp != NULL, "cannot create");
  20fab2:	9b03      	ldr	r3, [sp, #12]
  20fab4:	2b00      	cmp	r3, #0
  20fab6:	bf14      	ite	ne
  20fab8:	2301      	movne	r3, #1
  20faba:	2300      	moveq	r3, #0
  20fabc:	b2db      	uxtb	r3, r3
  20fabe:	495a      	ldr	r1, [pc, #360]	@ (20fc28 <oslib_test_009_005_execute+0x1b8>)
  20fac0:	4618      	mov	r0, r3
  20fac2:	f7f7 fdcd 	bl	207660 <__test_assert>
  20fac6:	4603      	mov	r3, r0
  20fac8:	2b00      	cmp	r3, #0
  20faca:	f040 80a4 	bne.w	20fc16 <oslib_test_009_005_execute+0x1a6>
  }
  test_end_step(2);

  /* [9.5.3] Creating a dynamic objects FIFO with the same name, must
     fail.*/
  test_set_step(3);
  20face:	4b53      	ldr	r3, [pc, #332]	@ (20fc1c <oslib_test_009_005_execute+0x1ac>)
  20fad0:	2203      	movs	r2, #3
  20fad2:	601a      	str	r2, [r3, #0]
  {
    dyn_objects_fifo_t *dofp1;

    dofp1 = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
  20fad4:	2304      	movs	r3, #4
  20fad6:	2210      	movs	r2, #16
  20fad8:	2110      	movs	r1, #16
  20fada:	4851      	ldr	r0, [pc, #324]	@ (20fc20 <oslib_test_009_005_execute+0x1b0>)
  20fadc:	f7f7 f9a8 	bl	206e30 <chFactoryCreateObjectsFIFO>
  20fae0:	9002      	str	r0, [sp, #8]
    test_assert(dofp1 == NULL, "can create");
  20fae2:	9b02      	ldr	r3, [sp, #8]
  20fae4:	2b00      	cmp	r3, #0
  20fae6:	bf0c      	ite	eq
  20fae8:	2301      	moveq	r3, #1
  20faea:	2300      	movne	r3, #0
  20faec:	b2db      	uxtb	r3, r3
  20faee:	494f      	ldr	r1, [pc, #316]	@ (20fc2c <oslib_test_009_005_execute+0x1bc>)
  20faf0:	4618      	mov	r0, r3
  20faf2:	f7f7 fdb5 	bl	207660 <__test_assert>
  20faf6:	4603      	mov	r3, r0
  20faf8:	2b00      	cmp	r3, #0
  20fafa:	f040 808c 	bne.w	20fc16 <oslib_test_009_005_execute+0x1a6>
  test_end_step(3);

  /* [9.5.4] Retrieving the dynamic objects FIFO by name, must exist,
     then increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
  20fafe:	4b47      	ldr	r3, [pc, #284]	@ (20fc1c <oslib_test_009_005_execute+0x1ac>)
  20fb00:	2204      	movs	r2, #4
  20fb02:	601a      	str	r2, [r3, #0]
  {
    dyn_objects_fifo_t *dofp1, *dofp2;

    dofp1 = chFactoryFindObjectsFIFO("myfifo");
  20fb04:	4846      	ldr	r0, [pc, #280]	@ (20fc20 <oslib_test_009_005_execute+0x1b0>)
  20fb06:	f7f7 f9e3 	bl	206ed0 <chFactoryFindObjectsFIFO>
  20fb0a:	9001      	str	r0, [sp, #4]
    test_assert(dofp1 != NULL, "not found");
  20fb0c:	9b01      	ldr	r3, [sp, #4]
  20fb0e:	2b00      	cmp	r3, #0
  20fb10:	bf14      	ite	ne
  20fb12:	2301      	movne	r3, #1
  20fb14:	2300      	moveq	r3, #0
  20fb16:	b2db      	uxtb	r3, r3
  20fb18:	4945      	ldr	r1, [pc, #276]	@ (20fc30 <oslib_test_009_005_execute+0x1c0>)
  20fb1a:	4618      	mov	r0, r3
  20fb1c:	f7f7 fda0 	bl	207660 <__test_assert>
  20fb20:	4603      	mov	r3, r0
  20fb22:	2b00      	cmp	r3, #0
  20fb24:	d177      	bne.n	20fc16 <oslib_test_009_005_execute+0x1a6>
    test_assert(dofp == dofp1, "object reference mismatch");
  20fb26:	9a03      	ldr	r2, [sp, #12]
  20fb28:	9b01      	ldr	r3, [sp, #4]
  20fb2a:	429a      	cmp	r2, r3
  20fb2c:	bf0c      	ite	eq
  20fb2e:	2301      	moveq	r3, #1
  20fb30:	2300      	movne	r3, #0
  20fb32:	b2db      	uxtb	r3, r3
  20fb34:	493f      	ldr	r1, [pc, #252]	@ (20fc34 <oslib_test_009_005_execute+0x1c4>)
  20fb36:	4618      	mov	r0, r3
  20fb38:	f7f7 fd92 	bl	207660 <__test_assert>
  20fb3c:	4603      	mov	r3, r0
  20fb3e:	2b00      	cmp	r3, #0
  20fb40:	d169      	bne.n	20fc16 <oslib_test_009_005_execute+0x1a6>
    test_assert(dofp1->element.refs == 2, "object reference mismatch");
  20fb42:	9b01      	ldr	r3, [sp, #4]
  20fb44:	685b      	ldr	r3, [r3, #4]
  20fb46:	2b02      	cmp	r3, #2
  20fb48:	bf0c      	ite	eq
  20fb4a:	2301      	moveq	r3, #1
  20fb4c:	2300      	movne	r3, #0
  20fb4e:	b2db      	uxtb	r3, r3
  20fb50:	4938      	ldr	r1, [pc, #224]	@ (20fc34 <oslib_test_009_005_execute+0x1c4>)
  20fb52:	4618      	mov	r0, r3
  20fb54:	f7f7 fd84 	bl	207660 <__test_assert>
  20fb58:	4603      	mov	r3, r0
  20fb5a:	2b00      	cmp	r3, #0
  20fb5c:	d15b      	bne.n	20fc16 <oslib_test_009_005_execute+0x1a6>

    dofp2 = (dyn_objects_fifo_t *)chFactoryDuplicateReference(&dofp1->element);
  20fb5e:	9b01      	ldr	r3, [sp, #4]
  20fb60:	4618      	mov	r0, r3
  20fb62:	f7ff fb35 	bl	20f1d0 <chFactoryDuplicateReference>
  20fb66:	9000      	str	r0, [sp, #0]
    test_assert(dofp1 == dofp2, "object reference mismatch");
  20fb68:	9a01      	ldr	r2, [sp, #4]
  20fb6a:	9b00      	ldr	r3, [sp, #0]
  20fb6c:	429a      	cmp	r2, r3
  20fb6e:	bf0c      	ite	eq
  20fb70:	2301      	moveq	r3, #1
  20fb72:	2300      	movne	r3, #0
  20fb74:	b2db      	uxtb	r3, r3
  20fb76:	492f      	ldr	r1, [pc, #188]	@ (20fc34 <oslib_test_009_005_execute+0x1c4>)
  20fb78:	4618      	mov	r0, r3
  20fb7a:	f7f7 fd71 	bl	207660 <__test_assert>
  20fb7e:	4603      	mov	r3, r0
  20fb80:	2b00      	cmp	r3, #0
  20fb82:	d148      	bne.n	20fc16 <oslib_test_009_005_execute+0x1a6>
    test_assert(dofp2->element.refs == 3, "object reference mismatch");
  20fb84:	9b00      	ldr	r3, [sp, #0]
  20fb86:	685b      	ldr	r3, [r3, #4]
  20fb88:	2b03      	cmp	r3, #3
  20fb8a:	bf0c      	ite	eq
  20fb8c:	2301      	moveq	r3, #1
  20fb8e:	2300      	movne	r3, #0
  20fb90:	b2db      	uxtb	r3, r3
  20fb92:	4928      	ldr	r1, [pc, #160]	@ (20fc34 <oslib_test_009_005_execute+0x1c4>)
  20fb94:	4618      	mov	r0, r3
  20fb96:	f7f7 fd63 	bl	207660 <__test_assert>
  20fb9a:	4603      	mov	r3, r0
  20fb9c:	2b00      	cmp	r3, #0
  20fb9e:	d13a      	bne.n	20fc16 <oslib_test_009_005_execute+0x1a6>

    chFactoryReleaseObjectsFIFO(dofp2);
  20fba0:	9800      	ldr	r0, [sp, #0]
  20fba2:	f7f7 f9ad 	bl	206f00 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp1->element.refs == 2, "references mismatch");
  20fba6:	9b01      	ldr	r3, [sp, #4]
  20fba8:	685b      	ldr	r3, [r3, #4]
  20fbaa:	2b02      	cmp	r3, #2
  20fbac:	bf0c      	ite	eq
  20fbae:	2301      	moveq	r3, #1
  20fbb0:	2300      	movne	r3, #0
  20fbb2:	b2db      	uxtb	r3, r3
  20fbb4:	4920      	ldr	r1, [pc, #128]	@ (20fc38 <oslib_test_009_005_execute+0x1c8>)
  20fbb6:	4618      	mov	r0, r3
  20fbb8:	f7f7 fd52 	bl	207660 <__test_assert>
  20fbbc:	4603      	mov	r3, r0
  20fbbe:	2b00      	cmp	r3, #0
  20fbc0:	d129      	bne.n	20fc16 <oslib_test_009_005_execute+0x1a6>

    chFactoryReleaseObjectsFIFO(dofp1);
  20fbc2:	9801      	ldr	r0, [sp, #4]
  20fbc4:	f7f7 f99c 	bl	206f00 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp->element.refs == 1, "references mismatch");
  20fbc8:	9b03      	ldr	r3, [sp, #12]
  20fbca:	685b      	ldr	r3, [r3, #4]
  20fbcc:	2b01      	cmp	r3, #1
  20fbce:	bf0c      	ite	eq
  20fbd0:	2301      	moveq	r3, #1
  20fbd2:	2300      	movne	r3, #0
  20fbd4:	b2db      	uxtb	r3, r3
  20fbd6:	4918      	ldr	r1, [pc, #96]	@ (20fc38 <oslib_test_009_005_execute+0x1c8>)
  20fbd8:	4618      	mov	r0, r3
  20fbda:	f7f7 fd41 	bl	207660 <__test_assert>
  20fbde:	4603      	mov	r3, r0
  20fbe0:	2b00      	cmp	r3, #0
  20fbe2:	d118      	bne.n	20fc16 <oslib_test_009_005_execute+0x1a6>
  }
  test_end_step(4);

  /* [9.5.5] Releasing the first reference to the dynamic objects FIFO
     must not trigger an assertion.*/
  test_set_step(5);
  20fbe4:	4b0d      	ldr	r3, [pc, #52]	@ (20fc1c <oslib_test_009_005_execute+0x1ac>)
  20fbe6:	2205      	movs	r2, #5
  20fbe8:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleaseObjectsFIFO(dofp);
  20fbea:	9803      	ldr	r0, [sp, #12]
  20fbec:	f7f7 f988 	bl	206f00 <chFactoryReleaseObjectsFIFO>
  }
  test_end_step(5);

  /* [9.5.6] Retrieving the dynamic objects FIFO by name again, must
     not exist.*/
  test_set_step(6);
  20fbf0:	4b0a      	ldr	r3, [pc, #40]	@ (20fc1c <oslib_test_009_005_execute+0x1ac>)
  20fbf2:	2206      	movs	r2, #6
  20fbf4:	601a      	str	r2, [r3, #0]
  {
    dofp = chFactoryFindObjectsFIFO("myfifo");
  20fbf6:	480a      	ldr	r0, [pc, #40]	@ (20fc20 <oslib_test_009_005_execute+0x1b0>)
  20fbf8:	f7f7 f96a 	bl	206ed0 <chFactoryFindObjectsFIFO>
  20fbfc:	9003      	str	r0, [sp, #12]
    test_assert(dofp == NULL, "found");
  20fbfe:	9b03      	ldr	r3, [sp, #12]
  20fc00:	2b00      	cmp	r3, #0
  20fc02:	bf0c      	ite	eq
  20fc04:	2301      	moveq	r3, #1
  20fc06:	2300      	movne	r3, #0
  20fc08:	b2db      	uxtb	r3, r3
  20fc0a:	4906      	ldr	r1, [pc, #24]	@ (20fc24 <oslib_test_009_005_execute+0x1b4>)
  20fc0c:	4618      	mov	r0, r3
  20fc0e:	f7f7 fd27 	bl	207660 <__test_assert>
  20fc12:	4603      	mov	r3, r0
  20fc14:	2b00      	cmp	r3, #0
  }
  test_end_step(6);
}
  20fc16:	b005      	add	sp, #20
  20fc18:	f85d fb04 	ldr.w	pc, [sp], #4
  20fc1c:	20000bb4 	.word	0x20000bb4
  20fc20:	080121a0 	.word	0x080121a0
  20fc24:	08012124 	.word	0x08012124
  20fc28:	08012174 	.word	0x08012174
  20fc2c:	08012184 	.word	0x08012184
  20fc30:	08012120 	.word	0x08012120
  20fc34:	0801213c 	.word	0x0801213c
  20fc38:	08012158 	.word	0x08012158
  20fc3c:	00000000 	.word	0x00000000

0020fc40 <oslib_test_009_006_teardown>:
 *   trigger an assertion.
 * - [9.6.6] Retrieving the dynamic pipe by name again, must not exist.
 * .
 */

static void oslib_test_009_006_teardown(void) {
  20fc40:	b500      	push	{lr}
  20fc42:	b083      	sub	sp, #12
  dyn_pipe_t *dpp;

  dpp = chFactoryFindPipe("mypipe");
  20fc44:	4809      	ldr	r0, [pc, #36]	@ (20fc6c <oslib_test_009_006_teardown+0x2c>)
  20fc46:	f7f7 f99b 	bl	206f80 <chFactoryFindPipe>
  20fc4a:	9001      	str	r0, [sp, #4]
  if (dpp != NULL) {
  20fc4c:	9b01      	ldr	r3, [sp, #4]
  20fc4e:	2b00      	cmp	r3, #0
  20fc50:	d007      	beq.n	20fc62 <oslib_test_009_006_teardown+0x22>
    while (dpp->element.refs > 0U) {
  20fc52:	e002      	b.n	20fc5a <oslib_test_009_006_teardown+0x1a>
      chFactoryReleasePipe(dpp);
  20fc54:	9801      	ldr	r0, [sp, #4]
  20fc56:	f7f7 f9ab 	bl	206fb0 <chFactoryReleasePipe>
    while (dpp->element.refs > 0U) {
  20fc5a:	9b01      	ldr	r3, [sp, #4]
  20fc5c:	685b      	ldr	r3, [r3, #4]
  20fc5e:	2b00      	cmp	r3, #0
  20fc60:	d1f8      	bne.n	20fc54 <oslib_test_009_006_teardown+0x14>
    }
  }
}
  20fc62:	bf00      	nop
  20fc64:	b003      	add	sp, #12
  20fc66:	f85d fb04 	ldr.w	pc, [sp], #4
  20fc6a:	bf00      	nop
  20fc6c:	080121a8 	.word	0x080121a8

0020fc70 <oslib_test_009_006_execute>:

static void oslib_test_009_006_execute(void) {
  20fc70:	b500      	push	{lr}
  20fc72:	b085      	sub	sp, #20
  dyn_pipe_t *dpp;

  /* [9.6.1] Retrieving a dynamic pipe by name, must not exist.*/
  test_set_step(1);
  20fc74:	4b67      	ldr	r3, [pc, #412]	@ (20fe14 <oslib_test_009_006_execute+0x1a4>)
  20fc76:	2201      	movs	r2, #1
  20fc78:	601a      	str	r2, [r3, #0]
  {
    dpp = chFactoryFindPipe("mypipe");
  20fc7a:	4867      	ldr	r0, [pc, #412]	@ (20fe18 <oslib_test_009_006_execute+0x1a8>)
  20fc7c:	f7f7 f980 	bl	206f80 <chFactoryFindPipe>
  20fc80:	9003      	str	r0, [sp, #12]
    test_assert(dpp == NULL, "found");
  20fc82:	9b03      	ldr	r3, [sp, #12]
  20fc84:	2b00      	cmp	r3, #0
  20fc86:	bf0c      	ite	eq
  20fc88:	2301      	moveq	r3, #1
  20fc8a:	2300      	movne	r3, #0
  20fc8c:	b2db      	uxtb	r3, r3
  20fc8e:	4963      	ldr	r1, [pc, #396]	@ (20fe1c <oslib_test_009_006_execute+0x1ac>)
  20fc90:	4618      	mov	r0, r3
  20fc92:	f7f7 fce5 	bl	207660 <__test_assert>
  20fc96:	4603      	mov	r3, r0
  20fc98:	2b00      	cmp	r3, #0
  20fc9a:	f040 80b8 	bne.w	20fe0e <oslib_test_009_006_execute+0x19e>
  }
  test_end_step(1);

  /* [9.6.2] Creating a dynamic pipe it must not exists, must
     succeed.*/
  test_set_step(2);
  20fc9e:	4b5d      	ldr	r3, [pc, #372]	@ (20fe14 <oslib_test_009_006_execute+0x1a4>)
  20fca0:	2202      	movs	r2, #2
  20fca2:	601a      	str	r2, [r3, #0]
  {
    dpp = chFactoryCreatePipe("mypipe", 16U);
  20fca4:	2110      	movs	r1, #16
  20fca6:	485c      	ldr	r0, [pc, #368]	@ (20fe18 <oslib_test_009_006_execute+0x1a8>)
  20fca8:	f7f7 f942 	bl	206f30 <chFactoryCreatePipe>
  20fcac:	9003      	str	r0, [sp, #12]
    test_assert(dpp != NULL, "cannot create");
  20fcae:	9b03      	ldr	r3, [sp, #12]
  20fcb0:	2b00      	cmp	r3, #0
  20fcb2:	bf14      	ite	ne
  20fcb4:	2301      	movne	r3, #1
  20fcb6:	2300      	moveq	r3, #0
  20fcb8:	b2db      	uxtb	r3, r3
  20fcba:	4959      	ldr	r1, [pc, #356]	@ (20fe20 <oslib_test_009_006_execute+0x1b0>)
  20fcbc:	4618      	mov	r0, r3
  20fcbe:	f7f7 fccf 	bl	207660 <__test_assert>
  20fcc2:	4603      	mov	r3, r0
  20fcc4:	2b00      	cmp	r3, #0
  20fcc6:	f040 80a2 	bne.w	20fe0e <oslib_test_009_006_execute+0x19e>
  }
  test_end_step(2);

  /* [9.6.3] Creating a dynamic pipe with the same name, must fail.*/
  test_set_step(3);
  20fcca:	4b52      	ldr	r3, [pc, #328]	@ (20fe14 <oslib_test_009_006_execute+0x1a4>)
  20fccc:	2203      	movs	r2, #3
  20fcce:	601a      	str	r2, [r3, #0]
  {
    dyn_pipe_t *dpp1;

    dpp1 = chFactoryCreatePipe("mypipe", 16U);
  20fcd0:	2110      	movs	r1, #16
  20fcd2:	4851      	ldr	r0, [pc, #324]	@ (20fe18 <oslib_test_009_006_execute+0x1a8>)
  20fcd4:	f7f7 f92c 	bl	206f30 <chFactoryCreatePipe>
  20fcd8:	9002      	str	r0, [sp, #8]
    test_assert(dpp1 == NULL, "can create");
  20fcda:	9b02      	ldr	r3, [sp, #8]
  20fcdc:	2b00      	cmp	r3, #0
  20fcde:	bf0c      	ite	eq
  20fce0:	2301      	moveq	r3, #1
  20fce2:	2300      	movne	r3, #0
  20fce4:	b2db      	uxtb	r3, r3
  20fce6:	494f      	ldr	r1, [pc, #316]	@ (20fe24 <oslib_test_009_006_execute+0x1b4>)
  20fce8:	4618      	mov	r0, r3
  20fcea:	f7f7 fcb9 	bl	207660 <__test_assert>
  20fcee:	4603      	mov	r3, r0
  20fcf0:	2b00      	cmp	r3, #0
  20fcf2:	f040 808c 	bne.w	20fe0e <oslib_test_009_006_execute+0x19e>
  test_end_step(3);

  /* [9.6.4] Retrieving the dynamic pipe by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
  20fcf6:	4b47      	ldr	r3, [pc, #284]	@ (20fe14 <oslib_test_009_006_execute+0x1a4>)
  20fcf8:	2204      	movs	r2, #4
  20fcfa:	601a      	str	r2, [r3, #0]
  {
    dyn_pipe_t *dpp1, *dpp2;

    dpp1 = chFactoryFindPipe("mypipe");
  20fcfc:	4846      	ldr	r0, [pc, #280]	@ (20fe18 <oslib_test_009_006_execute+0x1a8>)
  20fcfe:	f7f7 f93f 	bl	206f80 <chFactoryFindPipe>
  20fd02:	9001      	str	r0, [sp, #4]
    test_assert(dpp1 != NULL, "not found");
  20fd04:	9b01      	ldr	r3, [sp, #4]
  20fd06:	2b00      	cmp	r3, #0
  20fd08:	bf14      	ite	ne
  20fd0a:	2301      	movne	r3, #1
  20fd0c:	2300      	moveq	r3, #0
  20fd0e:	b2db      	uxtb	r3, r3
  20fd10:	4945      	ldr	r1, [pc, #276]	@ (20fe28 <oslib_test_009_006_execute+0x1b8>)
  20fd12:	4618      	mov	r0, r3
  20fd14:	f7f7 fca4 	bl	207660 <__test_assert>
  20fd18:	4603      	mov	r3, r0
  20fd1a:	2b00      	cmp	r3, #0
  20fd1c:	d177      	bne.n	20fe0e <oslib_test_009_006_execute+0x19e>
    test_assert(dpp == dpp1, "object reference mismatch");
  20fd1e:	9a03      	ldr	r2, [sp, #12]
  20fd20:	9b01      	ldr	r3, [sp, #4]
  20fd22:	429a      	cmp	r2, r3
  20fd24:	bf0c      	ite	eq
  20fd26:	2301      	moveq	r3, #1
  20fd28:	2300      	movne	r3, #0
  20fd2a:	b2db      	uxtb	r3, r3
  20fd2c:	493f      	ldr	r1, [pc, #252]	@ (20fe2c <oslib_test_009_006_execute+0x1bc>)
  20fd2e:	4618      	mov	r0, r3
  20fd30:	f7f7 fc96 	bl	207660 <__test_assert>
  20fd34:	4603      	mov	r3, r0
  20fd36:	2b00      	cmp	r3, #0
  20fd38:	d169      	bne.n	20fe0e <oslib_test_009_006_execute+0x19e>
    test_assert(dpp1->element.refs == 2, "object reference mismatch");
  20fd3a:	9b01      	ldr	r3, [sp, #4]
  20fd3c:	685b      	ldr	r3, [r3, #4]
  20fd3e:	2b02      	cmp	r3, #2
  20fd40:	bf0c      	ite	eq
  20fd42:	2301      	moveq	r3, #1
  20fd44:	2300      	movne	r3, #0
  20fd46:	b2db      	uxtb	r3, r3
  20fd48:	4938      	ldr	r1, [pc, #224]	@ (20fe2c <oslib_test_009_006_execute+0x1bc>)
  20fd4a:	4618      	mov	r0, r3
  20fd4c:	f7f7 fc88 	bl	207660 <__test_assert>
  20fd50:	4603      	mov	r3, r0
  20fd52:	2b00      	cmp	r3, #0
  20fd54:	d15b      	bne.n	20fe0e <oslib_test_009_006_execute+0x19e>

    dpp2 = (dyn_pipe_t *)chFactoryDuplicateReference(&dpp1->element);
  20fd56:	9b01      	ldr	r3, [sp, #4]
  20fd58:	4618      	mov	r0, r3
  20fd5a:	f7ff fa39 	bl	20f1d0 <chFactoryDuplicateReference>
  20fd5e:	9000      	str	r0, [sp, #0]
    test_assert(dpp1 == dpp2, "object reference mismatch");
  20fd60:	9a01      	ldr	r2, [sp, #4]
  20fd62:	9b00      	ldr	r3, [sp, #0]
  20fd64:	429a      	cmp	r2, r3
  20fd66:	bf0c      	ite	eq
  20fd68:	2301      	moveq	r3, #1
  20fd6a:	2300      	movne	r3, #0
  20fd6c:	b2db      	uxtb	r3, r3
  20fd6e:	492f      	ldr	r1, [pc, #188]	@ (20fe2c <oslib_test_009_006_execute+0x1bc>)
  20fd70:	4618      	mov	r0, r3
  20fd72:	f7f7 fc75 	bl	207660 <__test_assert>
  20fd76:	4603      	mov	r3, r0
  20fd78:	2b00      	cmp	r3, #0
  20fd7a:	d148      	bne.n	20fe0e <oslib_test_009_006_execute+0x19e>
    test_assert(dpp2->element.refs == 3, "object reference mismatch");
  20fd7c:	9b00      	ldr	r3, [sp, #0]
  20fd7e:	685b      	ldr	r3, [r3, #4]
  20fd80:	2b03      	cmp	r3, #3
  20fd82:	bf0c      	ite	eq
  20fd84:	2301      	moveq	r3, #1
  20fd86:	2300      	movne	r3, #0
  20fd88:	b2db      	uxtb	r3, r3
  20fd8a:	4928      	ldr	r1, [pc, #160]	@ (20fe2c <oslib_test_009_006_execute+0x1bc>)
  20fd8c:	4618      	mov	r0, r3
  20fd8e:	f7f7 fc67 	bl	207660 <__test_assert>
  20fd92:	4603      	mov	r3, r0
  20fd94:	2b00      	cmp	r3, #0
  20fd96:	d13a      	bne.n	20fe0e <oslib_test_009_006_execute+0x19e>

    chFactoryReleasePipe(dpp2);
  20fd98:	9800      	ldr	r0, [sp, #0]
  20fd9a:	f7f7 f909 	bl	206fb0 <chFactoryReleasePipe>
    test_assert(dpp1->element.refs == 2, "references mismatch");
  20fd9e:	9b01      	ldr	r3, [sp, #4]
  20fda0:	685b      	ldr	r3, [r3, #4]
  20fda2:	2b02      	cmp	r3, #2
  20fda4:	bf0c      	ite	eq
  20fda6:	2301      	moveq	r3, #1
  20fda8:	2300      	movne	r3, #0
  20fdaa:	b2db      	uxtb	r3, r3
  20fdac:	4920      	ldr	r1, [pc, #128]	@ (20fe30 <oslib_test_009_006_execute+0x1c0>)
  20fdae:	4618      	mov	r0, r3
  20fdb0:	f7f7 fc56 	bl	207660 <__test_assert>
  20fdb4:	4603      	mov	r3, r0
  20fdb6:	2b00      	cmp	r3, #0
  20fdb8:	d129      	bne.n	20fe0e <oslib_test_009_006_execute+0x19e>

    chFactoryReleasePipe(dpp1);
  20fdba:	9801      	ldr	r0, [sp, #4]
  20fdbc:	f7f7 f8f8 	bl	206fb0 <chFactoryReleasePipe>
    test_assert(dpp->element.refs == 1, "references mismatch");
  20fdc0:	9b03      	ldr	r3, [sp, #12]
  20fdc2:	685b      	ldr	r3, [r3, #4]
  20fdc4:	2b01      	cmp	r3, #1
  20fdc6:	bf0c      	ite	eq
  20fdc8:	2301      	moveq	r3, #1
  20fdca:	2300      	movne	r3, #0
  20fdcc:	b2db      	uxtb	r3, r3
  20fdce:	4918      	ldr	r1, [pc, #96]	@ (20fe30 <oslib_test_009_006_execute+0x1c0>)
  20fdd0:	4618      	mov	r0, r3
  20fdd2:	f7f7 fc45 	bl	207660 <__test_assert>
  20fdd6:	4603      	mov	r3, r0
  20fdd8:	2b00      	cmp	r3, #0
  20fdda:	d118      	bne.n	20fe0e <oslib_test_009_006_execute+0x19e>
  }
  test_end_step(4);

  /* [9.6.5] Releasing the first reference to the dynamic pipe must not
     trigger an assertion.*/
  test_set_step(5);
  20fddc:	4b0d      	ldr	r3, [pc, #52]	@ (20fe14 <oslib_test_009_006_execute+0x1a4>)
  20fdde:	2205      	movs	r2, #5
  20fde0:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleasePipe(dpp);
  20fde2:	9803      	ldr	r0, [sp, #12]
  20fde4:	f7f7 f8e4 	bl	206fb0 <chFactoryReleasePipe>
  }
  test_end_step(5);

  /* [9.6.6] Retrieving the dynamic pipe by name again, must not
     exist.*/
  test_set_step(6);
  20fde8:	4b0a      	ldr	r3, [pc, #40]	@ (20fe14 <oslib_test_009_006_execute+0x1a4>)
  20fdea:	2206      	movs	r2, #6
  20fdec:	601a      	str	r2, [r3, #0]
  {
    dpp = chFactoryFindPipe("mypipe");
  20fdee:	480a      	ldr	r0, [pc, #40]	@ (20fe18 <oslib_test_009_006_execute+0x1a8>)
  20fdf0:	f7f7 f8c6 	bl	206f80 <chFactoryFindPipe>
  20fdf4:	9003      	str	r0, [sp, #12]
    test_assert(dpp == NULL, "found");
  20fdf6:	9b03      	ldr	r3, [sp, #12]
  20fdf8:	2b00      	cmp	r3, #0
  20fdfa:	bf0c      	ite	eq
  20fdfc:	2301      	moveq	r3, #1
  20fdfe:	2300      	movne	r3, #0
  20fe00:	b2db      	uxtb	r3, r3
  20fe02:	4906      	ldr	r1, [pc, #24]	@ (20fe1c <oslib_test_009_006_execute+0x1ac>)
  20fe04:	4618      	mov	r0, r3
  20fe06:	f7f7 fc2b 	bl	207660 <__test_assert>
  20fe0a:	4603      	mov	r3, r0
  20fe0c:	2b00      	cmp	r3, #0
  }
  test_end_step(6);
}
  20fe0e:	b005      	add	sp, #20
  20fe10:	f85d fb04 	ldr.w	pc, [sp], #4
  20fe14:	20000bb4 	.word	0x20000bb4
  20fe18:	080121a8 	.word	0x080121a8
  20fe1c:	08012124 	.word	0x08012124
  20fe20:	08012174 	.word	0x08012174
  20fe24:	08012184 	.word	0x08012184
  20fe28:	08012120 	.word	0x08012120
  20fe2c:	0801213c 	.word	0x0801213c
  20fe30:	08012158 	.word	0x08012158
	...

0020fe40 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
  20fe40:	b082      	sub	sp, #8
  20fe42:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
  20fe44:	4b03      	ldr	r3, [pc, #12]	@ (20fe54 <chRegSetThreadName+0x14>)
  20fe46:	68db      	ldr	r3, [r3, #12]
  20fe48:	9a01      	ldr	r2, [sp, #4]
  20fe4a:	621a      	str	r2, [r3, #32]
#else
  (void)name;
#endif
}
  20fe4c:	bf00      	nop
  20fe4e:	b002      	add	sp, #8
  20fe50:	4770      	bx	lr
  20fe52:	bf00      	nop
  20fe54:	20000890 	.word	0x20000890
	...

0020fe60 <test_execute>:
                                 const testsuite_t *tsp) {
  20fe60:	b500      	push	{lr}
  20fe62:	b083      	sub	sp, #12
  20fe64:	9001      	str	r0, [sp, #4]
  20fe66:	9100      	str	r1, [sp, #0]
  return (msg_t)test_execute_stream(stream, tsp);
  20fe68:	9900      	ldr	r1, [sp, #0]
  20fe6a:	9801      	ldr	r0, [sp, #4]
  20fe6c:	f7f7 fc70 	bl	207750 <test_execute_stream>
  20fe70:	4603      	mov	r3, r0
}
  20fe72:	4618      	mov	r0, r3
  20fe74:	b003      	add	sp, #12
  20fe76:	f85d fb04 	ldr.w	pc, [sp], #4
  20fe7a:	bf00      	nop
  20fe7c:	0000      	movs	r0, r0
	...

0020fe80 <Thread1.lto_priv.2>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
  20fe80:	b500      	push	{lr}
  20fe82:	b083      	sub	sp, #12
  20fe84:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
  20fe86:	4818      	ldr	r0, [pc, #96]	@ (20fee8 <Thread1.lto_priv.2+0x68>)
  20fe88:	f7ff ffda 	bl	20fe40 <chRegSetThreadName>
  while (true) {
    palSetLine(LINE_LED1);
  20fe8c:	4b17      	ldr	r3, [pc, #92]	@ (20feec <Thread1.lto_priv.2+0x6c>)
  20fe8e:	2201      	movs	r2, #1
  20fe90:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(50);
  20fe92:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  20fe96:	f7f3 fbab 	bl	2035f0 <chThdSleep>
    palSetLine(LINE_LED2);
  20fe9a:	4b14      	ldr	r3, [pc, #80]	@ (20feec <Thread1.lto_priv.2+0x6c>)
  20fe9c:	2280      	movs	r2, #128	@ 0x80
  20fe9e:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(50);
  20fea0:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  20fea4:	f7f3 fba4 	bl	2035f0 <chThdSleep>
    palSetLine(LINE_LED3);
  20fea8:	4b10      	ldr	r3, [pc, #64]	@ (20feec <Thread1.lto_priv.2+0x6c>)
  20feaa:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
  20feae:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(200);
  20feb0:	f44f 60fa 	mov.w	r0, #2000	@ 0x7d0
  20feb4:	f7f3 fb9c 	bl	2035f0 <chThdSleep>
    palClearLine(LINE_LED1);
  20feb8:	4b0c      	ldr	r3, [pc, #48]	@ (20feec <Thread1.lto_priv.2+0x6c>)
  20feba:	2201      	movs	r2, #1
  20febc:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(50);
  20febe:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  20fec2:	f7f3 fb95 	bl	2035f0 <chThdSleep>
    palClearLine(LINE_LED2);
  20fec6:	4b09      	ldr	r3, [pc, #36]	@ (20feec <Thread1.lto_priv.2+0x6c>)
  20fec8:	2280      	movs	r2, #128	@ 0x80
  20feca:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(50);
  20fecc:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  20fed0:	f7f3 fb8e 	bl	2035f0 <chThdSleep>
    palClearLine(LINE_LED3);
  20fed4:	4b05      	ldr	r3, [pc, #20]	@ (20feec <Thread1.lto_priv.2+0x6c>)
  20fed6:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
  20feda:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(200);
  20fedc:	f44f 60fa 	mov.w	r0, #2000	@ 0x7d0
  20fee0:	f7f3 fb86 	bl	2035f0 <chThdSleep>
    palSetLine(LINE_LED1);
  20fee4:	bf00      	nop
  20fee6:	e7d1      	b.n	20fe8c <Thread1.lto_priv.2+0xc>
  20fee8:	080121b0 	.word	0x080121b0
  20feec:	40020400 	.word	0x40020400

0020fef0 <Thread2>:
}


volatile int k = 0;
static THD_WORKING_AREA(waThread2, 128);
static THD_FUNCTION(Thread2, arg) {
  20fef0:	b500      	push	{lr}
  20fef2:	b083      	sub	sp, #12
  20fef4:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("count");
  20fef6:	4807      	ldr	r0, [pc, #28]	@ (20ff14 <Thread2+0x24>)
  20fef8:	f7ff ffa2 	bl	20fe40 <chRegSetThreadName>
  while (true) {
     k ++;
  20fefc:	4b06      	ldr	r3, [pc, #24]	@ (20ff18 <Thread2+0x28>)
  20fefe:	681b      	ldr	r3, [r3, #0]
  20ff00:	3301      	adds	r3, #1
  20ff02:	4a05      	ldr	r2, [pc, #20]	@ (20ff18 <Thread2+0x28>)
  20ff04:	6013      	str	r3, [r2, #0]
     chThdSleepMilliseconds(500);
  20ff06:	f241 3088 	movw	r0, #5000	@ 0x1388
  20ff0a:	f7f3 fb71 	bl	2035f0 <chThdSleep>
     k ++;
  20ff0e:	bf00      	nop
  20ff10:	e7f4      	b.n	20fefc <Thread2+0xc>
  20ff12:	bf00      	nop
  20ff14:	080121b8 	.word	0x080121b8
  20ff18:	200027a0 	.word	0x200027a0
  20ff1c:	00000000 	.word	0x00000000

0020ff20 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
  20ff20:	b500      	push	{lr}
  20ff22:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
  20ff24:	f7f0 fc8c 	bl	200840 <halInit>
  chSysInit();
  20ff28:	f7f1 fffa 	bl	201f20 <chSysInit>

  /*
   * Activates the serial driver 3 using the driver default configuration.
   */
  sdStart(&SD3, NULL);
  20ff2c:	2100      	movs	r1, #0
  20ff2e:	4814      	ldr	r0, [pc, #80]	@ (20ff80 <main+0x60>)
  20ff30:	f7f1 f936 	bl	2011a0 <sdStart>

  /*
   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO + 1, Thread1, NULL);
  20ff34:	2300      	movs	r3, #0
  20ff36:	9300      	str	r3, [sp, #0]
  20ff38:	4b12      	ldr	r3, [pc, #72]	@ (20ff84 <main+0x64>)
  20ff3a:	2281      	movs	r2, #129	@ 0x81
  20ff3c:	f44f 7118 	mov.w	r1, #608	@ 0x260
  20ff40:	4811      	ldr	r0, [pc, #68]	@ (20ff88 <main+0x68>)
  20ff42:	f7f3 fa1d 	bl	203380 <chThdCreateStatic>
  chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO + 2, Thread2, NULL);
  20ff46:	2300      	movs	r3, #0
  20ff48:	9300      	str	r3, [sp, #0]
  20ff4a:	4b10      	ldr	r3, [pc, #64]	@ (20ff8c <main+0x6c>)
  20ff4c:	2282      	movs	r2, #130	@ 0x82
  20ff4e:	f44f 7118 	mov.w	r1, #608	@ 0x260
  20ff52:	480f      	ldr	r0, [pc, #60]	@ (20ff90 <main+0x70>)
  20ff54:	f7f3 fa14 	bl	203380 <chThdCreateStatic>
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (palReadLine(LINE_BUTTON)) {
  20ff58:	4b0e      	ldr	r3, [pc, #56]	@ (20ff94 <main+0x74>)
  20ff5a:	691b      	ldr	r3, [r3, #16]
  20ff5c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  20ff60:	2b00      	cmp	r3, #0
  20ff62:	d007      	beq.n	20ff74 <main+0x54>
      test_execute((BaseSequentialStream *)&SD3, &rt_test_suite);
  20ff64:	490c      	ldr	r1, [pc, #48]	@ (20ff98 <main+0x78>)
  20ff66:	4806      	ldr	r0, [pc, #24]	@ (20ff80 <main+0x60>)
  20ff68:	f7ff ff7a 	bl	20fe60 <test_execute>
      test_execute((BaseSequentialStream *)&SD3, &oslib_test_suite);
  20ff6c:	490b      	ldr	r1, [pc, #44]	@ (20ff9c <main+0x7c>)
  20ff6e:	4804      	ldr	r0, [pc, #16]	@ (20ff80 <main+0x60>)
  20ff70:	f7ff ff76 	bl	20fe60 <test_execute>
    }
    chThdSleepMilliseconds(500);
  20ff74:	f241 3088 	movw	r0, #5000	@ 0x1388
  20ff78:	f7f3 fb3a 	bl	2035f0 <chThdSleep>
    if (palReadLine(LINE_BUTTON)) {
  20ff7c:	e7ec      	b.n	20ff58 <main+0x38>
  20ff7e:	bf00      	nop
  20ff80:	20000800 	.word	0x20000800
  20ff84:	0020fe81 	.word	0x0020fe81
  20ff88:	20002540 	.word	0x20002540
  20ff8c:	0020fef1 	.word	0x0020fef1
  20ff90:	200027c0 	.word	0x200027c0
  20ff94:	40020800 	.word	0x40020800
  20ff98:	08012218 	.word	0x08012218
  20ff9c:	080126b8 	.word	0x080126b8
