
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000239 	.word	0x08000239
 8000008:	0800023b 	.word	0x0800023b
 800000c:	0800023b 	.word	0x0800023b
 8000010:	0800023b 	.word	0x0800023b
 8000014:	0800023b 	.word	0x0800023b
 8000018:	0800023b 	.word	0x0800023b
 800001c:	0800023b 	.word	0x0800023b
 8000020:	0800023b 	.word	0x0800023b
 8000024:	0800023b 	.word	0x0800023b
 8000028:	0800023b 	.word	0x0800023b
 800002c:	08002bb1 	.word	0x08002bb1
 8000030:	0800023b 	.word	0x0800023b
 8000034:	0800023b 	.word	0x0800023b
 8000038:	0800023b 	.word	0x0800023b
 800003c:	0800023b 	.word	0x0800023b
 8000040:	0800023b 	.word	0x0800023b
 8000044:	0800023b 	.word	0x0800023b
 8000048:	0800023b 	.word	0x0800023b
 800004c:	0800023b 	.word	0x0800023b
 8000050:	0800023b 	.word	0x0800023b
 8000054:	0800023b 	.word	0x0800023b
 8000058:	0800023b 	.word	0x0800023b
 800005c:	0800023b 	.word	0x0800023b
 8000060:	0800023b 	.word	0x0800023b
 8000064:	0800023b 	.word	0x0800023b
 8000068:	0800023b 	.word	0x0800023b
 800006c:	08001521 	.word	0x08001521
 8000070:	080015f1 	.word	0x080015f1
 8000074:	080016c1 	.word	0x080016c1
 8000078:	08001791 	.word	0x08001791
 800007c:	08001861 	.word	0x08001861
 8000080:	08001931 	.word	0x08001931
 8000084:	08001a01 	.word	0x08001a01
 8000088:	0800023b 	.word	0x0800023b
 800008c:	0800023b 	.word	0x0800023b
 8000090:	0800023b 	.word	0x0800023b
 8000094:	0800023b 	.word	0x0800023b
 8000098:	0800023b 	.word	0x0800023b
 800009c:	0800023b 	.word	0x0800023b
 80000a0:	0800023b 	.word	0x0800023b
 80000a4:	0800023b 	.word	0x0800023b
 80000a8:	0800023b 	.word	0x0800023b
 80000ac:	0800023b 	.word	0x0800023b
 80000b0:	08001f41 	.word	0x08001f41
 80000b4:	0800023b 	.word	0x0800023b
 80000b8:	0800023b 	.word	0x0800023b
 80000bc:	08001ad1 	.word	0x08001ad1
 80000c0:	08001d51 	.word	0x08001d51
 80000c4:	0800023b 	.word	0x0800023b
 80000c8:	0800023b 	.word	0x0800023b
 80000cc:	0800023b 	.word	0x0800023b
 80000d0:	0800023b 	.word	0x0800023b
 80000d4:	0800023b 	.word	0x0800023b
 80000d8:	0800023b 	.word	0x0800023b
 80000dc:	0800023b 	.word	0x0800023b
 80000e0:	0800023b 	.word	0x0800023b
 80000e4:	0800023b 	.word	0x0800023b
 80000e8:	0800023b 	.word	0x0800023b
 80000ec:	0800023b 	.word	0x0800023b
 80000f0:	0800023b 	.word	0x0800023b
 80000f4:	0800023b 	.word	0x0800023b
 80000f8:	0800023b 	.word	0x0800023b
 80000fc:	0800023b 	.word	0x0800023b
 8000100:	0800023b 	.word	0x0800023b
 8000104:	0800023b 	.word	0x0800023b
 8000108:	0800023b 	.word	0x0800023b
 800010c:	0800023b 	.word	0x0800023b
 8000110:	0800023b 	.word	0x0800023b
 8000114:	0800023b 	.word	0x0800023b
 8000118:	0800023b 	.word	0x0800023b
 800011c:	0800023b 	.word	0x0800023b
 8000120:	0800023b 	.word	0x0800023b
 8000124:	0800023b 	.word	0x0800023b
 8000128:	0800023b 	.word	0x0800023b
 800012c:	0800023b 	.word	0x0800023b
 8000130:	0800023b 	.word	0x0800023b
 8000134:	0800023b 	.word	0x0800023b
 8000138:	0800023b 	.word	0x0800023b
 800013c:	0800023b 	.word	0x0800023b
 8000140:	0800023b 	.word	0x0800023b
 8000144:	0800023b 	.word	0x0800023b
 8000148:	0800023b 	.word	0x0800023b
 800014c:	0800023b 	.word	0x0800023b
 8000150:	0800023b 	.word	0x0800023b
 8000154:	0800023b 	.word	0x0800023b
 8000158:	0800023b 	.word	0x0800023b
 800015c:	0800023b 	.word	0x0800023b

Disassembly of section .text:

08000160 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000160:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000162:	4826      	ldr	r0, [pc, #152]	; (80001fc <_crt0_entry+0x9c>)
                msr     MSP, r0
 8000164:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000168:	4825      	ldr	r0, [pc, #148]	; (8000200 <_crt0_entry+0xa0>)
                msr     PSP, r0
 800016a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 800016e:	4825      	ldr	r0, [pc, #148]	; (8000204 <_crt0_entry+0xa4>)
                ldr     r1, =SCB_VTOR
 8000170:	4925      	ldr	r1, [pc, #148]	; (8000208 <_crt0_entry+0xa8>)
                str     r0, [r1]
 8000172:	6008      	str	r0, [r1, #0]
                movt    r1, #SCB_FPDSCR >> 16
                str     r0, [r1]
#endif

                /* CONTROL register initialization as configured.*/
                movs    r0, #CRT0_CONTROL_INIT
 8000174:	2002      	movs	r0, #2
                msr     CONTROL, r0
 8000176:	f380 8814 	msr	CONTROL, r0
                isb
 800017a:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 800017e:	f001 f97f 	bl	8001480 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000182:	f001 ffed 	bl	8002160 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000186:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800018a:	4920      	ldr	r1, [pc, #128]	; (800020c <_crt0_entry+0xac>)
                ldr     r2, =__main_stack_end__
 800018c:	4a1b      	ldr	r2, [pc, #108]	; (80001fc <_crt0_entry+0x9c>)
.Lmsloop:
                cmp     r1, r2
 800018e:	4291      	cmp	r1, r2
                itt     lo
 8000190:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000192:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lmsloop
 8000196:	e7fa      	bcc.n	800018e <_crt0_entry+0x2e>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000198:	491d      	ldr	r1, [pc, #116]	; (8000210 <_crt0_entry+0xb0>)
                ldr     r2, =__process_stack_end__
 800019a:	4a19      	ldr	r2, [pc, #100]	; (8000200 <_crt0_entry+0xa0>)
.Lpsloop:
                cmp     r1, r2
 800019c:	4291      	cmp	r1, r2
                itt     lo
 800019e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001a0:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lpsloop
 80001a4:	e7fa      	bcc.n	800019c <_crt0_entry+0x3c>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 80001a6:	491b      	ldr	r1, [pc, #108]	; (8000214 <_crt0_entry+0xb4>)
                ldr     r2, =__data_base__
 80001a8:	4a1b      	ldr	r2, [pc, #108]	; (8000218 <_crt0_entry+0xb8>)
                ldr     r3, =__data_end__
 80001aa:	4b1c      	ldr	r3, [pc, #112]	; (800021c <_crt0_entry+0xbc>)
.Ldloop:
                cmp     r2, r3
 80001ac:	429a      	cmp	r2, r3
                ittt    lo
 80001ae:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 80001b0:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 80001b4:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     .Ldloop
 80001b8:	e7f8      	bcc.n	80001ac <_crt0_entry+0x4c>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 80001ba:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 80001bc:	4918      	ldr	r1, [pc, #96]	; (8000220 <_crt0_entry+0xc0>)
                ldr     r2, =__bss_end__
 80001be:	4a19      	ldr	r2, [pc, #100]	; (8000224 <_crt0_entry+0xc4>)
.Lbloop:
                cmp     r1, r2
 80001c0:	4291      	cmp	r1, r2
                itt     lo
 80001c2:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001c4:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lbloop
 80001c8:	e7fa      	bcc.n	80001c0 <_crt0_entry+0x60>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 80001ca:	f001 f971 	bl	80014b0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 80001ce:	f001 f95f 	bl	8001490 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 80001d2:	4c15      	ldr	r4, [pc, #84]	; (8000228 <_crt0_entry+0xc8>)
                ldr     r5, =__init_array_end__
 80001d4:	4d15      	ldr	r5, [pc, #84]	; (800022c <_crt0_entry+0xcc>)
.Linitloop:
                cmp     r4, r5
 80001d6:	42ac      	cmp	r4, r5
                bge     .Lendinitloop
 80001d8:	da03      	bge.n	80001e2 <_crt0_entry+0x82>
                ldr     r1, [r4], #4
 80001da:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80001de:	4788      	blx	r1
                b       .Linitloop
 80001e0:	e7f9      	b.n	80001d6 <_crt0_entry+0x76>
.Lendinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80001e2:	f002 fcf5 	bl	8002bd0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 80001e6:	4c12      	ldr	r4, [pc, #72]	; (8000230 <_crt0_entry+0xd0>)
                ldr     r5, =__fini_array_end__
 80001e8:	4d12      	ldr	r5, [pc, #72]	; (8000234 <_crt0_entry+0xd4>)
.Lfiniloop:
                cmp     r4, r5
 80001ea:	42ac      	cmp	r4, r5
                bge     .Lendfiniloop
 80001ec:	da03      	bge.n	80001f6 <_crt0_entry+0x96>
                ldr     r1, [r4], #4
 80001ee:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80001f2:	4788      	blx	r1
                b       .Lfiniloop
 80001f4:	e7f9      	b.n	80001ea <_crt0_entry+0x8a>
.Lendfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80001f6:	f001 b953 	b.w	80014a0 <__default_exit>
 80001fa:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 80001fc:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000200:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000204:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000208:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800020c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000210:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000214:	08003a10 	.word	0x08003a10
                ldr     r2, =__data_base__
 8000218:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800021c:	20000c30 	.word	0x20000c30
                ldr     r1, =__bss_base__
 8000220:	20000c40 	.word	0x20000c40
                ldr     r2, =__bss_end__
 8000224:	20001ba4 	.word	0x20001ba4
                ldr     r4, =__init_array_base__
 8000228:	08000160 	.word	0x08000160
                ldr     r5, =__init_array_end__
 800022c:	08000160 	.word	0x08000160
                ldr     r4, =__fini_array_base__
 8000230:	08000160 	.word	0x08000160
                ldr     r5, =__fini_array_end__
 8000234:	08000160 	.word	0x08000160

08000238 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000238:	e792      	b.n	8000160 <_crt0_entry>

0800023a <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 800023a:	f000 f800 	bl	800023e <_unhandled_exception>

0800023e <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 800023e:	e7fe      	b.n	800023e <_unhandled_exception>

08000240 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000240:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                /* Saving FPU context.*/
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000244:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000248:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 800024a:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800024c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000250 <__port_thread_start>:
__port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      __port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 8000250:	f002 f936 	bl	80024c0 <__dbg_check_unlock>
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000254:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000256:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 800025a:	4628      	mov	r0, r5
                blx     r4
 800025c:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 800025e:	2000      	movs	r0, #0
                bl      chThdExit
 8000260:	f002 fc5e 	bl	8002b20 <chThdExit>
1:              b       1b
 8000264:	e7fe      	b.n	8000264 <__port_thread_start+0x14>

08000266 <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 8000266:	f001 ffbb 	bl	80021e0 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 800026a:	f002 f941 	bl	80024f0 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 800026e:	f002 f927 	bl	80024c0 <__dbg_check_unlock>

08000272 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000272:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
1:              b       1b
 8000274:	e7fe      	b.n	8000274 <__port_exit_from_isr+0x2>
	...

08000278 <__aeabi_frsub>:
 8000278:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 800027c:	e002      	b.n	8000284 <__addsf3>
 800027e:	bf00      	nop

08000280 <__aeabi_fsub>:
 8000280:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000284 <__addsf3>:
 8000284:	0042      	lsls	r2, r0, #1
 8000286:	bf1f      	itttt	ne
 8000288:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 800028c:	ea92 0f03 	teqne	r2, r3
 8000290:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000294:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000298:	d06a      	beq.n	8000370 <__addsf3+0xec>
 800029a:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800029e:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80002a2:	bfc1      	itttt	gt
 80002a4:	18d2      	addgt	r2, r2, r3
 80002a6:	4041      	eorgt	r1, r0
 80002a8:	4048      	eorgt	r0, r1
 80002aa:	4041      	eorgt	r1, r0
 80002ac:	bfb8      	it	lt
 80002ae:	425b      	neglt	r3, r3
 80002b0:	2b19      	cmp	r3, #25
 80002b2:	bf88      	it	hi
 80002b4:	4770      	bxhi	lr
 80002b6:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80002ba:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80002be:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80002c2:	bf18      	it	ne
 80002c4:	4240      	negne	r0, r0
 80002c6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80002ca:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80002ce:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80002d2:	bf18      	it	ne
 80002d4:	4249      	negne	r1, r1
 80002d6:	ea92 0f03 	teq	r2, r3
 80002da:	d03f      	beq.n	800035c <__addsf3+0xd8>
 80002dc:	f1a2 0201 	sub.w	r2, r2, #1
 80002e0:	fa41 fc03 	asr.w	ip, r1, r3
 80002e4:	eb10 000c 	adds.w	r0, r0, ip
 80002e8:	f1c3 0320 	rsb	r3, r3, #32
 80002ec:	fa01 f103 	lsl.w	r1, r1, r3
 80002f0:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80002f4:	d502      	bpl.n	80002fc <__addsf3+0x78>
 80002f6:	4249      	negs	r1, r1
 80002f8:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80002fc:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000300:	d313      	bcc.n	800032a <__addsf3+0xa6>
 8000302:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000306:	d306      	bcc.n	8000316 <__addsf3+0x92>
 8000308:	0840      	lsrs	r0, r0, #1
 800030a:	ea4f 0131 	mov.w	r1, r1, rrx
 800030e:	f102 0201 	add.w	r2, r2, #1
 8000312:	2afe      	cmp	r2, #254	; 0xfe
 8000314:	d251      	bcs.n	80003ba <__addsf3+0x136>
 8000316:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 800031a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800031e:	bf08      	it	eq
 8000320:	f020 0001 	biceq.w	r0, r0, #1
 8000324:	ea40 0003 	orr.w	r0, r0, r3
 8000328:	4770      	bx	lr
 800032a:	0049      	lsls	r1, r1, #1
 800032c:	eb40 0000 	adc.w	r0, r0, r0
 8000330:	3a01      	subs	r2, #1
 8000332:	bf28      	it	cs
 8000334:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 8000338:	d2ed      	bcs.n	8000316 <__addsf3+0x92>
 800033a:	fab0 fc80 	clz	ip, r0
 800033e:	f1ac 0c08 	sub.w	ip, ip, #8
 8000342:	ebb2 020c 	subs.w	r2, r2, ip
 8000346:	fa00 f00c 	lsl.w	r0, r0, ip
 800034a:	bfaa      	itet	ge
 800034c:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000350:	4252      	neglt	r2, r2
 8000352:	4318      	orrge	r0, r3
 8000354:	bfbc      	itt	lt
 8000356:	40d0      	lsrlt	r0, r2
 8000358:	4318      	orrlt	r0, r3
 800035a:	4770      	bx	lr
 800035c:	f092 0f00 	teq	r2, #0
 8000360:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000364:	bf06      	itte	eq
 8000366:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 800036a:	3201      	addeq	r2, #1
 800036c:	3b01      	subne	r3, #1
 800036e:	e7b5      	b.n	80002dc <__addsf3+0x58>
 8000370:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000374:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000378:	bf18      	it	ne
 800037a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800037e:	d021      	beq.n	80003c4 <__addsf3+0x140>
 8000380:	ea92 0f03 	teq	r2, r3
 8000384:	d004      	beq.n	8000390 <__addsf3+0x10c>
 8000386:	f092 0f00 	teq	r2, #0
 800038a:	bf08      	it	eq
 800038c:	4608      	moveq	r0, r1
 800038e:	4770      	bx	lr
 8000390:	ea90 0f01 	teq	r0, r1
 8000394:	bf1c      	itt	ne
 8000396:	2000      	movne	r0, #0
 8000398:	4770      	bxne	lr
 800039a:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 800039e:	d104      	bne.n	80003aa <__addsf3+0x126>
 80003a0:	0040      	lsls	r0, r0, #1
 80003a2:	bf28      	it	cs
 80003a4:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80003a8:	4770      	bx	lr
 80003aa:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80003ae:	bf3c      	itt	cc
 80003b0:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80003b4:	4770      	bxcc	lr
 80003b6:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80003ba:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80003be:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80003c2:	4770      	bx	lr
 80003c4:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80003c8:	bf16      	itet	ne
 80003ca:	4608      	movne	r0, r1
 80003cc:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80003d0:	4601      	movne	r1, r0
 80003d2:	0242      	lsls	r2, r0, #9
 80003d4:	bf06      	itte	eq
 80003d6:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80003da:	ea90 0f01 	teqeq	r0, r1
 80003de:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80003e2:	4770      	bx	lr

080003e4 <__aeabi_ui2f>:
 80003e4:	f04f 0300 	mov.w	r3, #0
 80003e8:	e004      	b.n	80003f4 <__aeabi_i2f+0x8>
 80003ea:	bf00      	nop

080003ec <__aeabi_i2f>:
 80003ec:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80003f0:	bf48      	it	mi
 80003f2:	4240      	negmi	r0, r0
 80003f4:	ea5f 0c00 	movs.w	ip, r0
 80003f8:	bf08      	it	eq
 80003fa:	4770      	bxeq	lr
 80003fc:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000400:	4601      	mov	r1, r0
 8000402:	f04f 0000 	mov.w	r0, #0
 8000406:	e01c      	b.n	8000442 <__aeabi_l2f+0x2a>

08000408 <__aeabi_ul2f>:
 8000408:	ea50 0201 	orrs.w	r2, r0, r1
 800040c:	bf08      	it	eq
 800040e:	4770      	bxeq	lr
 8000410:	f04f 0300 	mov.w	r3, #0
 8000414:	e00a      	b.n	800042c <__aeabi_l2f+0x14>
 8000416:	bf00      	nop

08000418 <__aeabi_l2f>:
 8000418:	ea50 0201 	orrs.w	r2, r0, r1
 800041c:	bf08      	it	eq
 800041e:	4770      	bxeq	lr
 8000420:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000424:	d502      	bpl.n	800042c <__aeabi_l2f+0x14>
 8000426:	4240      	negs	r0, r0
 8000428:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800042c:	ea5f 0c01 	movs.w	ip, r1
 8000430:	bf02      	ittt	eq
 8000432:	4684      	moveq	ip, r0
 8000434:	4601      	moveq	r1, r0
 8000436:	2000      	moveq	r0, #0
 8000438:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 800043c:	bf08      	it	eq
 800043e:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000442:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000446:	fabc f28c 	clz	r2, ip
 800044a:	3a08      	subs	r2, #8
 800044c:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000450:	db10      	blt.n	8000474 <__aeabi_l2f+0x5c>
 8000452:	fa01 fc02 	lsl.w	ip, r1, r2
 8000456:	4463      	add	r3, ip
 8000458:	fa00 fc02 	lsl.w	ip, r0, r2
 800045c:	f1c2 0220 	rsb	r2, r2, #32
 8000460:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000464:	fa20 f202 	lsr.w	r2, r0, r2
 8000468:	eb43 0002 	adc.w	r0, r3, r2
 800046c:	bf08      	it	eq
 800046e:	f020 0001 	biceq.w	r0, r0, #1
 8000472:	4770      	bx	lr
 8000474:	f102 0220 	add.w	r2, r2, #32
 8000478:	fa01 fc02 	lsl.w	ip, r1, r2
 800047c:	f1c2 0220 	rsb	r2, r2, #32
 8000480:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000484:	fa21 f202 	lsr.w	r2, r1, r2
 8000488:	eb43 0002 	adc.w	r0, r3, r2
 800048c:	bf08      	it	eq
 800048e:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000492:	4770      	bx	lr

08000494 <__aeabi_fmul>:
 8000494:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000498:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 800049c:	bf1e      	ittt	ne
 800049e:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80004a2:	ea92 0f0c 	teqne	r2, ip
 80004a6:	ea93 0f0c 	teqne	r3, ip
 80004aa:	d06f      	beq.n	800058c <__aeabi_fmul+0xf8>
 80004ac:	441a      	add	r2, r3
 80004ae:	ea80 0c01 	eor.w	ip, r0, r1
 80004b2:	0240      	lsls	r0, r0, #9
 80004b4:	bf18      	it	ne
 80004b6:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80004ba:	d01e      	beq.n	80004fa <__aeabi_fmul+0x66>
 80004bc:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80004c0:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80004c4:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80004c8:	fba0 3101 	umull	r3, r1, r0, r1
 80004cc:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80004d0:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80004d4:	bf3e      	ittt	cc
 80004d6:	0049      	lslcc	r1, r1, #1
 80004d8:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80004dc:	005b      	lslcc	r3, r3, #1
 80004de:	ea40 0001 	orr.w	r0, r0, r1
 80004e2:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80004e6:	2afd      	cmp	r2, #253	; 0xfd
 80004e8:	d81d      	bhi.n	8000526 <__aeabi_fmul+0x92>
 80004ea:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80004ee:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80004f2:	bf08      	it	eq
 80004f4:	f020 0001 	biceq.w	r0, r0, #1
 80004f8:	4770      	bx	lr
 80004fa:	f090 0f00 	teq	r0, #0
 80004fe:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000502:	bf08      	it	eq
 8000504:	0249      	lsleq	r1, r1, #9
 8000506:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 800050a:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 800050e:	3a7f      	subs	r2, #127	; 0x7f
 8000510:	bfc2      	ittt	gt
 8000512:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000516:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 800051a:	4770      	bxgt	lr
 800051c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000520:	f04f 0300 	mov.w	r3, #0
 8000524:	3a01      	subs	r2, #1
 8000526:	dc5d      	bgt.n	80005e4 <__aeabi_fmul+0x150>
 8000528:	f112 0f19 	cmn.w	r2, #25
 800052c:	bfdc      	itt	le
 800052e:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000532:	4770      	bxle	lr
 8000534:	f1c2 0200 	rsb	r2, r2, #0
 8000538:	0041      	lsls	r1, r0, #1
 800053a:	fa21 f102 	lsr.w	r1, r1, r2
 800053e:	f1c2 0220 	rsb	r2, r2, #32
 8000542:	fa00 fc02 	lsl.w	ip, r0, r2
 8000546:	ea5f 0031 	movs.w	r0, r1, rrx
 800054a:	f140 0000 	adc.w	r0, r0, #0
 800054e:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000552:	bf08      	it	eq
 8000554:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000558:	4770      	bx	lr
 800055a:	f092 0f00 	teq	r2, #0
 800055e:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000562:	bf02      	ittt	eq
 8000564:	0040      	lsleq	r0, r0, #1
 8000566:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 800056a:	3a01      	subeq	r2, #1
 800056c:	d0f9      	beq.n	8000562 <__aeabi_fmul+0xce>
 800056e:	ea40 000c 	orr.w	r0, r0, ip
 8000572:	f093 0f00 	teq	r3, #0
 8000576:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 800057a:	bf02      	ittt	eq
 800057c:	0049      	lsleq	r1, r1, #1
 800057e:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000582:	3b01      	subeq	r3, #1
 8000584:	d0f9      	beq.n	800057a <__aeabi_fmul+0xe6>
 8000586:	ea41 010c 	orr.w	r1, r1, ip
 800058a:	e78f      	b.n	80004ac <__aeabi_fmul+0x18>
 800058c:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000590:	ea92 0f0c 	teq	r2, ip
 8000594:	bf18      	it	ne
 8000596:	ea93 0f0c 	teqne	r3, ip
 800059a:	d00a      	beq.n	80005b2 <__aeabi_fmul+0x11e>
 800059c:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80005a0:	bf18      	it	ne
 80005a2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80005a6:	d1d8      	bne.n	800055a <__aeabi_fmul+0xc6>
 80005a8:	ea80 0001 	eor.w	r0, r0, r1
 80005ac:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80005b0:	4770      	bx	lr
 80005b2:	f090 0f00 	teq	r0, #0
 80005b6:	bf17      	itett	ne
 80005b8:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80005bc:	4608      	moveq	r0, r1
 80005be:	f091 0f00 	teqne	r1, #0
 80005c2:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80005c6:	d014      	beq.n	80005f2 <__aeabi_fmul+0x15e>
 80005c8:	ea92 0f0c 	teq	r2, ip
 80005cc:	d101      	bne.n	80005d2 <__aeabi_fmul+0x13e>
 80005ce:	0242      	lsls	r2, r0, #9
 80005d0:	d10f      	bne.n	80005f2 <__aeabi_fmul+0x15e>
 80005d2:	ea93 0f0c 	teq	r3, ip
 80005d6:	d103      	bne.n	80005e0 <__aeabi_fmul+0x14c>
 80005d8:	024b      	lsls	r3, r1, #9
 80005da:	bf18      	it	ne
 80005dc:	4608      	movne	r0, r1
 80005de:	d108      	bne.n	80005f2 <__aeabi_fmul+0x15e>
 80005e0:	ea80 0001 	eor.w	r0, r0, r1
 80005e4:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80005e8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80005ec:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80005f0:	4770      	bx	lr
 80005f2:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80005f6:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80005fa:	4770      	bx	lr

080005fc <__aeabi_fdiv>:
 80005fc:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000600:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000604:	bf1e      	ittt	ne
 8000606:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 800060a:	ea92 0f0c 	teqne	r2, ip
 800060e:	ea93 0f0c 	teqne	r3, ip
 8000612:	d069      	beq.n	80006e8 <__aeabi_fdiv+0xec>
 8000614:	eba2 0203 	sub.w	r2, r2, r3
 8000618:	ea80 0c01 	eor.w	ip, r0, r1
 800061c:	0249      	lsls	r1, r1, #9
 800061e:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8000622:	d037      	beq.n	8000694 <__aeabi_fdiv+0x98>
 8000624:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000628:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 800062c:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000630:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000634:	428b      	cmp	r3, r1
 8000636:	bf38      	it	cc
 8000638:	005b      	lslcc	r3, r3, #1
 800063a:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 800063e:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8000642:	428b      	cmp	r3, r1
 8000644:	bf24      	itt	cs
 8000646:	1a5b      	subcs	r3, r3, r1
 8000648:	ea40 000c 	orrcs.w	r0, r0, ip
 800064c:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000650:	bf24      	itt	cs
 8000652:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8000656:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800065a:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 800065e:	bf24      	itt	cs
 8000660:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8000664:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000668:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 800066c:	bf24      	itt	cs
 800066e:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8000672:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000676:	011b      	lsls	r3, r3, #4
 8000678:	bf18      	it	ne
 800067a:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 800067e:	d1e0      	bne.n	8000642 <__aeabi_fdiv+0x46>
 8000680:	2afd      	cmp	r2, #253	; 0xfd
 8000682:	f63f af50 	bhi.w	8000526 <__aeabi_fmul+0x92>
 8000686:	428b      	cmp	r3, r1
 8000688:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800068c:	bf08      	it	eq
 800068e:	f020 0001 	biceq.w	r0, r0, #1
 8000692:	4770      	bx	lr
 8000694:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000698:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 800069c:	327f      	adds	r2, #127	; 0x7f
 800069e:	bfc2      	ittt	gt
 80006a0:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80006a4:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80006a8:	4770      	bxgt	lr
 80006aa:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80006ae:	f04f 0300 	mov.w	r3, #0
 80006b2:	3a01      	subs	r2, #1
 80006b4:	e737      	b.n	8000526 <__aeabi_fmul+0x92>
 80006b6:	f092 0f00 	teq	r2, #0
 80006ba:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80006be:	bf02      	ittt	eq
 80006c0:	0040      	lsleq	r0, r0, #1
 80006c2:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80006c6:	3a01      	subeq	r2, #1
 80006c8:	d0f9      	beq.n	80006be <__aeabi_fdiv+0xc2>
 80006ca:	ea40 000c 	orr.w	r0, r0, ip
 80006ce:	f093 0f00 	teq	r3, #0
 80006d2:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80006d6:	bf02      	ittt	eq
 80006d8:	0049      	lsleq	r1, r1, #1
 80006da:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80006de:	3b01      	subeq	r3, #1
 80006e0:	d0f9      	beq.n	80006d6 <__aeabi_fdiv+0xda>
 80006e2:	ea41 010c 	orr.w	r1, r1, ip
 80006e6:	e795      	b.n	8000614 <__aeabi_fdiv+0x18>
 80006e8:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80006ec:	ea92 0f0c 	teq	r2, ip
 80006f0:	d108      	bne.n	8000704 <__aeabi_fdiv+0x108>
 80006f2:	0242      	lsls	r2, r0, #9
 80006f4:	f47f af7d 	bne.w	80005f2 <__aeabi_fmul+0x15e>
 80006f8:	ea93 0f0c 	teq	r3, ip
 80006fc:	f47f af70 	bne.w	80005e0 <__aeabi_fmul+0x14c>
 8000700:	4608      	mov	r0, r1
 8000702:	e776      	b.n	80005f2 <__aeabi_fmul+0x15e>
 8000704:	ea93 0f0c 	teq	r3, ip
 8000708:	d104      	bne.n	8000714 <__aeabi_fdiv+0x118>
 800070a:	024b      	lsls	r3, r1, #9
 800070c:	f43f af4c 	beq.w	80005a8 <__aeabi_fmul+0x114>
 8000710:	4608      	mov	r0, r1
 8000712:	e76e      	b.n	80005f2 <__aeabi_fmul+0x15e>
 8000714:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000718:	bf18      	it	ne
 800071a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 800071e:	d1ca      	bne.n	80006b6 <__aeabi_fdiv+0xba>
 8000720:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8000724:	f47f af5c 	bne.w	80005e0 <__aeabi_fmul+0x14c>
 8000728:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 800072c:	f47f af3c 	bne.w	80005a8 <__aeabi_fmul+0x114>
 8000730:	e75f      	b.n	80005f2 <__aeabi_fmul+0x15e>
 8000732:	bf00      	nop

08000734 <__gesf2>:
 8000734:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8000738:	e006      	b.n	8000748 <__cmpsf2+0x4>
 800073a:	bf00      	nop

0800073c <__lesf2>:
 800073c:	f04f 0c01 	mov.w	ip, #1
 8000740:	e002      	b.n	8000748 <__cmpsf2+0x4>
 8000742:	bf00      	nop

08000744 <__cmpsf2>:
 8000744:	f04f 0c01 	mov.w	ip, #1
 8000748:	f84d cd04 	str.w	ip, [sp, #-4]!
 800074c:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000750:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000754:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000758:	bf18      	it	ne
 800075a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800075e:	d011      	beq.n	8000784 <__cmpsf2+0x40>
 8000760:	b001      	add	sp, #4
 8000762:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8000766:	bf18      	it	ne
 8000768:	ea90 0f01 	teqne	r0, r1
 800076c:	bf58      	it	pl
 800076e:	ebb2 0003 	subspl.w	r0, r2, r3
 8000772:	bf88      	it	hi
 8000774:	17c8      	asrhi	r0, r1, #31
 8000776:	bf38      	it	cc
 8000778:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 800077c:	bf18      	it	ne
 800077e:	f040 0001 	orrne.w	r0, r0, #1
 8000782:	4770      	bx	lr
 8000784:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000788:	d102      	bne.n	8000790 <__cmpsf2+0x4c>
 800078a:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 800078e:	d105      	bne.n	800079c <__cmpsf2+0x58>
 8000790:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8000794:	d1e4      	bne.n	8000760 <__cmpsf2+0x1c>
 8000796:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 800079a:	d0e1      	beq.n	8000760 <__cmpsf2+0x1c>
 800079c:	f85d 0b04 	ldr.w	r0, [sp], #4
 80007a0:	4770      	bx	lr
 80007a2:	bf00      	nop

080007a4 <__aeabi_cfrcmple>:
 80007a4:	4684      	mov	ip, r0
 80007a6:	4608      	mov	r0, r1
 80007a8:	4661      	mov	r1, ip
 80007aa:	e7ff      	b.n	80007ac <__aeabi_cfcmpeq>

080007ac <__aeabi_cfcmpeq>:
 80007ac:	b50f      	push	{r0, r1, r2, r3, lr}
 80007ae:	f7ff ffc9 	bl	8000744 <__cmpsf2>
 80007b2:	2800      	cmp	r0, #0
 80007b4:	bf48      	it	mi
 80007b6:	f110 0f00 	cmnmi.w	r0, #0
 80007ba:	bd0f      	pop	{r0, r1, r2, r3, pc}

080007bc <__aeabi_fcmpeq>:
 80007bc:	f84d ed08 	str.w	lr, [sp, #-8]!
 80007c0:	f7ff fff4 	bl	80007ac <__aeabi_cfcmpeq>
 80007c4:	bf0c      	ite	eq
 80007c6:	2001      	moveq	r0, #1
 80007c8:	2000      	movne	r0, #0
 80007ca:	f85d fb08 	ldr.w	pc, [sp], #8
 80007ce:	bf00      	nop

080007d0 <__aeabi_fcmplt>:
 80007d0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80007d4:	f7ff ffea 	bl	80007ac <__aeabi_cfcmpeq>
 80007d8:	bf34      	ite	cc
 80007da:	2001      	movcc	r0, #1
 80007dc:	2000      	movcs	r0, #0
 80007de:	f85d fb08 	ldr.w	pc, [sp], #8
 80007e2:	bf00      	nop

080007e4 <__aeabi_fcmple>:
 80007e4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80007e8:	f7ff ffe0 	bl	80007ac <__aeabi_cfcmpeq>
 80007ec:	bf94      	ite	ls
 80007ee:	2001      	movls	r0, #1
 80007f0:	2000      	movhi	r0, #0
 80007f2:	f85d fb08 	ldr.w	pc, [sp], #8
 80007f6:	bf00      	nop

080007f8 <__aeabi_fcmpge>:
 80007f8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80007fc:	f7ff ffd2 	bl	80007a4 <__aeabi_cfrcmple>
 8000800:	bf94      	ite	ls
 8000802:	2001      	movls	r0, #1
 8000804:	2000      	movhi	r0, #0
 8000806:	f85d fb08 	ldr.w	pc, [sp], #8
 800080a:	bf00      	nop

0800080c <__aeabi_fcmpgt>:
 800080c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000810:	f7ff ffc8 	bl	80007a4 <__aeabi_cfrcmple>
 8000814:	bf34      	ite	cc
 8000816:	2001      	movcc	r0, #1
 8000818:	2000      	movcs	r0, #0
 800081a:	f85d fb08 	ldr.w	pc, [sp], #8
 800081e:	bf00      	nop

08000820 <__aeabi_fcmpun>:
 8000820:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000824:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000828:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 800082c:	d102      	bne.n	8000834 <__aeabi_fcmpun+0x14>
 800082e:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 8000832:	d108      	bne.n	8000846 <__aeabi_fcmpun+0x26>
 8000834:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8000838:	d102      	bne.n	8000840 <__aeabi_fcmpun+0x20>
 800083a:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 800083e:	d102      	bne.n	8000846 <__aeabi_fcmpun+0x26>
 8000840:	f04f 0000 	mov.w	r0, #0
 8000844:	4770      	bx	lr
 8000846:	f04f 0001 	mov.w	r0, #1
 800084a:	4770      	bx	lr
 800084c:	0000      	movs	r0, r0
	...

08000850 <dmaServeInterrupt>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
 8000850:	b410      	push	{r4}
  uint32_t flags;
  uint32_t selfindex = (uint32_t)dmastp->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000852:	6802      	ldr	r2, [r0, #0]
 8000854:	7b43      	ldrb	r3, [r0, #13]
 8000856:	6811      	ldr	r1, [r2, #0]
  if (flags & dmastp->channel->CCR) {
 8000858:	6844      	ldr	r4, [r0, #4]
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 800085a:	40d9      	lsrs	r1, r3
  if (flags & dmastp->channel->CCR) {
 800085c:	6824      	ldr	r4, [r4, #0]
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 800085e:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000862:	420c      	tst	r4, r1
 8000864:	d00d      	beq.n	8000882 <dmaServeInterrupt+0x32>
  uint32_t selfindex = (uint32_t)dmastp->selfindex;
 8000866:	7b80      	ldrb	r0, [r0, #14]
    dmastp->dma->IFCR = flags << dmastp->shift;
    if (dma.streams[selfindex].func) {
 8000868:	4c07      	ldr	r4, [pc, #28]	; (8000888 <dmaServeInterrupt+0x38>)
    dmastp->dma->IFCR = flags << dmastp->shift;
 800086a:	fa01 f303 	lsl.w	r3, r1, r3
    if (dma.streams[selfindex].func) {
 800086e:	3001      	adds	r0, #1
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000870:	6053      	str	r3, [r2, #4]
    if (dma.streams[selfindex].func) {
 8000872:	f854 3030 	ldr.w	r3, [r4, r0, lsl #3]
 8000876:	b123      	cbz	r3, 8000882 <dmaServeInterrupt+0x32>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000878:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
 800087c:	6840      	ldr	r0, [r0, #4]
    }
  }
}
 800087e:	bc10      	pop	{r4}
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000880:	4718      	bx	r3
}
 8000882:	bc10      	pop	{r4}
 8000884:	4770      	bx	lr
 8000886:	bf00      	nop
 8000888:	20001b60 	.word	0x20001b60
 800088c:	00000000 	.word	0x00000000

08000890 <__idle_thread>:
__STATIC_FORCEINLINE void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8000890:	e7fe      	b.n	8000890 <__idle_thread>
 8000892:	bf00      	nop
	...

080008a0 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80008a0:	4b01      	ldr	r3, [pc, #4]	; (80008a8 <chTMStartMeasurementX+0x8>)
 80008a2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80008a4:	6083      	str	r3, [r0, #8]
}
 80008a6:	4770      	bx	lr
 80008a8:	e0001000 	.word	0xe0001000
 80008ac:	00000000 	.word	0x00000000

080008b0 <chTMStopMeasurementX>:
 80008b0:	4b0e      	ldr	r3, [pc, #56]	; (80008ec <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 80008b2:	4a0f      	ldr	r2, [pc, #60]	; (80008f0 <chTMStopMeasurementX+0x40>)
 80008b4:	685b      	ldr	r3, [r3, #4]
 80008b6:	6892      	ldr	r2, [r2, #8]
  tmp->last = (now - tmp->last) - offset;
 80008b8:	6881      	ldr	r1, [r0, #8]
 80008ba:	1a9b      	subs	r3, r3, r2
 80008bc:	1a5b      	subs	r3, r3, r1
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80008be:	b410      	push	{r4}
  tmp->n++;
 80008c0:	e9d0 4203 	ldrd	r4, r2, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
 80008c4:	18d2      	adds	r2, r2, r3
 80008c6:	6941      	ldr	r1, [r0, #20]
 80008c8:	6102      	str	r2, [r0, #16]
  if (tmp->last > tmp->worst) {
 80008ca:	6842      	ldr	r2, [r0, #4]
  tmp->cumulative += (rttime_t)tmp->last;
 80008cc:	f141 0100 	adc.w	r1, r1, #0
  if (tmp->last > tmp->worst) {
 80008d0:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 80008d2:	6802      	ldr	r2, [r0, #0]
  tmp->n++;
 80008d4:	f104 0401 	add.w	r4, r4, #1
    tmp->worst = tmp->last;
 80008d8:	bf88      	it	hi
 80008da:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 80008dc:	4293      	cmp	r3, r2
  tmp->last = (now - tmp->last) - offset;
 80008de:	e9c0 3402 	strd	r3, r4, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80008e2:	6141      	str	r1, [r0, #20]
}
 80008e4:	bc10      	pop	{r4}
    tmp->best = tmp->last;
 80008e6:	bf38      	it	cc
 80008e8:	6003      	strcc	r3, [r0, #0]
}
 80008ea:	4770      	bx	lr
 80008ec:	e0001000 	.word	0xe0001000
 80008f0:	20001b30 	.word	0x20001b30
	...

08000900 <__port_irq_epilogue>:
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000900:	2330      	movs	r3, #48	; 0x30
 8000902:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000906:	4b0d      	ldr	r3, [pc, #52]	; (800093c <__port_irq_epilogue+0x3c>)
 8000908:	685b      	ldr	r3, [r3, #4]
 800090a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800090e:	d102      	bne.n	8000916 <__port_irq_epilogue+0x16>
 8000910:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000914:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8000916:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
 800091a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    psp -= sizeof (struct port_extctx);
 800091e:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
 8000920:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8000922:	f383 8809 	msr	PSP, r3
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 8000926:	4a06      	ldr	r2, [pc, #24]	; (8000940 <__port_irq_epilogue+0x40>)
 8000928:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = tp->hdr.pqueue.prio;
 800092a:	68d2      	ldr	r2, [r2, #12]
    if (chSchIsPreemptionRequired()) {
 800092c:	6889      	ldr	r1, [r1, #8]
 800092e:	6892      	ldr	r2, [r2, #8]
 8000930:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8000932:	bf8c      	ite	hi
 8000934:	4a03      	ldrhi	r2, [pc, #12]	; (8000944 <__port_irq_epilogue+0x44>)
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8000936:	4a04      	ldrls	r2, [pc, #16]	; (8000948 <__port_irq_epilogue+0x48>)
 8000938:	619a      	str	r2, [r3, #24]
 800093a:	4770      	bx	lr
 800093c:	e000ed00 	.word	0xe000ed00
 8000940:	200010e0 	.word	0x200010e0
 8000944:	08000267 	.word	0x08000267
 8000948:	08000272 	.word	0x08000272
 800094c:	00000000 	.word	0x00000000

08000950 <dmaStreamAllocI.part.0.constprop.0>:
    uint32_t mask = (1U << i);
 8000950:	f04f 0c01 	mov.w	ip, #1
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
 8000954:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if ((dma.allocated_mask & mask) == 0U) {
 8000958:	4d24      	ldr	r5, [pc, #144]	; (80009ec <dmaStreamAllocI.part.0.constprop.0+0x9c>)
    uint32_t mask = (1U << i);
 800095a:	fa0c f200 	lsl.w	r2, ip, r0
    if ((dma.allocated_mask & mask) == 0U) {
 800095e:	682c      	ldr	r4, [r5, #0]
 8000960:	4222      	tst	r2, r4
  return NULL;
 8000962:	bf18      	it	ne
 8000964:	2000      	movne	r0, #0
    if ((dma.allocated_mask & mask) == 0U) {
 8000966:	d001      	beq.n	800096c <dmaStreamAllocI.part.0.constprop.0+0x1c>
}
 8000968:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800096c:	4603      	mov	r3, r0
        rccEnableDMA1(true);
 800096e:	4e20      	ldr	r6, [pc, #128]	; (80009f0 <dmaStreamAllocI.part.0.constprop.0+0xa0>)
      dma.allocated_mask  |= mask;
 8000970:	4314      	orrs	r4, r2
 8000972:	602c      	str	r4, [r5, #0]
        rccEnableDMA1(true);
 8000974:	6977      	ldr	r7, [r6, #20]
      dma.streams[i].func  = func;
 8000976:	4460      	add	r0, ip
 8000978:	f845 1030 	str.w	r1, [r5, r0, lsl #3]
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 800097c:	4c1d      	ldr	r4, [pc, #116]	; (80009f4 <dmaStreamAllocI.part.0.constprop.0+0xa4>)
      dma.streams[i].param = param;
 800097e:	491e      	ldr	r1, [pc, #120]	; (80009f8 <dmaStreamAllocI.part.0.constprop.0+0xa8>)
 8000980:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
        rccEnableDMA1(true);
 8000984:	ea47 070c 	orr.w	r7, r7, ip
      dma.streams[i].param = param;
 8000988:	6041      	str	r1, [r0, #4]
        rccEnableDMA1(true);
 800098a:	6177      	str	r7, [r6, #20]
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 800098c:	eb04 1003 	add.w	r0, r4, r3, lsl #4
        rccEnableDMA1(true);
 8000990:	6971      	ldr	r1, [r6, #20]
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8000992:	686e      	ldr	r6, [r5, #4]
 8000994:	6881      	ldr	r1, [r0, #8]
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8000996:	011b      	lsls	r3, r3, #4
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8000998:	420e      	tst	r6, r1
 800099a:	d00f      	beq.n	80009bc <dmaStreamAllocI.part.0.constprop.0+0x6c>
        dma.isr_mask |= mask;
 800099c:	4332      	orrs	r2, r6
 800099e:	606a      	str	r2, [r5, #4]
      dmaStreamDisable(dmastp);
 80009a0:	220e      	movs	r2, #14
 80009a2:	58e5      	ldr	r5, [r4, r3]
 80009a4:	18e1      	adds	r1, r4, r3
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80009a6:	2400      	movs	r4, #0
      dmaStreamDisable(dmastp);
 80009a8:	684b      	ldr	r3, [r1, #4]
 80009aa:	7b49      	ldrb	r1, [r1, #13]
 80009ac:	408a      	lsls	r2, r1
 80009ae:	6819      	ldr	r1, [r3, #0]
 80009b0:	f021 010f 	bic.w	r1, r1, #15
 80009b4:	6019      	str	r1, [r3, #0]
 80009b6:	606a      	str	r2, [r5, #4]
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80009b8:	601c      	str	r4, [r3, #0]
      return dmastp;
 80009ba:	e7d5      	b.n	8000968 <dmaStreamAllocI.part.0.constprop.0+0x18>
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80009bc:	f04f 0e50 	mov.w	lr, #80	; 0x50
          nvicEnableVector(dmastp->vector, priority);
 80009c0:	7bc1      	ldrb	r1, [r0, #15]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80009c2:	094f      	lsrs	r7, r1, #5
 80009c4:	00bf      	lsls	r7, r7, #2
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80009c6:	f101 4860 	add.w	r8, r1, #3758096384	; 0xe0000000
 80009ca:	f107 4760 	add.w	r7, r7, #3758096384	; 0xe0000000
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80009ce:	f001 011f 	and.w	r1, r1, #31
 80009d2:	f507 4761 	add.w	r7, r7, #57600	; 0xe100
 80009d6:	fa0c f101 	lsl.w	r1, ip, r1
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80009da:	f508 4861 	add.w	r8, r8, #57600	; 0xe100
 80009de:	f888 e300 	strb.w	lr, [r8, #768]	; 0x300
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80009e2:	f8c7 1180 	str.w	r1, [r7, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80009e6:	6039      	str	r1, [r7, #0]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 80009e8:	e7d8      	b.n	800099c <dmaStreamAllocI.part.0.constprop.0+0x4c>
 80009ea:	bf00      	nop
 80009ec:	20001b60 	.word	0x20001b60
 80009f0:	40021000 	.word	0x40021000
 80009f4:	08003900 	.word	0x08003900
 80009f8:	20000c40 	.word	0x20000c40
 80009fc:	00000000 	.word	0x00000000

08000a00 <trace_next.constprop.0>:
 *
 * @notapi
 */
NOINLINE static void trace_next(os_instance_t *oip) {

  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8000a00:	4b0c      	ldr	r3, [pc, #48]	; (8000a34 <trace_next.constprop.0+0x34>)
NOINLINE static void trace_next(os_instance_t *oip) {
 8000a02:	b430      	push	{r4, r5}
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000a04:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8000a08:	f8d3 10f4 	ldr.w	r1, [r3, #244]	; 0xf4
 8000a0c:	4c0a      	ldr	r4, [pc, #40]	; (8000a38 <trace_next.constprop.0+0x38>)
#if PORT_SUPPORTS_RT == TRUE
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8000a0e:	460a      	mov	r2, r1
 8000a10:	6a6d      	ldr	r5, [r5, #36]	; 0x24
 8000a12:	6808      	ldr	r0, [r1, #0]
 8000a14:	6864      	ldr	r4, [r4, #4]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(oip->trace_buffer.ptr);

  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 8000a16:	f603 0cf8 	addw	ip, r3, #2296	; 0x8f8
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8000a1a:	f364 201f 	bfi	r0, r4, #8, #24
 8000a1e:	808d      	strh	r5, [r1, #4]
 8000a20:	f842 0b10 	str.w	r0, [r2], #16
  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 8000a24:	4562      	cmp	r2, ip
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8000a26:	bf28      	it	cs
 8000a28:	f103 02f8 	addcs.w	r2, r3, #248	; 0xf8
 8000a2c:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
  }
}
 8000a30:	bc30      	pop	{r4, r5}
 8000a32:	4770      	bx	lr
 8000a34:	200010e0 	.word	0x200010e0
 8000a38:	e0001000 	.word	0xe0001000
 8000a3c:	00000000 	.word	0x00000000

08000a40 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8000a40:	4604      	mov	r4, r0
 8000a42:	b508      	push	{r3, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 8000a44:	b672      	cpsid	i
 * @notapi
 */
void __trace_halt(const char *reason) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8000a46:	4d09      	ldr	r5, [pc, #36]	; (8000a6c <chSysHalt+0x2c>)
 8000a48:	f8b5 30f0 	ldrh.w	r3, [r5, #240]	; 0xf0
 8000a4c:	071b      	lsls	r3, r3, #28
 8000a4e:	d505      	bpl.n	8000a5c <chSysHalt+0x1c>
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 8000a50:	2203      	movs	r2, #3
 8000a52:	4b07      	ldr	r3, [pc, #28]	; (8000a70 <chSysHalt+0x30>)
  currcore->dbg.panic_msg = reason;
 8000a54:	f8c5 40e4 	str.w	r4, [r5, #228]	; 0xe4
  ch_system.state = ch_sys_halted;
 8000a58:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
 8000a5a:	e7fe      	b.n	8000a5a <chSysHalt+0x1a>
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8000a5c:	2205      	movs	r2, #5
 8000a5e:	f8d5 30f4 	ldr.w	r3, [r5, #244]	; 0xf4
    oip->trace_buffer.ptr->state         = 0;
    oip->trace_buffer.ptr->u.halt.reason = reason;
 8000a62:	6098      	str	r0, [r3, #8]
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8000a64:	701a      	strb	r2, [r3, #0]
    trace_next(oip);
 8000a66:	f7ff ffcb 	bl	8000a00 <trace_next.constprop.0>
  }
}
 8000a6a:	e7f1      	b.n	8000a50 <chSysHalt+0x10>
 8000a6c:	200010e0 	.word	0x200010e0
 8000a70:	20001b30 	.word	0x20001b30
	...

08000a80 <i2c_lld_serve_tx_end_irq>:
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000a80:	070b      	lsls	r3, r1, #28
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8000a82:	b510      	push	{r4, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 8000a84:	6b44      	ldr	r4, [r0, #52]	; 0x34
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000a86:	d40f      	bmi.n	8000aa8 <i2c_lld_serve_tx_end_irq+0x28>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 8000a88:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8000a8a:	e9d2 0100 	ldrd	r0, r1, [r2]
 8000a8e:	680b      	ldr	r3, [r1, #0]
 8000a90:	f023 030f 	bic.w	r3, r3, #15
 8000a94:	600b      	str	r3, [r1, #0]
 8000a96:	230e      	movs	r3, #14
 8000a98:	7b52      	ldrb	r2, [r2, #13]
 8000a9a:	4093      	lsls	r3, r2
 8000a9c:	6043      	str	r3, [r0, #4]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8000a9e:	6863      	ldr	r3, [r4, #4]
 8000aa0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000aa4:	6063      	str	r3, [r4, #4]
}
 8000aa6:	bd10      	pop	{r4, pc}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8000aa8:	4801      	ldr	r0, [pc, #4]	; (8000ab0 <i2c_lld_serve_tx_end_irq+0x30>)
 8000aaa:	f7ff ffc9 	bl	8000a40 <chSysHalt>
 8000aae:	bf00      	nop
 8000ab0:	080035ac 	.word	0x080035ac
	...

08000ac0 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8000ac0:	b508      	push	{r3, lr}
  os_instance_t *oip = currcore;

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8000ac2:	4b06      	ldr	r3, [pc, #24]	; (8000adc <chDbgCheckClassI+0x1c>)
 8000ac4:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 8000ac8:	2a00      	cmp	r2, #0
 8000aca:	db04      	blt.n	8000ad6 <chDbgCheckClassI+0x16>
 8000acc:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8000ad0:	2b00      	cmp	r3, #0
 8000ad2:	dd00      	ble.n	8000ad6 <chDbgCheckClassI+0x16>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
  }
}
 8000ad4:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 8000ad6:	4802      	ldr	r0, [pc, #8]	; (8000ae0 <chDbgCheckClassI+0x20>)
 8000ad8:	f7ff ffb2 	bl	8000a40 <chSysHalt>
 8000adc:	200010e0 	.word	0x200010e0
 8000ae0:	080035b8 	.word	0x080035b8
	...

08000af0 <__sch_ready_ahead>:
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8000af0:	b510      	push	{r4, lr}
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8000af2:	7f03      	ldrb	r3, [r0, #28]
 8000af4:	b313      	cbz	r3, 8000b3c <__sch_ready_ahead+0x4c>
 8000af6:	2b0f      	cmp	r3, #15
 8000af8:	d020      	beq.n	8000b3c <__sch_ready_ahead+0x4c>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 8000afa:	4a12      	ldr	r2, [pc, #72]	; (8000b44 <__sch_ready_ahead+0x54>)
 8000afc:	4604      	mov	r4, r0
 8000afe:	f8b2 10f0 	ldrh.w	r1, [r2, #240]	; 0xf0
 8000b02:	07c9      	lsls	r1, r1, #31
 8000b04:	d50e      	bpl.n	8000b24 <__sch_ready_ahead+0x34>
  tp->state = CH_STATE_READY;
 8000b06:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8000b08:	6923      	ldr	r3, [r4, #16]
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio > p->prio));
 8000b0a:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 8000b0c:	7722      	strb	r2, [r4, #28]
    pqp = pqp->next;
 8000b0e:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio > p->prio));
 8000b10:	689a      	ldr	r2, [r3, #8]
 8000b12:	428a      	cmp	r2, r1
 8000b14:	d8fb      	bhi.n	8000b0e <__sch_ready_ahead+0x1e>

  /* Insertion on prev.*/
  p->next       = pqp;
  p->prev       = pqp->prev;
 8000b16:	685a      	ldr	r2, [r3, #4]
}
 8000b18:	4620      	mov	r0, r4
 8000b1a:	e9c4 3200 	strd	r3, r2, [r4]
  p->prev->next = p;
 8000b1e:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8000b20:	605c      	str	r4, [r3, #4]
 8000b22:	bd10      	pop	{r4, pc}
  __trace_ready(tp, tp->u.rdymsg);
 8000b24:	6b41      	ldr	r1, [r0, #52]	; 0x34
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8000b26:	f8d2 20f4 	ldr.w	r2, [r2, #244]	; 0xf4
 8000b2a:	00db      	lsls	r3, r3, #3
 8000b2c:	f043 0301 	orr.w	r3, r3, #1
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8000b30:	e9c2 0102 	strd	r0, r1, [r2, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8000b34:	7013      	strb	r3, [r2, #0]
    trace_next(oip);
 8000b36:	f7ff ff63 	bl	8000a00 <trace_next.constprop.0>
}
 8000b3a:	e7e4      	b.n	8000b06 <__sch_ready_ahead+0x16>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8000b3c:	4802      	ldr	r0, [pc, #8]	; (8000b48 <__sch_ready_ahead+0x58>)
 8000b3e:	f7ff ff7f 	bl	8000a40 <chSysHalt>
 8000b42:	bf00      	nop
 8000b44:	200010e0 	.word	0x200010e0
 8000b48:	0800367c 	.word	0x0800367c
 8000b4c:	00000000 	.word	0x00000000

08000b50 <chThdObjectInit>:
  tp->wabase = (void *)tdp->wbase;
  tp->waend  = (void *)tdp->wend;

  /* Thread-related fields.*/
  tp->hdr.pqueue.prio   = tdp->prio;
  tp->state             = CH_STATE_WTSTART;
 8000b50:	2202      	movs	r2, #2
                          const thread_descriptor_t *tdp) {
 8000b52:	b470      	push	{r4, r5, r6}
  }
  else {
    tp->owner           = currcore;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->dispose           = NULL;
 8000b54:	2400      	movs	r4, #0
  tp->wabase = (void *)tdp->wbase;
 8000b56:	684d      	ldr	r5, [r1, #4]
  tp->time              = (systime_t)0;
#endif

  /* Registry-related fields.*/
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 8000b58:	f04f 0c01 	mov.w	ip, #1
  tp->wabase = (void *)tdp->wbase;
 8000b5c:	6145      	str	r5, [r0, #20]
  tp->waend  = (void *)tdp->wend;
 8000b5e:	688d      	ldr	r5, [r1, #8]
    tp->owner           = currcore;
 8000b60:	4e0d      	ldr	r6, [pc, #52]	; (8000b98 <chThdObjectInit+0x48>)
  tp->waend  = (void *)tdp->wend;
 8000b62:	6185      	str	r5, [r0, #24]
  tp->hdr.pqueue.prio   = tdp->prio;
 8000b64:	68cd      	ldr	r5, [r1, #12]
  tp->state             = CH_STATE_WTSTART;
 8000b66:	8382      	strh	r2, [r0, #28]
  if (tdp->owner != NULL) {
 8000b68:	698a      	ldr	r2, [r1, #24]
  tp->refs              = (trefs_t)1;
 8000b6a:	f880 c01e 	strb.w	ip, [r0, #30]
    tp->owner           = currcore;
 8000b6e:	42a2      	cmp	r2, r4
 8000b70:	bf08      	it	eq
 8000b72:	4632      	moveq	r2, r6
  tp->name              = tdp->name;
 8000b74:	6809      	ldr	r1, [r1, #0]
 8000b76:	6102      	str	r2, [r0, #16]
 8000b78:	6201      	str	r1, [r0, #32]
  ch_list_init(&tp->waiting);
 8000b7a:	f100 0238 	add.w	r2, r0, #56	; 0x38
#endif

  /* Messages-related fields.*/
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8000b7e:	f100 013c 	add.w	r1, r0, #60	; 0x3c
  tp->object            = NULL;
 8000b82:	e9c0 440b 	strd	r4, r4, [r0, #44]	; 0x2c
  tp->epending          = (eventmask_t)0;
 8000b86:	e9c0 4411 	strd	r4, r4, [r0, #68]	; 0x44
  tp->hdr.pqueue.prio   = tdp->prio;
 8000b8a:	6085      	str	r5, [r0, #8]
  tp->realprio          = tdp->prio;
 8000b8c:	64c5      	str	r5, [r0, #76]	; 0x4c
  qp->prev = qp;
 8000b8e:	e9c0 110f 	strd	r1, r1, [r0, #60]	; 0x3c

  /* Custom thread initialization code.*/
  CH_CFG_THREAD_INIT_HOOK(tp);

  return tp;
}
 8000b92:	bc70      	pop	{r4, r5, r6}
  lp->next = lp;
 8000b94:	6382      	str	r2, [r0, #56]	; 0x38
 8000b96:	4770      	bx	lr
 8000b98:	200010e0 	.word	0x200010e0
 8000b9c:	00000000 	.word	0x00000000

08000ba0 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8000ba0:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000ba2:	2330      	movs	r3, #48	; 0x30
 8000ba4:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8000ba8:	4b19      	ldr	r3, [pc, #100]	; (8000c10 <chCoreAllocFromTop+0x70>)
 8000baa:	e9d3 453a 	ldrd	r4, r5, [r3, #232]	; 0xe8
 8000bae:	432c      	orrs	r4, r5
 8000bb0:	d120      	bne.n	8000bf4 <chCoreAllocFromTop+0x54>
  oip->dbg.lock_cnt = (cnt_t)1;
 8000bb2:	2401      	movs	r4, #1
 8000bb4:	f8c3 40ec 	str.w	r4, [r3, #236]	; 0xec
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8000bb8:	b1f9      	cbz	r1, 8000bfa <chCoreAllocFromTop+0x5a>
 8000bba:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
 8000bbe:	ea1c 0c01 	ands.w	ip, ip, r1
 8000bc2:	d11a      	bne.n	8000bfa <chCoreAllocFromTop+0x5a>
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000bc4:	4c13      	ldr	r4, [pc, #76]	; (8000c14 <chCoreAllocFromTop+0x74>)
 8000bc6:	4249      	negs	r1, r1
 8000bc8:	6865      	ldr	r5, [r4, #4]
 8000bca:	1a28      	subs	r0, r5, r0
 8000bcc:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000bce:	6821      	ldr	r1, [r4, #0]
  prev = p - offset;
 8000bd0:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000bd2:	428a      	cmp	r2, r1
 8000bd4:	d30c      	bcc.n	8000bf0 <chCoreAllocFromTop+0x50>
 8000bd6:	4295      	cmp	r5, r2
 8000bd8:	d30a      	bcc.n	8000bf0 <chCoreAllocFromTop+0x50>
  ch_memcore.topmem = prev;
 8000bda:	6062      	str	r2, [r4, #4]
  oip->dbg.lock_cnt = (cnt_t)0;
 8000bdc:	2100      	movs	r1, #0

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000bde:	681a      	ldr	r2, [r3, #0]
 8000be0:	f8c3 10ec 	str.w	r1, [r3, #236]	; 0xec
 8000be4:	429a      	cmp	r2, r3
 8000be6:	d10b      	bne.n	8000c00 <chCoreAllocFromTop+0x60>
 8000be8:	2300      	movs	r3, #0
 8000bea:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 8000bee:	bd38      	pop	{r3, r4, r5, pc}
    return NULL;
 8000bf0:	4660      	mov	r0, ip
 8000bf2:	e7f3      	b.n	8000bdc <chCoreAllocFromTop+0x3c>
    chSysHalt("SV#4");
 8000bf4:	4808      	ldr	r0, [pc, #32]	; (8000c18 <chCoreAllocFromTop+0x78>)
 8000bf6:	f7ff ff23 	bl	8000a40 <chSysHalt>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8000bfa:	4808      	ldr	r0, [pc, #32]	; (8000c1c <chCoreAllocFromTop+0x7c>)
 8000bfc:	f7ff ff20 	bl	8000a40 <chSysHalt>
 8000c00:	68d9      	ldr	r1, [r3, #12]
 8000c02:	6893      	ldr	r3, [r2, #8]
 8000c04:	688a      	ldr	r2, [r1, #8]
 8000c06:	429a      	cmp	r2, r3
 8000c08:	d2ee      	bcs.n	8000be8 <chCoreAllocFromTop+0x48>
 8000c0a:	4805      	ldr	r0, [pc, #20]	; (8000c20 <chCoreAllocFromTop+0x80>)
 8000c0c:	f7ff ff18 	bl	8000a40 <chSysHalt>
 8000c10:	200010e0 	.word	0x200010e0
 8000c14:	20001b28 	.word	0x20001b28
 8000c18:	080035c0 	.word	0x080035c0
 8000c1c:	08003738 	.word	0x08003738
 8000c20:	080036b8 	.word	0x080036b8
	...

08000c30 <chCoreAllocAlignedI>:
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8000c30:	4b10      	ldr	r3, [pc, #64]	; (8000c74 <chCoreAllocAlignedI+0x44>)
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8000c32:	b510      	push	{r4, lr}
 8000c34:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 8000c38:	2a00      	cmp	r2, #0
 8000c3a:	db15      	blt.n	8000c68 <chCoreAllocAlignedI+0x38>
 8000c3c:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8000c40:	2b00      	cmp	r3, #0
 8000c42:	dd11      	ble.n	8000c68 <chCoreAllocAlignedI+0x38>
 8000c44:	b199      	cbz	r1, 8000c6e <chCoreAllocAlignedI+0x3e>
 8000c46:	1e4b      	subs	r3, r1, #1
 8000c48:	400b      	ands	r3, r1
 8000c4a:	d110      	bne.n	8000c6e <chCoreAllocAlignedI+0x3e>
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000c4c:	4a0a      	ldr	r2, [pc, #40]	; (8000c78 <chCoreAllocAlignedI+0x48>)
 8000c4e:	4249      	negs	r1, r1
 8000c50:	6854      	ldr	r4, [r2, #4]
 8000c52:	1a20      	subs	r0, r4, r0
 8000c54:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000c56:	6811      	ldr	r1, [r2, #0]
 8000c58:	4288      	cmp	r0, r1
 8000c5a:	d303      	bcc.n	8000c64 <chCoreAllocAlignedI+0x34>
 8000c5c:	4284      	cmp	r4, r0
 8000c5e:	d301      	bcc.n	8000c64 <chCoreAllocAlignedI+0x34>
  ch_memcore.topmem = prev;
 8000c60:	6050      	str	r0, [r2, #4]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 8000c62:	bd10      	pop	{r4, pc}
    return NULL;
 8000c64:	4618      	mov	r0, r3
 8000c66:	bd10      	pop	{r4, pc}
    chSysHalt("SV#10");
 8000c68:	4804      	ldr	r0, [pc, #16]	; (8000c7c <chCoreAllocAlignedI+0x4c>)
 8000c6a:	f7ff fee9 	bl	8000a40 <chSysHalt>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8000c6e:	4804      	ldr	r0, [pc, #16]	; (8000c80 <chCoreAllocAlignedI+0x50>)
 8000c70:	f7ff fee6 	bl	8000a40 <chSysHalt>
 8000c74:	200010e0 	.word	0x200010e0
 8000c78:	20001b28 	.word	0x20001b28
 8000c7c:	080035b8 	.word	0x080035b8
 8000c80:	08003738 	.word	0x08003738
	...

08000c90 <vt_insert_first.constprop.0>:
                            sysinterval_t delay) {
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8000c90:	4b29      	ldr	r3, [pc, #164]	; (8000d38 <vt_insert_first.constprop.0+0xa8>)
static void vt_insert_first(virtual_timers_list_t *vtlp,
 8000c92:	b570      	push	{r4, r5, r6, lr}
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);

  /* Initial delta is what is configured statically.*/
  currdelta = vtlp->lastdelta;
 8000c94:	6a1e      	ldr	r6, [r3, #32]
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {

  dlp->delta      = delta;
  dlp->prev       = dlhp;
  dlp->next       = dlp->prev->next;
 8000c96:	691c      	ldr	r4, [r3, #16]
  dlp->prev       = dlhp;
 8000c98:	f103 0510 	add.w	r5, r3, #16

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8000c9c:	42b2      	cmp	r2, r6
  vtlp->lasttime = now;
 8000c9e:	8399      	strh	r1, [r3, #28]
 8000ca0:	e9c0 5201 	strd	r5, r2, [r0, #4]
  dlp->next       = dlp->prev->next;
 8000ca4:	6004      	str	r4, [r0, #0]
  dlp->next->prev = dlp;
 8000ca6:	6060      	str	r0, [r4, #4]
  dlhp->next      = dlp;
 8000ca8:	6118      	str	r0, [r3, #16]
  if (delay < currdelta) {
 8000caa:	d317      	bcc.n	8000cdc <vt_insert_first.constprop.0+0x4c>
 8000cac:	f5b2 4f7f 	cmp.w	r2, #65280	; 0xff00
 8000cb0:	bf28      	it	cs
 8000cb2:	f44f 427f 	movcs.w	r2, #65280	; 0xff00

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8000cb6:	1888      	adds	r0, r1, r2
 8000cb8:	b285      	uxth	r5, r0
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000cba:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000cbe:	68c4      	ldr	r4, [r0, #12]
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000cc0:	f014 0402 	ands.w	r4, r4, #2
 8000cc4:	d12a      	bne.n	8000d1c <vt_insert_first.constprop.0+0x8c>
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000cc6:	6345      	str	r5, [r0, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000cc8:	6104      	str	r4, [r0, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000cca:	2402      	movs	r4, #2
 8000ccc:	60c4      	str	r4, [r0, #12]
  return (systime_t)STM32_ST_TIM->CNT;
 8000cce:	6a44      	ldr	r4, [r0, #36]	; 0x24
 8000cd0:	b2a4      	uxth	r4, r4
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8000cd2:	1a65      	subs	r5, r4, r1
 8000cd4:	b2ad      	uxth	r5, r5
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8000cd6:	42aa      	cmp	r2, r5
 8000cd8:	d905      	bls.n	8000ce6 <vt_insert_first.constprop.0+0x56>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8000cda:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
 8000cdc:	f5b6 3f80 	cmp.w	r6, #65536	; 0x10000
 8000ce0:	d219      	bcs.n	8000d16 <vt_insert_first.constprop.0+0x86>
 8000ce2:	4632      	mov	r2, r6
 8000ce4:	e7e7      	b.n	8000cb6 <vt_insert_first.constprop.0+0x26>
    currdelta += (sysinterval_t)1;
 8000ce6:	1c75      	adds	r5, r6, #1
 8000ce8:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 8000cec:	d213      	bcs.n	8000d16 <vt_insert_first.constprop.0+0x86>
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000cee:	68c2      	ldr	r2, [r0, #12]
  return systime + (systime_t)interval;
 8000cf0:	4429      	add	r1, r5
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000cf2:	0792      	lsls	r2, r2, #30
 8000cf4:	b289      	uxth	r1, r1
 8000cf6:	d514      	bpl.n	8000d22 <vt_insert_first.constprop.0+0x92>
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000cf8:	6341      	str	r1, [r0, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8000cfa:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000cfc:	b292      	uxth	r2, r2
  return (sysinterval_t)((systime_t)(end - start));
 8000cfe:	1b11      	subs	r1, r2, r4
 8000d00:	b289      	uxth	r1, r1
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8000d02:	42a9      	cmp	r1, r5
 8000d04:	d210      	bcs.n	8000d28 <vt_insert_first.constprop.0+0x98>
  if (currdelta > vtlp->lastdelta) {
 8000d06:	42ae      	cmp	r6, r5
 8000d08:	d2e7      	bcs.n	8000cda <vt_insert_first.constprop.0+0x4a>
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8000d0a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    vtlp->lastdelta = currdelta;
 8000d0c:	621d      	str	r5, [r3, #32]
 8000d0e:	f042 0201 	orr.w	r2, r2, #1
 8000d12:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8000d14:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
 8000d16:	4809      	ldr	r0, [pc, #36]	; (8000d3c <vt_insert_first.constprop.0+0xac>)
 8000d18:	f7ff fe92 	bl	8000a40 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000d1c:	4808      	ldr	r0, [pc, #32]	; (8000d40 <vt_insert_first.constprop.0+0xb0>)
 8000d1e:	f7ff fe8f 	bl	8000a40 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000d22:	4808      	ldr	r0, [pc, #32]	; (8000d44 <vt_insert_first.constprop.0+0xb4>)
 8000d24:	f7ff fe8c 	bl	8000a40 <chSysHalt>
    currdelta += (sysinterval_t)1;
 8000d28:	3501      	adds	r5, #1
 8000d2a:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 8000d2e:	4621      	mov	r1, r4
 8000d30:	d0f1      	beq.n	8000d16 <vt_insert_first.constprop.0+0x86>
 8000d32:	4614      	mov	r4, r2
 8000d34:	e7db      	b.n	8000cee <vt_insert_first.constprop.0+0x5e>
 8000d36:	bf00      	nop
 8000d38:	200010e0 	.word	0x200010e0
 8000d3c:	080038b8 	.word	0x080038b8
 8000d40:	08003794 	.word	0x08003794
 8000d44:	080036e0 	.word	0x080036e0
	...

08000d50 <vt_set_alarm.constprop.0>:
static void vt_set_alarm(virtual_timers_list_t *vtlp,
 8000d50:	b570      	push	{r4, r5, r6, lr}
  currdelta = vtlp->lastdelta;
 8000d52:	4c1b      	ldr	r4, [pc, #108]	; (8000dc0 <vt_set_alarm.constprop.0+0x70>)
 8000d54:	6a23      	ldr	r3, [r4, #32]
  if (delay < currdelta) {
 8000d56:	428b      	cmp	r3, r1
 8000d58:	d819      	bhi.n	8000d8e <vt_set_alarm.constprop.0+0x3e>
 8000d5a:	f5b1 4f7f 	cmp.w	r1, #65280	; 0xff00
 8000d5e:	bf28      	it	cs
 8000d60:	f44f 417f 	movcs.w	r1, #65280	; 0xff00
  currdelta = vtlp->lastdelta;
 8000d64:	461d      	mov	r5, r3
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000d66:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
 8000d6a:	f8dc 600c 	ldr.w	r6, [ip, #12]
  return systime + (systime_t)interval;
 8000d6e:	1842      	adds	r2, r0, r1
 8000d70:	07b6      	lsls	r6, r6, #30
 8000d72:	b292      	uxth	r2, r2
 8000d74:	d519      	bpl.n	8000daa <vt_set_alarm.constprop.0+0x5a>
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000d76:	f8cc 2034 	str.w	r2, [ip, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8000d7a:	f8dc 2024 	ldr.w	r2, [ip, #36]	; 0x24
 8000d7e:	b292      	uxth	r2, r2
  return (sysinterval_t)((systime_t)(end - start));
 8000d80:	1a10      	subs	r0, r2, r0
 8000d82:	b280      	uxth	r0, r0
    if (likely(nowdelta < delay)) {
 8000d84:	4288      	cmp	r0, r1
 8000d86:	d213      	bcs.n	8000db0 <vt_set_alarm.constprop.0+0x60>
  if (currdelta > vtlp->lastdelta) {
 8000d88:	42ab      	cmp	r3, r5
 8000d8a:	d305      	bcc.n	8000d98 <vt_set_alarm.constprop.0+0x48>
}
 8000d8c:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
 8000d8e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8000d92:	d207      	bcs.n	8000da4 <vt_set_alarm.constprop.0+0x54>
 8000d94:	4619      	mov	r1, r3
 8000d96:	e7e5      	b.n	8000d64 <vt_set_alarm.constprop.0+0x14>
 8000d98:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    vtlp->lastdelta = currdelta;
 8000d9a:	6225      	str	r5, [r4, #32]
 8000d9c:	f043 0301 	orr.w	r3, r3, #1
 8000da0:	63e3      	str	r3, [r4, #60]	; 0x3c
}
 8000da2:	bd70      	pop	{r4, r5, r6, pc}
 8000da4:	4807      	ldr	r0, [pc, #28]	; (8000dc4 <vt_set_alarm.constprop.0+0x74>)
 8000da6:	f7ff fe4b 	bl	8000a40 <chSysHalt>
 8000daa:	4807      	ldr	r0, [pc, #28]	; (8000dc8 <vt_set_alarm.constprop.0+0x78>)
 8000dac:	f7ff fe48 	bl	8000a40 <chSysHalt>
    currdelta += (sysinterval_t)1;
 8000db0:	1c69      	adds	r1, r5, #1
 8000db2:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 8000db6:	d2f5      	bcs.n	8000da4 <vt_set_alarm.constprop.0+0x54>
    now = newnow;
 8000db8:	4610      	mov	r0, r2
 8000dba:	460d      	mov	r5, r1
 8000dbc:	e7d5      	b.n	8000d6a <vt_set_alarm.constprop.0+0x1a>
 8000dbe:	bf00      	nop
 8000dc0:	200010e0 	.word	0x200010e0
 8000dc4:	080038b8 	.word	0x080038b8
 8000dc8:	080036e0 	.word	0x080036e0
 8000dcc:	00000000 	.word	0x00000000

08000dd0 <__sch_ready_behind.isra.0>:
static thread_t *__sch_ready_behind(thread_t *tp) {
 8000dd0:	b510      	push	{r4, lr}
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8000dd2:	7f03      	ldrb	r3, [r0, #28]
 8000dd4:	b30b      	cbz	r3, 8000e1a <__sch_ready_behind.isra.0+0x4a>
 8000dd6:	2b0f      	cmp	r3, #15
 8000dd8:	d01f      	beq.n	8000e1a <__sch_ready_behind.isra.0+0x4a>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 8000dda:	4a11      	ldr	r2, [pc, #68]	; (8000e20 <__sch_ready_behind.isra.0+0x50>)
 8000ddc:	4604      	mov	r4, r0
 8000dde:	f8b2 10f0 	ldrh.w	r1, [r2, #240]	; 0xf0
 8000de2:	07c9      	lsls	r1, r1, #31
 8000de4:	d50d      	bpl.n	8000e02 <__sch_ready_behind.isra.0+0x32>
  tp->state = CH_STATE_READY;
 8000de6:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8000de8:	6923      	ldr	r3, [r4, #16]
  } while (unlikely(pqp->prio >= p->prio));
 8000dea:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 8000dec:	7722      	strb	r2, [r4, #28]
    pqp = pqp->next;
 8000dee:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8000df0:	689a      	ldr	r2, [r3, #8]
 8000df2:	428a      	cmp	r2, r1
 8000df4:	d2fb      	bcs.n	8000dee <__sch_ready_behind.isra.0+0x1e>
  p->prev       = pqp->prev;
 8000df6:	685a      	ldr	r2, [r3, #4]
 8000df8:	e9c4 3200 	strd	r3, r2, [r4]
  p->prev->next = p;
 8000dfc:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8000dfe:	605c      	str	r4, [r3, #4]
}
 8000e00:	bd10      	pop	{r4, pc}
  __trace_ready(tp, tp->u.rdymsg);
 8000e02:	6b41      	ldr	r1, [r0, #52]	; 0x34
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8000e04:	f8d2 20f4 	ldr.w	r2, [r2, #244]	; 0xf4
 8000e08:	00db      	lsls	r3, r3, #3
 8000e0a:	f043 0301 	orr.w	r3, r3, #1
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8000e0e:	e9c2 0102 	strd	r0, r1, [r2, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8000e12:	7013      	strb	r3, [r2, #0]
    trace_next(oip);
 8000e14:	f7ff fdf4 	bl	8000a00 <trace_next.constprop.0>
}
 8000e18:	e7e5      	b.n	8000de6 <__sch_ready_behind.isra.0+0x16>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8000e1a:	4802      	ldr	r0, [pc, #8]	; (8000e24 <__sch_ready_behind.isra.0+0x54>)
 8000e1c:	f7ff fe10 	bl	8000a40 <chSysHalt>
 8000e20:	200010e0 	.word	0x200010e0
 8000e24:	080037f4 	.word	0x080037f4
	...

08000e30 <i2c_lld_serve_rx_end_irq>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000e30:	070b      	lsls	r3, r1, #28
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8000e32:	b510      	push	{r4, lr}
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000e34:	d43f      	bmi.n	8000eb6 <i2c_lld_serve_rx_end_irq+0x86>
  dmaStreamDisable(i2cp->dmarx);
 8000e36:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  I2C_TypeDef *dp = i2cp->i2c;
 8000e38:	6b43      	ldr	r3, [r0, #52]	; 0x34
  dmaStreamDisable(i2cp->dmarx);
 8000e3a:	684c      	ldr	r4, [r1, #4]
 8000e3c:	6822      	ldr	r2, [r4, #0]
 8000e3e:	f022 020f 	bic.w	r2, r2, #15
 8000e42:	6022      	str	r2, [r4, #0]
 8000e44:	220e      	movs	r2, #14
 8000e46:	f891 c00d 	ldrb.w	ip, [r1, #13]
 8000e4a:	680c      	ldr	r4, [r1, #0]
 8000e4c:	fa02 f20c 	lsl.w	r2, r2, ip
 8000e50:	6062      	str	r2, [r4, #4]
    dp->CR2 &= ~I2C_CR2_LAST;
 8000e52:	685a      	ldr	r2, [r3, #4]
 8000e54:	2130      	movs	r1, #48	; 0x30
 8000e56:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8000e5a:	605a      	str	r2, [r3, #4]
    dp->CR1 &= ~I2C_CR1_ACK;
 8000e5c:	681a      	ldr	r2, [r3, #0]
 8000e5e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000e62:	601a      	str	r2, [r3, #0]
    dp->CR1 |= I2C_CR1_STOP;
 8000e64:	681a      	ldr	r2, [r3, #0]
 8000e66:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000e6a:	601a      	str	r2, [r3, #0]
 8000e6c:	f381 8811 	msr	BASEPRI, r1
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8000e70:	4c17      	ldr	r4, [pc, #92]	; (8000ed0 <i2c_lld_serve_rx_end_irq+0xa0>)
 8000e72:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8000e76:	2b00      	cmp	r3, #0
 8000e78:	dd23      	ble.n	8000ec2 <i2c_lld_serve_rx_end_irq+0x92>
 8000e7a:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8000e7e:	bb02      	cbnz	r2, 8000ec2 <i2c_lld_serve_rx_end_irq+0x92>
  oip->dbg.lock_cnt = (cnt_t)1;
 8000e80:	2101      	movs	r1, #1
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000e82:	69c3      	ldr	r3, [r0, #28]
 8000e84:	f8c4 10ec 	str.w	r1, [r4, #236]	; 0xec
 8000e88:	b17b      	cbz	r3, 8000eaa <i2c_lld_serve_rx_end_irq+0x7a>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8000e8a:	7f19      	ldrb	r1, [r3, #28]
 8000e8c:	2903      	cmp	r1, #3
 8000e8e:	d11b      	bne.n	8000ec8 <i2c_lld_serve_rx_end_irq+0x98>

    *trp = NULL;
 8000e90:	61c2      	str	r2, [r0, #28]
  return __sch_ready_behind(tp);
 8000e92:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 8000e94:	635a      	str	r2, [r3, #52]	; 0x34
 8000e96:	f7ff ff9b 	bl	8000dd0 <__sch_ready_behind.isra.0>
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8000e9a:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8000e9e:	2b00      	cmp	r3, #0
 8000ea0:	dd0c      	ble.n	8000ebc <i2c_lld_serve_rx_end_irq+0x8c>
 8000ea2:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8000ea6:	2b00      	cmp	r3, #0
 8000ea8:	dd08      	ble.n	8000ebc <i2c_lld_serve_rx_end_irq+0x8c>
  oip->dbg.lock_cnt = (cnt_t)0;
 8000eaa:	2300      	movs	r3, #0
 8000eac:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 8000eb0:	f383 8811 	msr	BASEPRI, r3
}
 8000eb4:	bd10      	pop	{r4, pc}
 8000eb6:	4807      	ldr	r0, [pc, #28]	; (8000ed4 <i2c_lld_serve_rx_end_irq+0xa4>)
 8000eb8:	f7ff fdc2 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#7");
 8000ebc:	4806      	ldr	r0, [pc, #24]	; (8000ed8 <i2c_lld_serve_rx_end_irq+0xa8>)
 8000ebe:	f7ff fdbf 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#6");
 8000ec2:	4806      	ldr	r0, [pc, #24]	; (8000edc <i2c_lld_serve_rx_end_irq+0xac>)
 8000ec4:	f7ff fdbc 	bl	8000a40 <chSysHalt>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8000ec8:	4805      	ldr	r0, [pc, #20]	; (8000ee0 <i2c_lld_serve_rx_end_irq+0xb0>)
 8000eca:	f7ff fdb9 	bl	8000a40 <chSysHalt>
 8000ece:	bf00      	nop
 8000ed0:	200010e0 	.word	0x200010e0
 8000ed4:	080035ac 	.word	0x080035ac
 8000ed8:	080035d0 	.word	0x080035d0
 8000edc:	080035c8 	.word	0x080035c8
 8000ee0:	08003834 	.word	0x08003834
	...

08000ef0 <__sch_wakeup>:
 8000ef0:	2330      	movs	r3, #48	; 0x30
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8000ef2:	b510      	push	{r4, lr}
 8000ef4:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8000ef8:	4c1e      	ldr	r4, [pc, #120]	; (8000f74 <__sch_wakeup+0x84>)
 8000efa:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8000efe:	2b00      	cmp	r3, #0
 8000f00:	dd35      	ble.n	8000f6e <__sch_wakeup+0x7e>
 8000f02:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8000f06:	2b00      	cmp	r3, #0
 8000f08:	d131      	bne.n	8000f6e <__sch_wakeup+0x7e>
  oip->dbg.lock_cnt = (cnt_t)1;
 8000f0a:	2301      	movs	r3, #1
 8000f0c:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
  switch (tp->state) {
 8000f10:	7f0b      	ldrb	r3, [r1, #28]
 8000f12:	2b0c      	cmp	r3, #12
 8000f14:	d810      	bhi.n	8000f38 <__sch_wakeup+0x48>
 8000f16:	e8df f003 	tbb	[pc, r3]
 8000f1a:	0f1d      	.short	0x0f1d
 8000f1c:	070b230f 	.word	0x070b230f
 8000f20:	0f0f0b0f 	.word	0x0f0f0b0f
 8000f24:	0f0f      	.short	0x0f0f
 8000f26:	0b          	.byte	0x0b
 8000f27:	00          	.byte	0x00
    chSemFastSignalI(tp->u.wtsemp);
 8000f28:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8000f2a:	6893      	ldr	r3, [r2, #8]
 8000f2c:	3301      	adds	r3, #1
 8000f2e:	6093      	str	r3, [r2, #8]
  p->prev->next = p->next;
 8000f30:	e9d1 3200 	ldrd	r3, r2, [r1]
 8000f34:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8000f36:	605a      	str	r2, [r3, #4]
  tp->u.rdymsg = MSG_TIMEOUT;
 8000f38:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  (void) __sch_ready_behind(tp);
 8000f3c:	4608      	mov	r0, r1
  tp->u.rdymsg = MSG_TIMEOUT;
 8000f3e:	634b      	str	r3, [r1, #52]	; 0x34
  (void) __sch_ready_behind(tp);
 8000f40:	f7ff ff46 	bl	8000dd0 <__sch_ready_behind.isra.0>
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8000f44:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8000f48:	2b00      	cmp	r3, #0
 8000f4a:	dd0d      	ble.n	8000f68 <__sch_wakeup+0x78>
 8000f4c:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8000f50:	2b00      	cmp	r3, #0
 8000f52:	dd09      	ble.n	8000f68 <__sch_wakeup+0x78>
  oip->dbg.lock_cnt = (cnt_t)0;
 8000f54:	2300      	movs	r3, #0
 8000f56:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 8000f5a:	f383 8811 	msr	BASEPRI, r3
}
 8000f5e:	bd10      	pop	{r4, pc}
    *tp->u.wttrp = NULL;
 8000f60:	2200      	movs	r2, #0
 8000f62:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8000f64:	601a      	str	r2, [r3, #0]
    break;
 8000f66:	e7e7      	b.n	8000f38 <__sch_wakeup+0x48>
    chSysHalt("SV#7");
 8000f68:	4803      	ldr	r0, [pc, #12]	; (8000f78 <__sch_wakeup+0x88>)
 8000f6a:	f7ff fd69 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#6");
 8000f6e:	4803      	ldr	r0, [pc, #12]	; (8000f7c <__sch_wakeup+0x8c>)
 8000f70:	f7ff fd66 	bl	8000a40 <chSysHalt>
 8000f74:	200010e0 	.word	0x200010e0
 8000f78:	080035d0 	.word	0x080035d0
 8000f7c:	080035c8 	.word	0x080035c8

08000f80 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8000f80:	b538      	push	{r3, r4, r5, lr}
 * @api
 */
void chDbgCheckClassS(void) {
  os_instance_t *oip = currcore;

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8000f82:	4b24      	ldr	r3, [pc, #144]	; (8001014 <chSchGoSleepS+0x94>)
 8000f84:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 8000f88:	2a00      	cmp	r2, #0
 8000f8a:	d13a      	bne.n	8001002 <chSchGoSleepS+0x82>
 8000f8c:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
 8000f90:	2a00      	cmp	r2, #0
 8000f92:	dd36      	ble.n	8001002 <chSchGoSleepS+0x82>
 * @return              Pointer to the idle thread.
 *
 * @xclass
 */
thread_t *chSysGetIdleThreadX(void) {
  thread_t *tp = threadref(currcore->rlist.pqueue.prev);
 8000f94:	685a      	ldr	r2, [r3, #4]

  chDbgAssert(tp->hdr.pqueue.prio == IDLEPRIO, "not idle thread");
 8000f96:	6891      	ldr	r1, [r2, #8]
 8000f98:	2901      	cmp	r1, #1
 8000f9a:	d138      	bne.n	800100e <chSchGoSleepS+0x8e>
  thread_t *otp = __instance_get_currthread(oip);
 8000f9c:	68dc      	ldr	r4, [r3, #12]
  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 8000f9e:	4294      	cmp	r4, r2
 8000fa0:	d032      	beq.n	8001008 <chSchGoSleepS+0x88>
  chDbgAssert(otp->owner == oip, "invalid core");
 8000fa2:	6922      	ldr	r2, [r4, #16]
 8000fa4:	429a      	cmp	r2, r3
 8000fa6:	d12f      	bne.n	8001008 <chSchGoSleepS+0x88>
  ch_priority_queue_t *p = pqp->next;
 8000fa8:	6815      	ldr	r5, [r2, #0]
  otp->state = newstate;
 8000faa:	7720      	strb	r0, [r4, #28]
  pqp->next       = p->next;
 8000fac:	682b      	ldr	r3, [r5, #0]
  pqp->next->prev = pqp;
 8000fae:	605a      	str	r2, [r3, #4]
  ntp->state = CH_STATE_CURRENT;
 8000fb0:	7729      	strb	r1, [r5, #28]
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8000fb2:	f8b2 10f0 	ldrh.w	r1, [r2, #240]	; 0xf0
  pqp->next       = p->next;
 8000fb6:	6013      	str	r3, [r2, #0]
 8000fb8:	078b      	lsls	r3, r1, #30
  __instance_set_currthread(oip, ntp);
 8000fba:	60d5      	str	r5, [r2, #12]
 8000fbc:	d50e      	bpl.n	8000fdc <chSchGoSleepS+0x5c>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8000fbe:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(ntp, otp);
 8000fc2:	6962      	ldr	r2, [r4, #20]
 8000fc4:	3b24      	subs	r3, #36	; 0x24
 8000fc6:	429a      	cmp	r2, r3
 8000fc8:	d805      	bhi.n	8000fd6 <chSchGoSleepS+0x56>
 8000fca:	4621      	mov	r1, r4
 8000fcc:	4628      	mov	r0, r5
}
 8000fce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(ntp, otp);
 8000fd2:	f7ff b935 	b.w	8000240 <__port_switch>
 8000fd6:	4810      	ldr	r0, [pc, #64]	; (8001018 <chSchGoSleepS+0x98>)
 8000fd8:	f7ff fd32 	bl	8000a40 <chSysHalt>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8000fdc:	7f23      	ldrb	r3, [r4, #28]
 8000fde:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8000fe0:	f8d2 20f4 	ldr.w	r2, [r2, #244]	; 0xf4
 8000fe4:	00db      	lsls	r3, r3, #3
 8000fe6:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8000fea:	e9c2 5102 	strd	r5, r1, [r2, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8000fee:	7013      	strb	r3, [r2, #0]
    trace_next(oip);
 8000ff0:	f7ff fd06 	bl	8000a00 <trace_next.constprop.0>
 8000ff4:	f3ef 8309 	mrs	r3, PSP
 8000ff8:	6962      	ldr	r2, [r4, #20]
 8000ffa:	3b24      	subs	r3, #36	; 0x24
 8000ffc:	429a      	cmp	r2, r3
 8000ffe:	d9e4      	bls.n	8000fca <chSchGoSleepS+0x4a>
 8001000:	e7e9      	b.n	8000fd6 <chSchGoSleepS+0x56>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 8001002:	4806      	ldr	r0, [pc, #24]	; (800101c <chSchGoSleepS+0x9c>)
 8001004:	f7ff fd1c 	bl	8000a40 <chSysHalt>
  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 8001008:	4805      	ldr	r0, [pc, #20]	; (8001020 <chSchGoSleepS+0xa0>)
 800100a:	f7ff fd19 	bl	8000a40 <chSysHalt>
 800100e:	4805      	ldr	r0, [pc, #20]	; (8001024 <chSchGoSleepS+0xa4>)
 8001010:	f7ff fd16 	bl	8000a40 <chSysHalt>
 8001014:	200010e0 	.word	0x200010e0
 8001018:	080035e0 	.word	0x080035e0
 800101c:	080035d8 	.word	0x080035d8
 8001020:	080037bc 	.word	0x080037bc
 8001024:	08003668 	.word	0x08003668
	...

08001030 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8001030:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8001034:	4d44      	ldr	r5, [pc, #272]	; (8001148 <chSchGoSleepTimeoutS+0x118>)
 8001036:	b087      	sub	sp, #28
 8001038:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 800103c:	2b00      	cmp	r3, #0
 800103e:	d157      	bne.n	80010f0 <chSchGoSleepTimeoutS+0xc0>
 8001040:	4607      	mov	r7, r0
 8001042:	f8d5 00ec 	ldr.w	r0, [r5, #236]	; 0xec
 8001046:	2800      	cmp	r0, #0
 8001048:	dd52      	ble.n	80010f0 <chSchGoSleepTimeoutS+0xc0>
  return (bool)(dlhp == dlhp->next);
 800104a:	46a8      	mov	r8, r5
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  /* Timer initialization.*/
  vtp->par     = par;
  vtp->func    = vtfunc;
  vtp->reload  = (sysinterval_t)0;
 800104c:	9305      	str	r3, [sp, #20]
 800104e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  vtp->func    = vtfunc;
 8001052:	483e      	ldr	r0, [pc, #248]	; (800114c <chSchGoSleepTimeoutS+0x11c>)
  thread_t *tp = __instance_get_currthread(currcore);
 8001054:	f8d5 900c 	ldr.w	r9, [r5, #12]
 8001058:	9003      	str	r0, [sp, #12]
 800105a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800105c:	f858 3f10 	ldr.w	r3, [r8, #16]!
 8001060:	460a      	mov	r2, r1
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8001062:	4543      	cmp	r3, r8
  vtp->par     = par;
 8001064:	f8cd 9010 	str.w	r9, [sp, #16]
 8001068:	b280      	uxth	r0, r0
    if (ch_dlist_isempty(&vtlp->dlist)) {
 800106a:	d04b      	beq.n	8001104 <chSchGoSleepTimeoutS+0xd4>
  return (sysinterval_t)((systime_t)(end - start));
 800106c:	8bac      	ldrh	r4, [r5, #28]
    if (delta < vtlp->dlist.next->delta) {
 800106e:	689a      	ldr	r2, [r3, #8]
 8001070:	1b04      	subs	r4, r0, r4
 8001072:	b2a4      	uxth	r4, r4
 8001074:	190e      	adds	r6, r1, r4
 8001076:	42b2      	cmp	r2, r6
    delta    = nowdelta + delay;
 8001078:	4634      	mov	r4, r6
    if (delta < vtlp->dlist.next->delta) {
 800107a:	d83c      	bhi.n	80010f6 <chSchGoSleepTimeoutS+0xc6>
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
 800107c:	689a      	ldr	r2, [r3, #8]
 800107e:	42b2      	cmp	r2, r6
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");
 8001080:	466e      	mov	r6, sp
  while (likely(dlp->delta < delta)) {
 8001082:	d305      	bcc.n	8001090 <chSchGoSleepTimeoutS+0x60>
 8001084:	e009      	b.n	800109a <chSchGoSleepTimeoutS+0x6a>

    delta -= dlp->delta;
    dlp = dlp->next;
 8001086:	681b      	ldr	r3, [r3, #0]
    delta -= dlp->delta;
 8001088:	1aa4      	subs	r4, r4, r2
  while (likely(dlp->delta < delta)) {
 800108a:	689a      	ldr	r2, [r3, #8]
 800108c:	4294      	cmp	r4, r2
 800108e:	d904      	bls.n	800109a <chSchGoSleepTimeoutS+0x6a>
    chDbgAssert(dlp != dlep, "element already in list");
 8001090:	42b3      	cmp	r3, r6
 8001092:	d1f8      	bne.n	8001086 <chSchGoSleepTimeoutS+0x56>
 8001094:	482e      	ldr	r0, [pc, #184]	; (8001150 <chSchGoSleepTimeoutS+0x120>)
 8001096:	f7ff fcd3 	bl	8000a40 <chSysHalt>
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 800109a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  dlp->delta      = delta;
 800109e:	9402      	str	r4, [sp, #8]
  dlp->delta -= delta;
 80010a0:	689a      	ldr	r2, [r3, #8]
  dlp->prev       = dlp->next->prev;
 80010a2:	6859      	ldr	r1, [r3, #4]
  dlp->delta -= delta;
 80010a4:	1b12      	subs	r2, r2, r4
  dlp->prev       = dlp->next->prev;
 80010a6:	9101      	str	r1, [sp, #4]
  dlp->next       = dlhp;
 80010a8:	9300      	str	r3, [sp, #0]
  dlp->prev->next = dlp;
 80010aa:	600e      	str	r6, [r1, #0]
  dlhp->prev      = dlp;
 80010ac:	e9c3 6201 	strd	r6, r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 80010b0:	61a8      	str	r0, [r5, #24]
    chSchGoSleepS(newstate);
 80010b2:	4638      	mov	r0, r7
 80010b4:	f7ff ff64 	bl	8000f80 <chSchGoSleepS>
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 80010b8:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 80010bc:	2b00      	cmp	r3, #0
 80010be:	db1e      	blt.n	80010fe <chSchGoSleepTimeoutS+0xce>
 80010c0:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
 80010c4:	2b00      	cmp	r3, #0
 80010c6:	dd1a      	ble.n	80010fe <chSchGoSleepTimeoutS+0xce>
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {

  chDbgCheckClassI();

  return (bool)(vtp->dlist.next != NULL);
 80010c8:	9b00      	ldr	r3, [sp, #0]
    if (chVTIsArmedI(&vt)) {
 80010ca:	b163      	cbz	r3, 80010e6 <chSchGoSleepTimeoutS+0xb6>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 80010cc:	692a      	ldr	r2, [r5, #16]
 80010ce:	42b2      	cmp	r2, r6
 80010d0:	d01e      	beq.n	8001110 <chSchGoSleepTimeoutS+0xe0>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
 80010d2:	e9dd 1001 	ldrd	r1, r0, [sp, #4]

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 80010d6:	689a      	ldr	r2, [r3, #8]
 80010d8:	600b      	str	r3, [r1, #0]
 80010da:	4402      	add	r2, r0
 80010dc:	e9c3 1201 	strd	r1, r2, [r3, #4]
    vtp->dlist.next = NULL;

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 80010e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80010e4:	61ab      	str	r3, [r5, #24]
}
 80010e6:	f8d9 0034 	ldr.w	r0, [r9, #52]	; 0x34
 80010ea:	b007      	add	sp, #28
 80010ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    chSysHalt("SV#11");
 80010f0:	4818      	ldr	r0, [pc, #96]	; (8001154 <chSchGoSleepTimeoutS+0x124>)
 80010f2:	f7ff fca5 	bl	8000a40 <chSysHalt>
      vt_set_alarm(vtlp, now, delay);
 80010f6:	f7ff fe2b 	bl	8000d50 <vt_set_alarm.constprop.0>
  dlp = dlhp->next;
 80010fa:	692b      	ldr	r3, [r5, #16]
 80010fc:	e7be      	b.n	800107c <chSchGoSleepTimeoutS+0x4c>
    chSysHalt("SV#10");
 80010fe:	4816      	ldr	r0, [pc, #88]	; (8001158 <chSchGoSleepTimeoutS+0x128>)
 8001100:	f7ff fc9e 	bl	8000a40 <chSysHalt>
      vt_insert_first(vtlp, vtp, now, delay);
 8001104:	466e      	mov	r6, sp
 8001106:	4601      	mov	r1, r0
 8001108:	4630      	mov	r0, r6
 800110a:	f7ff fdc1 	bl	8000c90 <vt_insert_first.constprop.0>
      return;
 800110e:	e7d0      	b.n	80010b2 <chSchGoSleepTimeoutS+0x82>
    return;
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
  vtp->dlist.next = NULL;
 8001110:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8001112:	4543      	cmp	r3, r8
  dlhp->next       = dlp->next;
 8001114:	612b      	str	r3, [r5, #16]
  vtp->dlist.next = NULL;
 8001116:	9200      	str	r2, [sp, #0]
  dlhp->next->prev = dlhp;
 8001118:	f8c3 8004 	str.w	r8, [r3, #4]
  if (ch_dlist_isempty(&vtlp->dlist)) {
 800111c:	d010      	beq.n	8001140 <chSchGoSleepTimeoutS+0x110>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 800111e:	6899      	ldr	r1, [r3, #8]
 8001120:	9802      	ldr	r0, [sp, #8]
 8001122:	8baa      	ldrh	r2, [r5, #28]
 8001124:	4401      	add	r1, r0
 8001126:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800112a:	6099      	str	r1, [r3, #8]
 800112c:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800112e:	b280      	uxth	r0, r0
 8001130:	1a83      	subs	r3, r0, r2
 8001132:	b29b      	uxth	r3, r3
  now = chVTGetSystemTimeX();
  nowdelta = chTimeDiffX(vtlp->lasttime, now);

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8001134:	4299      	cmp	r1, r3
 8001136:	d9d6      	bls.n	80010e6 <chSchGoSleepTimeoutS+0xb6>

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;

  /* Setting up the alarm.*/
  vt_set_alarm(vtlp, now, delta);
 8001138:	1ac9      	subs	r1, r1, r3
 800113a:	f7ff fe09 	bl	8000d50 <vt_set_alarm.constprop.0>
 800113e:	e7d2      	b.n	80010e6 <chSchGoSleepTimeoutS+0xb6>
  STM32_ST_TIM->DIER = 0U;
 8001140:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001144:	60da      	str	r2, [r3, #12]
}
 8001146:	e7ce      	b.n	80010e6 <chSchGoSleepTimeoutS+0xb6>
 8001148:	200010e0 	.word	0x200010e0
 800114c:	08000ef1 	.word	0x08000ef1
 8001150:	0800386c 	.word	0x0800386c
 8001154:	080035d8 	.word	0x080035d8
 8001158:	080035b8 	.word	0x080035b8
 800115c:	00000000 	.word	0x00000000

08001160 <i2cMasterTransmitTimeout.constprop.0>:
 *                      be retrieved using @p i2cGetErrors().
 * @retval MSG_TIMEOUT  if a timeout occurred before operation end.
 *
 * @api
 */
msg_t i2cMasterTransmitTimeout(I2CDriver *i2cp,
 8001160:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               sysinterval_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) &&
 8001164:	2a00      	cmp	r2, #0
 8001166:	d165      	bne.n	8001234 <i2cMasterTransmitTimeout.constprop.0+0xd4>
               (txbytes > 0U) && (txbuf != NULL) &&
               ((rxbytes == 0U) || ((rxbytes > 0U) && (rxbuf != NULL))) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 8001168:	4d73      	ldr	r5, [pc, #460]	; (8001338 <i2cMasterTransmitTimeout.constprop.0+0x1d8>)
 800116a:	782f      	ldrb	r7, [r5, #0]
 800116c:	2f02      	cmp	r7, #2
 800116e:	d163      	bne.n	8001238 <i2cMasterTransmitTimeout.constprop.0+0xd8>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001170:	2330      	movs	r3, #48	; 0x30
 8001172:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8001176:	4c71      	ldr	r4, [pc, #452]	; (800133c <i2cMasterTransmitTimeout.constprop.0+0x1dc>)
 8001178:	e9d4 363a 	ldrd	r3, r6, [r4, #232]	; 0xe8
 800117c:	4333      	orrs	r3, r6
 800117e:	d156      	bne.n	800122e <i2cMasterTransmitTimeout.constprop.0+0xce>

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8001180:	60ab      	str	r3, [r5, #8]
  oip->dbg.lock_cnt = (cnt_t)1;
 8001182:	2301      	movs	r3, #1
 8001184:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
  i2cp->state = I2C_ACTIVE_TX;
 8001188:	2303      	movs	r3, #3
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      sysinterval_t timeout) {
  I2C_TypeDef *dp = i2cp->i2c;
 800118a:	6b6e      	ldr	r6, [r5, #52]	; 0x34
 800118c:	702b      	strb	r3, [r5, #0]
  systime_t start, end;
  msg_t msg;

#if defined(STM32F1XX_I2C)
  osalDbgCheck((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL)));
 800118e:	2a00      	cmp	r2, #0
 8001190:	d15e      	bne.n	8001250 <i2cMasterTransmitTimeout.constprop.0+0xf0>

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8001192:	233a      	movs	r3, #58	; 0x3a
 8001194:	842b      	strh	r3, [r5, #32]
  oip->dbg.lock_cnt = (cnt_t)0;
 8001196:	2300      	movs	r3, #0
 8001198:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 800119c:	6823      	ldr	r3, [r4, #0]
 800119e:	42a3      	cmp	r3, r4
 80011a0:	f040 808c 	bne.w	80012bc <i2cMasterTransmitTimeout.constprop.0+0x15c>
 80011a4:	2300      	movs	r3, #0
 80011a6:	f383 8811 	msr	BASEPRI, r3
  return (systime_t)STM32_ST_TIM->CNT;
 80011aa:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 80011ae:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 80011b0:	f8df 918c 	ldr.w	r9, [pc, #396]	; 8001340 <i2cMasterTransmitTimeout.constprop.0+0x1e0>
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 80011b4:	f8d3 8004 	ldr.w	r8, [r3, #4]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80011b8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80011ba:	f8d3 e004 	ldr.w	lr, [r3, #4]
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 80011be:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80011c0:	f8c8 3000 	str.w	r3, [r8]
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80011c4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 80011c6:	f8c8 900c 	str.w	r9, [r8, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 80011ca:	f8c8 0004 	str.w	r0, [r8, #4]
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80011ce:	f8ce 3000 	str.w	r3, [lr]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 80011d2:	f8ce 100c 	str.w	r1, [lr, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 80011d6:	f8ce 2004 	str.w	r2, [lr, #4]
 80011da:	f8dc 2024 	ldr.w	r2, [ip, #36]	; 0x24
 80011de:	2030      	movs	r0, #48	; 0x30
 80011e0:	b292      	uxth	r2, r2
 80011e2:	f380 8811 	msr	BASEPRI, r0
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80011e6:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
 80011ea:	bb01      	cbnz	r1, 800122e <i2cMasterTransmitTimeout.constprop.0+0xce>
  oip->dbg.lock_cnt = (cnt_t)1;
 80011ec:	f04f 0e01 	mov.w	lr, #1
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80011f0:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 80011f4:	b9db      	cbnz	r3, 800122e <i2cMasterTransmitTimeout.constprop.0+0xce>
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 80011f6:	69b3      	ldr	r3, [r6, #24]
  oip->dbg.lock_cnt = (cnt_t)1;
 80011f8:	f8c4 e0ec 	str.w	lr, [r4, #236]	; 0xec
 80011fc:	079b      	lsls	r3, r3, #30
 80011fe:	d402      	bmi.n	8001206 <i2cMasterTransmitTimeout.constprop.0+0xa6>
 8001200:	6833      	ldr	r3, [r6, #0]
 8001202:	059b      	lsls	r3, r3, #22
 8001204:	d562      	bpl.n	80012cc <i2cMasterTransmitTimeout.constprop.0+0x16c>
 8001206:	f8dc 3024 	ldr.w	r3, [ip, #36]	; 0x24
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 800120a:	1a9b      	subs	r3, r3, r2
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end)) {
 800120c:	b29b      	uxth	r3, r3
 800120e:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8001212:	d224      	bcs.n	800125e <i2cMasterTransmitTimeout.constprop.0+0xfe>
 8001214:	6823      	ldr	r3, [r4, #0]
  oip->dbg.lock_cnt = (cnt_t)0;
 8001216:	f8c4 10ec 	str.w	r1, [r4, #236]	; 0xec
 800121a:	42a3      	cmp	r3, r4
 800121c:	d10f      	bne.n	800123e <i2cMasterTransmitTimeout.constprop.0+0xde>
 800121e:	f381 8811 	msr	BASEPRI, r1
 8001222:	f380 8811 	msr	BASEPRI, r0
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8001226:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 800122a:	2b00      	cmp	r3, #0
 800122c:	d0e0      	beq.n	80011f0 <i2cMasterTransmitTimeout.constprop.0+0x90>
    chSysHalt("SV#4");
 800122e:	4845      	ldr	r0, [pc, #276]	; (8001344 <i2cMasterTransmitTimeout.constprop.0+0x1e4>)
 8001230:	f7ff fc06 	bl	8000a40 <chSysHalt>
  osalDbgCheck((i2cp != NULL) &&
 8001234:	2900      	cmp	r1, #0
 8001236:	d197      	bne.n	8001168 <i2cMasterTransmitTimeout.constprop.0+0x8>
 8001238:	4843      	ldr	r0, [pc, #268]	; (8001348 <i2cMasterTransmitTimeout.constprop.0+0x1e8>)
 800123a:	f7ff fc01 	bl	8000a40 <chSysHalt>
 800123e:	f8d3 8008 	ldr.w	r8, [r3, #8]
 8001242:	68e3      	ldr	r3, [r4, #12]
 8001244:	689b      	ldr	r3, [r3, #8]
 8001246:	4543      	cmp	r3, r8
 8001248:	d2e9      	bcs.n	800121e <i2cMasterTransmitTimeout.constprop.0+0xbe>
 800124a:	4840      	ldr	r0, [pc, #256]	; (800134c <i2cMasterTransmitTimeout.constprop.0+0x1ec>)
 800124c:	f7ff fbf8 	bl	8000a40 <chSysHalt>
  osalDbgCheck((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL)));
 8001250:	2a01      	cmp	r2, #1
 8001252:	d001      	beq.n	8001258 <i2cMasterTransmitTimeout.constprop.0+0xf8>
 8001254:	2900      	cmp	r1, #0
 8001256:	d19c      	bne.n	8001192 <i2cMasterTransmitTimeout.constprop.0+0x32>
 8001258:	483d      	ldr	r0, [pc, #244]	; (8001350 <i2cMasterTransmitTimeout.constprop.0+0x1f0>)
 800125a:	f7ff fbf1 	bl	8000a40 <chSysHalt>
      dmaStreamDisable(i2cp->dmatx);
 800125e:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 8001260:	2705      	movs	r7, #5
 8001262:	6851      	ldr	r1, [r2, #4]
      dmaStreamDisable(i2cp->dmarx);
 8001264:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
      dmaStreamDisable(i2cp->dmatx);
 8001268:	680b      	ldr	r3, [r1, #0]
 800126a:	f8d2 e000 	ldr.w	lr, [r2]
 800126e:	f023 030f 	bic.w	r3, r3, #15
 8001272:	600b      	str	r3, [r1, #0]
 8001274:	230e      	movs	r3, #14
 8001276:	7b51      	ldrb	r1, [r2, #13]
      dmaStreamDisable(i2cp->dmarx);
 8001278:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800127a:	e9d2 c600 	ldrd	ip, r6, [r2]
  dp->CR1 |= I2C_CR1_START;

  /* Waits for the operation completion or a timeout.*/
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
  if (msg != MSG_OK) {
    dmaStreamDisable(i2cp->dmatx);
 800127e:	fa03 f101 	lsl.w	r1, r3, r1
 8001282:	f8ce 1004 	str.w	r1, [lr, #4]
    dmaStreamDisable(i2cp->dmarx);
 8001286:	6831      	ldr	r1, [r6, #0]
 8001288:	f021 010f 	bic.w	r1, r1, #15
 800128c:	6031      	str	r1, [r6, #0]
 800128e:	7b52      	ldrb	r2, [r2, #13]
 8001290:	4093      	lsls	r3, r2
 8001292:	f8cc 3004 	str.w	r3, [ip, #4]
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8001296:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 800129a:	702f      	strb	r7, [r5, #0]
 800129c:	2b00      	cmp	r3, #0
 800129e:	d13d      	bne.n	800131c <i2cMasterTransmitTimeout.constprop.0+0x1bc>
 80012a0:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 80012a4:	2a00      	cmp	r2, #0
 80012a6:	dd39      	ble.n	800131c <i2cMasterTransmitTimeout.constprop.0+0x1bc>
 80012a8:	6822      	ldr	r2, [r4, #0]
  oip->dbg.lock_cnt = (cnt_t)0;
 80012aa:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 80012ae:	42a2      	cmp	r2, r4
 80012b0:	d137      	bne.n	8001322 <i2cMasterTransmitTimeout.constprop.0+0x1c2>
 80012b2:	2300      	movs	r3, #0
 80012b4:	f383 8811 	msr	BASEPRI, r3
  else {
    i2cp->state = I2C_READY;
  }
  osalSysUnlock();
  return rdymsg;
}
 80012b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80012bc:	f8d3 c008 	ldr.w	ip, [r3, #8]
 80012c0:	68e3      	ldr	r3, [r4, #12]
 80012c2:	689b      	ldr	r3, [r3, #8]
 80012c4:	4563      	cmp	r3, ip
 80012c6:	f4bf af6d 	bcs.w	80011a4 <i2cMasterTransmitTimeout.constprop.0+0x44>
 80012ca:	e7be      	b.n	800124a <i2cMasterTransmitTimeout.constprop.0+0xea>
  dp->CR2 |= I2C_CR2_ITEVTEN;
 80012cc:	6873      	ldr	r3, [r6, #4]
  chDbgAssert(*trp == NULL, "not NULL");
 80012ce:	69ea      	ldr	r2, [r5, #28]
 80012d0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80012d4:	6073      	str	r3, [r6, #4]
  dp->CR1 |= I2C_CR1_START;
 80012d6:	6833      	ldr	r3, [r6, #0]
 80012d8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80012dc:	6033      	str	r3, [r6, #0]
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 80012de:	68e3      	ldr	r3, [r4, #12]
 80012e0:	bb3a      	cbnz	r2, 8001332 <i2cMasterTransmitTimeout.constprop.0+0x1d2>
  tp->u.wttrp = trp;
 80012e2:	4a1c      	ldr	r2, [pc, #112]	; (8001354 <i2cMasterTransmitTimeout.constprop.0+0x1f4>)
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80012e4:	2128      	movs	r1, #40	; 0x28
 80012e6:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
 80012e8:	635a      	str	r2, [r3, #52]	; 0x34
  *trp = tp;
 80012ea:	61eb      	str	r3, [r5, #28]
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80012ec:	f7ff fea0 	bl	8001030 <chSchGoSleepTimeoutS>
  if (msg != MSG_OK) {
 80012f0:	2800      	cmp	r0, #0
 80012f2:	d0d0      	beq.n	8001296 <i2cMasterTransmitTimeout.constprop.0+0x136>
    dmaStreamDisable(i2cp->dmatx);
 80012f4:	6b2e      	ldr	r6, [r5, #48]	; 0x30
    dmaStreamDisable(i2cp->dmarx);
 80012f6:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    dmaStreamDisable(i2cp->dmatx);
 80012f8:	f8d6 c004 	ldr.w	ip, [r6, #4]
    i2cp->state = I2C_LOCKED;
 80012fc:	1c43      	adds	r3, r0, #1
 80012fe:	f8dc 1000 	ldr.w	r1, [ip]
 8001302:	f8d6 e000 	ldr.w	lr, [r6]
 8001306:	f021 010f 	bic.w	r1, r1, #15
 800130a:	f8cc 1000 	str.w	r1, [ip]
 800130e:	7b71      	ldrb	r1, [r6, #13]
 8001310:	bf08      	it	eq
 8001312:	2705      	moveq	r7, #5
    dmaStreamDisable(i2cp->dmarx);
 8001314:	e9d2 c600 	ldrd	ip, r6, [r2]
    dmaStreamDisable(i2cp->dmatx);
 8001318:	230e      	movs	r3, #14
 800131a:	e7b0      	b.n	800127e <i2cMasterTransmitTimeout.constprop.0+0x11e>
    chSysHalt("SV#5");
 800131c:	480e      	ldr	r0, [pc, #56]	; (8001358 <i2cMasterTransmitTimeout.constprop.0+0x1f8>)
 800131e:	f7ff fb8f 	bl	8000a40 <chSysHalt>
 8001322:	68e1      	ldr	r1, [r4, #12]
 8001324:	6893      	ldr	r3, [r2, #8]
 8001326:	688a      	ldr	r2, [r1, #8]
 8001328:	429a      	cmp	r2, r3
 800132a:	d2c2      	bcs.n	80012b2 <i2cMasterTransmitTimeout.constprop.0+0x152>
 800132c:	480b      	ldr	r0, [pc, #44]	; (800135c <i2cMasterTransmitTimeout.constprop.0+0x1fc>)
 800132e:	f7ff fb87 	bl	8000a40 <chSysHalt>
  chDbgAssert(*trp == NULL, "not NULL");
 8001332:	480b      	ldr	r0, [pc, #44]	; (8001360 <i2cMasterTransmitTimeout.constprop.0+0x200>)
 8001334:	f7ff fb84 	bl	8000a40 <chSysHalt>
 8001338:	20000c40 	.word	0x20000c40
 800133c:	200010e0 	.word	0x200010e0
 8001340:	200010d4 	.word	0x200010d4
 8001344:	080035c0 	.word	0x080035c0
 8001348:	080037cc 	.word	0x080037cc
 800134c:	080036ec 	.word	0x080036ec
 8001350:	0800363c 	.word	0x0800363c
 8001354:	20000c5c 	.word	0x20000c5c
 8001358:	080035f0 	.word	0x080035f0
 800135c:	08003894 	.word	0x08003894
 8001360:	0800387c 	.word	0x0800387c
	...

08001370 <chMtxLockS.constprop.0>:
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8001370:	4b3c      	ldr	r3, [pc, #240]	; (8001464 <chMtxLockS.constprop.0+0xf4>)
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001372:	b570      	push	{r4, r5, r6, lr}
 8001374:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 8001378:	2a00      	cmp	r2, #0
 800137a:	d170      	bne.n	800145e <chMtxLockS.constprop.0+0xee>
 800137c:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
 8001380:	2a00      	cmp	r2, #0
 8001382:	dd6c      	ble.n	800145e <chMtxLockS.constprop.0+0xee>

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8001384:	4e38      	ldr	r6, [pc, #224]	; (8001468 <chMtxLockS.constprop.0+0xf8>)
 8001386:	68dc      	ldr	r4, [r3, #12]
 8001388:	6970      	ldr	r0, [r6, #20]
 800138a:	b320      	cbz	r0, 80013d6 <chMtxLockS.constprop.0+0x66>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 800138c:	68a2      	ldr	r2, [r4, #8]
 800138e:	6883      	ldr	r3, [r0, #8]
 8001390:	429a      	cmp	r2, r3
 8001392:	d906      	bls.n	80013a2 <chMtxLockS.constprop.0+0x32>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8001394:	7f03      	ldrb	r3, [r0, #28]
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 8001396:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 8001398:	2b06      	cmp	r3, #6
 800139a:	d040      	beq.n	800141e <chMtxLockS.constprop.0+0xae>
 800139c:	2b07      	cmp	r3, #7
 800139e:	d02a      	beq.n	80013f6 <chMtxLockS.constprop.0+0x86>
 80013a0:	b303      	cbz	r3, 80013e4 <chMtxLockS.constprop.0+0x74>
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
 80013a2:	4d32      	ldr	r5, [pc, #200]	; (800146c <chMtxLockS.constprop.0+0xfc>)
 80013a4:	462b      	mov	r3, r5
 80013a6:	e003      	b.n	80013b0 <chMtxLockS.constprop.0+0x40>
  do {
    cp = cp->next;
  } while ((cp != qp) &&
 80013a8:	6899      	ldr	r1, [r3, #8]
 80013aa:	68a2      	ldr	r2, [r4, #8]
 80013ac:	4291      	cmp	r1, r2
 80013ae:	d302      	bcc.n	80013b6 <chMtxLockS.constprop.0+0x46>
    cp = cp->next;
 80013b0:	681b      	ldr	r3, [r3, #0]
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 80013b2:	42ab      	cmp	r3, r5
 80013b4:	d1f8      	bne.n	80013a8 <chMtxLockS.constprop.0+0x38>
  tp->next       = cp;
  tp->prev       = cp->prev;
 80013b6:	685a      	ldr	r2, [r3, #4]
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
      currtp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 80013b8:	2006      	movs	r0, #6
 80013ba:	e9c4 3200 	strd	r3, r2, [r4]
  tp->prev->next = tp;
 80013be:	6014      	str	r4, [r2, #0]
  cp->prev       = tp;
 80013c0:	605c      	str	r4, [r3, #4]
      currtp->u.wtmtxp = mp;
 80013c2:	6365      	str	r5, [r4, #52]	; 0x34
      chSchGoSleepS(CH_STATE_WTMTX);
 80013c4:	f7ff fddc 	bl	8000f80 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == currtp, "not owner");
 80013c8:	6973      	ldr	r3, [r6, #20]
 80013ca:	429c      	cmp	r4, r3
 80013cc:	d144      	bne.n	8001458 <chMtxLockS.constprop.0+0xe8>
      chDbgAssert(currtp->mtxlist == mp, "not owned");
 80013ce:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80013d0:	42ab      	cmp	r3, r5
 80013d2:	d141      	bne.n	8001458 <chMtxLockS.constprop.0+0xe8>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 80013d4:	bd70      	pop	{r4, r5, r6, pc}
    mp->next = currtp->mtxlist;
 80013d6:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    currtp->mtxlist = mp;
 80013d8:	f106 030c 	add.w	r3, r6, #12
    mp->next = currtp->mtxlist;
 80013dc:	e9c6 4205 	strd	r4, r2, [r6, #20]
    currtp->mtxlist = mp;
 80013e0:	64a3      	str	r3, [r4, #72]	; 0x48
}
 80013e2:	bd70      	pop	{r4, r5, r6, pc}
          tp->state = CH_STATE_CURRENT;
 80013e4:	2101      	movs	r1, #1
  p->prev->next = p->next;
 80013e6:	e9d0 3200 	ldrd	r3, r2, [r0]
 80013ea:	7701      	strb	r1, [r0, #28]
 80013ec:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 80013ee:	605a      	str	r2, [r3, #4]
  return __sch_ready_behind(tp);
 80013f0:	f7ff fcee 	bl	8000dd0 <__sch_ready_behind.isra.0>
 80013f4:	e7d5      	b.n	80013a2 <chMtxLockS.constprop.0+0x32>
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 80013f6:	6b45      	ldr	r5, [r0, #52]	; 0x34
  p->prev->next = p->next;
 80013f8:	6841      	ldr	r1, [r0, #4]
 80013fa:	6802      	ldr	r2, [r0, #0]
  ch_queue_t *cp = qp;
 80013fc:	462b      	mov	r3, r5
 80013fe:	600a      	str	r2, [r1, #0]
  p->next->prev = p->prev;
 8001400:	6051      	str	r1, [r2, #4]
 8001402:	e003      	b.n	800140c <chMtxLockS.constprop.0+0x9c>
  } while ((cp != qp) &&
 8001404:	6899      	ldr	r1, [r3, #8]
 8001406:	6882      	ldr	r2, [r0, #8]
 8001408:	4291      	cmp	r1, r2
 800140a:	d302      	bcc.n	8001412 <chMtxLockS.constprop.0+0xa2>
    cp = cp->next;
 800140c:	681b      	ldr	r3, [r3, #0]
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 800140e:	429d      	cmp	r5, r3
 8001410:	d1f8      	bne.n	8001404 <chMtxLockS.constprop.0+0x94>
  tp->prev       = cp->prev;
 8001412:	685a      	ldr	r2, [r3, #4]
 8001414:	e9c0 3200 	strd	r3, r2, [r0]
  tp->prev->next = tp;
 8001418:	6010      	str	r0, [r2, #0]
  cp->prev       = tp;
 800141a:	6058      	str	r0, [r3, #4]
}
 800141c:	e7c1      	b.n	80013a2 <chMtxLockS.constprop.0+0x32>
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 800141e:	6b45      	ldr	r5, [r0, #52]	; 0x34
  p->prev->next = p->next;
 8001420:	6841      	ldr	r1, [r0, #4]
 8001422:	6802      	ldr	r2, [r0, #0]
  ch_queue_t *cp = qp;
 8001424:	462b      	mov	r3, r5
 8001426:	600a      	str	r2, [r1, #0]
  p->next->prev = p->prev;
 8001428:	6051      	str	r1, [r2, #4]
 800142a:	e003      	b.n	8001434 <chMtxLockS.constprop.0+0xc4>
  } while ((cp != qp) &&
 800142c:	6899      	ldr	r1, [r3, #8]
 800142e:	6882      	ldr	r2, [r0, #8]
 8001430:	4291      	cmp	r1, r2
 8001432:	d302      	bcc.n	800143a <chMtxLockS.constprop.0+0xca>
    cp = cp->next;
 8001434:	681b      	ldr	r3, [r3, #0]
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 8001436:	429d      	cmp	r5, r3
 8001438:	d1f8      	bne.n	800142c <chMtxLockS.constprop.0+0xbc>
  tp->prev       = cp->prev;
 800143a:	685a      	ldr	r2, [r3, #4]
  tp->next       = cp;
 800143c:	6003      	str	r3, [r0, #0]
  tp->prev       = cp->prev;
 800143e:	6042      	str	r2, [r0, #4]
  tp->prev->next = tp;
 8001440:	6010      	str	r0, [r2, #0]
  cp->prev       = tp;
 8001442:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 8001444:	68a8      	ldr	r0, [r5, #8]
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8001446:	68a2      	ldr	r2, [r4, #8]
 8001448:	6883      	ldr	r3, [r0, #8]
 800144a:	429a      	cmp	r2, r3
 800144c:	d9a9      	bls.n	80013a2 <chMtxLockS.constprop.0+0x32>
        switch (tp->state) {
 800144e:	7f03      	ldrb	r3, [r0, #28]
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 8001450:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 8001452:	2b06      	cmp	r3, #6
 8001454:	d1a2      	bne.n	800139c <chMtxLockS.constprop.0+0x2c>
 8001456:	e7e2      	b.n	800141e <chMtxLockS.constprop.0+0xae>
      chDbgAssert(mp->owner == currtp, "not owner");
 8001458:	4805      	ldr	r0, [pc, #20]	; (8001470 <chMtxLockS.constprop.0+0x100>)
 800145a:	f7ff faf1 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#11");
 800145e:	4805      	ldr	r0, [pc, #20]	; (8001474 <chMtxLockS.constprop.0+0x104>)
 8001460:	f7ff faee 	bl	8000a40 <chSysHalt>
 8001464:	200010e0 	.word	0x200010e0
 8001468:	20000c40 	.word	0x20000c40
 800146c:	20000c4c 	.word	0x20000c4c
 8001470:	08003808 	.word	0x08003808
 8001474:	080035d8 	.word	0x080035d8
	...

08001480 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8001480:	4770      	bx	lr
 8001482:	bf00      	nop
	...

08001490 <__late_init>:
 8001490:	4770      	bx	lr
 8001492:	bf00      	nop
	...

080014a0 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 80014a0:	e7fe      	b.n	80014a0 <__default_exit>
 80014a2:	bf00      	nop
	...

080014b0 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80014b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80014b2:	4d15      	ldr	r5, [pc, #84]	; (8001508 <__init_ram_areas+0x58>)
 80014b4:	4f15      	ldr	r7, [pc, #84]	; (800150c <__init_ram_areas+0x5c>)
 80014b6:	4916      	ldr	r1, [pc, #88]	; (8001510 <__init_ram_areas+0x60>)
 80014b8:	4816      	ldr	r0, [pc, #88]	; (8001514 <__init_ram_areas+0x64>)
 80014ba:	4a17      	ldr	r2, [pc, #92]	; (8001518 <__init_ram_areas+0x68>)
 80014bc:	f105 0470 	add.w	r4, r5, #112	; 0x70
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80014c0:	4281      	cmp	r1, r0
 80014c2:	d90d      	bls.n	80014e0 <__init_ram_areas+0x30>
 80014c4:	4603      	mov	r3, r0
 80014c6:	3a04      	subs	r2, #4
      *p = *tp;
 80014c8:	f852 6f04 	ldr.w	r6, [r2, #4]!
 80014cc:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->clear_area) {
 80014d0:	4299      	cmp	r1, r3
 80014d2:	d8f9      	bhi.n	80014c8 <__init_ram_areas+0x18>
      p++;
 80014d4:	1e4b      	subs	r3, r1, #1
 80014d6:	1a1b      	subs	r3, r3, r0
 80014d8:	f023 0303 	bic.w	r3, r3, #3
 80014dc:	3304      	adds	r3, #4
 80014de:	4418      	add	r0, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80014e0:	4287      	cmp	r7, r0
 80014e2:	d907      	bls.n	80014f4 <__init_ram_areas+0x44>
      *p = 0;
 80014e4:	1e7a      	subs	r2, r7, #1
 80014e6:	1a12      	subs	r2, r2, r0
 80014e8:	f022 0203 	bic.w	r2, r2, #3
 80014ec:	2100      	movs	r1, #0
 80014ee:	3204      	adds	r2, #4
 80014f0:	f002 f80a 	bl	8003508 <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 80014f4:	42a5      	cmp	r5, r4
 80014f6:	d005      	beq.n	8001504 <__init_ram_areas+0x54>
    uint32_t *p = rap->init_area;
 80014f8:	e9d5 2004 	ldrd	r2, r0, [r5, #16]
    while (p < rap->no_init_area) {
 80014fc:	e9d5 1706 	ldrd	r1, r7, [r5, #24]
 8001500:	3510      	adds	r5, #16
 8001502:	e7dd      	b.n	80014c0 <__init_ram_areas+0x10>
     for self-modifying code.*/
  SCB_CleanDCache();
  SCB_InvalidateICache();
#endif
#endif
}
 8001504:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001506:	bf00      	nop
 8001508:	08003990 	.word	0x08003990
 800150c:	20001ba4 	.word	0x20001ba4
 8001510:	20001ba4 	.word	0x20001ba4
 8001514:	20001ba4 	.word	0x20001ba4
 8001518:	08003e40 	.word	0x08003e40
 800151c:	00000000 	.word	0x00000000

08001520 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001520:	b570      	push	{r4, r5, r6, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001522:	4c2d      	ldr	r4, [pc, #180]	; (80015d8 <Vector6C+0xb8>)
 8001524:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001528:	f013 0504 	ands.w	r5, r3, #4
 800152c:	d039      	beq.n	80015a2 <Vector6C+0x82>
 800152e:	2530      	movs	r5, #48	; 0x30
 8001530:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001534:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001538:	2b00      	cmp	r3, #0
 800153a:	db46      	blt.n	80015ca <Vector6C+0xaa>
 800153c:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001540:	2a00      	cmp	r2, #0
 8001542:	d142      	bne.n	80015ca <Vector6C+0xaa>
  oip->dbg.isr_cnt++;
 8001544:	3301      	adds	r3, #1
 8001546:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 800154a:	f382 8811 	msr	BASEPRI, r2
  dmaServeInterrupt(STM32_DMA1_STREAM1);
 800154e:	4823      	ldr	r0, [pc, #140]	; (80015dc <Vector6C+0xbc>)
 8001550:	f7ff f97e 	bl	8000850 <dmaServeInterrupt>
 8001554:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001558:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 800155c:	2b00      	cmp	r3, #0
 800155e:	dd37      	ble.n	80015d0 <Vector6C+0xb0>
 8001560:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001564:	bba2      	cbnz	r2, 80015d0 <Vector6C+0xb0>
  oip->dbg.isr_cnt--;
 8001566:	3b01      	subs	r3, #1
 8001568:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 800156c:	f382 8811 	msr	BASEPRI, r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001570:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001574:	f013 0604 	ands.w	r6, r3, #4
 8001578:	d003      	beq.n	8001582 <Vector6C+0x62>
}
 800157a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 800157e:	f7ff b9bf 	b.w	8000900 <__port_irq_epilogue>
 8001582:	f385 8811 	msr	BASEPRI, r5
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001586:	2204      	movs	r2, #4
 8001588:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800158c:	4914      	ldr	r1, [pc, #80]	; (80015e0 <Vector6C+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800158e:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001590:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001592:	f7ff fa35 	bl	8000a00 <trace_next.constprop.0>
 8001596:	f386 8811 	msr	BASEPRI, r6
}
 800159a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 800159e:	f7ff b9af 	b.w	8000900 <__port_irq_epilogue>
 80015a2:	2330      	movs	r3, #48	; 0x30
 80015a4:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80015a8:	2203      	movs	r2, #3
 80015aa:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80015ae:	490c      	ldr	r1, [pc, #48]	; (80015e0 <Vector6C+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80015b0:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80015b2:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 80015b4:	f7ff fa24 	bl	8000a00 <trace_next.constprop.0>
 80015b8:	f385 8811 	msr	BASEPRI, r5
 80015bc:	2530      	movs	r5, #48	; 0x30
 80015be:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 80015c2:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80015c6:	2b00      	cmp	r3, #0
 80015c8:	dab8      	bge.n	800153c <Vector6C+0x1c>
    chSysHalt("SV#8");
 80015ca:	4806      	ldr	r0, [pc, #24]	; (80015e4 <Vector6C+0xc4>)
 80015cc:	f7ff fa38 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#9");
 80015d0:	4805      	ldr	r0, [pc, #20]	; (80015e8 <Vector6C+0xc8>)
 80015d2:	f7ff fa35 	bl	8000a40 <chSysHalt>
 80015d6:	bf00      	nop
 80015d8:	200010e0 	.word	0x200010e0
 80015dc:	08003900 	.word	0x08003900
 80015e0:	080038f4 	.word	0x080038f4
 80015e4:	080035f8 	.word	0x080035f8
 80015e8:	08003600 	.word	0x08003600
 80015ec:	00000000 	.word	0x00000000

080015f0 <Vector70>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80015f0:	b570      	push	{r4, r5, r6, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80015f2:	4c2d      	ldr	r4, [pc, #180]	; (80016a8 <Vector70+0xb8>)
 80015f4:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 80015f8:	f013 0504 	ands.w	r5, r3, #4
 80015fc:	d039      	beq.n	8001672 <Vector70+0x82>
 80015fe:	2530      	movs	r5, #48	; 0x30
 8001600:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001604:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001608:	2b00      	cmp	r3, #0
 800160a:	db46      	blt.n	800169a <Vector70+0xaa>
 800160c:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001610:	2a00      	cmp	r2, #0
 8001612:	d142      	bne.n	800169a <Vector70+0xaa>
  oip->dbg.isr_cnt++;
 8001614:	3301      	adds	r3, #1
 8001616:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 800161a:	f382 8811 	msr	BASEPRI, r2
  dmaServeInterrupt(STM32_DMA1_STREAM2);
 800161e:	4823      	ldr	r0, [pc, #140]	; (80016ac <Vector70+0xbc>)
 8001620:	f7ff f916 	bl	8000850 <dmaServeInterrupt>
 8001624:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001628:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 800162c:	2b00      	cmp	r3, #0
 800162e:	dd37      	ble.n	80016a0 <Vector70+0xb0>
 8001630:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001634:	bba2      	cbnz	r2, 80016a0 <Vector70+0xb0>
  oip->dbg.isr_cnt--;
 8001636:	3b01      	subs	r3, #1
 8001638:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 800163c:	f382 8811 	msr	BASEPRI, r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001640:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001644:	f013 0604 	ands.w	r6, r3, #4
 8001648:	d003      	beq.n	8001652 <Vector70+0x62>
}
 800164a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 800164e:	f7ff b957 	b.w	8000900 <__port_irq_epilogue>
 8001652:	f385 8811 	msr	BASEPRI, r5
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001656:	2204      	movs	r2, #4
 8001658:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800165c:	4914      	ldr	r1, [pc, #80]	; (80016b0 <Vector70+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800165e:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001660:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001662:	f7ff f9cd 	bl	8000a00 <trace_next.constprop.0>
 8001666:	f386 8811 	msr	BASEPRI, r6
}
 800166a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 800166e:	f7ff b947 	b.w	8000900 <__port_irq_epilogue>
 8001672:	2330      	movs	r3, #48	; 0x30
 8001674:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001678:	2203      	movs	r2, #3
 800167a:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800167e:	490c      	ldr	r1, [pc, #48]	; (80016b0 <Vector70+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001680:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001682:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001684:	f7ff f9bc 	bl	8000a00 <trace_next.constprop.0>
 8001688:	f385 8811 	msr	BASEPRI, r5
 800168c:	2530      	movs	r5, #48	; 0x30
 800168e:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001692:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001696:	2b00      	cmp	r3, #0
 8001698:	dab8      	bge.n	800160c <Vector70+0x1c>
    chSysHalt("SV#8");
 800169a:	4806      	ldr	r0, [pc, #24]	; (80016b4 <Vector70+0xc4>)
 800169c:	f7ff f9d0 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#9");
 80016a0:	4805      	ldr	r0, [pc, #20]	; (80016b8 <Vector70+0xc8>)
 80016a2:	f7ff f9cd 	bl	8000a40 <chSysHalt>
 80016a6:	bf00      	nop
 80016a8:	200010e0 	.word	0x200010e0
 80016ac:	08003910 	.word	0x08003910
 80016b0:	080038e8 	.word	0x080038e8
 80016b4:	080035f8 	.word	0x080035f8
 80016b8:	08003600 	.word	0x08003600
 80016bc:	00000000 	.word	0x00000000

080016c0 <Vector74>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80016c0:	b570      	push	{r4, r5, r6, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80016c2:	4c2d      	ldr	r4, [pc, #180]	; (8001778 <Vector74+0xb8>)
 80016c4:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 80016c8:	f013 0504 	ands.w	r5, r3, #4
 80016cc:	d039      	beq.n	8001742 <Vector74+0x82>
 80016ce:	2530      	movs	r5, #48	; 0x30
 80016d0:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 80016d4:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80016d8:	2b00      	cmp	r3, #0
 80016da:	db46      	blt.n	800176a <Vector74+0xaa>
 80016dc:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 80016e0:	2a00      	cmp	r2, #0
 80016e2:	d142      	bne.n	800176a <Vector74+0xaa>
  oip->dbg.isr_cnt++;
 80016e4:	3301      	adds	r3, #1
 80016e6:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 80016ea:	f382 8811 	msr	BASEPRI, r2
  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80016ee:	4823      	ldr	r0, [pc, #140]	; (800177c <Vector74+0xbc>)
 80016f0:	f7ff f8ae 	bl	8000850 <dmaServeInterrupt>
 80016f4:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80016f8:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80016fc:	2b00      	cmp	r3, #0
 80016fe:	dd37      	ble.n	8001770 <Vector74+0xb0>
 8001700:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001704:	bba2      	cbnz	r2, 8001770 <Vector74+0xb0>
  oip->dbg.isr_cnt--;
 8001706:	3b01      	subs	r3, #1
 8001708:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 800170c:	f382 8811 	msr	BASEPRI, r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001710:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001714:	f013 0604 	ands.w	r6, r3, #4
 8001718:	d003      	beq.n	8001722 <Vector74+0x62>
}
 800171a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 800171e:	f7ff b8ef 	b.w	8000900 <__port_irq_epilogue>
 8001722:	f385 8811 	msr	BASEPRI, r5
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001726:	2204      	movs	r2, #4
 8001728:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800172c:	4914      	ldr	r1, [pc, #80]	; (8001780 <Vector74+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800172e:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001730:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001732:	f7ff f965 	bl	8000a00 <trace_next.constprop.0>
 8001736:	f386 8811 	msr	BASEPRI, r6
}
 800173a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 800173e:	f7ff b8df 	b.w	8000900 <__port_irq_epilogue>
 8001742:	2330      	movs	r3, #48	; 0x30
 8001744:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001748:	2203      	movs	r2, #3
 800174a:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800174e:	490c      	ldr	r1, [pc, #48]	; (8001780 <Vector74+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001750:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001752:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001754:	f7ff f954 	bl	8000a00 <trace_next.constprop.0>
 8001758:	f385 8811 	msr	BASEPRI, r5
 800175c:	2530      	movs	r5, #48	; 0x30
 800175e:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001762:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001766:	2b00      	cmp	r3, #0
 8001768:	dab8      	bge.n	80016dc <Vector74+0x1c>
    chSysHalt("SV#8");
 800176a:	4806      	ldr	r0, [pc, #24]	; (8001784 <Vector74+0xc4>)
 800176c:	f7ff f968 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#9");
 8001770:	4805      	ldr	r0, [pc, #20]	; (8001788 <Vector74+0xc8>)
 8001772:	f7ff f965 	bl	8000a40 <chSysHalt>
 8001776:	bf00      	nop
 8001778:	200010e0 	.word	0x200010e0
 800177c:	08003920 	.word	0x08003920
 8001780:	080038d0 	.word	0x080038d0
 8001784:	080035f8 	.word	0x080035f8
 8001788:	08003600 	.word	0x08003600
 800178c:	00000000 	.word	0x00000000

08001790 <Vector78>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8001790:	b570      	push	{r4, r5, r6, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001792:	4c2d      	ldr	r4, [pc, #180]	; (8001848 <Vector78+0xb8>)
 8001794:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001798:	f013 0504 	ands.w	r5, r3, #4
 800179c:	d039      	beq.n	8001812 <Vector78+0x82>
 800179e:	2530      	movs	r5, #48	; 0x30
 80017a0:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 80017a4:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80017a8:	2b00      	cmp	r3, #0
 80017aa:	db46      	blt.n	800183a <Vector78+0xaa>
 80017ac:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 80017b0:	2a00      	cmp	r2, #0
 80017b2:	d142      	bne.n	800183a <Vector78+0xaa>
  oip->dbg.isr_cnt++;
 80017b4:	3301      	adds	r3, #1
 80017b6:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 80017ba:	f382 8811 	msr	BASEPRI, r2
  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80017be:	4823      	ldr	r0, [pc, #140]	; (800184c <Vector78+0xbc>)
 80017c0:	f7ff f846 	bl	8000850 <dmaServeInterrupt>
 80017c4:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80017c8:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80017cc:	2b00      	cmp	r3, #0
 80017ce:	dd37      	ble.n	8001840 <Vector78+0xb0>
 80017d0:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 80017d4:	bba2      	cbnz	r2, 8001840 <Vector78+0xb0>
  oip->dbg.isr_cnt--;
 80017d6:	3b01      	subs	r3, #1
 80017d8:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 80017dc:	f382 8811 	msr	BASEPRI, r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80017e0:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 80017e4:	f013 0604 	ands.w	r6, r3, #4
 80017e8:	d003      	beq.n	80017f2 <Vector78+0x62>
}
 80017ea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 80017ee:	f7ff b887 	b.w	8000900 <__port_irq_epilogue>
 80017f2:	f385 8811 	msr	BASEPRI, r5
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80017f6:	2204      	movs	r2, #4
 80017f8:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80017fc:	4914      	ldr	r1, [pc, #80]	; (8001850 <Vector78+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80017fe:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001800:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001802:	f7ff f8fd 	bl	8000a00 <trace_next.constprop.0>
 8001806:	f386 8811 	msr	BASEPRI, r6
}
 800180a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 800180e:	f7ff b877 	b.w	8000900 <__port_irq_epilogue>
 8001812:	2330      	movs	r3, #48	; 0x30
 8001814:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001818:	2203      	movs	r2, #3
 800181a:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800181e:	490c      	ldr	r1, [pc, #48]	; (8001850 <Vector78+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001820:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001822:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001824:	f7ff f8ec 	bl	8000a00 <trace_next.constprop.0>
 8001828:	f385 8811 	msr	BASEPRI, r5
 800182c:	2530      	movs	r5, #48	; 0x30
 800182e:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001832:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001836:	2b00      	cmp	r3, #0
 8001838:	dab8      	bge.n	80017ac <Vector78+0x1c>
    chSysHalt("SV#8");
 800183a:	4806      	ldr	r0, [pc, #24]	; (8001854 <Vector78+0xc4>)
 800183c:	f7ff f900 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#9");
 8001840:	4805      	ldr	r0, [pc, #20]	; (8001858 <Vector78+0xc8>)
 8001842:	f7ff f8fd 	bl	8000a40 <chSysHalt>
 8001846:	bf00      	nop
 8001848:	200010e0 	.word	0x200010e0
 800184c:	08003930 	.word	0x08003930
 8001850:	080038a0 	.word	0x080038a0
 8001854:	080035f8 	.word	0x080035f8
 8001858:	08003600 	.word	0x08003600
 800185c:	00000000 	.word	0x00000000

08001860 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8001860:	b570      	push	{r4, r5, r6, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001862:	4c2d      	ldr	r4, [pc, #180]	; (8001918 <Vector7C+0xb8>)
 8001864:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001868:	f013 0504 	ands.w	r5, r3, #4
 800186c:	d039      	beq.n	80018e2 <Vector7C+0x82>
 800186e:	2530      	movs	r5, #48	; 0x30
 8001870:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001874:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001878:	2b00      	cmp	r3, #0
 800187a:	db46      	blt.n	800190a <Vector7C+0xaa>
 800187c:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001880:	2a00      	cmp	r2, #0
 8001882:	d142      	bne.n	800190a <Vector7C+0xaa>
  oip->dbg.isr_cnt++;
 8001884:	3301      	adds	r3, #1
 8001886:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 800188a:	f382 8811 	msr	BASEPRI, r2
  dmaServeInterrupt(STM32_DMA1_STREAM5);
 800188e:	4823      	ldr	r0, [pc, #140]	; (800191c <Vector7C+0xbc>)
 8001890:	f7fe ffde 	bl	8000850 <dmaServeInterrupt>
 8001894:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001898:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 800189c:	2b00      	cmp	r3, #0
 800189e:	dd37      	ble.n	8001910 <Vector7C+0xb0>
 80018a0:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 80018a4:	bba2      	cbnz	r2, 8001910 <Vector7C+0xb0>
  oip->dbg.isr_cnt--;
 80018a6:	3b01      	subs	r3, #1
 80018a8:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 80018ac:	f382 8811 	msr	BASEPRI, r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80018b0:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 80018b4:	f013 0604 	ands.w	r6, r3, #4
 80018b8:	d003      	beq.n	80018c2 <Vector7C+0x62>
}
 80018ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 80018be:	f7ff b81f 	b.w	8000900 <__port_irq_epilogue>
 80018c2:	f385 8811 	msr	BASEPRI, r5
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80018c6:	2204      	movs	r2, #4
 80018c8:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80018cc:	4914      	ldr	r1, [pc, #80]	; (8001920 <Vector7C+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80018ce:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80018d0:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 80018d2:	f7ff f895 	bl	8000a00 <trace_next.constprop.0>
 80018d6:	f386 8811 	msr	BASEPRI, r6
}
 80018da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 80018de:	f7ff b80f 	b.w	8000900 <__port_irq_epilogue>
 80018e2:	2330      	movs	r3, #48	; 0x30
 80018e4:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80018e8:	2203      	movs	r2, #3
 80018ea:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80018ee:	490c      	ldr	r1, [pc, #48]	; (8001920 <Vector7C+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80018f0:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80018f2:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 80018f4:	f7ff f884 	bl	8000a00 <trace_next.constprop.0>
 80018f8:	f385 8811 	msr	BASEPRI, r5
 80018fc:	2530      	movs	r5, #48	; 0x30
 80018fe:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001902:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001906:	2b00      	cmp	r3, #0
 8001908:	dab8      	bge.n	800187c <Vector7C+0x1c>
    chSysHalt("SV#8");
 800190a:	4806      	ldr	r0, [pc, #24]	; (8001924 <Vector7C+0xc4>)
 800190c:	f7ff f898 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#9");
 8001910:	4805      	ldr	r0, [pc, #20]	; (8001928 <Vector7C+0xc8>)
 8001912:	f7ff f895 	bl	8000a40 <chSysHalt>
 8001916:	bf00      	nop
 8001918:	200010e0 	.word	0x200010e0
 800191c:	08003940 	.word	0x08003940
 8001920:	08003850 	.word	0x08003850
 8001924:	080035f8 	.word	0x080035f8
 8001928:	08003600 	.word	0x08003600
 800192c:	00000000 	.word	0x00000000

08001930 <Vector80>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8001930:	b570      	push	{r4, r5, r6, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001932:	4c2d      	ldr	r4, [pc, #180]	; (80019e8 <Vector80+0xb8>)
 8001934:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001938:	f013 0504 	ands.w	r5, r3, #4
 800193c:	d039      	beq.n	80019b2 <Vector80+0x82>
 800193e:	2530      	movs	r5, #48	; 0x30
 8001940:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001944:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001948:	2b00      	cmp	r3, #0
 800194a:	db46      	blt.n	80019da <Vector80+0xaa>
 800194c:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001950:	2a00      	cmp	r2, #0
 8001952:	d142      	bne.n	80019da <Vector80+0xaa>
  oip->dbg.isr_cnt++;
 8001954:	3301      	adds	r3, #1
 8001956:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 800195a:	f382 8811 	msr	BASEPRI, r2
  dmaServeInterrupt(STM32_DMA1_STREAM6);
 800195e:	4823      	ldr	r0, [pc, #140]	; (80019ec <Vector80+0xbc>)
 8001960:	f7fe ff76 	bl	8000850 <dmaServeInterrupt>
 8001964:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001968:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 800196c:	2b00      	cmp	r3, #0
 800196e:	dd37      	ble.n	80019e0 <Vector80+0xb0>
 8001970:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001974:	bba2      	cbnz	r2, 80019e0 <Vector80+0xb0>
  oip->dbg.isr_cnt--;
 8001976:	3b01      	subs	r3, #1
 8001978:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 800197c:	f382 8811 	msr	BASEPRI, r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001980:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001984:	f013 0604 	ands.w	r6, r3, #4
 8001988:	d003      	beq.n	8001992 <Vector80+0x62>
}
 800198a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 800198e:	f7fe bfb7 	b.w	8000900 <__port_irq_epilogue>
 8001992:	f385 8811 	msr	BASEPRI, r5
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001996:	2204      	movs	r2, #4
 8001998:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800199c:	4914      	ldr	r1, [pc, #80]	; (80019f0 <Vector80+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800199e:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80019a0:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 80019a2:	f7ff f82d 	bl	8000a00 <trace_next.constprop.0>
 80019a6:	f386 8811 	msr	BASEPRI, r6
}
 80019aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 80019ae:	f7fe bfa7 	b.w	8000900 <__port_irq_epilogue>
 80019b2:	2330      	movs	r3, #48	; 0x30
 80019b4:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80019b8:	2203      	movs	r2, #3
 80019ba:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80019be:	490c      	ldr	r1, [pc, #48]	; (80019f0 <Vector80+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80019c0:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80019c2:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 80019c4:	f7ff f81c 	bl	8000a00 <trace_next.constprop.0>
 80019c8:	f385 8811 	msr	BASEPRI, r5
 80019cc:	2530      	movs	r5, #48	; 0x30
 80019ce:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 80019d2:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80019d6:	2b00      	cmp	r3, #0
 80019d8:	dab8      	bge.n	800194c <Vector80+0x1c>
    chSysHalt("SV#8");
 80019da:	4806      	ldr	r0, [pc, #24]	; (80019f4 <Vector80+0xc4>)
 80019dc:	f7ff f830 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#9");
 80019e0:	4805      	ldr	r0, [pc, #20]	; (80019f8 <Vector80+0xc8>)
 80019e2:	f7ff f82d 	bl	8000a40 <chSysHalt>
 80019e6:	bf00      	nop
 80019e8:	200010e0 	.word	0x200010e0
 80019ec:	08003950 	.word	0x08003950
 80019f0:	08003814 	.word	0x08003814
 80019f4:	080035f8 	.word	0x080035f8
 80019f8:	08003600 	.word	0x08003600
 80019fc:	00000000 	.word	0x00000000

08001a00 <Vector84>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8001a00:	b570      	push	{r4, r5, r6, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001a02:	4c2d      	ldr	r4, [pc, #180]	; (8001ab8 <Vector84+0xb8>)
 8001a04:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001a08:	f013 0504 	ands.w	r5, r3, #4
 8001a0c:	d039      	beq.n	8001a82 <Vector84+0x82>
 8001a0e:	2530      	movs	r5, #48	; 0x30
 8001a10:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001a14:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001a18:	2b00      	cmp	r3, #0
 8001a1a:	db46      	blt.n	8001aaa <Vector84+0xaa>
 8001a1c:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001a20:	2a00      	cmp	r2, #0
 8001a22:	d142      	bne.n	8001aaa <Vector84+0xaa>
  oip->dbg.isr_cnt++;
 8001a24:	3301      	adds	r3, #1
 8001a26:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 8001a2a:	f382 8811 	msr	BASEPRI, r2
  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8001a2e:	4823      	ldr	r0, [pc, #140]	; (8001abc <Vector84+0xbc>)
 8001a30:	f7fe ff0e 	bl	8000850 <dmaServeInterrupt>
 8001a34:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001a38:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001a3c:	2b00      	cmp	r3, #0
 8001a3e:	dd37      	ble.n	8001ab0 <Vector84+0xb0>
 8001a40:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001a44:	bba2      	cbnz	r2, 8001ab0 <Vector84+0xb0>
  oip->dbg.isr_cnt--;
 8001a46:	3b01      	subs	r3, #1
 8001a48:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 8001a4c:	f382 8811 	msr	BASEPRI, r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001a50:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001a54:	f013 0604 	ands.w	r6, r3, #4
 8001a58:	d003      	beq.n	8001a62 <Vector84+0x62>
}
 8001a5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8001a5e:	f7fe bf4f 	b.w	8000900 <__port_irq_epilogue>
 8001a62:	f385 8811 	msr	BASEPRI, r5
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001a66:	2204      	movs	r2, #4
 8001a68:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001a6c:	4914      	ldr	r1, [pc, #80]	; (8001ac0 <Vector84+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001a6e:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001a70:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001a72:	f7fe ffc5 	bl	8000a00 <trace_next.constprop.0>
 8001a76:	f386 8811 	msr	BASEPRI, r6
}
 8001a7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8001a7e:	f7fe bf3f 	b.w	8000900 <__port_irq_epilogue>
 8001a82:	2330      	movs	r3, #48	; 0x30
 8001a84:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001a88:	2203      	movs	r2, #3
 8001a8a:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001a8e:	490c      	ldr	r1, [pc, #48]	; (8001ac0 <Vector84+0xc0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001a90:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001a92:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001a94:	f7fe ffb4 	bl	8000a00 <trace_next.constprop.0>
 8001a98:	f385 8811 	msr	BASEPRI, r5
 8001a9c:	2530      	movs	r5, #48	; 0x30
 8001a9e:	f385 8811 	msr	BASEPRI, r5
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001aa2:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001aa6:	2b00      	cmp	r3, #0
 8001aa8:	dab8      	bge.n	8001a1c <Vector84+0x1c>
    chSysHalt("SV#8");
 8001aaa:	4806      	ldr	r0, [pc, #24]	; (8001ac4 <Vector84+0xc4>)
 8001aac:	f7fe ffc8 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#9");
 8001ab0:	4805      	ldr	r0, [pc, #20]	; (8001ac8 <Vector84+0xc8>)
 8001ab2:	f7fe ffc5 	bl	8000a40 <chSysHalt>
 8001ab6:	bf00      	nop
 8001ab8:	200010e0 	.word	0x200010e0
 8001abc:	08003960 	.word	0x08003960
 8001ac0:	080037e8 	.word	0x080037e8
 8001ac4:	080035f8 	.word	0x080035f8
 8001ac8:	08003600 	.word	0x08003600
 8001acc:	00000000 	.word	0x00000000

08001ad0 <VectorBC>:
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 8001ad0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001ad4:	4c93      	ldr	r4, [pc, #588]	; (8001d24 <VectorBC+0x254>)
 8001ad6:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001ada:	f013 0504 	ands.w	r5, r3, #4
 8001ade:	d076      	beq.n	8001bce <VectorBC+0xfe>
 8001ae0:	2130      	movs	r1, #48	; 0x30
 8001ae2:	f381 8811 	msr	BASEPRI, r1
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001ae6:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001aea:	2b00      	cmp	r3, #0
 8001aec:	f2c0 8084 	blt.w	8001bf8 <VectorBC+0x128>
 8001af0:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001af4:	2a00      	cmp	r2, #0
 8001af6:	d17f      	bne.n	8001bf8 <VectorBC+0x128>
  oip->dbg.isr_cnt++;
 8001af8:	3301      	adds	r3, #1
 8001afa:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 8001afe:	f382 8811 	msr	BASEPRI, r2
  I2C_TypeDef *dp = i2cp->i2c;
 8001b02:	4a89      	ldr	r2, [pc, #548]	; (8001d28 <VectorBC+0x258>)
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8001b04:	4889      	ldr	r0, [pc, #548]	; (8001d2c <VectorBC+0x25c>)
  I2C_TypeDef *dp = i2cp->i2c;
 8001b06:	6b55      	ldr	r5, [r2, #52]	; 0x34
  uint32_t regSR2 = dp->SR2;
 8001b08:	69ab      	ldr	r3, [r5, #24]
  uint32_t event = dp->SR1;
 8001b0a:	696e      	ldr	r6, [r5, #20]
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8001b0c:	ea46 4303 	orr.w	r3, r6, r3, lsl #16
 8001b10:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8001b14:	4283      	cmp	r3, r0
 8001b16:	d834      	bhi.n	8001b82 <VectorBC+0xb2>
 8001b18:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8001b1c:	d90f      	bls.n	8001b3e <VectorBC+0x6e>
 8001b1e:	f5a3 3340 	sub.w	r3, r3, #196608	; 0x30000
 8001b22:	3b01      	subs	r3, #1
 8001b24:	2b10      	cmp	r3, #16
 8001b26:	d80d      	bhi.n	8001b44 <VectorBC+0x74>
 8001b28:	e8df f003 	tbb	[pc, r3]
 8001b2c:	0c0c8069 	.word	0x0c0c8069
 8001b30:	970c0c0c 	.word	0x970c0c0c
 8001b34:	0c0c0c0c 	.word	0x0c0c0c0c
 8001b38:	0c0c0c0c 	.word	0x0c0c0c0c
 8001b3c:	9c          	.byte	0x9c
 8001b3d:	00          	.byte	0x00
 8001b3e:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
 8001b42:	d05c      	beq.n	8001bfe <VectorBC+0x12e>
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8001b44:	f016 0f0a 	tst.w	r6, #10
    (void)dp->SR2;
 8001b48:	bf18      	it	ne
 8001b4a:	69ab      	ldrne	r3, [r5, #24]
 8001b4c:	2130      	movs	r1, #48	; 0x30
 8001b4e:	f381 8811 	msr	BASEPRI, r1
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001b52:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001b56:	2b00      	cmp	r3, #0
 8001b58:	f340 80d8 	ble.w	8001d0c <VectorBC+0x23c>
 8001b5c:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001b60:	2a00      	cmp	r2, #0
 8001b62:	f040 80d3 	bne.w	8001d0c <VectorBC+0x23c>
  oip->dbg.isr_cnt--;
 8001b66:	3b01      	subs	r3, #1
 8001b68:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 8001b6c:	f382 8811 	msr	BASEPRI, r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001b70:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001b74:	f013 0504 	ands.w	r5, r3, #4
 8001b78:	d019      	beq.n	8001bae <VectorBC+0xde>
}
 8001b7a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
 8001b7e:	f7fe bebf 	b.w	8000900 <__port_irq_epilogue>
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8001b82:	486b      	ldr	r0, [pc, #428]	; (8001d30 <VectorBC+0x260>)
 8001b84:	4283      	cmp	r3, r0
 8001b86:	d046      	beq.n	8001c16 <VectorBC+0x146>
 8001b88:	3002      	adds	r0, #2
 8001b8a:	4283      	cmp	r3, r0
 8001b8c:	d1da      	bne.n	8001b44 <VectorBC+0x74>
    (void)dp->DR; /* Clear BTF.*/
 8001b8e:	692b      	ldr	r3, [r5, #16]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8001b90:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8001b92:	685b      	ldr	r3, [r3, #4]
 8001b94:	685b      	ldr	r3, [r3, #4]
 8001b96:	2b00      	cmp	r3, #0
 8001b98:	f000 808c 	beq.w	8001cb4 <VectorBC+0x1e4>
      i2cp->addr |= 0x01;
 8001b9c:	8c11      	ldrh	r1, [r2, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8001b9e:	682b      	ldr	r3, [r5, #0]
      i2cp->addr |= 0x01;
 8001ba0:	f041 0101 	orr.w	r1, r1, #1
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8001ba4:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
      i2cp->addr |= 0x01;
 8001ba8:	8411      	strh	r1, [r2, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8001baa:	602b      	str	r3, [r5, #0]
      return;
 8001bac:	e7ce      	b.n	8001b4c <VectorBC+0x7c>
 8001bae:	f381 8811 	msr	BASEPRI, r1
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001bb2:	2204      	movs	r2, #4
 8001bb4:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001bb8:	495e      	ldr	r1, [pc, #376]	; (8001d34 <VectorBC+0x264>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001bba:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001bbc:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001bbe:	f7fe ff1f 	bl	8000a00 <trace_next.constprop.0>
 8001bc2:	f385 8811 	msr	BASEPRI, r5
}
 8001bc6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
 8001bca:	f7fe be99 	b.w	8000900 <__port_irq_epilogue>
 8001bce:	2330      	movs	r3, #48	; 0x30
 8001bd0:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001bd4:	2203      	movs	r2, #3
 8001bd6:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001bda:	4956      	ldr	r1, [pc, #344]	; (8001d34 <VectorBC+0x264>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001bdc:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001bde:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001be0:	f7fe ff0e 	bl	8000a00 <trace_next.constprop.0>
 8001be4:	f385 8811 	msr	BASEPRI, r5
 8001be8:	2130      	movs	r1, #48	; 0x30
 8001bea:	f381 8811 	msr	BASEPRI, r1
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001bee:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001bf2:	2b00      	cmp	r3, #0
 8001bf4:	f6bf af7c 	bge.w	8001af0 <VectorBC+0x20>
    chSysHalt("SV#8");
 8001bf8:	484f      	ldr	r0, [pc, #316]	; (8001d38 <VectorBC+0x268>)
 8001bfa:	f7fe ff21 	bl	8000a40 <chSysHalt>
    if ((i2cp->addr >> 8) > 0) {
 8001bfe:	8c13      	ldrh	r3, [r2, #32]
 8001c00:	0a1a      	lsrs	r2, r3, #8
 8001c02:	d02d      	beq.n	8001c60 <VectorBC+0x190>
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 8001c04:	f002 0206 	and.w	r2, r2, #6
 8001c08:	f003 0301 	and.w	r3, r3, #1
 8001c0c:	4313      	orrs	r3, r2
 8001c0e:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8001c12:	612b      	str	r3, [r5, #16]
 8001c14:	e796      	b.n	8001b44 <VectorBC+0x74>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8001c16:	686b      	ldr	r3, [r5, #4]
    dmaStreamEnable(i2cp->dmatx);
 8001c18:	6b12      	ldr	r2, [r2, #48]	; 0x30
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8001c1a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 8001c1e:	6852      	ldr	r2, [r2, #4]
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8001c20:	606b      	str	r3, [r5, #4]
    dmaStreamEnable(i2cp->dmatx);
 8001c22:	6813      	ldr	r3, [r2, #0]
 8001c24:	f043 0301 	orr.w	r3, r3, #1
 8001c28:	6013      	str	r3, [r2, #0]
    break;
 8001c2a:	e78b      	b.n	8001b44 <VectorBC+0x74>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8001c2c:	686b      	ldr	r3, [r5, #4]
    dmaStreamEnable(i2cp->dmarx);
 8001c2e:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8001c30:	f423 7200 	bic.w	r2, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 8001c34:	684b      	ldr	r3, [r1, #4]
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8001c36:	606a      	str	r2, [r5, #4]
    dmaStreamEnable(i2cp->dmarx);
 8001c38:	681a      	ldr	r2, [r3, #0]
 8001c3a:	f042 0201 	orr.w	r2, r2, #1
 8001c3e:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 8001c40:	686a      	ldr	r2, [r5, #4]
 8001c42:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001c46:	606a      	str	r2, [r5, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8001c48:	685b      	ldr	r3, [r3, #4]
 8001c4a:	2b01      	cmp	r3, #1
 8001c4c:	f63f af7a 	bhi.w	8001b44 <VectorBC+0x74>
      dp->CR1 &= ~I2C_CR1_ACK;
 8001c50:	682b      	ldr	r3, [r5, #0]
 8001c52:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001c56:	602b      	str	r3, [r5, #0]
 8001c58:	e774      	b.n	8001b44 <VectorBC+0x74>
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8001c5a:	8c13      	ldrh	r3, [r2, #32]
 8001c5c:	f3c3 0347 	ubfx	r3, r3, #1, #8
 8001c60:	612b      	str	r3, [r5, #16]
    break;
 8001c62:	e76f      	b.n	8001b44 <VectorBC+0x74>
  dp->CR1 = 0;
 8001c64:	2000      	movs	r0, #0
  dp->CR1 = I2C_CR1_SWRST;
 8001c66:	f44f 4900 	mov.w	r9, #32768	; 0x8000
  dmaStreamDisable(i2cp->dmatx);
 8001c6a:	230e      	movs	r3, #14
 8001c6c:	6b11      	ldr	r1, [r2, #48]	; 0x30
  dmaStreamDisable(i2cp->dmarx);
 8001c6e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  dmaStreamDisable(i2cp->dmatx);
 8001c70:	e9d1 e800 	ldrd	lr, r8, [r1]
  dmaStreamDisable(i2cp->dmarx);
 8001c74:	e9d2 7c00 	ldrd	r7, ip, [r2]
  dp->CR1 = I2C_CR1_SWRST;
 8001c78:	f8c5 9000 	str.w	r9, [r5]
  dp->CR1 = 0;
 8001c7c:	6028      	str	r0, [r5, #0]
  dp->CR2 = 0;
 8001c7e:	6068      	str	r0, [r5, #4]
  dp->SR1 = 0;
 8001c80:	6168      	str	r0, [r5, #20]
  dmaStreamDisable(i2cp->dmatx);
 8001c82:	f8d8 0000 	ldr.w	r0, [r8]
 8001c86:	f020 000f 	bic.w	r0, r0, #15
 8001c8a:	f8c8 0000 	str.w	r0, [r8]
 8001c8e:	7b49      	ldrb	r1, [r1, #13]
 8001c90:	fa03 f101 	lsl.w	r1, r3, r1
 8001c94:	f8ce 1004 	str.w	r1, [lr, #4]
  dmaStreamDisable(i2cp->dmarx);
 8001c98:	f8dc 1000 	ldr.w	r1, [ip]
 8001c9c:	f021 010f 	bic.w	r1, r1, #15
 8001ca0:	f8cc 1000 	str.w	r1, [ip]
 8001ca4:	7b52      	ldrb	r2, [r2, #13]
 8001ca6:	4093      	lsls	r3, r2
 8001ca8:	607b      	str	r3, [r7, #4]
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8001caa:	686b      	ldr	r3, [r5, #4]
 8001cac:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001cb0:	606b      	str	r3, [r5, #4]
    break;
 8001cb2:	e747      	b.n	8001b44 <VectorBC+0x74>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8001cb4:	686b      	ldr	r3, [r5, #4]
 8001cb6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001cba:	606b      	str	r3, [r5, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8001cbc:	682b      	ldr	r3, [r5, #0]
 8001cbe:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001cc2:	602b      	str	r3, [r5, #0]
 8001cc4:	f381 8811 	msr	BASEPRI, r1
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001cc8:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001ccc:	2b00      	cmp	r3, #0
 8001cce:	dd20      	ble.n	8001d12 <VectorBC+0x242>
 8001cd0:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8001cd4:	b9eb      	cbnz	r3, 8001d12 <VectorBC+0x242>
  oip->dbg.lock_cnt = (cnt_t)1;
 8001cd6:	2301      	movs	r3, #1
  if (*trp != NULL) {
 8001cd8:	69d0      	ldr	r0, [r2, #28]
 8001cda:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 8001cde:	b178      	cbz	r0, 8001d00 <VectorBC+0x230>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8001ce0:	7f03      	ldrb	r3, [r0, #28]
 8001ce2:	2b03      	cmp	r3, #3
 8001ce4:	d11b      	bne.n	8001d1e <VectorBC+0x24e>
    *trp = NULL;
 8001ce6:	2300      	movs	r3, #0
 8001ce8:	61d3      	str	r3, [r2, #28]
    tp->u.rdymsg = msg;
 8001cea:	6343      	str	r3, [r0, #52]	; 0x34
 8001cec:	f7ff f870 	bl	8000dd0 <__sch_ready_behind.isra.0>
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001cf0:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001cf4:	2b00      	cmp	r3, #0
 8001cf6:	dd0f      	ble.n	8001d18 <VectorBC+0x248>
 8001cf8:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8001cfc:	2b00      	cmp	r3, #0
 8001cfe:	dd0b      	ble.n	8001d18 <VectorBC+0x248>
  oip->dbg.lock_cnt = (cnt_t)0;
 8001d00:	2300      	movs	r3, #0
 8001d02:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 8001d06:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
}
 8001d0a:	e71b      	b.n	8001b44 <VectorBC+0x74>
    chSysHalt("SV#9");
 8001d0c:	480b      	ldr	r0, [pc, #44]	; (8001d3c <VectorBC+0x26c>)
 8001d0e:	f7fe fe97 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#6");
 8001d12:	480b      	ldr	r0, [pc, #44]	; (8001d40 <VectorBC+0x270>)
 8001d14:	f7fe fe94 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#7");
 8001d18:	480a      	ldr	r0, [pc, #40]	; (8001d44 <VectorBC+0x274>)
 8001d1a:	f7fe fe91 	bl	8000a40 <chSysHalt>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8001d1e:	480a      	ldr	r0, [pc, #40]	; (8001d48 <VectorBC+0x278>)
 8001d20:	f7fe fe8e 	bl	8000a40 <chSysHalt>
 8001d24:	200010e0 	.word	0x200010e0
 8001d28:	20000c40 	.word	0x20000c40
 8001d2c:	00030011 	.word	0x00030011
 8001d30:	00070082 	.word	0x00070082
 8001d34:	080038dc 	.word	0x080038dc
 8001d38:	080035f8 	.word	0x080035f8
 8001d3c:	08003600 	.word	0x08003600
 8001d40:	080035c8 	.word	0x080035c8
 8001d44:	080035d0 	.word	0x080035d0
 8001d48:	08003834 	.word	0x08003834
 8001d4c:	00000000 	.word	0x00000000

08001d50 <VectorC0>:
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 8001d50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint16_t sr = I2CD1.i2c->SR1;
 8001d54:	4d71      	ldr	r5, [pc, #452]	; (8001f1c <VectorC0+0x1cc>)
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001d56:	4c72      	ldr	r4, [pc, #456]	; (8001f20 <VectorC0+0x1d0>)
 8001d58:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8001d5a:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001d5e:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8001d62:	f013 0704 	ands.w	r7, r3, #4
 8001d66:	fa1f f688 	uxth.w	r6, r8
 8001d6a:	f000 80a2 	beq.w	8001eb2 <VectorC0+0x162>
 8001d6e:	2330      	movs	r3, #48	; 0x30
 8001d70:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001d74:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001d78:	2b00      	cmp	r3, #0
 8001d7a:	f2c0 80af 	blt.w	8001edc <VectorC0+0x18c>
 8001d7e:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001d82:	2a00      	cmp	r2, #0
 8001d84:	f040 80aa 	bne.w	8001edc <VectorC0+0x18c>
  oip->dbg.isr_cnt++;
 8001d88:	3301      	adds	r3, #1
 8001d8a:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 8001d8e:	f382 8811 	msr	BASEPRI, r2
  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8001d92:	f408 435f 	and.w	r3, r8, #57088	; 0xdf00
 8001d96:	43db      	mvns	r3, r3
  dmaStreamDisable(i2cp->dmarx);
 8001d98:	e9d5 100b 	ldrd	r1, r0, [r5, #44]	; 0x2c
  dmaStreamDisable(i2cp->dmatx);
 8001d9c:	e9d0 ce00 	ldrd	ip, lr, [r0]
  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8001da0:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8001da2:	6153      	str	r3, [r2, #20]
  dmaStreamDisable(i2cp->dmatx);
 8001da4:	230e      	movs	r3, #14
 8001da6:	f8de 7000 	ldr.w	r7, [lr]
 8001daa:	f027 070f 	bic.w	r7, r7, #15
 8001dae:	f8ce 7000 	str.w	r7, [lr]
 8001db2:	7b40      	ldrb	r0, [r0, #13]
  dmaStreamDisable(i2cp->dmarx);
 8001db4:	e9d1 7e00 	ldrd	r7, lr, [r1]
  dmaStreamDisable(i2cp->dmatx);
 8001db8:	fa03 f000 	lsl.w	r0, r3, r0
 8001dbc:	f8cc 0004 	str.w	r0, [ip, #4]
  dmaStreamDisable(i2cp->dmarx);
 8001dc0:	f8de 0000 	ldr.w	r0, [lr]
 8001dc4:	f020 000f 	bic.w	r0, r0, #15
 8001dc8:	f8ce 0000 	str.w	r0, [lr]
 8001dcc:	7b49      	ldrb	r1, [r1, #13]
 8001dce:	408b      	lsls	r3, r1
 8001dd0:	607b      	str	r3, [r7, #4]
  if (sr & I2C_SR1_BERR) {                          /* Bus error.           */
 8001dd2:	f416 7380 	ands.w	r3, r6, #256	; 0x100
    i2cp->errors |= I2C_BUS_ERROR;
 8001dd6:	bf18      	it	ne
 8001dd8:	2301      	movne	r3, #1
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8001dda:	05b1      	lsls	r1, r6, #22
    i2cp->errors |= I2C_BUS_ERROR;
 8001ddc:	60ab      	str	r3, [r5, #8]
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8001dde:	bf44      	itt	mi
 8001de0:	f043 0302 	orrmi.w	r3, r3, #2
 8001de4:	60ab      	strmi	r3, [r5, #8]
  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8001de6:	0577      	lsls	r7, r6, #21
 8001de8:	d50a      	bpl.n	8001e00 <VectorC0+0xb0>
      i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8001dea:	6851      	ldr	r1, [r2, #4]
      i2cp->errors |= I2C_ACK_FAILURE;
 8001dec:	f043 0304 	orr.w	r3, r3, #4
      i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8001df0:	f421 7100 	bic.w	r1, r1, #512	; 0x200
 8001df4:	6051      	str	r1, [r2, #4]
      i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8001df6:	6811      	ldr	r1, [r2, #0]
 8001df8:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8001dfc:	6011      	str	r1, [r2, #0]
      i2cp->errors |= I2C_ACK_FAILURE;
 8001dfe:	60ab      	str	r3, [r5, #8]
  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8001e00:	0530      	lsls	r0, r6, #20
    i2cp->errors |= I2C_OVERRUN;
 8001e02:	bf44      	itt	mi
 8001e04:	f043 0308 	orrmi.w	r3, r3, #8
 8001e08:	60ab      	strmi	r3, [r5, #8]
  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8001e0a:	0471      	lsls	r1, r6, #17
    i2cp->errors |= I2C_TIMEOUT;
 8001e0c:	bf44      	itt	mi
 8001e0e:	f043 0320 	orrmi.w	r3, r3, #32
 8001e12:	60ab      	strmi	r3, [r5, #8]
  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8001e14:	04f2      	lsls	r2, r6, #19
 8001e16:	d41c      	bmi.n	8001e52 <VectorC0+0x102>
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8001e18:	f418 4f00 	tst.w	r8, #32768	; 0x8000
 8001e1c:	d11f      	bne.n	8001e5e <VectorC0+0x10e>
  if (i2cp->errors != I2C_NO_ERROR)
 8001e1e:	bb0b      	cbnz	r3, 8001e64 <VectorC0+0x114>
 8001e20:	2130      	movs	r1, #48	; 0x30
 8001e22:	f381 8811 	msr	BASEPRI, r1
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001e26:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001e2a:	2b00      	cmp	r3, #0
 8001e2c:	dd69      	ble.n	8001f02 <VectorC0+0x1b2>
 8001e2e:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001e32:	2a00      	cmp	r2, #0
 8001e34:	d165      	bne.n	8001f02 <VectorC0+0x1b2>
  oip->dbg.isr_cnt--;
 8001e36:	3b01      	subs	r3, #1
 8001e38:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 8001e3c:	f382 8811 	msr	BASEPRI, r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001e40:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001e44:	f013 0504 	ands.w	r5, r3, #4
 8001e48:	d04b      	beq.n	8001ee2 <VectorC0+0x192>
}
 8001e4a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_EPILOGUE();
 8001e4e:	f7fe bd57 	b.w	8000900 <__port_irq_epilogue>
    i2cp->errors |= I2C_PEC_ERROR;
 8001e52:	f043 0310 	orr.w	r3, r3, #16
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8001e56:	f418 4f00 	tst.w	r8, #32768	; 0x8000
    i2cp->errors |= I2C_PEC_ERROR;
 8001e5a:	60ab      	str	r3, [r5, #8]
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8001e5c:	d002      	beq.n	8001e64 <VectorC0+0x114>
    i2cp->errors |= I2C_SMB_ALERT;
 8001e5e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001e62:	60ab      	str	r3, [r5, #8]
 8001e64:	2330      	movs	r3, #48	; 0x30
 8001e66:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001e6a:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001e6e:	2b00      	cmp	r3, #0
 8001e70:	dd4a      	ble.n	8001f08 <VectorC0+0x1b8>
 8001e72:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8001e76:	2b00      	cmp	r3, #0
 8001e78:	d146      	bne.n	8001f08 <VectorC0+0x1b8>
  oip->dbg.lock_cnt = (cnt_t)1;
 8001e7a:	2201      	movs	r2, #1
  if (*trp != NULL) {
 8001e7c:	69e8      	ldr	r0, [r5, #28]
 8001e7e:	f8c4 20ec 	str.w	r2, [r4, #236]	; 0xec
 8001e82:	b180      	cbz	r0, 8001ea6 <VectorC0+0x156>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8001e84:	7f02      	ldrb	r2, [r0, #28]
 8001e86:	2a03      	cmp	r2, #3
 8001e88:	d144      	bne.n	8001f14 <VectorC0+0x1c4>
    tp->u.rdymsg = msg;
 8001e8a:	f06f 0201 	mvn.w	r2, #1
    *trp = NULL;
 8001e8e:	61eb      	str	r3, [r5, #28]
    tp->u.rdymsg = msg;
 8001e90:	6342      	str	r2, [r0, #52]	; 0x34
 8001e92:	f7fe ff9d 	bl	8000dd0 <__sch_ready_behind.isra.0>
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001e96:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001e9a:	2b00      	cmp	r3, #0
 8001e9c:	dd37      	ble.n	8001f0e <VectorC0+0x1be>
 8001e9e:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8001ea2:	2b00      	cmp	r3, #0
 8001ea4:	dd33      	ble.n	8001f0e <VectorC0+0x1be>
  oip->dbg.lock_cnt = (cnt_t)0;
 8001ea6:	2300      	movs	r3, #0
 8001ea8:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 8001eac:	f383 8811 	msr	BASEPRI, r3
 8001eb0:	e7b6      	b.n	8001e20 <VectorC0+0xd0>
 8001eb2:	2330      	movs	r3, #48	; 0x30
 8001eb4:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001eb8:	2203      	movs	r2, #3
 8001eba:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 8001ebe:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001ec0:	4a18      	ldr	r2, [pc, #96]	; (8001f24 <VectorC0+0x1d4>)
 8001ec2:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8001ec4:	f7fe fd9c 	bl	8000a00 <trace_next.constprop.0>
 8001ec8:	f387 8811 	msr	BASEPRI, r7
 8001ecc:	2330      	movs	r3, #48	; 0x30
 8001ece:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001ed2:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001ed6:	2b00      	cmp	r3, #0
 8001ed8:	f6bf af51 	bge.w	8001d7e <VectorC0+0x2e>
    chSysHalt("SV#8");
 8001edc:	4812      	ldr	r0, [pc, #72]	; (8001f28 <VectorC0+0x1d8>)
 8001ede:	f7fe fdaf 	bl	8000a40 <chSysHalt>
 8001ee2:	f381 8811 	msr	BASEPRI, r1
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001ee6:	2204      	movs	r2, #4
 8001ee8:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001eec:	490d      	ldr	r1, [pc, #52]	; (8001f24 <VectorC0+0x1d4>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001eee:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001ef0:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001ef2:	f7fe fd85 	bl	8000a00 <trace_next.constprop.0>
 8001ef6:	f385 8811 	msr	BASEPRI, r5
}
 8001efa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_EPILOGUE();
 8001efe:	f7fe bcff 	b.w	8000900 <__port_irq_epilogue>
    chSysHalt("SV#9");
 8001f02:	480a      	ldr	r0, [pc, #40]	; (8001f2c <VectorC0+0x1dc>)
 8001f04:	f7fe fd9c 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#6");
 8001f08:	4809      	ldr	r0, [pc, #36]	; (8001f30 <VectorC0+0x1e0>)
 8001f0a:	f7fe fd99 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#7");
 8001f0e:	4809      	ldr	r0, [pc, #36]	; (8001f34 <VectorC0+0x1e4>)
 8001f10:	f7fe fd96 	bl	8000a40 <chSysHalt>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8001f14:	4808      	ldr	r0, [pc, #32]	; (8001f38 <VectorC0+0x1e8>)
 8001f16:	f7fe fd93 	bl	8000a40 <chSysHalt>
 8001f1a:	bf00      	nop
 8001f1c:	20000c40 	.word	0x20000c40
 8001f20:	200010e0 	.word	0x200010e0
 8001f24:	080038ac 	.word	0x080038ac
 8001f28:	080035f8 	.word	0x080035f8
 8001f2c:	08003600 	.word	0x08003600
 8001f30:	080035c8 	.word	0x080035c8
 8001f34:	080035d0 	.word	0x080035d0
 8001f38:	08003834 	.word	0x08003834
 8001f3c:	00000000 	.word	0x00000000

08001f40 <VectorB0>:
/**
 * @brief   Interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001f40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001f44:	4c7b      	ldr	r4, [pc, #492]	; (8002134 <VectorB0+0x1f4>)
 8001f46:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001f4a:	f013 0504 	ands.w	r5, r3, #4
 8001f4e:	d035      	beq.n	8001fbc <VectorB0+0x7c>
 8001f50:	2130      	movs	r1, #48	; 0x30
 8001f52:	f381 8811 	msr	BASEPRI, r1
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001f56:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001f5a:	2b00      	cmp	r3, #0
 8001f5c:	db42      	blt.n	8001fe4 <VectorB0+0xa4>
 8001f5e:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001f62:	2a00      	cmp	r2, #0
 8001f64:	d13e      	bne.n	8001fe4 <VectorB0+0xa4>
  oip->dbg.isr_cnt++;
 8001f66:	3301      	adds	r3, #1
 8001f68:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 8001f6c:	f382 8811 	msr	BASEPRI, r2
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 8001f70:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8001f74:	692b      	ldr	r3, [r5, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001f76:	68ea      	ldr	r2, [r5, #12]
 8001f78:	4013      	ands	r3, r2
 8001f7a:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;
 8001f7c:	43d2      	mvns	r2, r2

  if ((sr & TIM_SR_CC1IF) != 0U)
 8001f7e:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 8001f80:	612a      	str	r2, [r5, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 8001f82:	d432      	bmi.n	8001fea <VectorB0+0xaa>
 8001f84:	2130      	movs	r1, #48	; 0x30
 8001f86:	f381 8811 	msr	BASEPRI, r1
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001f8a:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001f8e:	2b00      	cmp	r3, #0
 8001f90:	f340 8097 	ble.w	80020c2 <VectorB0+0x182>
 8001f94:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8001f98:	2a00      	cmp	r2, #0
 8001f9a:	f040 8092 	bne.w	80020c2 <VectorB0+0x182>
  oip->dbg.isr_cnt--;
 8001f9e:	3b01      	subs	r3, #1
 8001fa0:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 8001fa4:	f382 8811 	msr	BASEPRI, r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001fa8:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 8001fac:	f013 0504 	ands.w	r5, r3, #4
 8001fb0:	f000 808a 	beq.w	80020c8 <VectorB0+0x188>
}
 8001fb4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8001fb8:	f7fe bca2 	b.w	8000900 <__port_irq_epilogue>
 8001fbc:	2330      	movs	r3, #48	; 0x30
 8001fbe:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001fc2:	2203      	movs	r2, #3
 8001fc4:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001fc8:	495b      	ldr	r1, [pc, #364]	; (8002138 <VectorB0+0x1f8>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001fca:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8001fcc:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 8001fce:	f7fe fd17 	bl	8000a00 <trace_next.constprop.0>
 8001fd2:	f385 8811 	msr	BASEPRI, r5
 8001fd6:	2130      	movs	r1, #48	; 0x30
 8001fd8:	f381 8811 	msr	BASEPRI, r1
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8001fdc:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001fe0:	2b00      	cmp	r3, #0
 8001fe2:	dabc      	bge.n	8001f5e <VectorB0+0x1e>
    chSysHalt("SV#8");
 8001fe4:	4855      	ldr	r0, [pc, #340]	; (800213c <VectorB0+0x1fc>)
 8001fe6:	f7fe fd2b 	bl	8000a40 <chSysHalt>
 8001fea:	f381 8811 	msr	BASEPRI, r1
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8001fee:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8001ff2:	2b00      	cmp	r3, #0
 8001ff4:	dd78      	ble.n	80020e8 <VectorB0+0x1a8>
 8001ff6:	f8d4 90ec 	ldr.w	r9, [r4, #236]	; 0xec
 8001ffa:	f1b9 0f00 	cmp.w	r9, #0
 8001ffe:	d173      	bne.n	80020e8 <VectorB0+0x1a8>
  oip->dbg.lock_cnt = (cnt_t)1;
 8002000:	2301      	movs	r3, #1
 8002002:	f8df a13c 	ldr.w	sl, [pc, #316]	; 8002140 <VectorB0+0x200>
 8002006:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 800200a:	f04f 0830 	mov.w	r8, #48	; 0x30
 800200e:	6a68      	ldr	r0, [r5, #36]	; 0x24
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8002010:	6926      	ldr	r6, [r4, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002012:	8ba3      	ldrh	r3, [r4, #28]
 8002014:	b280      	uxth	r0, r0

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 8002016:	68b1      	ldr	r1, [r6, #8]
  return (sysinterval_t)((systime_t)(end - start));
 8002018:	1ac2      	subs	r2, r0, r3
 800201a:	b292      	uxth	r2, r2
 800201c:	428a      	cmp	r2, r1
 800201e:	d369      	bcc.n	80020f4 <VectorB0+0x1b4>
  return systime + (systime_t)interval;
 8002020:	440b      	add	r3, r1
 8002022:	b29f      	uxth	r7, r3
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;
 8002024:	83a7      	strh	r7, [r4, #28]
  dlp->prev->next = dlp->next;
 8002026:	e9d6 3200 	ldrd	r3, r2, [r6]
 800202a:	6013      	str	r3, [r2, #0]
  dlp->next->prev = dlp->prev;
 800202c:	605a      	str	r2, [r3, #4]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
 800202e:	f8c6 9000 	str.w	r9, [r6]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002032:	6923      	ldr	r3, [r4, #16]
 8002034:	4553      	cmp	r3, sl
  STM32_ST_TIM->DIER = 0U;
 8002036:	bf08      	it	eq
 8002038:	f8c5 900c 	streq.w	r9, [r5, #12]
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 800203c:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8002040:	2b00      	cmp	r3, #0
 8002042:	dd54      	ble.n	80020ee <VectorB0+0x1ae>
 8002044:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8002048:	2b00      	cmp	r3, #0
 800204a:	dd50      	ble.n	80020ee <VectorB0+0x1ae>
  oip->dbg.lock_cnt = (cnt_t)0;
 800204c:	f8c4 90ec 	str.w	r9, [r4, #236]	; 0xec
 8002050:	f389 8811 	msr	BASEPRI, r9
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
 8002054:	4630      	mov	r0, r6
 8002056:	e9d6 3103 	ldrd	r3, r1, [r6, #12]
 800205a:	4798      	blx	r3
 800205c:	f388 8811 	msr	BASEPRI, r8
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002060:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8002064:	2b00      	cmp	r3, #0
 8002066:	dd3f      	ble.n	80020e8 <VectorB0+0x1a8>
 8002068:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 800206c:	2b00      	cmp	r3, #0
 800206e:	d13b      	bne.n	80020e8 <VectorB0+0x1a8>
  oip->dbg.lock_cnt = (cnt_t)1;
 8002070:	2301      	movs	r3, #1

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8002072:	6972      	ldr	r2, [r6, #20]
 8002074:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 8002078:	2a00      	cmp	r2, #0
 800207a:	d0c8      	beq.n	800200e <VectorB0+0xce>
  return (systime_t)STM32_ST_TIM->CNT;
 800207c:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800207e:	b289      	uxth	r1, r1
  return (sysinterval_t)((systime_t)(end - start));
 8002080:	1bcf      	subs	r7, r1, r7
 8002082:	b2bf      	uxth	r7, r7
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8002084:	42ba      	cmp	r2, r7
 8002086:	d34a      	bcc.n	800211e <VectorB0+0x1de>
  return (bool)(dlhp == dlhp->next);
 8002088:	6923      	ldr	r3, [r4, #16]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 800208a:	4553      	cmp	r3, sl
 800208c:	d04d      	beq.n	800212a <VectorB0+0x1ea>
  while (likely(dlp->delta < delta)) {
 800208e:	6899      	ldr	r1, [r3, #8]
 8002090:	428a      	cmp	r2, r1
 8002092:	d909      	bls.n	80020a8 <VectorB0+0x168>
    chDbgAssert(dlp != dlep, "element already in list");
 8002094:	42b3      	cmp	r3, r6
 8002096:	d102      	bne.n	800209e <VectorB0+0x15e>
 8002098:	e044      	b.n	8002124 <VectorB0+0x1e4>
 800209a:	429e      	cmp	r6, r3
 800209c:	d042      	beq.n	8002124 <VectorB0+0x1e4>
    dlp = dlp->next;
 800209e:	681b      	ldr	r3, [r3, #0]
    delta -= dlp->delta;
 80020a0:	1a52      	subs	r2, r2, r1
  while (likely(dlp->delta < delta)) {
 80020a2:	6899      	ldr	r1, [r3, #8]
 80020a4:	428a      	cmp	r2, r1
 80020a6:	d8f8      	bhi.n	800209a <VectorB0+0x15a>
  dlhp->delta = (sysinterval_t)-1;
 80020a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  dlp->delta      = delta;
 80020ac:	60b2      	str	r2, [r6, #8]
  dlp->delta -= delta;
 80020ae:	6899      	ldr	r1, [r3, #8]
  dlp->next       = dlhp;
 80020b0:	6033      	str	r3, [r6, #0]
  dlp->delta -= delta;
 80020b2:	1a8a      	subs	r2, r1, r2
  dlp->prev       = dlp->next->prev;
 80020b4:	6859      	ldr	r1, [r3, #4]
 80020b6:	6071      	str	r1, [r6, #4]
  dlp->prev->next = dlp;
 80020b8:	600e      	str	r6, [r1, #0]
  dlp->delta -= delta;
 80020ba:	e9c3 6201 	strd	r6, r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 80020be:	61a0      	str	r0, [r4, #24]
}
 80020c0:	e7a3      	b.n	800200a <VectorB0+0xca>
    chSysHalt("SV#9");
 80020c2:	4820      	ldr	r0, [pc, #128]	; (8002144 <VectorB0+0x204>)
 80020c4:	f7fe fcbc 	bl	8000a40 <chSysHalt>
 80020c8:	f381 8811 	msr	BASEPRI, r1
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80020cc:	2204      	movs	r2, #4
 80020ce:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80020d2:	4919      	ldr	r1, [pc, #100]	; (8002138 <VectorB0+0x1f8>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80020d4:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80020d6:	6099      	str	r1, [r3, #8]
    trace_next(oip);
 80020d8:	f7fe fc92 	bl	8000a00 <trace_next.constprop.0>
 80020dc:	f385 8811 	msr	BASEPRI, r5
}
 80020e0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 80020e4:	f7fe bc0c 	b.w	8000900 <__port_irq_epilogue>
    chSysHalt("SV#6");
 80020e8:	4817      	ldr	r0, [pc, #92]	; (8002148 <VectorB0+0x208>)
 80020ea:	f7fe fca9 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#7");
 80020ee:	4817      	ldr	r0, [pc, #92]	; (800214c <VectorB0+0x20c>)
 80020f0:	f7fe fca6 	bl	8000a40 <chSysHalt>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 80020f4:	4556      	cmp	r6, sl
 80020f6:	d004      	beq.n	8002102 <VectorB0+0x1c2>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;
 80020f8:	1a89      	subs	r1, r1, r2
  vtlp->lasttime += nowdelta;
 80020fa:	83a0      	strh	r0, [r4, #28]
  vtp->dlist.delta -= nowdelta;
 80020fc:	60b1      	str	r1, [r6, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(vtlp, now, vtp->dlist.delta);
 80020fe:	f7fe fe27 	bl	8000d50 <vt_set_alarm.constprop.0>
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002102:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8002106:	2b00      	cmp	r3, #0
 8002108:	ddf1      	ble.n	80020ee <VectorB0+0x1ae>
 800210a:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 800210e:	2b00      	cmp	r3, #0
 8002110:	dded      	ble.n	80020ee <VectorB0+0x1ae>
  oip->dbg.lock_cnt = (cnt_t)0;
 8002112:	2300      	movs	r3, #0
 8002114:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 8002118:	f383 8811 	msr	BASEPRI, r3
 800211c:	e732      	b.n	8001f84 <VectorB0+0x44>
        chDbgAssert(false, "skipped deadline");
 800211e:	480c      	ldr	r0, [pc, #48]	; (8002150 <VectorB0+0x210>)
 8002120:	f7fe fc8e 	bl	8000a40 <chSysHalt>
    chDbgAssert(dlp != dlep, "element already in list");
 8002124:	480b      	ldr	r0, [pc, #44]	; (8002154 <VectorB0+0x214>)
 8002126:	f7fe fc8b 	bl	8000a40 <chSysHalt>
        vt_insert_first(vtlp, vtp, now, delay);
 800212a:	4630      	mov	r0, r6
 800212c:	1bd2      	subs	r2, r2, r7
 800212e:	f7fe fdaf 	bl	8000c90 <vt_insert_first.constprop.0>
        return;
 8002132:	e7e6      	b.n	8002102 <VectorB0+0x1c2>
 8002134:	200010e0 	.word	0x200010e0
 8002138:	0800365c 	.word	0x0800365c
 800213c:	080035f8 	.word	0x080035f8
 8002140:	200010f0 	.word	0x200010f0
 8002144:	08003600 	.word	0x08003600
 8002148:	080035c8 	.word	0x080035c8
 800214c:	080035d0 	.word	0x080035d0
 8002150:	08003704 	.word	0x08003704
 8002154:	0800386c 	.word	0x0800386c
	...

08002160 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8002160:	4a1b      	ldr	r2, [pc, #108]	; (80021d0 <__early_init+0x70>)
 8002162:	6813      	ldr	r3, [r2, #0]
 8002164:	f043 0301 	orr.w	r3, r3, #1
 8002168:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800216a:	6813      	ldr	r3, [r2, #0]
 800216c:	0798      	lsls	r0, r3, #30
 800216e:	d5fc      	bpl.n	800216a <__early_init+0xa>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8002170:	2000      	movs	r0, #0
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8002172:	6813      	ldr	r3, [r2, #0]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8002174:	4916      	ldr	r1, [pc, #88]	; (80021d0 <__early_init+0x70>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8002176:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 800217a:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800217c:	6050      	str	r0, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800217e:	684b      	ldr	r3, [r1, #4]
 8002180:	f013 0f0c 	tst.w	r3, #12
 8002184:	d1fb      	bne.n	800217e <__early_init+0x1e>
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 8002186:	680b      	ldr	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 8002188:	4a11      	ldr	r2, [pc, #68]	; (80021d0 <__early_init+0x70>)
  RCC->CR |= RCC_CR_HSEON;
 800218a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800218e:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 8002190:	6813      	ldr	r3, [r2, #0]
 8002192:	0399      	lsls	r1, r3, #14
 8002194:	d5fc      	bpl.n	8002190 <__early_init+0x30>
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 8002196:	6853      	ldr	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8002198:	490d      	ldr	r1, [pc, #52]	; (80021d0 <__early_init+0x70>)
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 800219a:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 800219e:	6053      	str	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
 80021a0:	6813      	ldr	r3, [r2, #0]
 80021a2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80021a6:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80021a8:	680b      	ldr	r3, [r1, #0]
 80021aa:	019b      	lsls	r3, r3, #6
 80021ac:	d5fc      	bpl.n	80021a8 <__early_init+0x48>
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80021ae:	2012      	movs	r0, #18
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 80021b0:	4a08      	ldr	r2, [pc, #32]	; (80021d4 <__early_init+0x74>)
  FLASH->ACR = STM32_FLASHBITS;
 80021b2:	4b09      	ldr	r3, [pc, #36]	; (80021d8 <__early_init+0x78>)
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 80021b4:	604a      	str	r2, [r1, #4]
  FLASH->ACR = STM32_FLASHBITS;
 80021b6:	6018      	str	r0, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 80021b8:	684b      	ldr	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80021ba:	4a05      	ldr	r2, [pc, #20]	; (80021d0 <__early_init+0x70>)
  RCC->CFGR |= STM32_SW;
 80021bc:	f043 0302 	orr.w	r3, r3, #2
 80021c0:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80021c2:	6853      	ldr	r3, [r2, #4]
 80021c4:	f003 030c 	and.w	r3, r3, #12
 80021c8:	2b08      	cmp	r3, #8
 80021ca:	d1fa      	bne.n	80021c2 <__early_init+0x62>
 * any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 80021cc:	4770      	bx	lr
 80021ce:	bf00      	nop
 80021d0:	40021000 	.word	0x40021000
 80021d4:	001d6400 	.word	0x001d6400
 80021d8:	40022000 	.word	0x40022000
 80021dc:	00000000 	.word	0x00000000

080021e0 <__dbg_check_lock>:
void __dbg_check_lock(void) {
 80021e0:	b508      	push	{r3, lr}
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80021e2:	4b06      	ldr	r3, [pc, #24]	; (80021fc <__dbg_check_lock+0x1c>)
 80021e4:	e9d3 123a 	ldrd	r1, r2, [r3, #232]	; 0xe8
 80021e8:	430a      	orrs	r2, r1
 80021ea:	d103      	bne.n	80021f4 <__dbg_check_lock+0x14>
  oip->dbg.lock_cnt = (cnt_t)1;
 80021ec:	2201      	movs	r2, #1
 80021ee:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
}
 80021f2:	bd08      	pop	{r3, pc}
    chSysHalt("SV#4");
 80021f4:	4802      	ldr	r0, [pc, #8]	; (8002200 <__dbg_check_lock+0x20>)
 80021f6:	f7fe fc23 	bl	8000a40 <chSysHalt>
 80021fa:	bf00      	nop
 80021fc:	200010e0 	.word	0x200010e0
 8002200:	080035c0 	.word	0x080035c0
	...

08002210 <chThdCreateStatic.constprop.0.isra.0>:
thread_t *chThdCreateStatic(stkline_t *wbase, size_t wsize,
 8002210:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002214:	2330      	movs	r3, #48	; 0x30
 8002216:	4606      	mov	r6, r0
 8002218:	4689      	mov	r9, r1
 800221a:	b089      	sub	sp, #36	; 0x24
 800221c:	f383 8811 	msr	BASEPRI, r3
thread_t *chRegFirstThread(void) {
  thread_t *tp;
  uint8_t *p;

  chSysLock();
  p = (uint8_t *)REG_HEADER(currcore)->next;
 8002220:	4c97      	ldr	r4, [pc, #604]	; (8002480 <chThdCreateStatic.constprop.0.isra.0+0x270>)
  __dbg_check_lock();
 8002222:	f7ff ffdd 	bl	80021e0 <__dbg_check_lock>
 8002226:	6b23      	ldr	r3, [r4, #48]	; 0x30
  /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
  tp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
  /*lint -restore*/
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8002228:	f813 2c06 	ldrb.w	r2, [r3, #-6]
 800222c:	3201      	adds	r2, #1
 800222e:	f803 2c06 	strb.w	r2, [r3, #-6]
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002232:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
 8002236:	2a00      	cmp	r2, #0
 8002238:	d15e      	bne.n	80022f8 <chThdCreateStatic.constprop.0.isra.0+0xe8>
 800223a:	f8d4 10ec 	ldr.w	r1, [r4, #236]	; 0xec
 800223e:	2900      	cmp	r1, #0
 8002240:	dd5a      	ble.n	80022f8 <chThdCreateStatic.constprop.0.isra.0+0xe8>
  oip->dbg.lock_cnt = (cnt_t)0;
 8002242:	f8c4 20ec 	str.w	r2, [r4, #236]	; 0xec
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8002246:	6822      	ldr	r2, [r4, #0]
 8002248:	42a2      	cmp	r2, r4
 800224a:	d14d      	bne.n	80022e8 <chThdCreateStatic.constprop.0.isra.0+0xd8>
 800224c:	2200      	movs	r2, #0
  tp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 800224e:	3b24      	subs	r3, #36	; 0x24
 8002250:	f382 8811 	msr	BASEPRI, r2
 8002254:	2730      	movs	r7, #48	; 0x30
  oip->dbg.lock_cnt = (cnt_t)1;
 8002256:	2101      	movs	r1, #1

  chSysLock();

  /* Next element in the registry queue.*/
  nqp = tp->rqueue.next;
  if (nqp == REG_HEADER(currcore)) {
 8002258:	f8df 8228 	ldr.w	r8, [pc, #552]	; 8002484 <chThdCreateStatic.constprop.0.isra.0+0x274>
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 800225c:	695a      	ldr	r2, [r3, #20]
 800225e:	4296      	cmp	r6, r2
 8002260:	f000 80f3 	beq.w	800244a <chThdCreateStatic.constprop.0.isra.0+0x23a>
 8002264:	f387 8811 	msr	BASEPRI, r7
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002268:	e9d4 253a 	ldrd	r2, r5, [r4, #232]	; 0xe8
 800226c:	4315      	orrs	r5, r2
 800226e:	d138      	bne.n	80022e2 <chThdCreateStatic.constprop.0.isra.0+0xd2>
  nqp = tp->rqueue.next;
 8002270:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  oip->dbg.lock_cnt = (cnt_t)1;
 8002272:	f8c4 10ec 	str.w	r1, [r4, #236]	; 0xec
  if (nqp == REG_HEADER(currcore)) {
 8002276:	4542      	cmp	r2, r8
 8002278:	d009      	beq.n	800228e <chThdCreateStatic.constprop.0.isra.0+0x7e>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 800227a:	f812 0c06 	ldrb.w	r0, [r2, #-6]
    ntp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 800227e:	f1a2 0524 	sub.w	r5, r2, #36	; 0x24
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8002282:	28ff      	cmp	r0, #255	; 0xff
 8002284:	f000 80c4 	beq.w	8002410 <chThdCreateStatic.constprop.0.isra.0+0x200>
    ntp->refs++;
 8002288:	3001      	adds	r0, #1
 800228a:	f802 0c06 	strb.w	r0, [r2, #-6]
  oip->dbg.lock_cnt = (cnt_t)0;
 800228e:	2200      	movs	r2, #0
 8002290:	f8c4 20ec 	str.w	r2, [r4, #236]	; 0xec
 8002294:	6822      	ldr	r2, [r4, #0]
 8002296:	42a2      	cmp	r2, r4
 8002298:	f040 80bd 	bne.w	8002416 <chThdCreateStatic.constprop.0.isra.0+0x206>
 800229c:	2200      	movs	r2, #0
 800229e:	f382 8811 	msr	BASEPRI, r2
 80022a2:	f387 8811 	msr	BASEPRI, r7
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80022a6:	e9d4 023a 	ldrd	r0, r2, [r4, #232]	; 0xe8
 80022aa:	4302      	orrs	r2, r0
 80022ac:	d119      	bne.n	80022e2 <chThdCreateStatic.constprop.0.isra.0+0xd2>
  oip->dbg.lock_cnt = (cnt_t)1;
 80022ae:	f8c4 10ec 	str.w	r1, [r4, #236]	; 0xec
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80022b2:	7f98      	ldrb	r0, [r3, #30]
 80022b4:	2800      	cmp	r0, #0
 80022b6:	f000 80b5 	beq.w	8002424 <chThdCreateStatic.constprop.0.isra.0+0x214>
  tp->refs--;
 80022ba:	3801      	subs	r0, #1
 80022bc:	7798      	strb	r0, [r3, #30]
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80022be:	69d8      	ldr	r0, [r3, #28]
 80022c0:	f000 1cff 	and.w	ip, r0, #16711935	; 0xff00ff
 80022c4:	f1bc 0f0f 	cmp.w	ip, #15
 80022c8:	d019      	beq.n	80022fe <chThdCreateStatic.constprop.0.isra.0+0xee>
 80022ca:	6823      	ldr	r3, [r4, #0]
  oip->dbg.lock_cnt = (cnt_t)0;
 80022cc:	f8c4 20ec 	str.w	r2, [r4, #236]	; 0xec
 80022d0:	42a3      	cmp	r3, r4
 80022d2:	f040 8091 	bne.w	80023f8 <chThdCreateStatic.constprop.0.isra.0+0x1e8>
 80022d6:	2300      	movs	r3, #0
 80022d8:	f383 8811 	msr	BASEPRI, r3
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 80022dc:	b32d      	cbz	r5, 800232a <chThdCreateStatic.constprop.0.isra.0+0x11a>
 80022de:	462b      	mov	r3, r5
 80022e0:	e7bc      	b.n	800225c <chThdCreateStatic.constprop.0.isra.0+0x4c>
    chSysHalt("SV#4");
 80022e2:	4869      	ldr	r0, [pc, #420]	; (8002488 <chThdCreateStatic.constprop.0.isra.0+0x278>)
 80022e4:	f7fe fbac 	bl	8000a40 <chSysHalt>
 80022e8:	68e1      	ldr	r1, [r4, #12]
 80022ea:	6892      	ldr	r2, [r2, #8]
 80022ec:	6889      	ldr	r1, [r1, #8]
 80022ee:	4291      	cmp	r1, r2
 80022f0:	d2ac      	bcs.n	800224c <chThdCreateStatic.constprop.0.isra.0+0x3c>
 80022f2:	4866      	ldr	r0, [pc, #408]	; (800248c <chThdCreateStatic.constprop.0.isra.0+0x27c>)
 80022f4:	f7fe fba4 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#5");
 80022f8:	4865      	ldr	r0, [pc, #404]	; (8002490 <chThdCreateStatic.constprop.0.isra.0+0x280>)
 80022fa:	f7fe fba1 	bl	8000a40 <chSysHalt>
  p->prev->next = p->next;
 80022fe:	e9d3 0c09 	ldrd	r0, ip, [r3, #36]	; 0x24
 8002302:	f8cc 0000 	str.w	r0, [ip]
  p->next->prev = p->prev;
 8002306:	f8c0 c004 	str.w	ip, [r0, #4]
  oip->dbg.lock_cnt = (cnt_t)0;
 800230a:	f8c4 20ec 	str.w	r2, [r4, #236]	; 0xec
 800230e:	6822      	ldr	r2, [r4, #0]
 8002310:	42a2      	cmp	r2, r4
 8002312:	f040 809d 	bne.w	8002450 <chThdCreateStatic.constprop.0.isra.0+0x240>
 8002316:	2200      	movs	r2, #0
 8002318:	f382 8811 	msr	BASEPRI, r2
    if (tp->dispose != NULL) {
 800231c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800231e:	2a00      	cmp	r2, #0
 8002320:	d0dc      	beq.n	80022dc <chThdCreateStatic.constprop.0.isra.0+0xcc>
      tp->dispose(tp);
 8002322:	4618      	mov	r0, r3
 8002324:	4790      	blx	r2
 8002326:	2101      	movs	r1, #1
 8002328:	e7d8      	b.n	80022dc <chThdCreateStatic.constprop.0.isra.0+0xcc>
    *startp++ = CH_DBG_STACK_FILL_VALUE;
 800232a:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 800232e:	2155      	movs	r1, #85	; 0x55
 8002330:	4630      	mov	r0, r6
 8002332:	f001 f8e9 	bl	8003508 <memset>
  THD_DESC_DECL(desc, "noname", wbase, wend, prio, func, arg, currcore, NULL);
 8002336:	4b57      	ldr	r3, [pc, #348]	; (8002494 <chThdCreateStatic.constprop.0.isra.0+0x284>)
  tp = chThdObjectInit(threadref(stktop), &desc);
 8002338:	a901      	add	r1, sp, #4
  THD_DESC_DECL(desc, "noname", wbase, wend, prio, func, arg, currcore, NULL);
 800233a:	e9cd 3601 	strd	r3, r6, [sp, #4]
  wend = (uint8_t *)wbase + wsize;
 800233e:	f506 7308 	add.w	r3, r6, #544	; 0x220
  THD_DESC_DECL(desc, "noname", wbase, wend, prio, func, arg, currcore, NULL);
 8002342:	9303      	str	r3, [sp, #12]
 8002344:	2380      	movs	r3, #128	; 0x80
  tp = chThdObjectInit(threadref(stktop), &desc);
 8002346:	f506 70e0 	add.w	r0, r6, #448	; 0x1c0
  THD_DESC_DECL(desc, "noname", wbase, wend, prio, func, arg, currcore, NULL);
 800234a:	9304      	str	r3, [sp, #16]
 800234c:	e9cd 9505 	strd	r9, r5, [sp, #20]
 8002350:	9407      	str	r4, [sp, #28]
  tp = chThdObjectInit(threadref(stktop), &desc);
 8002352:	f7fe fbfd 	bl	8000b50 <chThdObjectInit>
  PORT_SETUP_CONTEXT(tp, wbase, tp, func, arg);
 8002356:	4a50      	ldr	r2, [pc, #320]	; (8002498 <chThdCreateStatic.constprop.0.isra.0+0x288>)
 8002358:	f1a0 0124 	sub.w	r1, r0, #36	; 0x24
 800235c:	2330      	movs	r3, #48	; 0x30
  tp = chThdObjectInit(threadref(stktop), &desc);
 800235e:	4606      	mov	r6, r0
  PORT_SETUP_CONTEXT(tp, wbase, tp, func, arg);
 8002360:	e940 9509 	strd	r9, r5, [r0, #-36]	; 0x24
 8002364:	60c1      	str	r1, [r0, #12]
 8002366:	f840 2c04 	str.w	r2, [r0, #-4]
 800236a:	f383 8811 	msr	BASEPRI, r3
  __dbg_check_lock();
 800236e:	f7ff ff37 	bl	80021e0 <__dbg_check_lock>
  REG_INSERT(tp->owner, tp);
 8002372:	6933      	ldr	r3, [r6, #16]
 8002374:	f106 0224 	add.w	r2, r6, #36	; 0x24
 8002378:	f103 0130 	add.w	r1, r3, #48	; 0x30
  p->next       = qp;
 800237c:	6271      	str	r1, [r6, #36]	; 0x24
  p->prev       = qp->prev;
 800237e:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8002380:	62b1      	str	r1, [r6, #40]	; 0x28
  p->prev->next = p;
 8002382:	600a      	str	r2, [r1, #0]
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002384:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
  qp->prev      = p;
 8002388:	635a      	str	r2, [r3, #52]	; 0x34
 800238a:	2900      	cmp	r1, #0
 800238c:	d13d      	bne.n	800240a <chThdCreateStatic.constprop.0.isra.0+0x1fa>
 800238e:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8002392:	2b00      	cmp	r3, #0
 8002394:	dd39      	ble.n	800240a <chThdCreateStatic.constprop.0.isra.0+0x1fa>
  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 8002396:	6822      	ldr	r2, [r4, #0]
  thread_t *otp = __instance_get_currthread(oip);
 8002398:	68e0      	ldr	r0, [r4, #12]
  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 800239a:	42a2      	cmp	r2, r4
 800239c:	6883      	ldr	r3, [r0, #8]
 800239e:	d162      	bne.n	8002466 <chThdCreateStatic.constprop.0.isra.0+0x256>
  ntp->u.rdymsg = msg;
 80023a0:	2100      	movs	r1, #0
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 80023a2:	68b2      	ldr	r2, [r6, #8]
  ntp->u.rdymsg = msg;
 80023a4:	6371      	str	r1, [r6, #52]	; 0x34
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 80023a6:	429a      	cmp	r2, r3
 80023a8:	d959      	bls.n	800245e <chThdCreateStatic.constprop.0.isra.0+0x24e>
    otp = __sch_ready_ahead(otp);
 80023aa:	f7fe fba1 	bl	8000af0 <__sch_ready_ahead>
    ntp->state = CH_STATE_CURRENT;
 80023ae:	2301      	movs	r3, #1
 80023b0:	7733      	strb	r3, [r6, #28]
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80023b2:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
    otp = __sch_ready_ahead(otp);
 80023b6:	4605      	mov	r5, r0
 80023b8:	079b      	lsls	r3, r3, #30
    __instance_set_currthread(oip, ntp);
 80023ba:	60e6      	str	r6, [r4, #12]
 80023bc:	d538      	bpl.n	8002430 <chThdCreateStatic.constprop.0.isra.0+0x220>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80023be:	f3ef 8309 	mrs	r3, PSP
    chSysSwitch(ntp, otp);
 80023c2:	696a      	ldr	r2, [r5, #20]
 80023c4:	3b24      	subs	r3, #36	; 0x24
 80023c6:	429a      	cmp	r2, r3
 80023c8:	d82f      	bhi.n	800242a <chThdCreateStatic.constprop.0.isra.0+0x21a>
 80023ca:	4629      	mov	r1, r5
 80023cc:	4630      	mov	r0, r6
 80023ce:	f7fd ff37 	bl	8000240 <__port_switch>
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80023d2:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80023d6:	2b00      	cmp	r3, #0
 80023d8:	d18e      	bne.n	80022f8 <chThdCreateStatic.constprop.0.isra.0+0xe8>
 80023da:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 80023de:	2a00      	cmp	r2, #0
 80023e0:	dd8a      	ble.n	80022f8 <chThdCreateStatic.constprop.0.isra.0+0xe8>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80023e2:	6822      	ldr	r2, [r4, #0]
  oip->dbg.lock_cnt = (cnt_t)0;
 80023e4:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 80023e8:	42a2      	cmp	r2, r4
 80023ea:	d142      	bne.n	8002472 <chThdCreateStatic.constprop.0.isra.0+0x262>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80023ec:	2300      	movs	r3, #0
 80023ee:	f383 8811 	msr	BASEPRI, r3
}
 80023f2:	b009      	add	sp, #36	; 0x24
 80023f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80023f8:	689a      	ldr	r2, [r3, #8]
 80023fa:	68e3      	ldr	r3, [r4, #12]
 80023fc:	689b      	ldr	r3, [r3, #8]
 80023fe:	4293      	cmp	r3, r2
 8002400:	f4bf af69 	bcs.w	80022d6 <chThdCreateStatic.constprop.0.isra.0+0xc6>
 8002404:	4825      	ldr	r0, [pc, #148]	; (800249c <chThdCreateStatic.constprop.0.isra.0+0x28c>)
 8002406:	f7fe fb1b 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#11");
 800240a:	4825      	ldr	r0, [pc, #148]	; (80024a0 <chThdCreateStatic.constprop.0.isra.0+0x290>)
 800240c:	f7fe fb18 	bl	8000a40 <chSysHalt>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8002410:	4824      	ldr	r0, [pc, #144]	; (80024a4 <chThdCreateStatic.constprop.0.isra.0+0x294>)
 8002412:	f7fe fb15 	bl	8000a40 <chSysHalt>
 8002416:	6890      	ldr	r0, [r2, #8]
 8002418:	68e2      	ldr	r2, [r4, #12]
 800241a:	6892      	ldr	r2, [r2, #8]
 800241c:	4282      	cmp	r2, r0
 800241e:	f4bf af3d 	bcs.w	800229c <chThdCreateStatic.constprop.0.isra.0+0x8c>
 8002422:	e766      	b.n	80022f2 <chThdCreateStatic.constprop.0.isra.0+0xe2>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8002424:	4820      	ldr	r0, [pc, #128]	; (80024a8 <chThdCreateStatic.constprop.0.isra.0+0x298>)
 8002426:	f7fe fb0b 	bl	8000a40 <chSysHalt>
 800242a:	4820      	ldr	r0, [pc, #128]	; (80024ac <chThdCreateStatic.constprop.0.isra.0+0x29c>)
 800242c:	f7fe fb08 	bl	8000a40 <chSysHalt>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002430:	7f03      	ldrb	r3, [r0, #28]
 8002432:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8002434:	f8d4 20f4 	ldr.w	r2, [r4, #244]	; 0xf4
 8002438:	00db      	lsls	r3, r3, #3
 800243a:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800243e:	60d1      	str	r1, [r2, #12]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002440:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.sw.ntp    = ntp;
 8002442:	6096      	str	r6, [r2, #8]
    trace_next(oip);
 8002444:	f7fe fadc 	bl	8000a00 <trace_next.constprop.0>
 8002448:	e7b9      	b.n	80023be <chThdCreateStatic.constprop.0.isra.0+0x1ae>
  chDbgAssert(chRegFindThreadByWorkingArea(wbase) == NULL,
 800244a:	4819      	ldr	r0, [pc, #100]	; (80024b0 <chThdCreateStatic.constprop.0.isra.0+0x2a0>)
 800244c:	f7fe faf8 	bl	8000a40 <chSysHalt>
 8002450:	6890      	ldr	r0, [r2, #8]
 8002452:	68e2      	ldr	r2, [r4, #12]
 8002454:	6892      	ldr	r2, [r2, #8]
 8002456:	4282      	cmp	r2, r0
 8002458:	f4bf af5d 	bcs.w	8002316 <chThdCreateStatic.constprop.0.isra.0+0x106>
 800245c:	e7d2      	b.n	8002404 <chThdCreateStatic.constprop.0.isra.0+0x1f4>
    (void) __sch_ready_behind(ntp);
 800245e:	4630      	mov	r0, r6
 8002460:	f7fe fcb6 	bl	8000dd0 <__sch_ready_behind.isra.0>
 8002464:	e7b5      	b.n	80023d2 <chThdCreateStatic.constprop.0.isra.0+0x1c2>
  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 8002466:	6892      	ldr	r2, [r2, #8]
 8002468:	4293      	cmp	r3, r2
 800246a:	d299      	bcs.n	80023a0 <chThdCreateStatic.constprop.0.isra.0+0x190>
 800246c:	4811      	ldr	r0, [pc, #68]	; (80024b4 <chThdCreateStatic.constprop.0.isra.0+0x2a4>)
 800246e:	f7fe fae7 	bl	8000a40 <chSysHalt>
 8002472:	68e1      	ldr	r1, [r4, #12]
 8002474:	6893      	ldr	r3, [r2, #8]
 8002476:	688a      	ldr	r2, [r1, #8]
 8002478:	429a      	cmp	r2, r3
 800247a:	d2b7      	bcs.n	80023ec <chThdCreateStatic.constprop.0.isra.0+0x1dc>
 800247c:	e7c2      	b.n	8002404 <chThdCreateStatic.constprop.0.isra.0+0x1f4>
 800247e:	bf00      	nop
 8002480:	200010e0 	.word	0x200010e0
 8002484:	20001110 	.word	0x20001110
 8002488:	080035c0 	.word	0x080035c0
 800248c:	08003720 	.word	0x08003720
 8002490:	080035f0 	.word	0x080035f0
 8002494:	08003608 	.word	0x08003608
 8002498:	08000251 	.word	0x08000251
 800249c:	08003788 	.word	0x08003788
 80024a0:	080035d8 	.word	0x080035d8
 80024a4:	080036a8 	.word	0x080036a8
 80024a8:	08003764 	.word	0x08003764
 80024ac:	080035e0 	.word	0x080035e0
 80024b0:	08003774 	.word	0x08003774
 80024b4:	08003710 	.word	0x08003710
	...

080024c0 <__dbg_check_unlock>:
void __dbg_check_unlock(void) {
 80024c0:	b508      	push	{r3, lr}
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80024c2:	4b07      	ldr	r3, [pc, #28]	; (80024e0 <__dbg_check_unlock+0x20>)
 80024c4:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 80024c8:	b932      	cbnz	r2, 80024d8 <__dbg_check_unlock+0x18>
 80024ca:	f8d3 10ec 	ldr.w	r1, [r3, #236]	; 0xec
 80024ce:	2900      	cmp	r1, #0
 80024d0:	dd02      	ble.n	80024d8 <__dbg_check_unlock+0x18>
  oip->dbg.lock_cnt = (cnt_t)0;
 80024d2:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
}
 80024d6:	bd08      	pop	{r3, pc}
    chSysHalt("SV#5");
 80024d8:	4802      	ldr	r0, [pc, #8]	; (80024e4 <__dbg_check_unlock+0x24>)
 80024da:	f7fe fab1 	bl	8000a40 <chSysHalt>
 80024de:	bf00      	nop
 80024e0:	200010e0 	.word	0x200010e0
 80024e4:	080035f0 	.word	0x080035f0
	...

080024f0 <chSchDoPreemption>:
  ntp->state = CH_STATE_CURRENT;
 80024f0:	2201      	movs	r2, #1
static void __sch_reschedule_ahead(void) {
 80024f2:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = __instance_get_currthread(oip);
 80024f4:	4c17      	ldr	r4, [pc, #92]	; (8002554 <chSchDoPreemption+0x64>)
  ch_priority_queue_t *p = pqp->next;
 80024f6:	6826      	ldr	r6, [r4, #0]
 80024f8:	68e0      	ldr	r0, [r4, #12]
  pqp->next       = p->next;
 80024fa:	6833      	ldr	r3, [r6, #0]
  pqp->next->prev = pqp;
 80024fc:	605c      	str	r4, [r3, #4]
  ntp->state = CH_STATE_CURRENT;
 80024fe:	7732      	strb	r2, [r6, #28]
  pqp->next       = p->next;
 8002500:	6023      	str	r3, [r4, #0]
  __instance_set_currthread(oip, ntp);
 8002502:	60e6      	str	r6, [r4, #12]
  otp = __sch_ready_ahead(otp);
 8002504:	f7fe faf4 	bl	8000af0 <__sch_ready_ahead>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002508:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
 800250c:	4605      	mov	r5, r0
 800250e:	079b      	lsls	r3, r3, #30
 8002510:	d50b      	bpl.n	800252a <chSchDoPreemption+0x3a>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002512:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(ntp, otp);
 8002516:	696a      	ldr	r2, [r5, #20]
 8002518:	3b24      	subs	r3, #36	; 0x24
 800251a:	429a      	cmp	r2, r3
 800251c:	d817      	bhi.n	800254e <chSchDoPreemption+0x5e>
 800251e:	4629      	mov	r1, r5
 8002520:	4630      	mov	r0, r6
}
 8002522:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(ntp, otp);
 8002526:	f7fd be8b 	b.w	8000240 <__port_switch>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800252a:	7f03      	ldrb	r3, [r0, #28]
 800252c:	6b41      	ldr	r1, [r0, #52]	; 0x34
 800252e:	f8d4 20f4 	ldr.w	r2, [r4, #244]	; 0xf4
 8002532:	00db      	lsls	r3, r3, #3
 8002534:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002538:	e9c2 6102 	strd	r6, r1, [r2, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800253c:	7013      	strb	r3, [r2, #0]
    trace_next(oip);
 800253e:	f7fe fa5f 	bl	8000a00 <trace_next.constprop.0>
 8002542:	f3ef 8309 	mrs	r3, PSP
 8002546:	696a      	ldr	r2, [r5, #20]
 8002548:	3b24      	subs	r3, #36	; 0x24
 800254a:	429a      	cmp	r2, r3
 800254c:	d9e7      	bls.n	800251e <chSchDoPreemption+0x2e>
 800254e:	4802      	ldr	r0, [pc, #8]	; (8002558 <chSchDoPreemption+0x68>)
 8002550:	f7fe fa76 	bl	8000a40 <chSysHalt>
 8002554:	200010e0 	.word	0x200010e0
 8002558:	080035e0 	.word	0x080035e0
 800255c:	00000000 	.word	0x00000000

08002560 <chMtxUnlock.constprop.0>:
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002562:	4c33      	ldr	r4, [pc, #204]	; (8002630 <chMtxUnlock.constprop.0+0xd0>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002564:	2330      	movs	r3, #48	; 0x30
 8002566:	68e1      	ldr	r1, [r4, #12]
 8002568:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 800256c:	e9d4 323a 	ldrd	r3, r2, [r4, #232]	; 0xe8
 8002570:	431a      	orrs	r2, r3
 8002572:	d14f      	bne.n	8002614 <chMtxUnlock.constprop.0+0xb4>
  oip->dbg.lock_cnt = (cnt_t)1;
 8002574:	2001      	movs	r0, #1

  chDbgCheck(mp != NULL);

  chSysLock();

  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 8002576:	6c8b      	ldr	r3, [r1, #72]	; 0x48
 8002578:	f8c4 00ec 	str.w	r0, [r4, #236]	; 0xec
 800257c:	2b00      	cmp	r3, #0
 800257e:	d046      	beq.n	800260e <chMtxUnlock.constprop.0+0xae>
  chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 8002580:	6898      	ldr	r0, [r3, #8]
 8002582:	4281      	cmp	r1, r0
 8002584:	d143      	bne.n	800260e <chMtxUnlock.constprop.0+0xae>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(currtp->mtxlist == mp, "not next in list");
 8002586:	4d2b      	ldr	r5, [pc, #172]	; (8002634 <chMtxUnlock.constprop.0+0xd4>)
 8002588:	f105 060c 	add.w	r6, r5, #12
 800258c:	42b3      	cmp	r3, r6
 800258e:	d13e      	bne.n	800260e <chMtxUnlock.constprop.0+0xae>
  return (bool)(qp->next != qp);
 8002590:	68e8      	ldr	r0, [r5, #12]

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
 8002592:	69ab      	ldr	r3, [r5, #24]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002594:	42b0      	cmp	r0, r6
    currtp->mtxlist = mp->next;
 8002596:	648b      	str	r3, [r1, #72]	; 0x48
    if (chMtxQueueNotEmptyS(mp)) {
 8002598:	d02e      	beq.n	80025f8 <chMtxUnlock.constprop.0+0x98>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 800259a:	6ccf      	ldr	r7, [r1, #76]	; 0x4c
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
 800259c:	b14b      	cbz	r3, 80025b2 <chMtxUnlock.constprop.0+0x52>
 800259e:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80025a0:	4293      	cmp	r3, r2
 80025a2:	d003      	beq.n	80025ac <chMtxUnlock.constprop.0+0x4c>
 80025a4:	6892      	ldr	r2, [r2, #8]
 80025a6:	4297      	cmp	r7, r2
 80025a8:	bf38      	it	cc
 80025aa:	4617      	movcc	r7, r2
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
 80025ac:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 80025ae:	2b00      	cmp	r3, #0
 80025b0:	d1f5      	bne.n	800259e <chMtxUnlock.constprop.0+0x3e>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 80025b2:	608f      	str	r7, [r1, #8]
  qp->next       = p->next;
 80025b4:	6803      	ldr	r3, [r0, #0]
 80025b6:	60eb      	str	r3, [r5, #12]
  qp->next->prev = qp;
 80025b8:	605e      	str	r6, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80025ba:	6c83      	ldr	r3, [r0, #72]	; 0x48
      tp->mtxlist = mp;
 80025bc:	6486      	str	r6, [r0, #72]	; 0x48
      mp->next = tp->mtxlist;
 80025be:	e9c5 0305 	strd	r0, r3, [r5, #20]
  return __sch_ready_behind(tp);
 80025c2:	f7fe fc05 	bl	8000dd0 <__sch_ready_behind.isra.0>
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80025c6:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80025ca:	bb33      	cbnz	r3, 800261a <chMtxUnlock.constprop.0+0xba>
 80025cc:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 80025d0:	2b00      	cmp	r3, #0
 80025d2:	dd22      	ble.n	800261a <chMtxUnlock.constprop.0+0xba>
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 80025d4:	6822      	ldr	r2, [r4, #0]
 80025d6:	68e3      	ldr	r3, [r4, #12]
 80025d8:	6892      	ldr	r2, [r2, #8]
 80025da:	689b      	ldr	r3, [r3, #8]
 80025dc:	429a      	cmp	r2, r3
 80025de:	d90c      	bls.n	80025fa <chMtxUnlock.constprop.0+0x9a>
    __sch_reschedule_ahead();
 80025e0:	f7ff ff86 	bl	80024f0 <chSchDoPreemption>
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80025e4:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80025e8:	b91b      	cbnz	r3, 80025f2 <chMtxUnlock.constprop.0+0x92>
 80025ea:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 80025ee:	2b00      	cmp	r3, #0
 80025f0:	dc03      	bgt.n	80025fa <chMtxUnlock.constprop.0+0x9a>
    chSysHalt("SV#5");
 80025f2:	4811      	ldr	r0, [pc, #68]	; (8002638 <chMtxUnlock.constprop.0+0xd8>)
 80025f4:	f7fe fa24 	bl	8000a40 <chSysHalt>
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 80025f8:	616a      	str	r2, [r5, #20]
  oip->dbg.lock_cnt = (cnt_t)0;
 80025fa:	2200      	movs	r2, #0
 80025fc:	6823      	ldr	r3, [r4, #0]
 80025fe:	f8c4 20ec 	str.w	r2, [r4, #236]	; 0xec
 8002602:	42a3      	cmp	r3, r4
 8002604:	d10c      	bne.n	8002620 <chMtxUnlock.constprop.0+0xc0>
 8002606:	2300      	movs	r3, #0
 8002608:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 800260c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 800260e:	480b      	ldr	r0, [pc, #44]	; (800263c <chMtxUnlock.constprop.0+0xdc>)
 8002610:	f7fe fa16 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#4");
 8002614:	480a      	ldr	r0, [pc, #40]	; (8002640 <chMtxUnlock.constprop.0+0xe0>)
 8002616:	f7fe fa13 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#11");
 800261a:	480a      	ldr	r0, [pc, #40]	; (8002644 <chMtxUnlock.constprop.0+0xe4>)
 800261c:	f7fe fa10 	bl	8000a40 <chSysHalt>
 8002620:	68e2      	ldr	r2, [r4, #12]
 8002622:	689b      	ldr	r3, [r3, #8]
 8002624:	6892      	ldr	r2, [r2, #8]
 8002626:	429a      	cmp	r2, r3
 8002628:	d2ed      	bcs.n	8002606 <chMtxUnlock.constprop.0+0xa6>
 800262a:	4807      	ldr	r0, [pc, #28]	; (8002648 <chMtxUnlock.constprop.0+0xe8>)
 800262c:	f7fe fa08 	bl	8000a40 <chSysHalt>
 8002630:	200010e0 	.word	0x200010e0
 8002634:	20000c40 	.word	0x20000c40
 8002638:	080035f0 	.word	0x080035f0
 800263c:	0800372c 	.word	0x0800372c
 8002640:	080035c0 	.word	0x080035c0
 8002644:	080035d8 	.word	0x080035d8
 8002648:	08003844 	.word	0x08003844
 800264c:	00000000 	.word	0x00000000

08002650 <PollAccelThread>:

/*
 * Accelerometer polling thread.
 */
static THD_WORKING_AREA(PollAccelThreadWA, 256);
static THD_FUNCTION(PollAccelThread, arg) {
 8002650:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8002654:	4c80      	ldr	r4, [pc, #512]	; (8002858 <PollAccelThread+0x208>)
 8002656:	4981      	ldr	r1, [pc, #516]	; (800285c <PollAccelThread+0x20c>)
 8002658:	68e2      	ldr	r2, [r4, #12]
 800265a:	2330      	movs	r3, #48	; 0x30
 800265c:	b085      	sub	sp, #20
 800265e:	6211      	str	r1, [r2, #32]
 8002660:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002664:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8002668:	2b00      	cmp	r3, #0
 800266a:	f040 80d4 	bne.w	8002816 <PollAccelThread+0x1c6>
static void raw2g(uint8_t *raw, float *g) {
  int16_t tmp;

  for (size_t i=0; i<3; i++){
    tmp = raw[i*2] | (raw[i*2+1] << 8);
    g[i] = (float)tmp / 16384.0; /* convert raw value to G */
 800266e:	f04f 5762 	mov.w	r7, #947912704	; 0x38800000
void lis3GetAcc(float *result) {
  msg_t status = MSG_OK;
  sysinterval_t tmo = TIME_MS2I(4);

  /* read in burst mode */
  memset(accel_rx_data, 0x55, sizeof(accel_rx_data));
 8002672:	4d7b      	ldr	r5, [pc, #492]	; (8002860 <PollAccelThread+0x210>)
 8002674:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8002678:	2b00      	cmp	r3, #0
 800267a:	f040 80cc 	bne.w	8002816 <PollAccelThread+0x1c6>
  oip->dbg.lock_cnt = (cnt_t)1;
 800267e:	2301      	movs	r3, #1
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8002680:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8002684:	2008      	movs	r0, #8
 8002686:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 800268a:	f7fe fcd1 	bl	8001030 <chSchGoSleepTimeoutS>
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 800268e:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8002692:	2b00      	cmp	r3, #0
 8002694:	f040 80c2 	bne.w	800281c <PollAccelThread+0x1cc>
 8002698:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 800269c:	2a00      	cmp	r2, #0
 800269e:	f340 80bd 	ble.w	800281c <PollAccelThread+0x1cc>
  oip->dbg.lock_cnt = (cnt_t)0;
 80026a2:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 80026a6:	6823      	ldr	r3, [r4, #0]
 80026a8:	42a3      	cmp	r3, r4
 80026aa:	f040 80bd 	bne.w	8002828 <PollAccelThread+0x1d8>
 80026ae:	2300      	movs	r3, #0
 80026b0:	f383 8811 	msr	BASEPRI, r3
 80026b4:	f04f 3355 	mov.w	r3, #1431655765	; 0x55555555
  accel_tx_data[0] = ACCEL_OUT_DATA | AUTO_INCREMENT_BIT;
 80026b8:	22a8      	movs	r2, #168	; 0xa8
 80026ba:	4e6a      	ldr	r6, [pc, #424]	; (8002864 <PollAccelThread+0x214>)
  memset(accel_rx_data, 0x55, sizeof(accel_rx_data));
 80026bc:	e9c5 3300 	strd	r3, r3, [r5]
  accel_tx_data[0] = ACCEL_OUT_DATA | AUTO_INCREMENT_BIT;
 80026c0:	7032      	strb	r2, [r6, #0]
 80026c2:	2330      	movs	r3, #48	; 0x30
 80026c4:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80026c8:	e9d4 233a 	ldrd	r2, r3, [r4, #232]	; 0xe8
 80026cc:	4313      	orrs	r3, r2
 80026ce:	f040 80a2 	bne.w	8002816 <PollAccelThread+0x1c6>
  oip->dbg.lock_cnt = (cnt_t)1;
 80026d2:	2301      	movs	r3, #1
 80026d4:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
  chMtxLockS(mp);
 80026d8:	f7fe fe4a 	bl	8001370 <chMtxLockS.constprop.0>
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80026dc:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80026e0:	2b00      	cmp	r3, #0
 80026e2:	f040 809b 	bne.w	800281c <PollAccelThread+0x1cc>
 80026e6:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 80026ea:	2a00      	cmp	r2, #0
 80026ec:	f340 8096 	ble.w	800281c <PollAccelThread+0x1cc>
  oip->dbg.lock_cnt = (cnt_t)0;
 80026f0:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 80026f4:	6823      	ldr	r3, [r4, #0]
 80026f6:	42a3      	cmp	r3, r4
 80026f8:	f040 809f 	bne.w	800283a <PollAccelThread+0x1ea>
 80026fc:	2300      	movs	r3, #0
 80026fe:	f383 8811 	msr	BASEPRI, r3
  i2cAcquireBus(&I2CD1);
  status = i2cMasterTransmitTimeout(&I2CD1, addr,
 8002702:	2206      	movs	r2, #6
 8002704:	2001      	movs	r0, #1
 8002706:	4956      	ldr	r1, [pc, #344]	; (8002860 <PollAccelThread+0x210>)
 8002708:	f7fe fd2a 	bl	8001160 <i2cMasterTransmitTimeout.constprop.0>
 800270c:	4680      	mov	r8, r0
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 800270e:	f7ff ff27 	bl	8002560 <chMtxUnlock.constprop.0>
                          accel_tx_data, 1, accel_rx_data, 6, tmo);
  i2cReleaseBus(&I2CD1);
  osalDbgCheck(MSG_OK == status);
 8002712:	f1b8 0f00 	cmp.w	r8, #0
 8002716:	f040 8084 	bne.w	8002822 <PollAccelThread+0x1d2>
 800271a:	f8df 8144 	ldr.w	r8, [pc, #324]	; 8002860 <PollAccelThread+0x210>
 800271e:	f8df 9148 	ldr.w	r9, [pc, #328]	; 8002868 <PollAccelThread+0x218>
 8002722:	46c3      	mov	fp, r8
 8002724:	46ca      	mov	sl, r9
    tmp = raw[i*2] | (raw[i*2+1] << 8);
 8002726:	f89b 3001 	ldrb.w	r3, [fp, #1]
 800272a:	f81b 0b02 	ldrb.w	r0, [fp], #2
 800272e:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    g[i] = (float)tmp / 16384.0; /* convert raw value to G */
 8002732:	b200      	sxth	r0, r0
 8002734:	f7fd fe5a 	bl	80003ec <__aeabi_i2f>
 8002738:	4639      	mov	r1, r7
 800273a:	f7fd feab 	bl	8000494 <__aeabi_fmul>
  for (size_t i=0; i<3; i++){
 800273e:	4b4b      	ldr	r3, [pc, #300]	; (800286c <PollAccelThread+0x21c>)
    g[i] = (float)tmp / 16384.0; /* convert raw value to G */
 8002740:	f84a 0b04 	str.w	r0, [sl], #4
  for (size_t i=0; i<3; i++){
 8002744:	4553      	cmp	r3, sl
 8002746:	d1ee      	bne.n	8002726 <PollAccelThread+0xd6>
  float accel_single_byte_check[3];
  const float check_threshold = 0.1;

  /* read data byte at a time */
  memset(accel_rx_data, 0x55, sizeof(accel_rx_data));
  accel_tx_data[0] = ACCEL_OUT_DATA;
 8002748:	2228      	movs	r2, #40	; 0x28
  memset(accel_rx_data, 0x55, sizeof(accel_rx_data));
 800274a:	f04f 3355 	mov.w	r3, #1431655765	; 0x55555555
  accel_tx_data[0] = ACCEL_OUT_DATA;
 800274e:	7032      	strb	r2, [r6, #0]
  memset(accel_rx_data, 0x55, sizeof(accel_rx_data));
 8002750:	4a43      	ldr	r2, [pc, #268]	; (8002860 <PollAccelThread+0x210>)
 8002752:	e9c2 3300 	strd	r3, r3, [r2]
 8002756:	2330      	movs	r3, #48	; 0x30
 8002758:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 800275c:	e9d4 233a 	ldrd	r2, r3, [r4, #232]	; 0xe8
 8002760:	4313      	orrs	r3, r2
 8002762:	d158      	bne.n	8002816 <PollAccelThread+0x1c6>
  oip->dbg.lock_cnt = (cnt_t)1;
 8002764:	2301      	movs	r3, #1
 8002766:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 800276a:	f7fe fe01 	bl	8001370 <chMtxLockS.constprop.0>
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 800276e:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8002772:	2b00      	cmp	r3, #0
 8002774:	d152      	bne.n	800281c <PollAccelThread+0x1cc>
 8002776:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 800277a:	2a00      	cmp	r2, #0
 800277c:	dd4e      	ble.n	800281c <PollAccelThread+0x1cc>
  oip->dbg.lock_cnt = (cnt_t)0;
 800277e:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 8002782:	6823      	ldr	r3, [r4, #0]
 8002784:	42a3      	cmp	r3, r4
 8002786:	d161      	bne.n	800284c <PollAccelThread+0x1fc>
 8002788:	f04f 0b00 	mov.w	fp, #0
 800278c:	f38b 8811 	msr	BASEPRI, fp
  i2cAcquireBus(&I2CD1);
  for (size_t i=0; i<6; i++) {
    status = i2cMasterTransmitTimeout(&I2CD1, addr,
 8002790:	2201      	movs	r2, #1
 8002792:	eb05 010b 	add.w	r1, r5, fp
 8002796:	4610      	mov	r0, r2
 8002798:	f7fe fce2 	bl	8001160 <i2cMasterTransmitTimeout.constprop.0>
                            accel_tx_data, 1, &accel_rx_data[i], 1, tmo);
    osalDbgCheck(MSG_OK == status);
 800279c:	2800      	cmp	r0, #0
 800279e:	d140      	bne.n	8002822 <PollAccelThread+0x1d2>
    accel_tx_data[0]++;
 80027a0:	7833      	ldrb	r3, [r6, #0]
  for (size_t i=0; i<6; i++) {
 80027a2:	f10b 0b01 	add.w	fp, fp, #1
    accel_tx_data[0]++;
 80027a6:	3301      	adds	r3, #1
  for (size_t i=0; i<6; i++) {
 80027a8:	f1bb 0f06 	cmp.w	fp, #6
    accel_tx_data[0]++;
 80027ac:	7033      	strb	r3, [r6, #0]
  for (size_t i=0; i<6; i++) {
 80027ae:	d1ef      	bne.n	8002790 <PollAccelThread+0x140>
 80027b0:	ae01      	add	r6, sp, #4
 80027b2:	4682      	mov	sl, r0
 80027b4:	46b3      	mov	fp, r6
 80027b6:	f7ff fed3 	bl	8002560 <chMtxUnlock.constprop.0>
    tmp = raw[i*2] | (raw[i*2+1] << 8);
 80027ba:	f898 3001 	ldrb.w	r3, [r8, #1]
 80027be:	f818 0b02 	ldrb.w	r0, [r8], #2
  for (size_t i=0; i<3; i++){
 80027c2:	f10a 0a01 	add.w	sl, sl, #1
    tmp = raw[i*2] | (raw[i*2+1] << 8);
 80027c6:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    g[i] = (float)tmp / 16384.0; /* convert raw value to G */
 80027ca:	b200      	sxth	r0, r0
 80027cc:	f7fd fe0e 	bl	80003ec <__aeabi_i2f>
 80027d0:	4639      	mov	r1, r7
 80027d2:	f7fd fe5f 	bl	8000494 <__aeabi_fmul>
  for (size_t i=0; i<3; i++){
 80027d6:	f1ba 0f03 	cmp.w	sl, #3
    g[i] = (float)tmp / 16384.0; /* convert raw value to G */
 80027da:	f84b 0b04 	str.w	r0, [fp], #4
  for (size_t i=0; i<3; i++){
 80027de:	d1ec      	bne.n	80027ba <PollAccelThread+0x16a>
  }
  i2cReleaseBus(&I2CD1);
  raw2g(accel_rx_data, accel_single_byte_check);

  /* check results */
  for (size_t i=0; i<3; i++) {
 80027e0:	f04f 0800 	mov.w	r8, #0
    osalDbgCheck(fabsf(result[i] - accel_single_byte_check[i]) < check_threshold);
 80027e4:	f856 1b04 	ldr.w	r1, [r6], #4
 80027e8:	f859 0b04 	ldr.w	r0, [r9], #4
 80027ec:	f7fd fd48 	bl	8000280 <__aeabi_fsub>
 80027f0:	491f      	ldr	r1, [pc, #124]	; (8002870 <PollAccelThread+0x220>)
 80027f2:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 80027f6:	f7fd ffeb 	bl	80007d0 <__aeabi_fcmplt>
 80027fa:	b190      	cbz	r0, 8002822 <PollAccelThread+0x1d2>
  for (size_t i=0; i<3; i++) {
 80027fc:	f108 0801 	add.w	r8, r8, #1
 8002800:	f1b8 0f03 	cmp.w	r8, #3
 8002804:	d1ee      	bne.n	80027e4 <PollAccelThread+0x194>
 8002806:	2330      	movs	r3, #48	; 0x30
 8002808:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 800280c:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8002810:	2b00      	cmp	r3, #0
 8002812:	f43f af2f 	beq.w	8002674 <PollAccelThread+0x24>
    chSysHalt("SV#4");
 8002816:	4817      	ldr	r0, [pc, #92]	; (8002874 <PollAccelThread+0x224>)
 8002818:	f7fe f912 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#5");
 800281c:	4816      	ldr	r0, [pc, #88]	; (8002878 <PollAccelThread+0x228>)
 800281e:	f7fe f90f 	bl	8000a40 <chSysHalt>
  osalDbgCheck(MSG_OK == status);
 8002822:	4816      	ldr	r0, [pc, #88]	; (800287c <PollAccelThread+0x22c>)
 8002824:	f7fe f90c 	bl	8000a40 <chSysHalt>
 8002828:	68e2      	ldr	r2, [r4, #12]
 800282a:	689b      	ldr	r3, [r3, #8]
 800282c:	6892      	ldr	r2, [r2, #8]
 800282e:	429a      	cmp	r2, r3
 8002830:	f4bf af3d 	bcs.w	80026ae <PollAccelThread+0x5e>
 8002834:	4812      	ldr	r0, [pc, #72]	; (8002880 <PollAccelThread+0x230>)
 8002836:	f7fe f903 	bl	8000a40 <chSysHalt>
 800283a:	68e2      	ldr	r2, [r4, #12]
 800283c:	689b      	ldr	r3, [r3, #8]
 800283e:	6892      	ldr	r2, [r2, #8]
 8002840:	429a      	cmp	r2, r3
 8002842:	f4bf af5b 	bcs.w	80026fc <PollAccelThread+0xac>
 8002846:	480f      	ldr	r0, [pc, #60]	; (8002884 <PollAccelThread+0x234>)
 8002848:	f7fe f8fa 	bl	8000a40 <chSysHalt>
 800284c:	68e2      	ldr	r2, [r4, #12]
 800284e:	689b      	ldr	r3, [r3, #8]
 8002850:	6892      	ldr	r2, [r2, #8]
 8002852:	429a      	cmp	r2, r3
 8002854:	d298      	bcs.n	8002788 <PollAccelThread+0x138>
 8002856:	e7f6      	b.n	8002846 <PollAccelThread+0x1f6>
 8002858:	200010e0 	.word	0x200010e0
 800285c:	08003610 	.word	0x08003610
 8002860:	200010cc 	.word	0x200010cc
 8002864:	200010d4 	.word	0x200010d4
 8002868:	200010c0 	.word	0x200010c0
 800286c:	200010cc 	.word	0x200010cc
 8002870:	3dcccccd 	.word	0x3dcccccd
 8002874:	080035c0 	.word	0x080035c0
 8002878:	080035f0 	.word	0x080035f0
 800287c:	080036c4 	.word	0x080036c4
 8002880:	08003788 	.word	0x08003788
 8002884:	08003844 	.word	0x08003844
	...

08002890 <PollFakeThread>:
 8002890:	4c94      	ldr	r4, [pc, #592]	; (8002ae4 <PollFakeThread+0x254>)
 8002892:	4995      	ldr	r1, [pc, #596]	; (8002ae8 <PollFakeThread+0x258>)
 8002894:	68e2      	ldr	r2, [r4, #12]

/*
 * Fake polling thread.
 */
static THD_WORKING_AREA(PollFakeThreadWA, 256);
static THD_FUNCTION(PollFakeThread, arg) {
 8002896:	b580      	push	{r7, lr}
 8002898:	2330      	movs	r3, #48	; 0x30
 800289a:	6211      	str	r1, [r2, #32]
 800289c:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80028a0:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80028a4:	2b00      	cmp	r3, #0
 80028a6:	f040 80be 	bne.w	8002a26 <PollFakeThread+0x196>

  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
               (rxbytes > 0U) && (rxbuf != NULL) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 80028aa:	4d90      	ldr	r5, [pc, #576]	; (8002aec <PollFakeThread+0x25c>)
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 80028ac:	4e90      	ldr	r6, [pc, #576]	; (8002af0 <PollFakeThread+0x260>)
  tp->u.wttrp = trp;
 80028ae:	f105 071c 	add.w	r7, r5, #28
 80028b2:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 80028b6:	2b00      	cmp	r3, #0
 80028b8:	f040 80b5 	bne.w	8002a26 <PollFakeThread+0x196>
  oip->dbg.lock_cnt = (cnt_t)1;
 80028bc:	2301      	movs	r3, #1
 80028be:	21a0      	movs	r1, #160	; 0xa0
 80028c0:	2008      	movs	r0, #8
 80028c2:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 80028c6:	f7fe fbb3 	bl	8001030 <chSchGoSleepTimeoutS>
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80028ca:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80028ce:	2b00      	cmp	r3, #0
 80028d0:	d177      	bne.n	80029c2 <PollFakeThread+0x132>
 80028d2:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 80028d6:	2a00      	cmp	r2, #0
 80028d8:	dd73      	ble.n	80029c2 <PollFakeThread+0x132>
  oip->dbg.lock_cnt = (cnt_t)0;
 80028da:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 80028de:	6823      	ldr	r3, [r4, #0]
 80028e0:	42a3      	cmp	r3, r4
 80028e2:	f040 80a3 	bne.w	8002a2c <PollFakeThread+0x19c>
 80028e6:	2300      	movs	r3, #0
 80028e8:	f383 8811 	msr	BASEPRI, r3
 80028ec:	2330      	movs	r3, #48	; 0x30
 80028ee:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80028f2:	e9d4 233a 	ldrd	r2, r3, [r4, #232]	; 0xe8
 80028f6:	4313      	orrs	r3, r2
 80028f8:	f040 8095 	bne.w	8002a26 <PollFakeThread+0x196>
  oip->dbg.lock_cnt = (cnt_t)1;
 80028fc:	2301      	movs	r3, #1
 80028fe:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 8002902:	f7fe fd35 	bl	8001370 <chMtxLockS.constprop.0>
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002906:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 800290a:	2b00      	cmp	r3, #0
 800290c:	d159      	bne.n	80029c2 <PollFakeThread+0x132>
 800290e:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8002912:	2a00      	cmp	r2, #0
 8002914:	dd55      	ble.n	80029c2 <PollFakeThread+0x132>
  oip->dbg.lock_cnt = (cnt_t)0;
 8002916:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 800291a:	6823      	ldr	r3, [r4, #0]
 800291c:	42a3      	cmp	r3, r4
 800291e:	f040 808e 	bne.w	8002a3e <PollFakeThread+0x1ae>
 8002922:	2300      	movs	r3, #0
 8002924:	f383 8811 	msr	BASEPRI, r3
 8002928:	f895 8000 	ldrb.w	r8, [r5]
 800292c:	f1b8 0f02 	cmp.w	r8, #2
 8002930:	f040 808e 	bne.w	8002a50 <PollFakeThread+0x1c0>
 8002934:	2330      	movs	r3, #48	; 0x30
 8002936:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 800293a:	e9d4 323a 	ldrd	r3, r2, [r4, #232]	; 0xe8
 800293e:	4313      	orrs	r3, r2
 8002940:	d171      	bne.n	8002a26 <PollFakeThread+0x196>

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8002942:	60ab      	str	r3, [r5, #8]
  oip->dbg.lock_cnt = (cnt_t)0;
 8002944:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
  i2cp->state = I2C_ACTIVE_RX;
 8002948:	2304      	movs	r3, #4
 800294a:	702b      	strb	r3, [r5, #0]
  i2cp->addr = (addr << 1) | 0x01;
 800294c:	2399      	movs	r3, #153	; 0x99
 800294e:	6822      	ldr	r2, [r4, #0]
 8002950:	842b      	strh	r3, [r5, #32]
 8002952:	42a2      	cmp	r2, r4
  I2C_TypeDef *dp = i2cp->i2c;
 8002954:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002956:	f040 8086 	bne.w	8002a66 <PollFakeThread+0x1d6>
 800295a:	2000      	movs	r0, #0
 800295c:	f380 8811 	msr	BASEPRI, r0
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8002960:	2202      	movs	r2, #2
 8002962:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
 8002966:	f04f 0e30 	mov.w	lr, #48	; 0x30
  oip->dbg.lock_cnt = (cnt_t)1;
 800296a:	f04f 0901 	mov.w	r9, #1
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800296e:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8002970:	f8d5 a024 	ldr.w	sl, [r5, #36]	; 0x24
 8002974:	6849      	ldr	r1, [r1, #4]
 8002976:	f8c1 a000 	str.w	sl, [r1]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 800297a:	60ce      	str	r6, [r1, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 800297c:	604a      	str	r2, [r1, #4]
 800297e:	f8dc 2024 	ldr.w	r2, [ip, #36]	; 0x24
 8002982:	fa1f fa82 	uxth.w	sl, r2
 8002986:	f38e 8811 	msr	BASEPRI, lr
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 800298a:	e9d4 123a 	ldrd	r1, r2, [r4, #232]	; 0xe8
 800298e:	430a      	orrs	r2, r1
 8002990:	d149      	bne.n	8002a26 <PollFakeThread+0x196>
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8002992:	699a      	ldr	r2, [r3, #24]
  oip->dbg.lock_cnt = (cnt_t)1;
 8002994:	f8c4 90ec 	str.w	r9, [r4, #236]	; 0xec
 8002998:	0791      	lsls	r1, r2, #30
 800299a:	d402      	bmi.n	80029a2 <PollFakeThread+0x112>
 800299c:	681a      	ldr	r2, [r3, #0]
 800299e:	0592      	lsls	r2, r2, #22
 80029a0:	d568      	bpl.n	8002a74 <PollFakeThread+0x1e4>
 80029a2:	f8dc 2024 	ldr.w	r2, [ip, #36]	; 0x24
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 80029a6:	eba2 020a 	sub.w	r2, r2, sl
    if (!osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end)) {
 80029aa:	b292      	uxth	r2, r2
 80029ac:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
 80029b0:	d20a      	bcs.n	80029c8 <PollFakeThread+0x138>
 80029b2:	6822      	ldr	r2, [r4, #0]
  oip->dbg.lock_cnt = (cnt_t)0;
 80029b4:	f8c4 00ec 	str.w	r0, [r4, #236]	; 0xec
 80029b8:	42a2      	cmp	r2, r4
 80029ba:	d14c      	bne.n	8002a56 <PollFakeThread+0x1c6>
 80029bc:	f380 8811 	msr	BASEPRI, r0
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 80029c0:	e7e1      	b.n	8002986 <PollFakeThread+0xf6>
    chSysHalt("SV#5");
 80029c2:	484c      	ldr	r0, [pc, #304]	; (8002af4 <PollFakeThread+0x264>)
 80029c4:	f7fe f83c 	bl	8000a40 <chSysHalt>
      dmaStreamDisable(i2cp->dmarx);
 80029c8:	230e      	movs	r3, #14
  rdymsg = i2c_lld_master_receive_timeout(i2cp, addr, rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 80029ca:	f04f 0805 	mov.w	r8, #5
 80029ce:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 80029d2:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80029d4:	e9d2 c000 	ldrd	ip, r0, [r2]
 80029d8:	6801      	ldr	r1, [r0, #0]
 80029da:	f021 010f 	bic.w	r1, r1, #15
 80029de:	6001      	str	r1, [r0, #0]
 80029e0:	7b52      	ldrb	r2, [r2, #13]
 80029e2:	4093      	lsls	r3, r2
 80029e4:	f8cc 3004 	str.w	r3, [ip, #4]
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80029e8:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80029ec:	f885 8000 	strb.w	r8, [r5]
 80029f0:	2b00      	cmp	r3, #0
 80029f2:	d1e6      	bne.n	80029c2 <PollFakeThread+0x132>
 80029f4:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 80029f8:	2a00      	cmp	r2, #0
 80029fa:	dde2      	ble.n	80029c2 <PollFakeThread+0x132>
  oip->dbg.lock_cnt = (cnt_t)0;
 80029fc:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8002a00:	6823      	ldr	r3, [r4, #0]
 8002a02:	42a3      	cmp	r3, r4
 8002a04:	d162      	bne.n	8002acc <PollFakeThread+0x23c>
 8002a06:	2300      	movs	r3, #0
 8002a08:	f383 8811 	msr	BASEPRI, r3
 8002a0c:	f7ff fda8 	bl	8002560 <chMtxUnlock.constprop.0>

  i2cAcquireBus(&I2CD1);
  status = i2cMasterReceiveTimeout(&I2CD1, addr, rx_data, 2, tmo);
  i2cReleaseBus(&I2CD1);

  if (status == MSG_RESET){
 8002a10:	f119 0f02 	cmn.w	r9, #2
 8002a14:	d054      	beq.n	8002ac0 <PollFakeThread+0x230>
 8002a16:	2330      	movs	r3, #48	; 0x30
 8002a18:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002a1c:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8002a20:	2b00      	cmp	r3, #0
 8002a22:	f43f af46 	beq.w	80028b2 <PollFakeThread+0x22>
    chSysHalt("SV#4");
 8002a26:	4834      	ldr	r0, [pc, #208]	; (8002af8 <PollFakeThread+0x268>)
 8002a28:	f7fe f80a 	bl	8000a40 <chSysHalt>
 8002a2c:	68e2      	ldr	r2, [r4, #12]
 8002a2e:	689b      	ldr	r3, [r3, #8]
 8002a30:	6892      	ldr	r2, [r2, #8]
 8002a32:	429a      	cmp	r2, r3
 8002a34:	f4bf af57 	bcs.w	80028e6 <PollFakeThread+0x56>
 8002a38:	4830      	ldr	r0, [pc, #192]	; (8002afc <PollFakeThread+0x26c>)
 8002a3a:	f7fe f801 	bl	8000a40 <chSysHalt>
 8002a3e:	68e2      	ldr	r2, [r4, #12]
 8002a40:	689b      	ldr	r3, [r3, #8]
 8002a42:	6892      	ldr	r2, [r2, #8]
 8002a44:	429a      	cmp	r2, r3
 8002a46:	f4bf af6c 	bcs.w	8002922 <PollFakeThread+0x92>
 8002a4a:	482d      	ldr	r0, [pc, #180]	; (8002b00 <PollFakeThread+0x270>)
 8002a4c:	f7fd fff8 	bl	8000a40 <chSysHalt>
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 8002a50:	482c      	ldr	r0, [pc, #176]	; (8002b04 <PollFakeThread+0x274>)
 8002a52:	f7fd fff5 	bl	8000a40 <chSysHalt>
 8002a56:	6891      	ldr	r1, [r2, #8]
 8002a58:	68e2      	ldr	r2, [r4, #12]
 8002a5a:	6892      	ldr	r2, [r2, #8]
 8002a5c:	428a      	cmp	r2, r1
 8002a5e:	d2ad      	bcs.n	80029bc <PollFakeThread+0x12c>
 8002a60:	4829      	ldr	r0, [pc, #164]	; (8002b08 <PollFakeThread+0x278>)
 8002a62:	f7fd ffed 	bl	8000a40 <chSysHalt>
 8002a66:	68e1      	ldr	r1, [r4, #12]
 8002a68:	6892      	ldr	r2, [r2, #8]
 8002a6a:	6889      	ldr	r1, [r1, #8]
 8002a6c:	4291      	cmp	r1, r2
 8002a6e:	f4bf af74 	bcs.w	800295a <PollFakeThread+0xca>
 8002a72:	e7f5      	b.n	8002a60 <PollFakeThread+0x1d0>
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8002a74:	685a      	ldr	r2, [r3, #4]
 8002a76:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002a7a:	605a      	str	r2, [r3, #4]
  dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8002a7c:	681a      	ldr	r2, [r3, #0]
 8002a7e:	f442 62a0 	orr.w	r2, r2, #1280	; 0x500
 8002a82:	601a      	str	r2, [r3, #0]
  chDbgAssert(*trp == NULL, "not NULL");
 8002a84:	69ea      	ldr	r2, [r5, #28]
  return __sch_get_currthread();
 8002a86:	68e3      	ldr	r3, [r4, #12]
 8002a88:	bb42      	cbnz	r2, 8002adc <PollFakeThread+0x24c>
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8002a8a:	2128      	movs	r1, #40	; 0x28
 8002a8c:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
 8002a8e:	635f      	str	r7, [r3, #52]	; 0x34
  *trp = tp;
 8002a90:	61eb      	str	r3, [r5, #28]
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8002a92:	f7fe facd 	bl	8001030 <chSchGoSleepTimeoutS>
  if (msg != MSG_OK) {
 8002a96:	4681      	mov	r9, r0
 8002a98:	2800      	cmp	r0, #0
 8002a9a:	d0a5      	beq.n	80029e8 <PollFakeThread+0x158>
    dmaStreamDisable(i2cp->dmarx);
 8002a9c:	230e      	movs	r3, #14
 8002a9e:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    i2cp->state = I2C_LOCKED;
 8002aa0:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8002aa4:	e9d2 c000 	ldrd	ip, r0, [r2]
 8002aa8:	6801      	ldr	r1, [r0, #0]
 8002aaa:	bf08      	it	eq
 8002aac:	f04f 0805 	moveq.w	r8, #5
 8002ab0:	f021 010f 	bic.w	r1, r1, #15
 8002ab4:	6001      	str	r1, [r0, #0]
 8002ab6:	7b52      	ldrb	r2, [r2, #13]
 8002ab8:	4093      	lsls	r3, r2
 8002aba:	f8cc 3004 	str.w	r3, [ip, #4]
 8002abe:	e793      	b.n	80029e8 <PollFakeThread+0x158>
    errors = i2cGetErrors(&I2CD1);
    osalDbgCheck(I2C_ACK_FAILURE == errors);
 8002ac0:	68ab      	ldr	r3, [r5, #8]
 8002ac2:	2b04      	cmp	r3, #4
 8002ac4:	d0a7      	beq.n	8002a16 <PollFakeThread+0x186>
 8002ac6:	4811      	ldr	r0, [pc, #68]	; (8002b0c <PollFakeThread+0x27c>)
 8002ac8:	f7fd ffba 	bl	8000a40 <chSysHalt>
 8002acc:	68e2      	ldr	r2, [r4, #12]
 8002ace:	689b      	ldr	r3, [r3, #8]
 8002ad0:	6892      	ldr	r2, [r2, #8]
 8002ad2:	429a      	cmp	r2, r3
 8002ad4:	d297      	bcs.n	8002a06 <PollFakeThread+0x176>
 8002ad6:	480e      	ldr	r0, [pc, #56]	; (8002b10 <PollFakeThread+0x280>)
 8002ad8:	f7fd ffb2 	bl	8000a40 <chSysHalt>
  chDbgAssert(*trp == NULL, "not NULL");
 8002adc:	480d      	ldr	r0, [pc, #52]	; (8002b14 <PollFakeThread+0x284>)
 8002ade:	f7fd ffaf 	bl	8000a40 <chSysHalt>
 8002ae2:	bf00      	nop
 8002ae4:	200010e0 	.word	0x200010e0
 8002ae8:	0800361c 	.word	0x0800361c
 8002aec:	20000c40 	.word	0x20000c40
 8002af0:	20001ba0 	.word	0x20001ba0
 8002af4:	080035f0 	.word	0x080035f0
 8002af8:	080035c0 	.word	0x080035c0
 8002afc:	08003788 	.word	0x08003788
 8002b00:	08003844 	.word	0x08003844
 8002b04:	080037a4 	.word	0x080037a4
 8002b08:	080036ec 	.word	0x080036ec
 8002b0c:	080036d0 	.word	0x080036d0
 8002b10:	08003894 	.word	0x08003894
 8002b14:	0800387c 	.word	0x0800387c
	...

08002b20 <chThdExit>:
void chThdExit(msg_t msg) {
 8002b20:	b508      	push	{r3, lr}
 8002b22:	2330      	movs	r3, #48	; 0x30
 8002b24:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002b28:	4c1a      	ldr	r4, [pc, #104]	; (8002b94 <chThdExit+0x74>)
 8002b2a:	e9d4 233a 	ldrd	r2, r3, [r4, #232]	; 0xe8
 8002b2e:	4313      	orrs	r3, r2
 8002b30:	d122      	bne.n	8002b78 <chThdExit+0x58>
  oip->dbg.lock_cnt = (cnt_t)1;
 8002b32:	2201      	movs	r2, #1
 8002b34:	68e5      	ldr	r5, [r4, #12]
  return (bool)(lp->next != lp);
 8002b36:	6bab      	ldr	r3, [r5, #56]	; 0x38
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8002b38:	f105 0638 	add.w	r6, r5, #56	; 0x38
 8002b3c:	429e      	cmp	r6, r3
 8002b3e:	f8c4 20ec 	str.w	r2, [r4, #236]	; 0xec
  currtp->u.exitcode = msg;
 8002b42:	6368      	str	r0, [r5, #52]	; 0x34
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8002b44:	d107      	bne.n	8002b56 <chThdExit+0x36>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8002b46:	7fab      	ldrb	r3, [r5, #30]
 8002b48:	b1cb      	cbz	r3, 8002b7e <chThdExit+0x5e>
  chSchGoSleepS(CH_STATE_FINAL);
 8002b4a:	200f      	movs	r0, #15
 8002b4c:	f7fe fa18 	bl	8000f80 <chSchGoSleepS>
  chDbgAssert(false, "zombies apocalypse");
 8002b50:	4811      	ldr	r0, [pc, #68]	; (8002b98 <chThdExit+0x78>)
 8002b52:	f7fd ff75 	bl	8000a40 <chSysHalt>
  lp->next = p->next;
 8002b56:	681a      	ldr	r2, [r3, #0]
 8002b58:	63aa      	str	r2, [r5, #56]	; 0x38
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002b5a:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
 8002b5e:	2a00      	cmp	r2, #0
 8002b60:	db15      	blt.n	8002b8e <chThdExit+0x6e>
 8002b62:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 8002b66:	2a00      	cmp	r2, #0
 8002b68:	dd11      	ble.n	8002b8e <chThdExit+0x6e>
  return __sch_ready_behind(tp);
 8002b6a:	4618      	mov	r0, r3
 8002b6c:	f7fe f930 	bl	8000dd0 <__sch_ready_behind.isra.0>
  return (bool)(lp->next != lp);
 8002b70:	6bab      	ldr	r3, [r5, #56]	; 0x38
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8002b72:	42b3      	cmp	r3, r6
 8002b74:	d0e7      	beq.n	8002b46 <chThdExit+0x26>
 8002b76:	e7ee      	b.n	8002b56 <chThdExit+0x36>
    chSysHalt("SV#4");
 8002b78:	4808      	ldr	r0, [pc, #32]	; (8002b9c <chThdExit+0x7c>)
 8002b7a:	f7fd ff61 	bl	8000a40 <chSysHalt>
    if (currtp->dispose == NULL) {
 8002b7e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8002b80:	2b00      	cmp	r3, #0
 8002b82:	d1e2      	bne.n	8002b4a <chThdExit+0x2a>
  p->prev->next = p->next;
 8002b84:	e9d5 3209 	ldrd	r3, r2, [r5, #36]	; 0x24
 8002b88:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8002b8a:	605a      	str	r2, [r3, #4]
  return p;
 8002b8c:	e7dd      	b.n	8002b4a <chThdExit+0x2a>
    chSysHalt("SV#10");
 8002b8e:	4804      	ldr	r0, [pc, #16]	; (8002ba0 <chThdExit+0x80>)
 8002b90:	f7fd ff56 	bl	8000a40 <chSysHalt>
 8002b94:	200010e0 	.word	0x200010e0
 8002b98:	08003758 	.word	0x08003758
 8002b9c:	080035c0 	.word	0x080035c0
 8002ba0:	080035b8 	.word	0x080035b8
	...

08002bb0 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002bb0:	f3ef 8309 	mrs	r3, PSP
  psp += sizeof (struct port_extctx);
 8002bb4:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002bb6:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002bba:	2300      	movs	r3, #0
 8002bbc:	f383 8811 	msr	BASEPRI, r3
}
 8002bc0:	4770      	bx	lr
 8002bc2:	bf00      	nop
	...

08002bd0 <main>:
  rccResetAPB1(0xFFFFFFFF);
 8002bd0:	2100      	movs	r1, #0
 8002bd2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002bd6:	4b12      	ldr	r3, [pc, #72]	; (8002c20 <main+0x50>)
  dma.allocated_mask = 0U;
 8002bd8:	4c12      	ldr	r4, [pc, #72]	; (8002c24 <main+0x54>)
 8002bda:	6918      	ldr	r0, [r3, #16]

/*
 * Entry point, note, the main() function is already a thread in the system
 * on entry.
 */
int main(void) {
 8002bdc:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  dma.isr_mask       = 0U;
 8002be0:	6061      	str	r1, [r4, #4]
 8002be2:	611a      	str	r2, [r3, #16]
 8002be4:	691e      	ldr	r6, [r3, #16]
 8002be6:	6119      	str	r1, [r3, #16]
 8002be8:	691e      	ldr	r6, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8002bea:	68de      	ldr	r6, [r3, #12]
 8002bec:	60da      	str	r2, [r3, #12]
 8002bee:	68da      	ldr	r2, [r3, #12]
 8002bf0:	60d9      	str	r1, [r3, #12]
 8002bf2:	68da      	ldr	r2, [r3, #12]
  rccEnablePWRInterface(true);
 8002bf4:	69de      	ldr	r6, [r3, #28]
  PWR->CR |= PWR_CR_DBP;
 8002bf6:	4f0c      	ldr	r7, [pc, #48]	; (8002c28 <main+0x58>)
  rccEnablePWRInterface(true);
 8002bf8:	f046 5680 	orr.w	r6, r6, #268435456	; 0x10000000
 8002bfc:	61de      	str	r6, [r3, #28]
 8002bfe:	69de      	ldr	r6, [r3, #28]
  rccEnableBKPInterface(true);
 8002c00:	69de      	ldr	r6, [r3, #28]
 8002c02:	460a      	mov	r2, r1
 8002c04:	f046 6600 	orr.w	r6, r6, #134217728	; 0x8000000
 8002c08:	61de      	str	r6, [r3, #28]
 8002c0a:	69db      	ldr	r3, [r3, #28]
  PWR->CR |= PWR_CR_DBP;
 8002c0c:	683b      	ldr	r3, [r7, #0]
 8002c0e:	4807      	ldr	r0, [pc, #28]	; (8002c2c <main+0x5c>)
 8002c10:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002c14:	603b      	str	r3, [r7, #0]
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8002c16:	4d06      	ldr	r5, [pc, #24]	; (8002c30 <main+0x60>)
 8002c18:	460b      	mov	r3, r1
 8002c1a:	b089      	sub	sp, #36	; 0x24
  dma.allocated_mask = 0U;
 8002c1c:	6021      	str	r1, [r4, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002c1e:	e00c      	b.n	8002c3a <main+0x6a>
 8002c20:	40021000 	.word	0x40021000
 8002c24:	20001b60 	.word	0x20001b60
 8002c28:	40007000 	.word	0x40007000
 8002c2c:	40020008 	.word	0x40020008
 8002c30:	08003900 	.word	0x08003900
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8002c34:	eb05 01c2 	add.w	r1, r5, r2, lsl #3
 8002c38:	6848      	ldr	r0, [r1, #4]
    dma.streams[i].func = NULL;
 8002c3a:	eb04 0182 	add.w	r1, r4, r2, lsl #2
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002c3e:	3202      	adds	r2, #2
 8002c40:	2a0e      	cmp	r2, #14
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8002c42:	6003      	str	r3, [r0, #0]
    dma.streams[i].func = NULL;
 8002c44:	608b      	str	r3, [r1, #8]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002c46:	d1f5      	bne.n	8002c34 <main+0x64>
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002c48:	f04f 0c60 	mov.w	ip, #96	; 0x60
  DMA1->IFCR = 0xFFFFFFFFU;
 8002c4c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002c50:	2140      	movs	r1, #64	; 0x40
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002c52:	4acd      	ldr	r2, [pc, #820]	; (8002f88 <main+0x3b8>)
 8002c54:	4ccd      	ldr	r4, [pc, #820]	; (8002f8c <main+0x3bc>)
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002c56:	f44f 7e80 	mov.w	lr, #256	; 0x100
 8002c5a:	6060      	str	r0, [r4, #4]
 8002c5c:	f44f 6a80 	mov.w	sl, #1024	; 0x400
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002c60:	f882 c306 	strb.w	ip, [r2, #774]	; 0x306
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002c64:	f44f 0800 	mov.w	r8, #8388608	; 0x800000
 8002c68:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
 8002c6c:	f44f 7900 	mov.w	r9, #512	; 0x200
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002c70:	6011      	str	r1, [r2, #0]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002c72:	2180      	movs	r1, #128	; 0x80

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
 8002c74:	f04f 3788 	mov.w	r7, #2290649224	; 0x88888888
  i2cp->state  = I2C_STOP;
 8002c78:	f04f 0b01 	mov.w	fp, #1
  rccEnableAPB2(APB2_EN_MASK, true);
 8002c7c:	4ec4      	ldr	r6, [pc, #784]	; (8002f90 <main+0x3c0>)
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002c7e:	f882 c307 	strb.w	ip, [r2, #775]	; 0x307
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002c82:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002c86:	6011      	str	r1, [r2, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002c88:	f882 c308 	strb.w	ip, [r2, #776]	; 0x308
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002c8c:	f8c2 e180 	str.w	lr, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002c90:	f8c2 e000 	str.w	lr, [r2]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002c94:	f882 c309 	strb.w	ip, [r2, #777]	; 0x309
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002c98:	f8c2 9180 	str.w	r9, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002c9c:	f8c2 9000 	str.w	r9, [r2]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002ca0:	f882 c30a 	strb.w	ip, [r2, #778]	; 0x30a
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002ca4:	f8c2 a180 	str.w	sl, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002ca8:	f8c2 a000 	str.w	sl, [r2]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002cac:	f882 c317 	strb.w	ip, [r2, #791]	; 0x317
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002cb0:	f8c2 8180 	str.w	r8, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002cb4:	f8c2 8000 	str.w	r8, [r2]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002cb8:	f882 c328 	strb.w	ip, [r2, #808]	; 0x328
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002cbc:	f8c2 e184 	str.w	lr, [r2, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002cc0:	f8c2 e004 	str.w	lr, [r2, #4]
 8002cc4:	f8d6 c018 	ldr.w	ip, [r6, #24]
  GPIOA->CRL = config->PAData.crl;
 8002cc8:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 8002f94 <main+0x3c4>
  rccEnableAPB2(APB2_EN_MASK, true);
 8002ccc:	f04c 0c7d 	orr.w	ip, ip, #125	; 0x7d
 8002cd0:	f8c6 c018 	str.w	ip, [r6, #24]
 8002cd4:	f8d6 c018 	ldr.w	ip, [r6, #24]
  GPIOA->ODR = config->PAData.odr;
 8002cd8:	f8df c2bc 	ldr.w	ip, [pc, #700]	; 8002f98 <main+0x3c8>
  GPIOB->ODR = config->PBData.odr;
 8002cdc:	f8df a2bc 	ldr.w	sl, [pc, #700]	; 8002f9c <main+0x3cc>
  GPIOA->ODR = config->PAData.odr;
 8002ce0:	f8cc 000c 	str.w	r0, [ip, #12]
  GPIOA->CRH = config->PAData.crh;
 8002ce4:	f8cc 7004 	str.w	r7, [ip, #4]
  GPIOA->CRL = config->PAData.crl;
 8002ce8:	f8cc 9000 	str.w	r9, [ip]
  GPIOB->CRH = config->PBData.crh;
 8002cec:	f8df 92b0 	ldr.w	r9, [pc, #688]	; 8002fa0 <main+0x3d0>
  GPIOB->ODR = config->PBData.odr;
 8002cf0:	f8ca 000c 	str.w	r0, [sl, #12]
  GPIOB->CRH = config->PBData.crh;
 8002cf4:	f8ca 9004 	str.w	r9, [sl, #4]
  GPIOB->CRL = config->PBData.crl;
 8002cf8:	f8df 92a8 	ldr.w	r9, [pc, #680]	; 8002fa4 <main+0x3d4>
  GPIOC->ODR = config->PCData.odr;
 8002cfc:	f108 587e 	add.w	r8, r8, #1065353216	; 0x3f800000
  GPIOB->CRL = config->PBData.crl;
 8002d00:	f8ca 9000 	str.w	r9, [sl]
  GPIOC->CRH = config->PCData.crh;
 8002d04:	f109 4919 	add.w	r9, r9, #2566914048	; 0x99000000
 8002d08:	f509 097d 	add.w	r9, r9, #16580608	; 0xfd0000
  GPIOC->ODR = config->PCData.odr;
 8002d0c:	f508 3888 	add.w	r8, r8, #69632	; 0x11000
  GPIOC->CRH = config->PCData.crh;
 8002d10:	f509 492b 	add.w	r9, r9, #43776	; 0xab00
 8002d14:	4da4      	ldr	r5, [pc, #656]	; (8002fa8 <main+0x3d8>)
  GPIOC->ODR = config->PCData.odr;
 8002d16:	f8c8 000c 	str.w	r0, [r8, #12]
  GPIOC->CRH = config->PCData.crh;
 8002d1a:	f8c8 9004 	str.w	r9, [r8, #4]
  GPIOC->CRL = config->PCData.crl;
 8002d1e:	f8df 928c 	ldr.w	r9, [pc, #652]	; 8002fac <main+0x3dc>
  I2CD1.dmatx  = NULL;
 8002d22:	e9c5 330b 	strd	r3, r3, [r5, #44]	; 0x2c
  i2cp->config = NULL;
 8002d26:	606b      	str	r3, [r5, #4]
  mp->owner = NULL;
 8002d28:	616b      	str	r3, [r5, #20]
  I2CD1.thread = NULL;
 8002d2a:	61eb      	str	r3, [r5, #28]
  GPIOD->ODR = config->PDData.odr;
 8002d2c:	f8df e280 	ldr.w	lr, [pc, #640]	; 8002fb0 <main+0x3e0>
  GPIOC->CRL = config->PCData.crl;
 8002d30:	f8c8 9000 	str.w	r9, [r8]
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
 8002d34:	f8df 827c 	ldr.w	r8, [pc, #636]	; 8002fb4 <main+0x3e4>
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8002d38:	f50c 5c80 	add.w	ip, ip, #4096	; 0x1000
  GPIOD->ODR = config->PDData.odr;
 8002d3c:	f8ce 000c 	str.w	r0, [lr, #12]
  GPIOD->CRH = config->PDData.crh;
 8002d40:	f8ce 7004 	str.w	r7, [lr, #4]
  GPIOD->CRL = config->PDData.crl;
 8002d44:	f8ce 8000 	str.w	r8, [lr]
  GPIOE->ODR = config->PEData.odr;
 8002d48:	f8cc 000c 	str.w	r0, [ip, #12]
  GPIOE->CRH = config->PEData.crh;
 8002d4c:	f8cc 7004 	str.w	r7, [ip, #4]
  GPIOE->CRL = config->PEData.crl;
 8002d50:	f8cc 7000 	str.w	r7, [ip]
  i2cp->state  = I2C_STOP;
 8002d54:	f885 b000 	strb.w	fp, [r5]
  ST_ENABLE_CLOCK();
 8002d58:	69f7      	ldr	r7, [r6, #28]
  ST_ENABLE_STOP();
 8002d5a:	f8df c25c 	ldr.w	ip, [pc, #604]	; 8002fb8 <main+0x3e8>
  ST_ENABLE_CLOCK();
 8002d5e:	ea47 070b 	orr.w	r7, r7, fp
 8002d62:	61f7      	str	r7, [r6, #28]
 8002d64:	69f6      	ldr	r6, [r6, #28]
  ST_ENABLE_STOP();
 8002d66:	f8dc 7004 	ldr.w	r7, [ip, #4]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002d6a:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  ST_ENABLE_STOP();
 8002d6e:	f447 6700 	orr.w	r7, r7, #2048	; 0x800
 8002d72:	f8cc 7004 	str.w	r7, [ip, #4]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002d76:	f641 471f 	movw	r7, #7199	; 0x1c1f
 8002d7a:	628f      	str	r7, [r1, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002d7c:	f64f 77ff 	movw	r7, #65535	; 0xffff
 8002d80:	62cf      	str	r7, [r1, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8002d82:	618b      	str	r3, [r1, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002d84:	634b      	str	r3, [r1, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8002d86:	60cb      	str	r3, [r1, #12]
  STM32_ST_TIM->CR2    = 0;
 8002d88:	604b      	str	r3, [r1, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002d8a:	f8c1 b014 	str.w	fp, [r1, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002d8e:	f8c1 b000 	str.w	fp, [r1]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002d92:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8002d96:	f882 131c 	strb.w	r1, [r2, #796]	; 0x31c
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002d9a:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
 8002d9e:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002da2:	6011      	str	r1, [r2, #0]
  I2CD1.i2c    = I2C1;
 8002da4:	4a85      	ldr	r2, [pc, #532]	; (8002fbc <main+0x3ec>)
  ch_system.state = ch_sys_initializing;
 8002da6:	4e86      	ldr	r6, [pc, #536]	; (8002fc0 <main+0x3f0>)
 8002da8:	636a      	str	r2, [r5, #52]	; 0x34
  qp->next = qp;
 8002daa:	f105 020c 	add.w	r2, r5, #12
  qp->prev = qp;
 8002dae:	e9c5 2203 	strd	r2, r2, [r5, #12]
 8002db2:	f886 b000 	strb.w	fp, [r6]
  tmp->cumulative = (rttime_t)0;
 8002db6:	2200      	movs	r2, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 8002db8:	e9c6 3301 	strd	r3, r3, [r6, #4]
  tmp->worst      = (rtcnt_t)0;
 8002dbc:	e9cd 0300 	strd	r0, r3, [sp]
  tmp->n          = (ucnt_t)0;
 8002dc0:	e9cd 3302 	strd	r3, r3, [sp, #8]
  tmp->cumulative = (rttime_t)0;
 8002dc4:	2300      	movs	r3, #0
}
 8002dc6:	2404      	movs	r4, #4
  tmp->cumulative = (rttime_t)0;
 8002dc8:	e9cd 2304 	strd	r2, r3, [sp, #16]
  chTMObjectInit(&tm);
  i = TM_CALIBRATION_LOOP;
  do {
    chTMStartMeasurementX(&tm);
 8002dcc:	4668      	mov	r0, sp
 8002dce:	f7fd fd67 	bl	80008a0 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8002dd2:	f7fd fd6d 	bl	80008b0 <chTMStopMeasurementX>
    i--;
  } while (i > 0U);
 8002dd6:	3c01      	subs	r4, #1
 8002dd8:	d1f8      	bne.n	8002dcc <main+0x1fc>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 8002dda:	2014      	movs	r0, #20
 8002ddc:	211c      	movs	r1, #28
  mp->align = align;
 8002dde:	2204      	movs	r2, #4
  tcp->offset = tm.best;
 8002de0:	9b00      	ldr	r3, [sp, #0]
  ch_memcore.basemem = __heap_base__;
 8002de2:	4f78      	ldr	r7, [pc, #480]	; (8002fc4 <main+0x3f4>)
 8002de4:	60b3      	str	r3, [r6, #8]
  qp->next = qp;
 8002de6:	4b78      	ldr	r3, [pc, #480]	; (8002fc8 <main+0x3f8>)
  mp->object_size = size;
 8002de8:	6198      	str	r0, [r3, #24]
 8002dea:	6319      	str	r1, [r3, #48]	; 0x30
 8002dec:	4877      	ldr	r0, [pc, #476]	; (8002fcc <main+0x3fc>)
  ch_memcore.topmem  = __heap_end__;
 8002dee:	4978      	ldr	r1, [pc, #480]	; (8002fd0 <main+0x400>)
  mp->align = align;
 8002df0:	61da      	str	r2, [r3, #28]
 8002df2:	635a      	str	r2, [r3, #52]	; 0x34
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8002df4:	4a77      	ldr	r2, [pc, #476]	; (8002fd4 <main+0x404>)
 8002df6:	6079      	str	r1, [r7, #4]
 */
void chCoreGetStatusX(memory_area_t *map) {

  map->base = ch_memcore.basemem;
  /*lint -save -e9033 [10.8] The cast is safe.*/
  map->size = (size_t)(ch_memcore.topmem - ch_memcore.basemem);
 8002df8:	1a09      	subs	r1, r1, r0
 8002dfa:	6091      	str	r1, [r2, #8]
  mp->provider = provider;
 8002dfc:	4976      	ldr	r1, [pc, #472]	; (8002fd8 <main+0x408>)
  map->base = ch_memcore.basemem;
 8002dfe:	6050      	str	r0, [r2, #4]
 8002e00:	6219      	str	r1, [r3, #32]
 8002e02:	6399      	str	r1, [r3, #56]	; 0x38
 8002e04:	4975      	ldr	r1, [pc, #468]	; (8002fdc <main+0x40c>)
  chCoreGetStatusX(&default_heap.area);
  H_FREE_NEXT(&default_heap.header) = NULL;
  H_FREE_PAGES(&default_heap.header) = 0;
 8002e06:	e9c2 4403 	strd	r4, r4, [r2, #12]
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8002e0a:	6011      	str	r1, [r2, #0]
 8002e0c:	f102 0114 	add.w	r1, r2, #20
  qp->prev = qp;
 8002e10:	e9c2 1105 	strd	r1, r1, [r2, #20]
 8002e14:	61d4      	str	r4, [r2, #28]
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8002e16:	f103 0210 	add.w	r2, r3, #16
 8002e1a:	611a      	str	r2, [r3, #16]
 8002e1c:	f103 0224 	add.w	r2, r3, #36	; 0x24
 8002e20:	625a      	str	r2, [r3, #36]	; 0x24
 8002e22:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8002e26:	629a      	str	r2, [r3, #40]	; 0x28
 8002e28:	f103 023c 	add.w	r2, r3, #60	; 0x3c
  ch_memcore.basemem = __heap_base__;
 8002e2c:	6038      	str	r0, [r7, #0]
 8002e2e:	63da      	str	r2, [r3, #60]	; 0x3c
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
 8002e30:	6870      	ldr	r0, [r6, #4]
 8002e32:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8002e36:	641a      	str	r2, [r3, #64]	; 0x40
 8002e38:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8002e3c:	e9c3 3300 	strd	r3, r3, [r3]
 8002e40:	609c      	str	r4, [r3, #8]
  mp->next = NULL;
 8002e42:	615c      	str	r4, [r3, #20]
 8002e44:	62dc      	str	r4, [r3, #44]	; 0x2c
 8002e46:	645a      	str	r2, [r3, #68]	; 0x44
 8002e48:	2800      	cmp	r0, #0
 8002e4a:	f040 824b 	bne.w	80032e4 <main+0x714>
  ch_system.instances[core_id] = oip;
 8002e4e:	4f64      	ldr	r7, [pc, #400]	; (8002fe0 <main+0x410>)

  /* Core associated to this instance.*/
  oip->core_id = core_id;

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 8002e50:	4b64      	ldr	r3, [pc, #400]	; (8002fe4 <main+0x414>)
  ch_system.instances[core_id] = oip;
 8002e52:	6077      	str	r7, [r6, #4]
  oip->core_id = core_id;
 8002e54:	63bc      	str	r4, [r7, #56]	; 0x38
  oip->config = oicp;
 8002e56:	643b      	str	r3, [r7, #64]	; 0x40
 8002e58:	2030      	movs	r0, #48	; 0x30
 8002e5a:	f380 8811 	msr	BASEPRI, r0
  __ASM volatile ("cpsie i" : : : "memory");
 8002e5e:	b662      	cpsie	i
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002e60:	f64f 08ff 	movw	r8, #63743	; 0xf8ff
  pqp->prio = (tprio_t)0;
 8002e64:	e9c7 7401 	strd	r7, r4, [r7, #4]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8002e68:	4b5f      	ldr	r3, [pc, #380]	; (8002fe8 <main+0x418>)
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
 8002e6a:	63fc      	str	r4, [r7, #60]	; 0x3c

  sdp->panic_msg = NULL;

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 8002e6c:	f8c7 40e8 	str.w	r4, [r7, #232]	; 0xe8
 8002e70:	68d9      	ldr	r1, [r3, #12]
  reg_value  =  (reg_value                                   |
 8002e72:	4a5e      	ldr	r2, [pc, #376]	; (8002fec <main+0x41c>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002e74:	ea01 0108 	and.w	r1, r1, r8
  reg_value  =  (reg_value                                   |
 8002e78:	430a      	orrs	r2, r1

  ch_dlist_init(&vtlp->dlist);
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 8002e7a:	83bc      	strh	r4, [r7, #28]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8002e7c:	60da      	str	r2, [r3, #12]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8002e7e:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002e82:	f04f 0e20 	mov.w	lr, #32
 8002e86:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002e8a:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
  dlhp->delta = (sysinterval_t)-1;
 8002e8e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002e92:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8002e96:	4956      	ldr	r1, [pc, #344]	; (8002ff0 <main+0x420>)
 8002e98:	61ba      	str	r2, [r7, #24]
 8002e9a:	680a      	ldr	r2, [r1, #0]
  qp->next = qp;
 8002e9c:	eb07 0800 	add.w	r8, r7, r0
 8002ea0:	f042 0201 	orr.w	r2, r2, #1
 8002ea4:	600a      	str	r2, [r1, #0]
 8002ea6:	f883 e01f 	strb.w	lr, [r3, #31]
 8002eaa:	f883 0022 	strb.w	r0, [r3, #34]	; 0x22
  vtlp->lastdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002eae:	2302      	movs	r3, #2
 8002eb0:	f8dc 1024 	ldr.w	r1, [ip, #36]	; 0x24
  tbp->suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8002eb4:	f04f 0c01 	mov.w	ip, #1
 8002eb8:	623b      	str	r3, [r7, #32]
 8002eba:	4b4e      	ldr	r3, [pc, #312]	; (8002ff4 <main+0x424>)
  qp->prev = qp;
 8002ebc:	e9c7 880c 	strd	r8, r8, [r7, #48]	; 0x30
 8002ec0:	e9c7 c33b 	strd	ip, r3, [r7, #236]	; 0xec
  dlhp->next  = dlhp;
 8002ec4:	f107 0310 	add.w	r3, r7, #16
  dlhp->prev  = dlhp;
 8002ec8:	e9c7 3304 	strd	r3, r3, [r7, #16]
  tbp->ptr       = &tbp->buffer[0];
 8002ecc:	f107 03f8 	add.w	r3, r7, #248	; 0xf8
 8002ed0:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8002ed4:	4623      	mov	r3, r4
 8002ed6:	b28a      	uxth	r2, r1
 8002ed8:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
  pqp->next = pqp;
 8002edc:	603f      	str	r7, [r7, #0]
  sdp->panic_msg = NULL;
 8002ede:	f8c7 40e4 	str.w	r4, [r7, #228]	; 0xe4
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8002ee2:	eb07 1304 	add.w	r3, r7, r4, lsl #4
 8002ee6:	f893 20f8 	ldrb.w	r2, [r3, #248]	; 0xf8
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002eea:	3401      	adds	r4, #1
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8002eec:	f36f 0202 	bfc	r2, #0, #3
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002ef0:	2c80      	cmp	r4, #128	; 0x80
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8002ef2:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002ef6:	d1f4      	bne.n	8002ee2 <main+0x312>

  /* Now this instructions flow becomes the main thread or the idle thread
     depending on the CH_CFG_NO_IDLE_THREAD setting.*/
  {
#if CH_CFG_NO_IDLE_THREAD == FALSE
    const THD_DECL(main_thd_desc,
 8002ef8:	9403      	str	r4, [sp, #12]
 8002efa:	2400      	movs	r4, #0
 8002efc:	4b3e      	ldr	r3, [pc, #248]	; (8002ff8 <main+0x428>)
                   "main", oicp->cstack_base, oicp->cstack_end,
                   NORMALPRIO, NULL, NULL, oip
    );

    oip->rlist.current = chThdObjectInit(&oip->mainthread, &main_thd_desc);
 8002efe:	4669      	mov	r1, sp
    const THD_DECL(main_thd_desc,
 8002f00:	9300      	str	r3, [sp, #0]
 8002f02:	4b3e      	ldr	r3, [pc, #248]	; (8002ffc <main+0x42c>)
    oip->rlist.current = chThdObjectInit(&oip->mainthread, &main_thd_desc);
 8002f04:	483e      	ldr	r0, [pc, #248]	; (8003000 <main+0x430>)
    const THD_DECL(main_thd_desc,
 8002f06:	9301      	str	r3, [sp, #4]
 8002f08:	4b3e      	ldr	r3, [pc, #248]	; (8003004 <main+0x434>)
 8002f0a:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8002f0e:	9302      	str	r3, [sp, #8]
 8002f10:	9706      	str	r7, [sp, #24]
    oip->rlist.current = chThdObjectInit(&oip->mainthread, &main_thd_desc);
 8002f12:	f7fd fe1d 	bl	8000b50 <chThdObjectInit>
 8002f16:	4603      	mov	r3, r0
#if CH_CFG_USE_REGISTRY == TRUE
  REG_INSERT(oip, oip->rlist.current);
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8002f18:	f04f 0c01 	mov.w	ip, #1
    *startp++ = CH_DBG_STACK_FILL_VALUE;
 8002f1c:	f44f 7280 	mov.w	r2, #256	; 0x100
  p->prev       = qp->prev;
 8002f20:	f8d7 e034 	ldr.w	lr, [r7, #52]	; 0x34
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    const THD_DECL(idle_thd_desc,
 8002f24:	4838      	ldr	r0, [pc, #224]	; (8003008 <main+0x438>)
 8002f26:	e9c3 8e09 	strd	r8, lr, [r3, #36]	; 0x24
 8002f2a:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 800300c <main+0x43c>
  REG_INSERT(oip, oip->rlist.current);
 8002f2e:	f103 0824 	add.w	r8, r3, #36	; 0x24
    const THD_DECL(idle_thd_desc,
 8002f32:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 8003010 <main+0x440>
 8002f36:	eb00 0a02 	add.w	sl, r0, r2
 8002f3a:	2155      	movs	r1, #85	; 0x55
    oip->rlist.current = chThdObjectInit(&oip->mainthread, &main_thd_desc);
 8002f3c:	60fb      	str	r3, [r7, #12]
  p->prev->next = p;
 8002f3e:	f8ce 8000 	str.w	r8, [lr]
  qp->prev      = p;
 8002f42:	f8c7 8034 	str.w	r8, [r7, #52]	; 0x34
  oip->rlist.current->state = CH_STATE_CURRENT;
 8002f46:	f883 c01c 	strb.w	ip, [r3, #28]
    const THD_DECL(idle_thd_desc,
 8002f4a:	e9cd ac02 	strd	sl, ip, [sp, #8]
 8002f4e:	e9cd 9404 	strd	r9, r4, [sp, #16]
 8002f52:	e9cd b000 	strd	fp, r0, [sp]
 8002f56:	9706      	str	r7, [sp, #24]
 8002f58:	f000 fad6 	bl	8003508 <memset>
  tp = chThdObjectInit(tp, tdp);
 8002f5c:	4669      	mov	r1, sp
 8002f5e:	482d      	ldr	r0, [pc, #180]	; (8003014 <main+0x444>)
 8002f60:	f7fd fdf6 	bl	8000b50 <chThdObjectInit>
  PORT_SETUP_CONTEXT(tp, tp->wabase, tp->waend, tdp->funcp, tdp->arg);
 8002f64:	e9dd a904 	ldrd	sl, r9, [sp, #16]
  REG_INSERT(tp->owner, tp);
 8002f68:	6901      	ldr	r1, [r0, #16]
  PORT_SETUP_CONTEXT(tp, tp->wabase, tp->waend, tdp->funcp, tdp->arg);
 8002f6a:	6982      	ldr	r2, [r0, #24]
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002f6c:	f8d7 e0e8 	ldr.w	lr, [r7, #232]	; 0xe8
 8002f70:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8003018 <main+0x448>
  p->prev       = qp->prev;
 8002f74:	f8d1 c034 	ldr.w	ip, [r1, #52]	; 0x34
 8002f78:	f1a2 0b24 	sub.w	fp, r2, #36	; 0x24
 8002f7c:	f8c0 b00c 	str.w	fp, [r0, #12]
  REG_INSERT(tp->owner, tp);
 8002f80:	f100 0424 	add.w	r4, r0, #36	; 0x24
 8002f84:	e04a      	b.n	800301c <main+0x44c>
 8002f86:	bf00      	nop
 8002f88:	e000e100 	.word	0xe000e100
 8002f8c:	40020000 	.word	0x40020000
 8002f90:	40021000 	.word	0x40021000
 8002f94:	88884b84 	.word	0x88884b84
 8002f98:	40010800 	.word	0x40010800
 8002f9c:	40010c00 	.word	0x40010c00
 8002fa0:	b4b3ee88 	.word	0xb4b3ee88
 8002fa4:	ee888888 	.word	0xee888888
 8002fa8:	20000c40 	.word	0x20000c40
 8002fac:	44048888 	.word	0x44048888
 8002fb0:	40011400 	.word	0x40011400
 8002fb4:	88888844 	.word	0x88888844
 8002fb8:	e0042000 	.word	0xe0042000
 8002fbc:	40005400 	.word	0x40005400
 8002fc0:	20001b30 	.word	0x20001b30
 8002fc4:	20001b28 	.word	0x20001b28
 8002fc8:	20001ae0 	.word	0x20001ae0
 8002fcc:	20001ba8 	.word	0x20001ba8
 8002fd0:	20005000 	.word	0x20005000
 8002fd4:	20001b3c 	.word	0x20001b3c
 8002fd8:	08000c31 	.word	0x08000c31
 8002fdc:	08000ba1 	.word	0x08000ba1
 8002fe0:	200010e0 	.word	0x200010e0
 8002fe4:	08003970 	.word	0x08003970
 8002fe8:	e000ed00 	.word	0xe000ed00
 8002fec:	05fa0300 	.word	0x05fa0300
 8002ff0:	e0001000 	.word	0xe0001000
 8002ff4:	0080ffe0 	.word	0x0080ffe0
 8002ff8:	08003628 	.word	0x08003628
 8002ffc:	20000400 	.word	0x20000400
 8003000:	20001174 	.word	0x20001174
 8003004:	20000800 	.word	0x20000800
 8003008:	200019e0 	.word	0x200019e0
 800300c:	08003630 	.word	0x08003630
 8003010:	08000891 	.word	0x08000891
 8003014:	20001124 	.word	0x20001124
 8003018:	08000251 	.word	0x08000251
  PORT_SETUP_CONTEXT(tp, tp->wabase, tp->waend, tdp->funcp, tdp->arg);
 800301c:	e942 a909 	strd	sl, r9, [r2, #-36]	; 0x24
 8003020:	f842 8c04 	str.w	r8, [r2, #-4]
 8003024:	f1be 0f00 	cmp.w	lr, #0
  REG_INSERT(tp->owner, tp);
 8003028:	f101 0230 	add.w	r2, r1, #48	; 0x30
 800302c:	f8c0 c028 	str.w	ip, [r0, #40]	; 0x28
  p->next       = qp;
 8003030:	6242      	str	r2, [r0, #36]	; 0x24
  p->prev->next = p;
 8003032:	f8cc 4000 	str.w	r4, [ip]
  qp->prev      = p;
 8003036:	634c      	str	r4, [r1, #52]	; 0x34
 8003038:	f2c0 814e 	blt.w	80032d8 <main+0x708>
 800303c:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8003040:	2b00      	cmp	r3, #0
 8003042:	f340 8149 	ble.w	80032d8 <main+0x708>
 8003046:	f7fd fec3 	bl	8000dd0 <__sch_ready_behind.isra.0>
  ch_system.state = ch_sys_running;
 800304a:	2302      	movs	r3, #2
 800304c:	7033      	strb	r3, [r6, #0]
  __dbg_check_unlock();
 800304e:	f7ff fa37 	bl	80024c0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003052:	683b      	ldr	r3, [r7, #0]
 8003054:	42bb      	cmp	r3, r7
 8003056:	f040 815e 	bne.w	8003316 <main+0x746>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800305a:	2300      	movs	r3, #0
 800305c:	f383 8811 	msr	BASEPRI, r3
 8003060:	2330      	movs	r3, #48	; 0x30
 8003062:	f383 8811 	msr	BASEPRI, r3
  __dbg_check_lock();
 8003066:	f7ff f8bb 	bl	80021e0 <__dbg_check_lock>
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 800306a:	782e      	ldrb	r6, [r5, #0]
 800306c:	1e73      	subs	r3, r6, #1
 800306e:	2b01      	cmp	r3, #1
 8003070:	f200 815a 	bhi.w	8003328 <main+0x758>
  i2cp->config = config;
 8003074:	4bb8      	ldr	r3, [pc, #736]	; (8003358 <main+0x788>)
  if (i2cp->state == I2C_STOP) {
 8003076:	2e01      	cmp	r6, #1
  I2C_TypeDef *dp = i2cp->i2c;
 8003078:	6b6c      	ldr	r4, [r5, #52]	; 0x34
 800307a:	606b      	str	r3, [r5, #4]
  if (i2cp->state == I2C_STOP) {
 800307c:	f000 80e7 	beq.w	800324e <main+0x67e>
  dp->CR1 = I2C_CR1_SWRST;
 8003080:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
  dp->CR1 = 0;
 8003084:	f04f 0c00 	mov.w	ip, #0
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8003088:	f44f 6010 	mov.w	r0, #2304	; 0x900
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 800308c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800308e:	f104 0310 	add.w	r3, r4, #16
 8003092:	6852      	ldr	r2, [r2, #4]
  int32_t clock_speed = i2cp->config->clock_speed;
 8003094:	686e      	ldr	r6, [r5, #4]
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8003096:	6093      	str	r3, [r2, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8003098:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 800309a:	6852      	ldr	r2, [r2, #4]
 800309c:	6093      	str	r3, [r2, #8]
  int32_t clock_speed = i2cp->config->clock_speed;
 800309e:	6873      	ldr	r3, [r6, #4]
  osalDbgCheck((i2cp != NULL) &&
 80030a0:	4aae      	ldr	r2, [pc, #696]	; (800335c <main+0x78c>)
 80030a2:	1e59      	subs	r1, r3, #1
 80030a4:	4291      	cmp	r1, r2
  dp->CR1 = I2C_CR1_SWRST;
 80030a6:	f8c4 e000 	str.w	lr, [r4]
  dp->CR1 = 0;
 80030aa:	f8c4 c000 	str.w	ip, [r4]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 80030ae:	6060      	str	r0, [r4, #4]
  osalDbgCheck((i2cp != NULL) &&
 80030b0:	f200 811b 	bhi.w	80032ea <main+0x71a>
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 80030b4:	f64f 7cc0 	movw	ip, #65472	; 0xffc0
  I2C_TypeDef *dp = i2cp->i2c;
 80030b8:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 80030ba:	7a30      	ldrb	r0, [r6, #8]
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 80030bc:	6851      	ldr	r1, [r2, #4]
 80030be:	ea01 010c 	and.w	r1, r1, ip
 80030c2:	6051      	str	r1, [r2, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 80030c4:	6851      	ldr	r1, [r2, #4]
 80030c6:	f041 0124 	orr.w	r1, r1, #36	; 0x24
 80030ca:	6051      	str	r1, [r2, #4]
  if (clock_speed <= 100000) {
 80030cc:	49a4      	ldr	r1, [pc, #656]	; (8003360 <main+0x790>)
 80030ce:	428b      	cmp	r3, r1
 80030d0:	f300 80a4 	bgt.w	800321c <main+0x64c>
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");
 80030d4:	2801      	cmp	r0, #1
 80030d6:	f040 8108 	bne.w	80032ea <main+0x71a>
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
 80030da:	48a2      	ldr	r0, [pc, #648]	; (8003364 <main+0x794>)
 80030dc:	005b      	lsls	r3, r3, #1
 80030de:	fbb0 f1f3 	udiv	r1, r0, r3
 80030e2:	fb03 0011 	mls	r0, r3, r1, r0
 80030e6:	2800      	cmp	r0, #0
 80030e8:	f040 80ff 	bne.w	80032ea <main+0x71a>
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 80030ec:	b289      	uxth	r1, r1
    osalDbgAssert(clock_div >= 0x04,
 80030ee:	2903      	cmp	r1, #3
 80030f0:	f240 80fb 	bls.w	80032ea <main+0x71a>
    dp->TRISE = I2C_CLK_FREQ + 1;
 80030f4:	2325      	movs	r3, #37	; 0x25
  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 80030f6:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
    dp->TRISE = I2C_CLK_FREQ + 1;
 80030fa:	6213      	str	r3, [r2, #32]
    regCCR |= (clock_div & I2C_CCR_CCR);
 80030fc:	f3c1 030b 	ubfx	r3, r1, #0, #12
  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8003100:	f080 80f3 	bcs.w	80032ea <main+0x71a>
  dp->CCR = regCCR;
 8003104:	61d3      	str	r3, [r2, #28]
  i2copmode_t opmode = i2cp->config->op_mode;
 8003106:	7831      	ldrb	r1, [r6, #0]
  regCR1 = dp->CR1;
 8003108:	6813      	ldr	r3, [r2, #0]
  switch (opmode) {
 800310a:	2902      	cmp	r1, #2
  regCR1 = dp->CR1;
 800310c:	b29b      	uxth	r3, r3
  switch (opmode) {
 800310e:	f000 80f9 	beq.w	8003304 <main+0x734>
 8003112:	2903      	cmp	r1, #3
 8003114:	f000 80f3 	beq.w	80032fe <main+0x72e>
 8003118:	2901      	cmp	r1, #1
 800311a:	f000 80ec 	beq.w	80032f6 <main+0x726>
    i2cp->state = I2C_READY;
 800311e:	2102      	movs	r1, #2
  dp->CR1 = regCR1;
 8003120:	6013      	str	r3, [r2, #0]
  dp->CR1 |= I2C_CR1_PE;
 8003122:	6823      	ldr	r3, [r4, #0]
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8003124:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 8003128:	f043 0301 	orr.w	r3, r3, #1
 800312c:	6023      	str	r3, [r4, #0]
 800312e:	7029      	strb	r1, [r5, #0]
 8003130:	2a00      	cmp	r2, #0
 8003132:	f040 80dd 	bne.w	80032f0 <main+0x720>
 8003136:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800313a:	2b00      	cmp	r3, #0
 800313c:	f340 80d8 	ble.w	80032f0 <main+0x720>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003140:	683b      	ldr	r3, [r7, #0]
  oip->dbg.lock_cnt = (cnt_t)0;
 8003142:	f8c7 20ec 	str.w	r2, [r7, #236]	; 0xec
 8003146:	42bb      	cmp	r3, r7
 8003148:	f040 8148 	bne.w	80033dc <main+0x80c>
 800314c:	2300      	movs	r3, #0
 800314e:	f383 8811 	msr	BASEPRI, r3
  accel_tx_data[0] = ACCEL_CTRL_REG1 | AUTO_INCREMENT_BIT;
 8003152:	4a85      	ldr	r2, [pc, #532]	; (8003368 <main+0x798>)
 8003154:	4985      	ldr	r1, [pc, #532]	; (800336c <main+0x79c>)
 8003156:	2330      	movs	r3, #48	; 0x30
 8003158:	6011      	str	r1, [r2, #0]
 800315a:	f383 8811 	msr	BASEPRI, r3
  __dbg_check_lock();
 800315e:	f7ff f83f 	bl	80021e0 <__dbg_check_lock>
  chMtxLockS(mp);
 8003162:	f7fe f905 	bl	8001370 <chMtxLockS.constprop.0>
  __dbg_check_unlock();
 8003166:	f7ff f9ab 	bl	80024c0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 800316a:	683b      	ldr	r3, [r7, #0]
 800316c:	42bb      	cmp	r3, r7
 800316e:	f040 812c 	bne.w	80033ca <main+0x7fa>
 8003172:	2200      	movs	r2, #0
 8003174:	f382 8811 	msr	BASEPRI, r2
  status = i2cMasterTransmitTimeout(&I2CD1, addr,
 8003178:	2004      	movs	r0, #4
 800317a:	4611      	mov	r1, r2
 800317c:	f7fd fff0 	bl	8001160 <i2cMasterTransmitTimeout.constprop.0>
 8003180:	4604      	mov	r4, r0
 8003182:	f7ff f9ed 	bl	8002560 <chMtxUnlock.constprop.0>
  osalDbgCheck(MSG_OK == status);
 8003186:	2c00      	cmp	r4, #0
 8003188:	f040 80e2 	bne.w	8003350 <main+0x780>

  i2cStart(&I2CD1, &i2cfg1);
  lis3Start();

  /* Create accelerometer thread. */
  chThdCreateStatic(PollAccelThreadWA,
 800318c:	4978      	ldr	r1, [pc, #480]	; (8003370 <main+0x7a0>)
 800318e:	4879      	ldr	r0, [pc, #484]	; (8003374 <main+0x7a4>)
 8003190:	f7ff f83e 	bl	8002210 <chThdCreateStatic.constprop.0.isra.0>
          NORMALPRIO,
          PollAccelThread,
          NULL);

  /* Create not responding thread. */
  chThdCreateStatic(PollFakeThreadWA,
 8003194:	4978      	ldr	r1, [pc, #480]	; (8003378 <main+0x7a8>)
 8003196:	4879      	ldr	r0, [pc, #484]	; (800337c <main+0x7ac>)
 8003198:	f7ff f83a 	bl	8002210 <chThdCreateStatic.constprop.0.isra.0>
  /* main loop handles LED */
  while (true) {
    if (sqrtf(acc[0]*acc[0] + acc[1]*acc[1]) > 0.5)
      palClearPad(IOPORT3, GPIOC_LED); /* on */
    else
      palSetPad(IOPORT3, GPIOC_LED); /* off */
 800319c:	f44f 5980 	mov.w	r9, #4096	; 0x1000
    if (sqrtf(acc[0]*acc[0] + acc[1]*acc[1]) > 0.5)
 80031a0:	f04f 587c 	mov.w	r8, #1056964608	; 0x3f000000
 80031a4:	4d76      	ldr	r5, [pc, #472]	; (8003380 <main+0x7b0>)
      palSetPad(IOPORT3, GPIOC_LED); /* off */
 80031a6:	4e77      	ldr	r6, [pc, #476]	; (8003384 <main+0x7b4>)
    if (sqrtf(acc[0]*acc[0] + acc[1]*acc[1]) > 0.5)
 80031a8:	6829      	ldr	r1, [r5, #0]
 80031aa:	f8d5 a004 	ldr.w	sl, [r5, #4]
 80031ae:	4608      	mov	r0, r1
 80031b0:	f7fd f970 	bl	8000494 <__aeabi_fmul>
 80031b4:	4651      	mov	r1, sl
 80031b6:	4604      	mov	r4, r0
 80031b8:	4650      	mov	r0, sl
 80031ba:	f7fd f96b 	bl	8000494 <__aeabi_fmul>
 80031be:	4601      	mov	r1, r0
 80031c0:	4620      	mov	r0, r4
 80031c2:	f7fd f85f 	bl	8000284 <__addsf3>
 80031c6:	f000 f91d 	bl	8003404 <sqrtf>
 80031ca:	4641      	mov	r1, r8
 80031cc:	f7fd fb1e 	bl	800080c <__aeabi_fcmpgt>
 80031d0:	2800      	cmp	r0, #0
 80031d2:	f000 8084 	beq.w	80032de <main+0x70e>
      palClearPad(IOPORT3, GPIOC_LED); /* on */
 80031d6:	f8c6 9014 	str.w	r9, [r6, #20]
 80031da:	2330      	movs	r3, #48	; 0x30
 80031dc:	f383 8811 	msr	BASEPRI, r3
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80031e0:	e9d7 233a 	ldrd	r2, r3, [r7, #232]	; 0xe8
 80031e4:	4313      	orrs	r3, r2
 80031e6:	f040 8093 	bne.w	8003310 <main+0x740>
  oip->dbg.lock_cnt = (cnt_t)1;
 80031ea:	2301      	movs	r3, #1
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 80031ec:	21c8      	movs	r1, #200	; 0xc8
 80031ee:	2008      	movs	r0, #8
 80031f0:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 80031f4:	f7fd ff1c 	bl	8001030 <chSchGoSleepTimeoutS>
  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80031f8:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 80031fc:	2b00      	cmp	r3, #0
 80031fe:	d177      	bne.n	80032f0 <main+0x720>
 8003200:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8003204:	2a00      	cmp	r2, #0
 8003206:	dd73      	ble.n	80032f0 <main+0x720>
  oip->dbg.lock_cnt = (cnt_t)0;
 8003208:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 800320c:	683b      	ldr	r3, [r7, #0]
 800320e:	42bb      	cmp	r3, r7
 8003210:	f040 80d2 	bne.w	80033b8 <main+0x7e8>
 8003214:	2300      	movs	r3, #0
 8003216:	f383 8811 	msr	BASEPRI, r3
}
 800321a:	e7c5      	b.n	80031a8 <main+0x5d8>
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
 800321c:	1e81      	subs	r1, r0, #2
 800321e:	2901      	cmp	r1, #1
 8003220:	d863      	bhi.n	80032ea <main+0x71a>
    if (duty == FAST_DUTY_CYCLE_2) {
 8003222:	2802      	cmp	r0, #2
 8003224:	f000 8089 	beq.w	800333a <main+0x76a>
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
 8003228:	2119      	movs	r1, #25
 800322a:	fb03 f101 	mul.w	r1, r3, r1
 800322e:	484d      	ldr	r0, [pc, #308]	; (8003364 <main+0x794>)
 8003230:	fbb0 f3f1 	udiv	r3, r0, r1
 8003234:	fb01 0113 	mls	r1, r1, r3, r0
 8003238:	2900      	cmp	r1, #0
 800323a:	d156      	bne.n	80032ea <main+0x71a>
      regCCR |= I2C_CCR_DUTY;
 800323c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 8003240:	b29b      	uxth	r3, r3
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 8003242:	210b      	movs	r1, #11
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 8003244:	4303      	orrs	r3, r0
 8003246:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 800324a:	6211      	str	r1, [r2, #32]
 800324c:	e75a      	b.n	8003104 <main+0x534>
    i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800324e:	228a      	movs	r2, #138	; 0x8a
    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8003250:	239a      	movs	r3, #154	; 0x9a
 8003252:	e9c5 2309 	strd	r2, r3, [r5, #36]	; 0x24
      rccResetI2C1();
 8003256:	f8df 8130 	ldr.w	r8, [pc, #304]	; 8003388 <main+0x7b8>
 800325a:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800325e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8003262:	f8c8 3010 	str.w	r3, [r8, #16]
 8003266:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800326a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800326e:	f8c8 3010 	str.w	r3, [r8, #16]
  osalDbgCheckClassI();
 8003272:	f7fd fc25 	bl	8000ac0 <chDbgCheckClassI>
 8003276:	2006      	movs	r0, #6
 8003278:	4944      	ldr	r1, [pc, #272]	; (800338c <main+0x7bc>)
 800327a:	f8d8 3010 	ldr.w	r3, [r8, #16]
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
 800327e:	f7fd fb67 	bl	8000950 <dmaStreamAllocI.part.0.constprop.0>
      i2cp->dmarx = dmaStreamAllocI(STM32_I2C_I2C1_RX_DMA_STREAM,
 8003282:	62e8      	str	r0, [r5, #44]	; 0x2c
      osalDbgAssert(i2cp->dmarx != NULL, "unable to allocate stream");
 8003284:	2800      	cmp	r0, #0
 8003286:	d055      	beq.n	8003334 <main+0x764>
  osalDbgCheckClassI();
 8003288:	f7fd fc1a 	bl	8000ac0 <chDbgCheckClassI>
 800328c:	2005      	movs	r0, #5
 800328e:	4940      	ldr	r1, [pc, #256]	; (8003390 <main+0x7c0>)
 8003290:	f7fd fb5e 	bl	8000950 <dmaStreamAllocI.part.0.constprop.0>
      i2cp->dmatx = dmaStreamAllocI(STM32_I2C_I2C1_TX_DMA_STREAM,
 8003294:	6328      	str	r0, [r5, #48]	; 0x30
      osalDbgAssert(i2cp->dmatx != NULL, "unable to allocate stream");
 8003296:	2800      	cmp	r0, #0
 8003298:	d04c      	beq.n	8003334 <main+0x764>
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 800329a:	2250      	movs	r2, #80	; 0x50
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800329c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
      rccEnableI2C1(true);
 80032a0:	f8d8 301c 	ldr.w	r3, [r8, #28]
 80032a4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80032a8:	f8c8 301c 	str.w	r3, [r8, #28]
 80032ac:	f8d8 301c 	ldr.w	r3, [r8, #28]
      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80032b0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80032b2:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 80032b6:	626b      	str	r3, [r5, #36]	; 0x24
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80032b8:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80032ba:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 80032be:	62ab      	str	r3, [r5, #40]	; 0x28
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80032c0:	4b34      	ldr	r3, [pc, #208]	; (8003394 <main+0x7c4>)
 80032c2:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80032c6:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80032ca:	6019      	str	r1, [r3, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80032cc:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80032d0:	f8c3 6184 	str.w	r6, [r3, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80032d4:	605e      	str	r6, [r3, #4]
 80032d6:	e6d3      	b.n	8003080 <main+0x4b0>
    chSysHalt("SV#10");
 80032d8:	482f      	ldr	r0, [pc, #188]	; (8003398 <main+0x7c8>)
 80032da:	f7fd fbb1 	bl	8000a40 <chSysHalt>
      palSetPad(IOPORT3, GPIOC_LED); /* off */
 80032de:	f8c6 9010 	str.w	r9, [r6, #16]
 80032e2:	e77a      	b.n	80031da <main+0x60a>
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
 80032e4:	482d      	ldr	r0, [pc, #180]	; (800339c <main+0x7cc>)
 80032e6:	f7fd fbab 	bl	8000a40 <chSysHalt>
  osalDbgCheck((i2cp != NULL) &&
 80032ea:	482d      	ldr	r0, [pc, #180]	; (80033a0 <main+0x7d0>)
 80032ec:	f7fd fba8 	bl	8000a40 <chSysHalt>
    chSysHalt("SV#5");
 80032f0:	482c      	ldr	r0, [pc, #176]	; (80033a4 <main+0x7d4>)
 80032f2:	f7fd fba5 	bl	8000a40 <chSysHalt>
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 80032f6:	f023 030a 	bic.w	r3, r3, #10
 80032fa:	b29b      	uxth	r3, r3
    break;
 80032fc:	e70f      	b.n	800311e <main+0x54e>
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 80032fe:	f043 030a 	orr.w	r3, r3, #10
    break;
 8003302:	e70c      	b.n	800311e <main+0x54e>
 8003304:	f023 0308 	bic.w	r3, r3, #8
 8003308:	b29b      	uxth	r3, r3
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 800330a:	f043 0302 	orr.w	r3, r3, #2
    break;
 800330e:	e706      	b.n	800311e <main+0x54e>
    chSysHalt("SV#4");
 8003310:	4825      	ldr	r0, [pc, #148]	; (80033a8 <main+0x7d8>)
 8003312:	f7fd fb95 	bl	8000a40 <chSysHalt>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003316:	68fa      	ldr	r2, [r7, #12]
 8003318:	689b      	ldr	r3, [r3, #8]
 800331a:	6892      	ldr	r2, [r2, #8]
 800331c:	429a      	cmp	r2, r3
 800331e:	f4bf ae9c 	bcs.w	800305a <main+0x48a>
 8003322:	4822      	ldr	r0, [pc, #136]	; (80033ac <main+0x7dc>)
 8003324:	f7fd fb8c 	bl	8000a40 <chSysHalt>
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 8003328:	2e05      	cmp	r6, #5
 800332a:	d160      	bne.n	80033ee <main+0x81e>
  i2cp->config = config;
 800332c:	4b0a      	ldr	r3, [pc, #40]	; (8003358 <main+0x788>)
  I2C_TypeDef *dp = i2cp->i2c;
 800332e:	6b6c      	ldr	r4, [r5, #52]	; 0x34
 8003330:	606b      	str	r3, [r5, #4]
void i2c_lld_start(I2CDriver *i2cp) {
 8003332:	e6a5      	b.n	8003080 <main+0x4b0>
      osalDbgAssert(i2cp->dmarx != NULL, "unable to allocate stream");
 8003334:	481e      	ldr	r0, [pc, #120]	; (80033b0 <main+0x7e0>)
 8003336:	f7fd fb83 	bl	8000a40 <chSysHalt>
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
 800333a:	480a      	ldr	r0, [pc, #40]	; (8003364 <main+0x794>)
 800333c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003340:	fbb0 f1f3 	udiv	r1, r0, r3
 8003344:	fb03 0011 	mls	r0, r3, r1, r0
 8003348:	2800      	cmp	r0, #0
 800334a:	d1ce      	bne.n	80032ea <main+0x71a>
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 800334c:	b28b      	uxth	r3, r1
 800334e:	e778      	b.n	8003242 <main+0x672>
 8003350:	4818      	ldr	r0, [pc, #96]	; (80033b4 <main+0x7e4>)
 8003352:	f7fd fb75 	bl	8000a40 <chSysHalt>
 8003356:	bf00      	nop
 8003358:	08003984 	.word	0x08003984
 800335c:	00061a7f 	.word	0x00061a7f
 8003360:	000186a0 	.word	0x000186a0
 8003364:	02255100 	.word	0x02255100
 8003368:	200010d4 	.word	0x200010d4
 800336c:	0041e7a0 	.word	0x0041e7a0
 8003370:	08002651 	.word	0x08002651
 8003374:	20000c80 	.word	0x20000c80
 8003378:	08002891 	.word	0x08002891
 800337c:	20000ea0 	.word	0x20000ea0
 8003380:	200010c0 	.word	0x200010c0
 8003384:	40011000 	.word	0x40011000
 8003388:	40021000 	.word	0x40021000
 800338c:	08000e31 	.word	0x08000e31
 8003390:	08000a81 	.word	0x08000a81
 8003394:	e000e100 	.word	0xe000e100
 8003398:	080035b8 	.word	0x080035b8
 800339c:	08003690 	.word	0x08003690
 80033a0:	08003820 	.word	0x08003820
 80033a4:	080035f0 	.word	0x080035f0
 80033a8:	080035c0 	.word	0x080035c0
 80033ac:	080036f8 	.word	0x080036f8
 80033b0:	0800385c 	.word	0x0800385c
 80033b4:	0800374c 	.word	0x0800374c
 80033b8:	68fa      	ldr	r2, [r7, #12]
 80033ba:	689b      	ldr	r3, [r3, #8]
 80033bc:	6892      	ldr	r2, [r2, #8]
 80033be:	429a      	cmp	r2, r3
 80033c0:	f4bf af28 	bcs.w	8003214 <main+0x644>
 80033c4:	480b      	ldr	r0, [pc, #44]	; (80033f4 <main+0x824>)
 80033c6:	f7fd fb3b 	bl	8000a40 <chSysHalt>
 80033ca:	68fa      	ldr	r2, [r7, #12]
 80033cc:	689b      	ldr	r3, [r3, #8]
 80033ce:	6892      	ldr	r2, [r2, #8]
 80033d0:	429a      	cmp	r2, r3
 80033d2:	f4bf aece 	bcs.w	8003172 <main+0x5a2>
 80033d6:	4808      	ldr	r0, [pc, #32]	; (80033f8 <main+0x828>)
 80033d8:	f7fd fb32 	bl	8000a40 <chSysHalt>
 80033dc:	68fa      	ldr	r2, [r7, #12]
 80033de:	689b      	ldr	r3, [r3, #8]
 80033e0:	6892      	ldr	r2, [r2, #8]
 80033e2:	429a      	cmp	r2, r3
 80033e4:	f4bf aeb2 	bcs.w	800314c <main+0x57c>
 80033e8:	4804      	ldr	r0, [pc, #16]	; (80033fc <main+0x82c>)
 80033ea:	f7fd fb29 	bl	8000a40 <chSysHalt>
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 80033ee:	4804      	ldr	r0, [pc, #16]	; (8003400 <main+0x830>)
 80033f0:	f7fd fb26 	bl	8000a40 <chSysHalt>
 80033f4:	08003788 	.word	0x08003788
 80033f8:	08003844 	.word	0x08003844
 80033fc:	08003894 	.word	0x08003894
 8003400:	080038c4 	.word	0x080038c4

08003404 <sqrtf>:
 8003404:	b538      	push	{r3, r4, r5, lr}
 8003406:	4604      	mov	r4, r0
 8003408:	f000 f820 	bl	800344c <__ieee754_sqrtf>
 800340c:	4b0e      	ldr	r3, [pc, #56]	; (8003448 <sqrtf+0x44>)
 800340e:	4605      	mov	r5, r0
 8003410:	f993 3000 	ldrsb.w	r3, [r3]
 8003414:	3301      	adds	r3, #1
 8003416:	d009      	beq.n	800342c <sqrtf+0x28>
 8003418:	4621      	mov	r1, r4
 800341a:	4620      	mov	r0, r4
 800341c:	f7fd fa00 	bl	8000820 <__aeabi_fcmpun>
 8003420:	b920      	cbnz	r0, 800342c <sqrtf+0x28>
 8003422:	4620      	mov	r0, r4
 8003424:	2100      	movs	r1, #0
 8003426:	f7fd f9d3 	bl	80007d0 <__aeabi_fcmplt>
 800342a:	b908      	cbnz	r0, 8003430 <sqrtf+0x2c>
 800342c:	4628      	mov	r0, r5
 800342e:	bd38      	pop	{r3, r4, r5, pc}
 8003430:	f000 f864 	bl	80034fc <__errno>
 8003434:	2221      	movs	r2, #33	; 0x21
 8003436:	4603      	mov	r3, r0
 8003438:	2100      	movs	r1, #0
 800343a:	601a      	str	r2, [r3, #0]
 800343c:	4608      	mov	r0, r1
 800343e:	f7fd f8dd 	bl	80005fc <__aeabi_fdiv>
 8003442:	4605      	mov	r5, r0
 8003444:	4628      	mov	r0, r5
 8003446:	bd38      	pop	{r3, r4, r5, pc}
 8003448:	20000800 	.word	0x20000800

0800344c <__ieee754_sqrtf>:
 800344c:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 8003450:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8003454:	b510      	push	{r4, lr}
 8003456:	4604      	mov	r4, r0
 8003458:	d234      	bcs.n	80034c4 <__ieee754_sqrtf+0x78>
 800345a:	b392      	cbz	r2, 80034c2 <__ieee754_sqrtf+0x76>
 800345c:	2800      	cmp	r0, #0
 800345e:	4603      	mov	r3, r0
 8003460:	db42      	blt.n	80034e8 <__ieee754_sqrtf+0x9c>
 8003462:	f010 4fff 	tst.w	r0, #2139095040	; 0x7f800000
 8003466:	ea4f 54e0 	mov.w	r4, r0, asr #23
 800346a:	d032      	beq.n	80034d2 <__ieee754_sqrtf+0x86>
 800346c:	2100      	movs	r1, #0
 800346e:	f1a4 007f 	sub.w	r0, r4, #127	; 0x7f
 8003472:	07e2      	lsls	r2, r4, #31
 8003474:	f04f 0c19 	mov.w	ip, #25
 8003478:	ea4f 0460 	mov.w	r4, r0, asr #1
 800347c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8003480:	4608      	mov	r0, r1
 8003482:	f3c3 0316 	ubfx	r3, r3, #0, #23
 8003486:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800348a:	bf58      	it	pl
 800348c:	005b      	lslpl	r3, r3, #1
 800348e:	005b      	lsls	r3, r3, #1
 8003490:	eb00 0e02 	add.w	lr, r0, r2
 8003494:	459e      	cmp	lr, r3
 8003496:	dc04      	bgt.n	80034a2 <__ieee754_sqrtf+0x56>
 8003498:	eb0e 0002 	add.w	r0, lr, r2
 800349c:	eba3 030e 	sub.w	r3, r3, lr
 80034a0:	4411      	add	r1, r2
 80034a2:	f1bc 0c01 	subs.w	ip, ip, #1
 80034a6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80034aa:	ea4f 0252 	mov.w	r2, r2, lsr #1
 80034ae:	d1ef      	bne.n	8003490 <__ieee754_sqrtf+0x44>
 80034b0:	b113      	cbz	r3, 80034b8 <__ieee754_sqrtf+0x6c>
 80034b2:	3101      	adds	r1, #1
 80034b4:	f021 0101 	bic.w	r1, r1, #1
 80034b8:	1048      	asrs	r0, r1, #1
 80034ba:	f100 507c 	add.w	r0, r0, #1056964608	; 0x3f000000
 80034be:	eb00 50c4 	add.w	r0, r0, r4, lsl #23
 80034c2:	bd10      	pop	{r4, pc}
 80034c4:	4601      	mov	r1, r0
 80034c6:	f7fc ffe5 	bl	8000494 <__aeabi_fmul>
 80034ca:	4621      	mov	r1, r4
 80034cc:	f7fc feda 	bl	8000284 <__addsf3>
 80034d0:	bd10      	pop	{r4, pc}
 80034d2:	f410 0200 	ands.w	r2, r0, #8388608	; 0x800000
 80034d6:	d10e      	bne.n	80034f6 <__ieee754_sqrtf+0xaa>
 80034d8:	005b      	lsls	r3, r3, #1
 80034da:	0218      	lsls	r0, r3, #8
 80034dc:	4611      	mov	r1, r2
 80034de:	f102 0201 	add.w	r2, r2, #1
 80034e2:	d5f9      	bpl.n	80034d8 <__ieee754_sqrtf+0x8c>
 80034e4:	1a64      	subs	r4, r4, r1
 80034e6:	e7c1      	b.n	800346c <__ieee754_sqrtf+0x20>
 80034e8:	4601      	mov	r1, r0
 80034ea:	f7fc fec9 	bl	8000280 <__aeabi_fsub>
 80034ee:	4601      	mov	r1, r0
 80034f0:	f7fd f884 	bl	80005fc <__aeabi_fdiv>
 80034f4:	bd10      	pop	{r4, pc}
 80034f6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80034fa:	e7f3      	b.n	80034e4 <__ieee754_sqrtf+0x98>

080034fc <__errno>:
 80034fc:	4b01      	ldr	r3, [pc, #4]	; (8003504 <__errno+0x8>)
 80034fe:	6818      	ldr	r0, [r3, #0]
 8003500:	4770      	bx	lr
 8003502:	bf00      	nop
 8003504:	20000804 	.word	0x20000804

08003508 <memset>:
 8003508:	0783      	lsls	r3, r0, #30
 800350a:	b530      	push	{r4, r5, lr}
 800350c:	d048      	beq.n	80035a0 <memset+0x98>
 800350e:	1e54      	subs	r4, r2, #1
 8003510:	2a00      	cmp	r2, #0
 8003512:	d03f      	beq.n	8003594 <memset+0x8c>
 8003514:	4603      	mov	r3, r0
 8003516:	b2ca      	uxtb	r2, r1
 8003518:	e001      	b.n	800351e <memset+0x16>
 800351a:	3c01      	subs	r4, #1
 800351c:	d33a      	bcc.n	8003594 <memset+0x8c>
 800351e:	f803 2b01 	strb.w	r2, [r3], #1
 8003522:	079d      	lsls	r5, r3, #30
 8003524:	d1f9      	bne.n	800351a <memset+0x12>
 8003526:	2c03      	cmp	r4, #3
 8003528:	d92d      	bls.n	8003586 <memset+0x7e>
 800352a:	b2cd      	uxtb	r5, r1
 800352c:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8003530:	2c0f      	cmp	r4, #15
 8003532:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8003536:	d936      	bls.n	80035a6 <memset+0x9e>
 8003538:	f1a4 0210 	sub.w	r2, r4, #16
 800353c:	f022 0c0f 	bic.w	ip, r2, #15
 8003540:	f103 0e20 	add.w	lr, r3, #32
 8003544:	44e6      	add	lr, ip
 8003546:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 800354a:	f103 0210 	add.w	r2, r3, #16
 800354e:	e942 5504 	strd	r5, r5, [r2, #-16]
 8003552:	e942 5502 	strd	r5, r5, [r2, #-8]
 8003556:	3210      	adds	r2, #16
 8003558:	4572      	cmp	r2, lr
 800355a:	d1f8      	bne.n	800354e <memset+0x46>
 800355c:	f10c 0201 	add.w	r2, ip, #1
 8003560:	f014 0f0c 	tst.w	r4, #12
 8003564:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 8003568:	f004 0c0f 	and.w	ip, r4, #15
 800356c:	d013      	beq.n	8003596 <memset+0x8e>
 800356e:	f1ac 0304 	sub.w	r3, ip, #4
 8003572:	f023 0303 	bic.w	r3, r3, #3
 8003576:	3304      	adds	r3, #4
 8003578:	4413      	add	r3, r2
 800357a:	f842 5b04 	str.w	r5, [r2], #4
 800357e:	4293      	cmp	r3, r2
 8003580:	d1fb      	bne.n	800357a <memset+0x72>
 8003582:	f00c 0403 	and.w	r4, ip, #3
 8003586:	b12c      	cbz	r4, 8003594 <memset+0x8c>
 8003588:	b2ca      	uxtb	r2, r1
 800358a:	441c      	add	r4, r3
 800358c:	f803 2b01 	strb.w	r2, [r3], #1
 8003590:	429c      	cmp	r4, r3
 8003592:	d1fb      	bne.n	800358c <memset+0x84>
 8003594:	bd30      	pop	{r4, r5, pc}
 8003596:	4664      	mov	r4, ip
 8003598:	4613      	mov	r3, r2
 800359a:	2c00      	cmp	r4, #0
 800359c:	d1f4      	bne.n	8003588 <memset+0x80>
 800359e:	e7f9      	b.n	8003594 <memset+0x8c>
 80035a0:	4603      	mov	r3, r0
 80035a2:	4614      	mov	r4, r2
 80035a4:	e7bf      	b.n	8003526 <memset+0x1e>
 80035a6:	461a      	mov	r2, r3
 80035a8:	46a4      	mov	ip, r4
 80035aa:	e7e0      	b.n	800356e <memset+0x66>
